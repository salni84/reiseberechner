/*! Built with http://stenciljs.com */
import { h } from '../webcomponents.core.js';

import { a as anime } from './chunk-16499f22.js';

const colors = {
    aluminium: "#dde3e7",
    "aluminium-tint-2": "#e4e9ec",
    horizon: "#eef3f6",
    turquoise: "#0eaba9",
    azure: "#1781e3",
    iris: "#5944c6",
    orchid: "#a63297",
    pink: "#e61e64",
    light: "rgba(0, 0, 0, .1)",
    dark: "rgba(255, 255, 255, .4)"
};

class PieChart {
    constructor() {
        this.viewBox = 34;
        this.radius = 16;
        this.segmentPaddingForSizeSmall = 0;
        this.segmentPaddingForSizeMedium = 3;
        this.hundredPercent = this.radius * 2 * Math.PI;
        this.animationDuration = 300;
        this.data = [];
        this.value = "";
        this.legendPosition = "bottom";
        this.size = "medium";
        this.backgroundTheme = "light";
        this.dataState = [];
    }
    dataChanged() {
        this.parseData();
    }
    componentWillLoad() {
        this.parseData();
    }
    animateSegment(segment, timeline) {
        if (!segment.circle) {
            return;
        }
        timeline.add({
            targets: segment.circle,
            begin: () => {
                segment.circle.style.display = "";
            },
            "stroke-dasharray": `${segment.width} ${this.hundredPercent}`,
            duration: this.animationDuration,
            easing: "easeInQuint"
        });
    }
    animateLegendItem(legendItem, timeline) {
        if (!legendItem) {
            return;
        }
        timeline.add({
            targets: legendItem,
            opacity: 1,
            duration: this.animationDuration,
            easing: "easeInQuint"
        });
    }
    dataToSegments() {
        const segmentPadding = this.size === "medium"
            ? this.segmentPaddingForSizeMedium
            : this.segmentPaddingForSizeSmall;
        const totalValue = this.dataState.reduce((total, d) => total + d.value, 0);
        const segmentsSmallerThanPadding = this.dataState.filter((d) => {
            let width = d.value / totalValue * this.hundredPercent;
            return width < segmentPadding;
        });
        const totalValueOfSegmentsSmallerThanPadding = segmentsSmallerThanPadding.reduce((total, d) => {
            return total + d.value;
        }, 0);
        const segmentPaddingRotationDeg = (360 / this.hundredPercent * segmentPadding);
        let rotation = segmentPaddingRotationDeg;
        return this.dataState
            .filter(({}, i) => this.size === "small" ? i === 0 : true)
            .map((d) => {
            const availableWidth = this.hundredPercent - (segmentPadding * segmentsSmallerThanPadding.length);
            let width = d.value / (totalValue - totalValueOfSegmentsSmallerThanPadding) * availableWidth;
            if (width < segmentPadding) {
                width = 0;
            }
            else {
                width = width - segmentPadding;
            }
            const segment = { d, width, rotation };
            rotation += this.widthToDeg(segment.width) + segmentPaddingRotationDeg;
            return segment;
        });
    }
    widthToDeg(width) {
        return 360 / this.hundredPercent * width;
    }
    getComponentClassNames() {
        return {
            component: true,
            [this.legendPosition]: true,
            [this.size]: true,
            [this.backgroundTheme]: true
        };
    }
    parseData() {
        if (typeof this.data === "string") {
            try {
                this.dataState = JSON.parse(this.data);
            }
            catch (e) {
            }
        }
        else {
            this.dataState = this.data;
        }
    }
    hasLabelsOrSrHints() {
        return this.dataState.some(this.hasLabelOrSrHint);
    }
    hasLabelOrSrHint(d) {
        return !!d.label || !!d.srHint;
    }
    getSegmentColor(d) {
        if (d && d.color) {
            return colors[d.color];
        }
        return colors[this.backgroundTheme];
    }
    render() {
        const center = this.viewBox / 2;
        const segmentsTimeline = anime.timeline();
        const legendItemsTimeline = anime.timeline();
        return (h("div", { class: this.getComponentClassNames() },
            h("div", { class: "wrapper" },
                h("div", { class: "chart-container" },
                    h("div", { class: "chart" },
                        this.size === "small" &&
                            h("svg", { viewBox: `0 0 ${this.viewBox} ${this.viewBox}`, style: { transform: `rotate(${this.widthToDeg(this.hundredPercent)}deg)` } },
                                h("circle", { "stroke-dasharray": `${this.hundredPercent} ${this.hundredPercent}`, stroke: this.getSegmentColor(), cx: center, cy: center, r: this.radius })),
                        this.dataToSegments().map((segment) => {
                            return (h("svg", { key: Math.random(), viewBox: `0 0 ${this.viewBox} ${this.viewBox}`, style: { transform: `rotate(${segment.rotation}deg)` } },
                                h("circle", { ref: (el) => this.animateSegment(Object.assign({}, segment, { circle: el }), segmentsTimeline), style: { display: "none" }, "stroke-dasharray": `0 ${this.hundredPercent}`, stroke: this.getSegmentColor(segment.d), cx: center, cy: center, r: this.radius })));
                        })),
                    h("div", { class: "metadata", "aria-hidden": "true" },
                        h("div", { class: "value" }, this.value),
                        this.size !== "small" &&
                            h("div", { class: "description" }, this.description))),
                this.hasLabelsOrSrHints() &&
                    h("ul", { class: { legend: true, "sr-only": this.size === "small" } }, this.dataState.filter(this.hasLabelOrSrHint).map((d) => {
                        return (h("li", { key: Math.random(), ref: (el) => this.animateLegendItem(el, legendItemsTimeline), style: { opacity: "0" } },
                            h("span", { "aria-hidden": "true" },
                                h("sdx-icon", { "icon-name": "icon-record-filled", style: { color: this.getSegmentColor(d) } }),
                                " ",
                                d.label),
                            d.srHint && h("span", { class: "sr-only" }, d.srHint)));
                    })))));
    }
    static get is() { return "sdx-pie-chart"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "backgroundTheme": {
            "type": String,
            "attr": "background-theme"
        },
        "data": {
            "type": String,
            "attr": "data",
            "watchCallbacks": ["dataChanged"]
        },
        "dataState": {
            "state": true
        },
        "description": {
            "type": String,
            "attr": "description"
        },
        "legendPosition": {
            "type": String,
            "attr": "legend-position"
        },
        "size": {
            "type": String,
            "attr": "size"
        },
        "value": {
            "type": String,
            "attr": "value"
        }
    }; }
    static get style() { return "\@charset \"UTF-8\";*,:after,:before,:host{-webkit-box-sizing:border-box;box-sizing:border-box}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}.component{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center}.component.small .wrapper .chart-container .chart{height:64px;width:64px}.component.small .wrapper .chart-container .chart svg{height:64px;width:64px;stroke-linecap:butt}.component.small .wrapper .chart-container .metadata{font-size:16px;top:8px;right:8px;bottom:8px;left:8px}.component.bottom .wrapper{-ms-flex-direction:column;flex-direction:column;-ms-flex-preferred-size:100%;flex-basis:100%}.component.bottom .wrapper .legend{margin-top:24px;-ms-flex-wrap:wrap;flex-wrap:wrap;width:100%}.component.bottom .wrapper .legend li:not(:last-of-type){margin-right:24px}.component.right .wrapper .legend{margin-left:32px;-ms-flex-direction:column;flex-direction:column}.component.right .wrapper .legend li:not(:last-of-type){margin-bottom:8px}.component.dark .wrapper .chart-container .metadata,.component.dark .wrapper .chart-container .metadata .description{color:#fff}.component .wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.component .wrapper .chart-container{position:relative}.component .wrapper .chart-container .chart{-webkit-transform:rotate(-90deg);transform:rotate(-90deg);height:182px;width:182px}.component .wrapper .chart-container .chart svg{position:absolute;top:0;left:0;fill:transparent;stroke-width:2;stroke-linecap:round;height:182px;width:182px}.component .wrapper .chart-container .metadata{font-weight:400;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;line-height:28px;letter-spacing:-.89px;font-size:32px;position:absolute;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;top:32px;right:24px;bottom:24px;left:24px}.component .wrapper .chart-container .metadata .description{font-size:16px;color:#666;white-space:nowrap;width:100%;overflow:hidden;text-overflow:ellipsis;text-align:center}.component .wrapper .legend{display:-ms-flexbox;display:flex;list-style:none;padding:0;font-weight:300;-ms-flex-pack:center;justify-content:center;margin:0}.component .wrapper .legend li{white-space:nowrap}"; }
}

export { PieChart as SdxPieChart };
