/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */


import './stencil.core';


import {
  ArrowDirection,
  ArrowPosition,
} from './components/accordion/types';
import {
  AnimationName,
} from './components/animation/types';
import {
  ButtonGroupLayout,
} from './components/button/types';
import {
  BackgroundTheme,
  ButtonTheme,
  Display,
  FlipDirection,
} from './core/types/types';
import {
  Size,
} from './components/icon/types';
import {
  Type,
} from './components/input-item/types';
import {
  InputType,
} from './components/input/types';
import {
  Direction,
} from './components/menu-flyout/types';
import {
  PieChartDataPoint,
} from './components/pie-chart/types';
import {
  Size as Size2,
} from './components/price/types';
import {
  Status,
  StepPosition,
} from './components/progress-full/types';
import {
  Design,
  Position,
  Size as Size3,
} from './components/ribbon/types';
import {
  Position as Position2,
} from './components/scroll-to-top/types';
import {
  KeyboardBehavior,
} from './components/select/types';


export namespace Components {

  interface SdxAccordionItemBody {
    'arrowPosition': ArrowPosition;
    /**
    * Toggles body directly when initial load or with an animation.
    */
    'toggle': (isOpen: boolean) => void;
  }
  interface SdxAccordionItemBodyAttributes extends StencilHTMLAttributes {
    'arrowPosition'?: ArrowPosition;
  }

  interface SdxAccordionArrow {
    'arrowPosition': ArrowPosition;
    'direction': ArrowDirection;
    'hover': boolean;
  }
  interface SdxAccordionArrowAttributes extends StencilHTMLAttributes {
    'arrowPosition'?: ArrowPosition;
    'direction'?: ArrowDirection;
    'hover'?: boolean;
  }

  interface SdxAccordionItemHeader {
    'arrowPosition': ArrowPosition;
    /**
    * Closes this accordion item.
    */
    'closeItem': () => void;
    'expand': boolean;
    /**
    * Opens this accordion item.
    */
    'openItem': () => void;
    /**
    * Triggers toggle information in accordion
    */
    'toggle': () => void;
  }
  interface SdxAccordionItemHeaderAttributes extends StencilHTMLAttributes {
    'arrowPosition'?: ArrowPosition;
    'expand'?: boolean;
    /**
    * Triggers toggle information in accordion
    */
    'toggle'?: () => void;
  }

  interface SdxAccordionItemSection {}
  interface SdxAccordionItemSectionAttributes extends StencilHTMLAttributes {}

  interface SdxAccordionItem {
    /**
    * If the accordion item is initially open.
    */
    'open': boolean;
  }
  interface SdxAccordionItemAttributes extends StencilHTMLAttributes {
    /**
    * If the accordion item is initially open.
    */
    'open'?: boolean;
  }

  interface SdxAccordion {
    /**
    * Position of the arrow in the header.
    */
    'arrowPosition': ArrowPosition;
    /**
    * Closes the accordion item.
    */
    'close': (index: number) => void;
    /**
    * Closes all accordion items.
    */
    'closeAll': () => void;
    /**
    * Allow to keep multiple accordion items opened.
    */
    'keepOpen': boolean;
    /**
    * Opens the accordion item.
    */
    'open': (index: number) => void;
    /**
    * Opens all accordion items.
    */
    'openAll': () => void;
    /**
    * Toggle display of the accordion item.
    */
    'toggle': (index: number) => void;
  }
  interface SdxAccordionAttributes extends StencilHTMLAttributes {
    /**
    * Position of the arrow in the header.
    */
    'arrowPosition'?: ArrowPosition;
    /**
    * Allow to keep multiple accordion items opened.
    */
    'keepOpen'?: boolean;
  }

  interface SdxAnimation {
    /**
    * The animation to play.
    */
    'animationName'?: AnimationName;
  }
  interface SdxAnimationAttributes extends StencilHTMLAttributes {
    /**
    * The animation to play.
    */
    'animationName'?: AnimationName;
  }

  interface SdxButtonGroup {
    /**
    * Defines how buttons are aligned, sized and distributed.
    */
    'layout': ButtonGroupLayout;
  }
  interface SdxButtonGroupAttributes extends StencilHTMLAttributes {
    /**
    * Defines how buttons are aligned, sized and distributed.
    */
    'layout'?: ButtonGroupLayout;
  }

  interface SdxButton {
    /**
    * Value for aria-expanded that will be applied to the button element. Used for buttons that trigger expanding/collapsing such as an accordion, dropdown menu or tooltip.
    */
    'ariaExpandedOnButton'?: boolean;
    /**
    * Background theme. Use "dark" to make button colorless, whenever it is used on a colored or dark background (single color or image).
    */
    'background': BackgroundTheme;
    /**
    * Button disabled.
    */
    'disabled': boolean;
    /**
    * href when used as a link looking like a button.
    */
    'href': string;
    'iconName': string;
    'iconSize': Size;
    /**
    * Button text.
    */
    'label': string;
    /**
    * Description text read by the screen reader. Will be appended to the button content.
    */
    'srHint': string;
    /**
    * target when used as a link looking like a button.
    */
    'target'?: string;
    /**
    * Button theme. For further information about the different themes, see designers' section: https://sdx.swisscom.ch/components_-_buttons.html#design
    */
    'theme': ButtonTheme;
    'valid'?: boolean;
  }
  interface SdxButtonAttributes extends StencilHTMLAttributes {
    /**
    * Value for aria-expanded that will be applied to the button element. Used for buttons that trigger expanding/collapsing such as an accordion, dropdown menu or tooltip.
    */
    'ariaExpandedOnButton'?: boolean;
    /**
    * Background theme. Use "dark" to make button colorless, whenever it is used on a colored or dark background (single color or image).
    */
    'background'?: BackgroundTheme;
    /**
    * Button disabled.
    */
    'disabled'?: boolean;
    /**
    * href when used as a link looking like a button.
    */
    'href'?: string;
    'iconName'?: string;
    'iconSize'?: Size;
    /**
    * Button text.
    */
    'label'?: string;
    /**
    * Description text read by the screen reader. Will be appended to the button content.
    */
    'srHint'?: string;
    /**
    * target when used as a link looking like a button.
    */
    'target'?: string;
    /**
    * Button theme. For further information about the different themes, see designers' section: https://sdx.swisscom.ch/components_-_buttons.html#design
    */
    'theme'?: ButtonTheme;
    'valid'?: boolean;
  }

  interface SdxDummy {}
  interface SdxDummyAttributes extends StencilHTMLAttributes {}

  interface SdxFlip {
    /**
    * Mirror the content across one or both axes (or none at all).
    */
    'direction': FlipDirection;
  }
  interface SdxFlipAttributes extends StencilHTMLAttributes {
    /**
    * Mirror the content across one or both axes (or none at all).
    */
    'direction'?: FlipDirection;
  }

  interface SdxIcon {
    /**
    * SDX predefined color class.
    */
    'colorClass': string;
    /**
    * Mirror the icon.
    */
    'flip': FlipDirection;
    /**
    * Hide the icon (animated).
    */
    'hidden': boolean;
    /**
    * Name of the SDX icon (e.g. "icon-clear-circle").
    */
    'iconName': string;
    /**
    * The dimension of the icon.
    */
    'size': Size;
    /**
    * Description text read by the screen reader.
    */
    'srHint': string;
  }
  interface SdxIconAttributes extends StencilHTMLAttributes {
    /**
    * SDX predefined color class.
    */
    'colorClass'?: string;
    /**
    * Mirror the icon.
    */
    'flip'?: FlipDirection;
    /**
    * Hide the icon (animated).
    */
    'hidden'?: boolean;
    /**
    * Name of the SDX icon (e.g. "icon-clear-circle").
    */
    'iconName'?: string;
    /**
    * The dimension of the icon.
    */
    'size'?: Size;
    /**
    * Description text read by the screen reader.
    */
    'srHint'?: string;
  }

  interface SdxInputGroup {
    /**
    * Callback when the selected radio changed.
    */
    'changeCallback': ((checked: boolean) => void) | string | undefined;
    /**
    * Returns the current selection.
    */
    'getSelection': () => any[];
    /**
    * Display all input items in a row (for maximum two items &mdash; more items should be embedded in a grid).
    */
    'inline': boolean;
    /**
    * Label of the input group.
    */
    'label': string;
    /**
    * Name parameter (useful when the item is embedded in a traditional HTML form submit).
    */
    'name': string;
    /**
    * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
    */
    'required': boolean;
    /**
    * The form input variant of the item.
    */
    'type': Type;
    /**
    * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
  }
  interface SdxInputGroupAttributes extends StencilHTMLAttributes {
    /**
    * Callback when the selected radio changed.
    */
    'changeCallback'?: ((checked: boolean) => void) | string | undefined;
    /**
    * Display all input items in a row (for maximum two items &mdash; more items should be embedded in a grid).
    */
    'inline'?: boolean;
    /**
    * Label of the input group.
    */
    'label'?: string;
    /**
    * Name parameter (useful when the item is embedded in a traditional HTML form submit).
    */
    'name'?: string;
    /**
    * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
    */
    'required'?: boolean;
    /**
    * The form input variant of the item.
    */
    'type'?: Type;
    /**
    * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
  }

  interface SdxInputItem {
    /**
    * Callback whenever the user checks/unchecks the component.
    */
    'changeCallback': ((checked: boolean) => void) | string | undefined;
    /**
    * Whether the item is turned on or off.
    */
    'checked': boolean;
    /**
    * Make sure that the input item does not receive focus. Use this when the input item is used within a component that already handles focus (e.g. sdx-select-option in sdx-select with multiselect).
    */
    'disableFocus': boolean;
    /**
    * Not selectable.
    */
    'disabled': boolean;
    /**
    * Name parameter (useful when the item is embedded in a traditional HTML form submit).
    */
    'name'?: string;
    /**
    * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
    */
    'required': boolean;
    /**
    * The form input variant of the item.
    */
    'type': Type;
    /**
    * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
    /**
    * The current value.
    */
    'value': any;
  }
  interface SdxInputItemAttributes extends StencilHTMLAttributes {
    /**
    * Callback whenever the user checks/unchecks the component.
    */
    'changeCallback'?: ((checked: boolean) => void) | string | undefined;
    /**
    * Whether the item is turned on or off.
    */
    'checked'?: boolean;
    /**
    * Make sure that the input item does not receive focus. Use this when the input item is used within a component that already handles focus (e.g. sdx-select-option in sdx-select with multiselect).
    */
    'disableFocus'?: boolean;
    /**
    * Not selectable.
    */
    'disabled'?: boolean;
    /**
    * Name parameter (useful when the item is embedded in a traditional HTML form submit).
    */
    'name'?: string;
    /**
    * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
    */
    'required'?: boolean;
    /**
    * The form input variant of the item.
    */
    'type'?: Type;
    /**
    * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
    /**
    * The current value.
    */
    'value'?: any;
  }

  interface SdxInput {
    /**
    * Specifies the input fields native autocomplete behavior on modern browsers (e.g. "off", "username" or "new-password").
    */
    'autocomplete': string | undefined;
    /**
    * Callback that will fire when the input loses focus.
    */
    'blurCallback'?: (() => void) | string;
    /**
    * Callback that will fire when the value has changed, regardless of method (keyboard or programmatical).
    */
    'changeCallback'?: ((value: string) => void) | string;
    /**
    * Disabled and not focussable using tab.
    */
    'disabled': boolean;
    'editable': boolean;
    /**
    * Datepicker settings. When <code>type="date"</code>, flatpickr is used and can be configured via this attribute. Examples: <code>{ locale: "fr" }</code>, <code>{ minDate: "today" }</code> or <code>{ "altInput": true, "altFormat": "l j. F, Y" }</code>. See all options: https://flatpickr.js.org/examples/
    */
    'flatpickrOptions': any;
    /**
    * Callback that will fire when the input gets focus.
    */
    'focusCallback'?: (() => void) | string;
    /**
    * Callback that will fire on hitting enter.
    */
    'hitEnterCallback'?: (() => void) | string;
    /**
    * Callback that will fire when the value changes using the keyboard.
    */
    'inputCallback'?: ((value: string) => void) | string;
    'inputStyle': { [ key: string ]: string };
    /**
    * Text that will be written on the top.
    */
    'label': string;
    /**
    * For input type="number", maximum valid input value.
    */
    'max': number | undefined;
    /**
    * Allowed number of characters.
    */
    'maxlength': number | undefined;
    /**
    * For input type="number", minimum valid input value.
    */
    'min': number | undefined;
    /**
    * Name parameter (useful when the item is embedded in a traditional HTML form submit).
    */
    'name'?: string;
    /**
    * Default text that will be shown unless there's a value.
    */
    'placeholder': string;
    /**
    * Disabled, but focussable using tab.
    */
    'readonly': boolean;
    /**
    * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
    */
    'required': boolean;
    /**
    * Marks the text within the input on focus.
    */
    'selectTextOnFocus': boolean;
    /**
    * Text for the screen reader labelling the input field.
    */
    'srHint': string;
    /**
    * For input type="number", step size.
    */
    'step': number | undefined;
    /**
    * Default input field type (e.g. "search", "password", "date", etc.). When set to "date", flatpickr will take over. Caution: flatpickr does not fulfill the accessibility requirements of SDX, yet (but we're on it...).
    */
    'type': InputType;
    /**
    * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why). It can also be set to true, but this should only be done in rare cases (e.g. when checking a user name for availabilty using server-side validation).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
    /**
    * Can be used for both reading and writing the value.
    */
    'value': string;
  }
  interface SdxInputAttributes extends StencilHTMLAttributes {
    /**
    * Specifies the input fields native autocomplete behavior on modern browsers (e.g. "off", "username" or "new-password").
    */
    'autocomplete'?: string | undefined;
    /**
    * Callback that will fire when the input loses focus.
    */
    'blurCallback'?: (() => void) | string;
    /**
    * Callback that will fire when the value has changed, regardless of method (keyboard or programmatical).
    */
    'changeCallback'?: ((value: string) => void) | string;
    /**
    * Disabled and not focussable using tab.
    */
    'disabled'?: boolean;
    'editable'?: boolean;
    /**
    * Datepicker settings. When <code>type="date"</code>, flatpickr is used and can be configured via this attribute. Examples: <code>{ locale: "fr" }</code>, <code>{ minDate: "today" }</code> or <code>{ "altInput": true, "altFormat": "l j. F, Y" }</code>. See all options: https://flatpickr.js.org/examples/
    */
    'flatpickrOptions'?: any;
    /**
    * Callback that will fire when the input gets focus.
    */
    'focusCallback'?: (() => void) | string;
    /**
    * Callback that will fire on hitting enter.
    */
    'hitEnterCallback'?: (() => void) | string;
    /**
    * Callback that will fire when the value changes using the keyboard.
    */
    'inputCallback'?: ((value: string) => void) | string;
    'inputStyle'?: { [ key: string ]: string };
    /**
    * Text that will be written on the top.
    */
    'label'?: string;
    /**
    * For input type="number", maximum valid input value.
    */
    'max'?: number | undefined;
    /**
    * Allowed number of characters.
    */
    'maxlength'?: number | undefined;
    /**
    * For input type="number", minimum valid input value.
    */
    'min'?: number | undefined;
    /**
    * Name parameter (useful when the item is embedded in a traditional HTML form submit).
    */
    'name'?: string;
    /**
    * Default text that will be shown unless there's a value.
    */
    'placeholder'?: string;
    /**
    * Disabled, but focussable using tab.
    */
    'readonly'?: boolean;
    /**
    * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
    */
    'required'?: boolean;
    /**
    * Marks the text within the input on focus.
    */
    'selectTextOnFocus'?: boolean;
    /**
    * Text for the screen reader labelling the input field.
    */
    'srHint'?: string;
    /**
    * For input type="number", step size.
    */
    'step'?: number | undefined;
    /**
    * Default input field type (e.g. "search", "password", "date", etc.). When set to "date", flatpickr will take over. Caution: flatpickr does not fulfill the accessibility requirements of SDX, yet (but we're on it...).
    */
    'type'?: InputType;
    /**
    * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why). It can also be set to true, but this should only be done in rare cases (e.g. when checking a user name for availabilty using server-side validation).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
    /**
    * Can be used for both reading and writing the value.
    */
    'value'?: string;
  }

  interface SdxLoadingSpinner {
    /**
    * Dimension of the spinner.
    */
    'size': "small" | "large";
    /**
    * Description text read by the screen reader.
    */
    'srHint': string;
  }
  interface SdxLoadingSpinnerAttributes extends StencilHTMLAttributes {
    /**
    * Dimension of the spinner.
    */
    'size'?: "small" | "large";
    /**
    * Description text read by the screen reader.
    */
    'srHint'?: string;
  }

  interface SdxMenuFlyoutContent {}
  interface SdxMenuFlyoutContentAttributes extends StencilHTMLAttributes {}

  interface SdxMenuFlyoutCta {
    /**
    * Width of the flyout. If none is set, the Flyout grows dynamically (up to a certain point) based on the content.
    */
    'size': "small" | "medium" | "large" | "auto";
  }
  interface SdxMenuFlyoutCtaAttributes extends StencilHTMLAttributes {
    /**
    * Width of the flyout. If none is set, the Flyout grows dynamically (up to a certain point) based on the content.
    */
    'size'?: "small" | "medium" | "large" | "auto";
  }

  interface SdxMenuFlyoutListItem {
    /**
    * Whether the item is disabled.
    */
    'disabled': boolean;
    /**
    * The URL this item should link to (if it’s a regular link not handled by JS).
    */
    'href': string;
    /**
    * If the item is not selectable, it is neither highlighted nor has it cursor: pointer.
    */
    'selectable': boolean;
  }
  interface SdxMenuFlyoutListItemAttributes extends StencilHTMLAttributes {
    /**
    * Whether the item is disabled.
    */
    'disabled'?: boolean;
    /**
    * The URL this item should link to (if it’s a regular link not handled by JS).
    */
    'href'?: string;
    /**
    * If the item is not selectable, it is neither highlighted nor has it cursor: pointer.
    */
    'selectable'?: boolean;
  }

  interface SdxMenuFlyoutList {}
  interface SdxMenuFlyoutListAttributes extends StencilHTMLAttributes {}

  interface SdxMenuFlyoutToggle {}
  interface SdxMenuFlyoutToggleAttributes extends StencilHTMLAttributes {}

  interface SdxMenuFlyout {
    /**
    * Closes the flyout.
    */
    'close': () => Promise<void>;
    /**
    * Close if the user clicks on the flyout.
    */
    'closeOnClick': boolean;
    /**
    * In which direction the flyout opens.
    */
    'direction': Direction;
    /**
    * Callback that will fire after the flyouts display status has changed.
    */
    'displayChangeCallback'?: ((display: Display) => void) | string;
    /**
    * Opens the flyout.
    */
    'open': () => Promise<void>;
    /**
    * Toggles the flyout.
    */
    'toggle': () => Promise<void>;
  }
  interface SdxMenuFlyoutAttributes extends StencilHTMLAttributes {
    /**
    * Close if the user clicks on the flyout.
    */
    'closeOnClick'?: boolean;
    /**
    * In which direction the flyout opens.
    */
    'direction'?: Direction;
    /**
    * Callback that will fire after the flyouts display status has changed.
    */
    'displayChangeCallback'?: ((display: Display) => void) | string;
  }

  interface SdxNumericStepper {
    /**
    * Callback that will fire on change.
    */
    'changeCallback': ((value: string) => void) | string | undefined;
    /**
    * Disabled and not focusable using tab.
    */
    'disabled': boolean;
    /**
    * Text that will be written on the top of the numeric stepper. Make sure to include the maximum possible value here for the user.
    */
    'label': string;
    /**
    * Maximum value. Cannot be set greater than 999.
    */
    'max': number;
    /**
    * Minimum value. Cannot be negative.
    */
    'min': number;
    /**
    * Text for the screen reader describing the numeric stepper.
    */
    'srHint': string;
    /**
    * Step size.
    */
    'step': number;
    /**
    * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why). It can also be set to true, but this should only be done in rare cases (e.g. when checking a user name for availabilty using server-side validation).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
    /**
    * Initial value. Must be between 0 and 999 including.
    */
    'value': number;
  }
  interface SdxNumericStepperAttributes extends StencilHTMLAttributes {
    /**
    * Callback that will fire on change.
    */
    'changeCallback'?: ((value: string) => void) | string | undefined;
    /**
    * Disabled and not focusable using tab.
    */
    'disabled'?: boolean;
    /**
    * Text that will be written on the top of the numeric stepper. Make sure to include the maximum possible value here for the user.
    */
    'label'?: string;
    /**
    * Maximum value. Cannot be set greater than 999.
    */
    'max'?: number;
    /**
    * Minimum value. Cannot be negative.
    */
    'min'?: number;
    /**
    * Text for the screen reader describing the numeric stepper.
    */
    'srHint'?: string;
    /**
    * Step size.
    */
    'step'?: number;
    /**
    * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why). It can also be set to true, but this should only be done in rare cases (e.g. when checking a user name for availabilty using server-side validation).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
    /**
    * Initial value. Must be between 0 and 999 including.
    */
    'value'?: number;
  }

  interface SdxPieChart {
    /**
    * Background color scheme.
    */
    'backgroundTheme': BackgroundTheme;
    /**
    * The values to display.
    */
    'data': PieChartDataPoint[] | string;
    /**
    * Description text of what is displayed (e.g. "Storage" or "Available"). This does not appear in the "small" version.
    */
    'description'?: string;
    /**
    * Where to render the labels.
    */
    'legendPosition': "bottom" | "right";
    /**
    * Dimension of the chart.
    */
    'size': "small" | "medium";
    /**
    * Text that contains the relevant information (e.g. "100 %"). It will be displayed in the center of the chart.
    */
    'value': string;
  }
  interface SdxPieChartAttributes extends StencilHTMLAttributes {
    /**
    * Background color scheme.
    */
    'backgroundTheme'?: BackgroundTheme;
    /**
    * The values to display.
    */
    'data'?: PieChartDataPoint[] | string;
    /**
    * Description text of what is displayed (e.g. "Storage" or "Available"). This does not appear in the "small" version.
    */
    'description'?: string;
    /**
    * Where to render the labels.
    */
    'legendPosition'?: "bottom" | "right";
    /**
    * Dimension of the chart.
    */
    'size'?: "small" | "medium";
    /**
    * Text that contains the relevant information (e.g. "100 %"). It will be displayed in the center of the chart.
    */
    'value'?: string;
  }

  interface SdxPrice {
    /**
    * The amount to be paid.
    */
    'amount': number;
    /**
    * Time period, for example "/mo.".
    */
    'period': string;
    /**
    * The font size.
    */
    'size': Size;
    /**
    * Description text read by the screen reader.
    */
    'srHint': string;
  }
  interface SdxPriceAttributes extends StencilHTMLAttributes {
    /**
    * The amount to be paid.
    */
    'amount'?: number;
    /**
    * Time period, for example "/mo.".
    */
    'period'?: string;
    /**
    * The font size.
    */
    'size'?: Size;
    /**
    * Description text read by the screen reader.
    */
    'srHint'?: string;
  }

  interface SdxProgressFullStep {
    'position': StepPosition;
    'status': Status;
    /**
    * Triggered when a user clicks on the button or description of a completed step.
    */
    'stepClickCallback': (() => void) | string | undefined;
    'value': number;
  }
  interface SdxProgressFullStepAttributes extends StencilHTMLAttributes {
    'position'?: StepPosition;
    'status'?: Status;
    /**
    * Triggered when a user clicks on the button or description of a completed step.
    */
    'stepClickCallback'?: (() => void) | string | undefined;
    'value'?: number;
  }

  interface SdxProgressFull {
    'animated': boolean;
    /**
    * Get the current active step.
    */
    'getActiveStep': () => number;
    /**
    * Move to next step if its available.
    */
    'nextStep': () => void;
    /**
    * Move to previous step if its available.
    */
    'previousStep': () => void;
    /**
    * Set a step as active based on an index.
    */
    'setActiveStep': (index: number, animation: boolean) => void;
    /**
    * Current active step of the progress bar.
    */
    'step': number;
    /**
    * Triggered when the active step was changed.
    */
    'stepChangeCallback': ((activeStep: number, previousActiveStep?: number) => void) | string | undefined;
    /**
    * Label used next to total amount of steps when not all steps are being displayed.
    */
    'stepsLabel': string;
  }
  interface SdxProgressFullAttributes extends StencilHTMLAttributes {
    'animated'?: boolean;
    /**
    * Current active step of the progress bar.
    */
    'step'?: number;
    /**
    * Triggered when the active step was changed.
    */
    'stepChangeCallback'?: ((activeStep: number, previousActiveStep?: number) => void) | string | undefined;
    /**
    * Label used next to total amount of steps when not all steps are being displayed.
    */
    'stepsLabel'?: string;
  }

  interface SdxRibbon {
    /**
    * Look.
    */
    'design': Design;
    /**
    * Text content.
    */
    'label': string;
    /**
    * Location.
    */
    'position': Position;
    /**
    * Dimension.
    */
    'size': Size;
  }
  interface SdxRibbonAttributes extends StencilHTMLAttributes {
    /**
    * Look.
    */
    'design'?: Design;
    /**
    * Text content.
    */
    'label'?: string;
    /**
    * Location.
    */
    'position'?: Position;
    /**
    * Dimension.
    */
    'size'?: Size;
  }

  interface SdxScrollToTop {
    'demo': boolean;
    'position': Position;
  }
  interface SdxScrollToTopAttributes extends StencilHTMLAttributes {
    'demo'?: boolean;
    'position'?: Position;
  }

  interface SdxSearch {
    /**
    * Callback that will fire on change (same as valueChangeCallback).
    */
    'changeCallback': ((value: string) => void) | string | undefined;
    /**
    * Default text that will disappear on type.
    */
    'placeholder': string;
    /**
    * Callback that will fire on hitting enter or on clicking the button.
    */
    'searchSubmitCallback': ((value: string) => void) | string | undefined;
    /**
    * Text for the screen reader labelling the search input field.
    */
    'srHint': string;
    /**
    * Button text for the screen reader to read in place of the search icon.
    */
    'srHintForButton': string;
    /**
    * Can be used for both reading and writing the (current) value.
    */
    'value': string;
    'valueChangeCallback': ((value: string) => void) | string | undefined;
  }
  interface SdxSearchAttributes extends StencilHTMLAttributes {
    /**
    * Callback that will fire on change (same as valueChangeCallback).
    */
    'changeCallback'?: ((value: string) => void) | string | undefined;
    /**
    * Default text that will disappear on type.
    */
    'placeholder'?: string;
    /**
    * Callback that will fire on hitting enter or on clicking the button.
    */
    'searchSubmitCallback'?: ((value: string) => void) | string | undefined;
    /**
    * Text for the screen reader labelling the search input field.
    */
    'srHint'?: string;
    /**
    * Button text for the screen reader to read in place of the search icon.
    */
    'srHintForButton'?: string;
    /**
    * Can be used for both reading and writing the (current) value.
    */
    'value'?: string;
    'valueChangeCallback'?: ((value: string) => void) | string | undefined;
  }

  interface SdxSelectOptgroup {
    /**
    * Label of the group to be displayed.
    */
    'name': string;
  }
  interface SdxSelectOptgroupAttributes extends StencilHTMLAttributes {
    /**
    * Label of the group to be displayed.
    */
    'name'?: string;
  }

  interface SdxSelectOption {
    /**
    * Not selectable (event propagation will be stopped).
    */
    'disabled': boolean;
    'placeholder': boolean;
    /**
    * Whether this option is initially selected.
    */
    'selected': boolean;
    /**
    * Value of the option that will be returned in the selection.
    */
    'value': any;
  }
  interface SdxSelectOptionAttributes extends StencilHTMLAttributes {
    /**
    * Not selectable (event propagation will be stopped).
    */
    'disabled'?: boolean;
    'placeholder'?: boolean;
    /**
    * Whether this option is initially selected.
    */
    'selected'?: boolean;
    /**
    * Value of the option that will be returned in the selection.
    */
    'value'?: any;
  }

  interface SdxSelect {
    'animated': boolean;
    /**
    * Background color scheme.
    */
    'backgroundTheme': BackgroundTheme;
    /**
    * Callback that will fire when the input loses focus. Used when "keyboard-behavior" is "filter" or "autocomplete".
    */
    'blurCallback'?: (() => void) | string;
    /**
    * Callback when user selects an option (or types something while in "autocomplete" mode).
    */
    'changeCallback': ((selection: any[]) => void) | string | undefined;
    /**
    * Closes the sdx-select.
    */
    'close': () => Promise<void>;
    /**
    * Disables the sdx-select.
    */
    'disabled': boolean;
    /**
    * Function that decides whether an option element matches a filter by returning true or false. Defaults to a function that performs a simple string match test on the option elements textContent property. Used when "keyboard-behavior" is "filter" or "autocomplete".
    */
    'filterFunction': ((optionEl: HTMLSdxSelectOptionElement, keyword: string) => boolean) | string | undefined;
    'filterable': boolean;
    /**
    * Callback that will fire when the input gets focus. Used when "keyboard-behavior" is "filter" or "autocomplete".
    */
    'focusCallback'?: (() => void) | string;
    /**
    * Returns the current selection.
    */
    'getSelection': () => any[];
    /**
    * How the component should behave when the user types something on the keyboard. "focus" jumps to and focuses the option starting with the typed character. "filter" lists only options (and optgroups) that match the entered keyword. "autocomplete" is similar to "filter", but makes the component behave more like an input field, e.g. the "value" reflects the content of the filter and there is no thumb to open or close.
    */
    'keyboardBehavior': KeyboardBehavior;
    /**
    * Will be written on the top of the sdx-select.
    */
    'label': string;
    /**
    * Shows a loading spinner and disables the sdx-select.
    */
    'loading': boolean;
    /**
    * Maximum dropdown height in px.
    */
    'maxHeight': number;
    /**
    * Enable multi select.
    */
    'multiple': boolean;
    /**
    * Name parameter (useful when the item is embedded in a traditional HTML form submit).
    */
    'name'?: string;
    /**
    * Label for "no matches found".
    */
    'noMatchesFoundLabel': string;
    /**
    * Opens the sdx-select.
    */
    'open': () => Promise<void>;
    /**
    * Text to be displayed when nothing is selected.
    */
    'placeholder': string;
    /**
    * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
    */
    'required': boolean;
    /**
    * Callback when user selects an option (and the select is *not* in "autocomplete" mode).
    */
    'selectCallback': ((selection: any[]) => void) | string | undefined;
    /**
    * Description text read by the screen reader.
    */
    'srHint': string;
    /**
    * Toggles the sdx-select.
    */
    'toggle': () => Promise<void>;
    /**
    * Set this to false to declare the component as invalid (note that this only works with when the "validation-message" attribute is set - and vice versa).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
    /**
    * The value(s) of the currently selected option(s). Please note that this is always an array, even without the "multiple" attribute, for both getting and setting the value <code>(e.g. mySelect.value = [ "value1" ])</code>).
    */
    'value': any[];
  }
  interface SdxSelectAttributes extends StencilHTMLAttributes {
    'animated'?: boolean;
    /**
    * Background color scheme.
    */
    'backgroundTheme'?: BackgroundTheme;
    /**
    * Callback that will fire when the input loses focus. Used when "keyboard-behavior" is "filter" or "autocomplete".
    */
    'blurCallback'?: (() => void) | string;
    /**
    * Callback when user selects an option (or types something while in "autocomplete" mode).
    */
    'changeCallback'?: ((selection: any[]) => void) | string | undefined;
    /**
    * Disables the sdx-select.
    */
    'disabled'?: boolean;
    /**
    * Function that decides whether an option element matches a filter by returning true or false. Defaults to a function that performs a simple string match test on the option elements textContent property. Used when "keyboard-behavior" is "filter" or "autocomplete".
    */
    'filterFunction'?: ((optionEl: HTMLSdxSelectOptionElement, keyword: string) => boolean) | string | undefined;
    'filterable'?: boolean;
    /**
    * Callback that will fire when the input gets focus. Used when "keyboard-behavior" is "filter" or "autocomplete".
    */
    'focusCallback'?: (() => void) | string;
    /**
    * How the component should behave when the user types something on the keyboard. "focus" jumps to and focuses the option starting with the typed character. "filter" lists only options (and optgroups) that match the entered keyword. "autocomplete" is similar to "filter", but makes the component behave more like an input field, e.g. the "value" reflects the content of the filter and there is no thumb to open or close.
    */
    'keyboardBehavior'?: KeyboardBehavior;
    /**
    * Will be written on the top of the sdx-select.
    */
    'label'?: string;
    /**
    * Shows a loading spinner and disables the sdx-select.
    */
    'loading'?: boolean;
    /**
    * Maximum dropdown height in px.
    */
    'maxHeight'?: number;
    /**
    * Enable multi select.
    */
    'multiple'?: boolean;
    /**
    * Name parameter (useful when the item is embedded in a traditional HTML form submit).
    */
    'name'?: string;
    /**
    * Label for "no matches found".
    */
    'noMatchesFoundLabel'?: string;
    /**
    * Text to be displayed when nothing is selected.
    */
    'placeholder'?: string;
    /**
    * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
    */
    'required'?: boolean;
    /**
    * Callback when user selects an option (and the select is *not* in "autocomplete" mode).
    */
    'selectCallback'?: ((selection: any[]) => void) | string | undefined;
    /**
    * Description text read by the screen reader.
    */
    'srHint'?: string;
    /**
    * Set this to false to declare the component as invalid (note that this only works with when the "validation-message" attribute is set - and vice versa).
    */
    'valid'?: boolean;
    /**
    * Text that explains the validation status to the user.
    */
    'validationMessage'?: string;
    /**
    * The value(s) of the currently selected option(s). Please note that this is always an array, even without the "multiple" attribute, for both getting and setting the value <code>(e.g. mySelect.value = [ "value1" ])</code>).
    */
    'value'?: any[];
  }

  interface SdxShowMore {
    /**
    * Button theme.
    */
    'buttonTheme': ButtonTheme;
    /**
    * Label for "from".
    */
    'fromLabel': string;
    /**
    * How many items to add by each turn.
    */
    'incrementBy': number;
    /**
    * Triggered when the number of displayed items has incremented.
    */
    'incrementCallback'?: ((count: number) => void) | string;
    /**
    * Number of items to start from.
    */
    'initialItems': number;
    /**
    * Label for "more".
    */
    'moreLabel': string;
    /**
    * Number of all items in total.
    */
    'totalItems': number;
  }
  interface SdxShowMoreAttributes extends StencilHTMLAttributes {
    /**
    * Button theme.
    */
    'buttonTheme'?: ButtonTheme;
    /**
    * Label for "from".
    */
    'fromLabel'?: string;
    /**
    * How many items to add by each turn.
    */
    'incrementBy'?: number;
    /**
    * Triggered when the number of displayed items has incremented.
    */
    'incrementCallback'?: ((count: number) => void) | string;
    /**
    * Number of items to start from.
    */
    'initialItems'?: number;
    /**
    * Label for "more".
    */
    'moreLabel'?: string;
    /**
    * Number of all items in total.
    */
    'totalItems'?: number;
  }

  interface SdxStickerCircle {
    /**
    * SDX predefined color class (or transparent) for the sticker background.
    */
    'bgColorClass': string;
    /**
    * Offset from the bottom edge, in % of the content's height.
    */
    'bottom'?: number;
    /**
    * SDX predefined color class for the text and border.
    */
    'colorClass': string;
    /**
    * The content width at which the sticker should be normal size (nonscaled).
    */
    'contentWidth'?: number;
    /**
    * Offset from the left edge, in % of the content's width.
    */
    'left'?: number;
    /**
    * Offset from the right edge, in % of the content's width.
    */
    'right'?: number;
    /**
    * The size (diameter) in px.
    */
    'size': number;
    /**
    * Description text read by the screen reader.
    */
    'srHint': string;
    /**
    * Offset from the top edge, in % of the content's height.
    */
    'top'?: number;
  }
  interface SdxStickerCircleAttributes extends StencilHTMLAttributes {
    /**
    * SDX predefined color class (or transparent) for the sticker background.
    */
    'bgColorClass'?: string;
    /**
    * Offset from the bottom edge, in % of the content's height.
    */
    'bottom'?: number;
    /**
    * SDX predefined color class for the text and border.
    */
    'colorClass'?: string;
    /**
    * The content width at which the sticker should be normal size (nonscaled).
    */
    'contentWidth'?: number;
    /**
    * Offset from the left edge, in % of the content's width.
    */
    'left'?: number;
    /**
    * Offset from the right edge, in % of the content's width.
    */
    'right'?: number;
    /**
    * The size (diameter) in px.
    */
    'size'?: number;
    /**
    * Description text read by the screen reader.
    */
    'srHint'?: string;
    /**
    * Offset from the top edge, in % of the content's height.
    */
    'top'?: number;
  }

  interface SdxTextTruncate {}
  interface SdxTextTruncateAttributes extends StencilHTMLAttributes {}

  interface SdxValidationMessage {
    'valid': boolean;
    'validationMessage': string;
  }
  interface SdxValidationMessageAttributes extends StencilHTMLAttributes {
    'valid'?: boolean;
    'validationMessage'?: string;
  }

  interface SdxItunesAutocomplete {}
  interface SdxItunesAutocompleteAttributes extends StencilHTMLAttributes {}
}

declare global {
  interface StencilElementInterfaces {
    'SdxAccordionItemBody': Components.SdxAccordionItemBody;
    'SdxAccordionArrow': Components.SdxAccordionArrow;
    'SdxAccordionItemHeader': Components.SdxAccordionItemHeader;
    'SdxAccordionItemSection': Components.SdxAccordionItemSection;
    'SdxAccordionItem': Components.SdxAccordionItem;
    'SdxAccordion': Components.SdxAccordion;
    'SdxAnimation': Components.SdxAnimation;
    'SdxButtonGroup': Components.SdxButtonGroup;
    'SdxButton': Components.SdxButton;
    'SdxDummy': Components.SdxDummy;
    'SdxFlip': Components.SdxFlip;
    'SdxIcon': Components.SdxIcon;
    'SdxInputGroup': Components.SdxInputGroup;
    'SdxInputItem': Components.SdxInputItem;
    'SdxInput': Components.SdxInput;
    'SdxLoadingSpinner': Components.SdxLoadingSpinner;
    'SdxMenuFlyoutContent': Components.SdxMenuFlyoutContent;
    'SdxMenuFlyoutCta': Components.SdxMenuFlyoutCta;
    'SdxMenuFlyoutListItem': Components.SdxMenuFlyoutListItem;
    'SdxMenuFlyoutList': Components.SdxMenuFlyoutList;
    'SdxMenuFlyoutToggle': Components.SdxMenuFlyoutToggle;
    'SdxMenuFlyout': Components.SdxMenuFlyout;
    'SdxNumericStepper': Components.SdxNumericStepper;
    'SdxPieChart': Components.SdxPieChart;
    'SdxPrice': Components.SdxPrice;
    'SdxProgressFullStep': Components.SdxProgressFullStep;
    'SdxProgressFull': Components.SdxProgressFull;
    'SdxRibbon': Components.SdxRibbon;
    'SdxScrollToTop': Components.SdxScrollToTop;
    'SdxSearch': Components.SdxSearch;
    'SdxSelectOptgroup': Components.SdxSelectOptgroup;
    'SdxSelectOption': Components.SdxSelectOption;
    'SdxSelect': Components.SdxSelect;
    'SdxShowMore': Components.SdxShowMore;
    'SdxStickerCircle': Components.SdxStickerCircle;
    'SdxTextTruncate': Components.SdxTextTruncate;
    'SdxValidationMessage': Components.SdxValidationMessage;
    'SdxItunesAutocomplete': Components.SdxItunesAutocomplete;
  }

  interface StencilIntrinsicElements {
    'sdx-accordion-item-body': Components.SdxAccordionItemBodyAttributes;
    'sdx-accordion-arrow': Components.SdxAccordionArrowAttributes;
    'sdx-accordion-item-header': Components.SdxAccordionItemHeaderAttributes;
    'sdx-accordion-item-section': Components.SdxAccordionItemSectionAttributes;
    'sdx-accordion-item': Components.SdxAccordionItemAttributes;
    'sdx-accordion': Components.SdxAccordionAttributes;
    'sdx-animation': Components.SdxAnimationAttributes;
    'sdx-button-group': Components.SdxButtonGroupAttributes;
    'sdx-button': Components.SdxButtonAttributes;
    'sdx-dummy': Components.SdxDummyAttributes;
    'sdx-flip': Components.SdxFlipAttributes;
    'sdx-icon': Components.SdxIconAttributes;
    'sdx-input-group': Components.SdxInputGroupAttributes;
    'sdx-input-item': Components.SdxInputItemAttributes;
    'sdx-input': Components.SdxInputAttributes;
    'sdx-loading-spinner': Components.SdxLoadingSpinnerAttributes;
    'sdx-menu-flyout-content': Components.SdxMenuFlyoutContentAttributes;
    'sdx-menu-flyout-cta': Components.SdxMenuFlyoutCtaAttributes;
    'sdx-menu-flyout-list-item': Components.SdxMenuFlyoutListItemAttributes;
    'sdx-menu-flyout-list': Components.SdxMenuFlyoutListAttributes;
    'sdx-menu-flyout-toggle': Components.SdxMenuFlyoutToggleAttributes;
    'sdx-menu-flyout': Components.SdxMenuFlyoutAttributes;
    'sdx-numeric-stepper': Components.SdxNumericStepperAttributes;
    'sdx-pie-chart': Components.SdxPieChartAttributes;
    'sdx-price': Components.SdxPriceAttributes;
    'sdx-progress-full-step': Components.SdxProgressFullStepAttributes;
    'sdx-progress-full': Components.SdxProgressFullAttributes;
    'sdx-ribbon': Components.SdxRibbonAttributes;
    'sdx-scroll-to-top': Components.SdxScrollToTopAttributes;
    'sdx-search': Components.SdxSearchAttributes;
    'sdx-select-optgroup': Components.SdxSelectOptgroupAttributes;
    'sdx-select-option': Components.SdxSelectOptionAttributes;
    'sdx-select': Components.SdxSelectAttributes;
    'sdx-show-more': Components.SdxShowMoreAttributes;
    'sdx-sticker-circle': Components.SdxStickerCircleAttributes;
    'sdx-text-truncate': Components.SdxTextTruncateAttributes;
    'sdx-validation-message': Components.SdxValidationMessageAttributes;
    'sdx-itunes-autocomplete': Components.SdxItunesAutocompleteAttributes;
  }


  interface HTMLSdxAccordionItemBodyElement extends Components.SdxAccordionItemBody, HTMLStencilElement {}
  var HTMLSdxAccordionItemBodyElement: {
    prototype: HTMLSdxAccordionItemBodyElement;
    new (): HTMLSdxAccordionItemBodyElement;
  };

  interface HTMLSdxAccordionArrowElement extends Components.SdxAccordionArrow, HTMLStencilElement {}
  var HTMLSdxAccordionArrowElement: {
    prototype: HTMLSdxAccordionArrowElement;
    new (): HTMLSdxAccordionArrowElement;
  };

  interface HTMLSdxAccordionItemHeaderElement extends Components.SdxAccordionItemHeader, HTMLStencilElement {}
  var HTMLSdxAccordionItemHeaderElement: {
    prototype: HTMLSdxAccordionItemHeaderElement;
    new (): HTMLSdxAccordionItemHeaderElement;
  };

  interface HTMLSdxAccordionItemSectionElement extends Components.SdxAccordionItemSection, HTMLStencilElement {}
  var HTMLSdxAccordionItemSectionElement: {
    prototype: HTMLSdxAccordionItemSectionElement;
    new (): HTMLSdxAccordionItemSectionElement;
  };

  interface HTMLSdxAccordionItemElement extends Components.SdxAccordionItem, HTMLStencilElement {}
  var HTMLSdxAccordionItemElement: {
    prototype: HTMLSdxAccordionItemElement;
    new (): HTMLSdxAccordionItemElement;
  };

  interface HTMLSdxAccordionElement extends Components.SdxAccordion, HTMLStencilElement {}
  var HTMLSdxAccordionElement: {
    prototype: HTMLSdxAccordionElement;
    new (): HTMLSdxAccordionElement;
  };

  interface HTMLSdxAnimationElement extends Components.SdxAnimation, HTMLStencilElement {}
  var HTMLSdxAnimationElement: {
    prototype: HTMLSdxAnimationElement;
    new (): HTMLSdxAnimationElement;
  };

  interface HTMLSdxButtonGroupElement extends Components.SdxButtonGroup, HTMLStencilElement {}
  var HTMLSdxButtonGroupElement: {
    prototype: HTMLSdxButtonGroupElement;
    new (): HTMLSdxButtonGroupElement;
  };

  interface HTMLSdxButtonElement extends Components.SdxButton, HTMLStencilElement {}
  var HTMLSdxButtonElement: {
    prototype: HTMLSdxButtonElement;
    new (): HTMLSdxButtonElement;
  };

  interface HTMLSdxDummyElement extends Components.SdxDummy, HTMLStencilElement {}
  var HTMLSdxDummyElement: {
    prototype: HTMLSdxDummyElement;
    new (): HTMLSdxDummyElement;
  };

  interface HTMLSdxFlipElement extends Components.SdxFlip, HTMLStencilElement {}
  var HTMLSdxFlipElement: {
    prototype: HTMLSdxFlipElement;
    new (): HTMLSdxFlipElement;
  };

  interface HTMLSdxIconElement extends Components.SdxIcon, HTMLStencilElement {}
  var HTMLSdxIconElement: {
    prototype: HTMLSdxIconElement;
    new (): HTMLSdxIconElement;
  };

  interface HTMLSdxInputGroupElement extends Components.SdxInputGroup, HTMLStencilElement {}
  var HTMLSdxInputGroupElement: {
    prototype: HTMLSdxInputGroupElement;
    new (): HTMLSdxInputGroupElement;
  };

  interface HTMLSdxInputItemElement extends Components.SdxInputItem, HTMLStencilElement {}
  var HTMLSdxInputItemElement: {
    prototype: HTMLSdxInputItemElement;
    new (): HTMLSdxInputItemElement;
  };

  interface HTMLSdxInputElement extends Components.SdxInput, HTMLStencilElement {}
  var HTMLSdxInputElement: {
    prototype: HTMLSdxInputElement;
    new (): HTMLSdxInputElement;
  };

  interface HTMLSdxLoadingSpinnerElement extends Components.SdxLoadingSpinner, HTMLStencilElement {}
  var HTMLSdxLoadingSpinnerElement: {
    prototype: HTMLSdxLoadingSpinnerElement;
    new (): HTMLSdxLoadingSpinnerElement;
  };

  interface HTMLSdxMenuFlyoutContentElement extends Components.SdxMenuFlyoutContent, HTMLStencilElement {}
  var HTMLSdxMenuFlyoutContentElement: {
    prototype: HTMLSdxMenuFlyoutContentElement;
    new (): HTMLSdxMenuFlyoutContentElement;
  };

  interface HTMLSdxMenuFlyoutCtaElement extends Components.SdxMenuFlyoutCta, HTMLStencilElement {}
  var HTMLSdxMenuFlyoutCtaElement: {
    prototype: HTMLSdxMenuFlyoutCtaElement;
    new (): HTMLSdxMenuFlyoutCtaElement;
  };

  interface HTMLSdxMenuFlyoutListItemElement extends Components.SdxMenuFlyoutListItem, HTMLStencilElement {}
  var HTMLSdxMenuFlyoutListItemElement: {
    prototype: HTMLSdxMenuFlyoutListItemElement;
    new (): HTMLSdxMenuFlyoutListItemElement;
  };

  interface HTMLSdxMenuFlyoutListElement extends Components.SdxMenuFlyoutList, HTMLStencilElement {}
  var HTMLSdxMenuFlyoutListElement: {
    prototype: HTMLSdxMenuFlyoutListElement;
    new (): HTMLSdxMenuFlyoutListElement;
  };

  interface HTMLSdxMenuFlyoutToggleElement extends Components.SdxMenuFlyoutToggle, HTMLStencilElement {}
  var HTMLSdxMenuFlyoutToggleElement: {
    prototype: HTMLSdxMenuFlyoutToggleElement;
    new (): HTMLSdxMenuFlyoutToggleElement;
  };

  interface HTMLSdxMenuFlyoutElement extends Components.SdxMenuFlyout, HTMLStencilElement {}
  var HTMLSdxMenuFlyoutElement: {
    prototype: HTMLSdxMenuFlyoutElement;
    new (): HTMLSdxMenuFlyoutElement;
  };

  interface HTMLSdxNumericStepperElement extends Components.SdxNumericStepper, HTMLStencilElement {}
  var HTMLSdxNumericStepperElement: {
    prototype: HTMLSdxNumericStepperElement;
    new (): HTMLSdxNumericStepperElement;
  };

  interface HTMLSdxPieChartElement extends Components.SdxPieChart, HTMLStencilElement {}
  var HTMLSdxPieChartElement: {
    prototype: HTMLSdxPieChartElement;
    new (): HTMLSdxPieChartElement;
  };

  interface HTMLSdxPriceElement extends Components.SdxPrice, HTMLStencilElement {}
  var HTMLSdxPriceElement: {
    prototype: HTMLSdxPriceElement;
    new (): HTMLSdxPriceElement;
  };

  interface HTMLSdxProgressFullStepElement extends Components.SdxProgressFullStep, HTMLStencilElement {}
  var HTMLSdxProgressFullStepElement: {
    prototype: HTMLSdxProgressFullStepElement;
    new (): HTMLSdxProgressFullStepElement;
  };

  interface HTMLSdxProgressFullElement extends Components.SdxProgressFull, HTMLStencilElement {}
  var HTMLSdxProgressFullElement: {
    prototype: HTMLSdxProgressFullElement;
    new (): HTMLSdxProgressFullElement;
  };

  interface HTMLSdxRibbonElement extends Components.SdxRibbon, HTMLStencilElement {}
  var HTMLSdxRibbonElement: {
    prototype: HTMLSdxRibbonElement;
    new (): HTMLSdxRibbonElement;
  };

  interface HTMLSdxScrollToTopElement extends Components.SdxScrollToTop, HTMLStencilElement {}
  var HTMLSdxScrollToTopElement: {
    prototype: HTMLSdxScrollToTopElement;
    new (): HTMLSdxScrollToTopElement;
  };

  interface HTMLSdxSearchElement extends Components.SdxSearch, HTMLStencilElement {}
  var HTMLSdxSearchElement: {
    prototype: HTMLSdxSearchElement;
    new (): HTMLSdxSearchElement;
  };

  interface HTMLSdxSelectOptgroupElement extends Components.SdxSelectOptgroup, HTMLStencilElement {}
  var HTMLSdxSelectOptgroupElement: {
    prototype: HTMLSdxSelectOptgroupElement;
    new (): HTMLSdxSelectOptgroupElement;
  };

  interface HTMLSdxSelectOptionElement extends Components.SdxSelectOption, HTMLStencilElement {}
  var HTMLSdxSelectOptionElement: {
    prototype: HTMLSdxSelectOptionElement;
    new (): HTMLSdxSelectOptionElement;
  };

  interface HTMLSdxSelectElement extends Components.SdxSelect, HTMLStencilElement {}
  var HTMLSdxSelectElement: {
    prototype: HTMLSdxSelectElement;
    new (): HTMLSdxSelectElement;
  };

  interface HTMLSdxShowMoreElement extends Components.SdxShowMore, HTMLStencilElement {}
  var HTMLSdxShowMoreElement: {
    prototype: HTMLSdxShowMoreElement;
    new (): HTMLSdxShowMoreElement;
  };

  interface HTMLSdxStickerCircleElement extends Components.SdxStickerCircle, HTMLStencilElement {}
  var HTMLSdxStickerCircleElement: {
    prototype: HTMLSdxStickerCircleElement;
    new (): HTMLSdxStickerCircleElement;
  };

  interface HTMLSdxTextTruncateElement extends Components.SdxTextTruncate, HTMLStencilElement {}
  var HTMLSdxTextTruncateElement: {
    prototype: HTMLSdxTextTruncateElement;
    new (): HTMLSdxTextTruncateElement;
  };

  interface HTMLSdxValidationMessageElement extends Components.SdxValidationMessage, HTMLStencilElement {}
  var HTMLSdxValidationMessageElement: {
    prototype: HTMLSdxValidationMessageElement;
    new (): HTMLSdxValidationMessageElement;
  };

  interface HTMLSdxItunesAutocompleteElement extends Components.SdxItunesAutocomplete, HTMLStencilElement {}
  var HTMLSdxItunesAutocompleteElement: {
    prototype: HTMLSdxItunesAutocompleteElement;
    new (): HTMLSdxItunesAutocompleteElement;
  };

  interface HTMLElementTagNameMap {
    'sdx-accordion-item-body': HTMLSdxAccordionItemBodyElement
    'sdx-accordion-arrow': HTMLSdxAccordionArrowElement
    'sdx-accordion-item-header': HTMLSdxAccordionItemHeaderElement
    'sdx-accordion-item-section': HTMLSdxAccordionItemSectionElement
    'sdx-accordion-item': HTMLSdxAccordionItemElement
    'sdx-accordion': HTMLSdxAccordionElement
    'sdx-animation': HTMLSdxAnimationElement
    'sdx-button-group': HTMLSdxButtonGroupElement
    'sdx-button': HTMLSdxButtonElement
    'sdx-dummy': HTMLSdxDummyElement
    'sdx-flip': HTMLSdxFlipElement
    'sdx-icon': HTMLSdxIconElement
    'sdx-input-group': HTMLSdxInputGroupElement
    'sdx-input-item': HTMLSdxInputItemElement
    'sdx-input': HTMLSdxInputElement
    'sdx-loading-spinner': HTMLSdxLoadingSpinnerElement
    'sdx-menu-flyout-content': HTMLSdxMenuFlyoutContentElement
    'sdx-menu-flyout-cta': HTMLSdxMenuFlyoutCtaElement
    'sdx-menu-flyout-list-item': HTMLSdxMenuFlyoutListItemElement
    'sdx-menu-flyout-list': HTMLSdxMenuFlyoutListElement
    'sdx-menu-flyout-toggle': HTMLSdxMenuFlyoutToggleElement
    'sdx-menu-flyout': HTMLSdxMenuFlyoutElement
    'sdx-numeric-stepper': HTMLSdxNumericStepperElement
    'sdx-pie-chart': HTMLSdxPieChartElement
    'sdx-price': HTMLSdxPriceElement
    'sdx-progress-full-step': HTMLSdxProgressFullStepElement
    'sdx-progress-full': HTMLSdxProgressFullElement
    'sdx-ribbon': HTMLSdxRibbonElement
    'sdx-scroll-to-top': HTMLSdxScrollToTopElement
    'sdx-search': HTMLSdxSearchElement
    'sdx-select-optgroup': HTMLSdxSelectOptgroupElement
    'sdx-select-option': HTMLSdxSelectOptionElement
    'sdx-select': HTMLSdxSelectElement
    'sdx-show-more': HTMLSdxShowMoreElement
    'sdx-sticker-circle': HTMLSdxStickerCircleElement
    'sdx-text-truncate': HTMLSdxTextTruncateElement
    'sdx-validation-message': HTMLSdxValidationMessageElement
    'sdx-itunes-autocomplete': HTMLSdxItunesAutocompleteElement
  }

  interface ElementTagNameMap {
    'sdx-accordion-item-body': HTMLSdxAccordionItemBodyElement;
    'sdx-accordion-arrow': HTMLSdxAccordionArrowElement;
    'sdx-accordion-item-header': HTMLSdxAccordionItemHeaderElement;
    'sdx-accordion-item-section': HTMLSdxAccordionItemSectionElement;
    'sdx-accordion-item': HTMLSdxAccordionItemElement;
    'sdx-accordion': HTMLSdxAccordionElement;
    'sdx-animation': HTMLSdxAnimationElement;
    'sdx-button-group': HTMLSdxButtonGroupElement;
    'sdx-button': HTMLSdxButtonElement;
    'sdx-dummy': HTMLSdxDummyElement;
    'sdx-flip': HTMLSdxFlipElement;
    'sdx-icon': HTMLSdxIconElement;
    'sdx-input-group': HTMLSdxInputGroupElement;
    'sdx-input-item': HTMLSdxInputItemElement;
    'sdx-input': HTMLSdxInputElement;
    'sdx-loading-spinner': HTMLSdxLoadingSpinnerElement;
    'sdx-menu-flyout-content': HTMLSdxMenuFlyoutContentElement;
    'sdx-menu-flyout-cta': HTMLSdxMenuFlyoutCtaElement;
    'sdx-menu-flyout-list-item': HTMLSdxMenuFlyoutListItemElement;
    'sdx-menu-flyout-list': HTMLSdxMenuFlyoutListElement;
    'sdx-menu-flyout-toggle': HTMLSdxMenuFlyoutToggleElement;
    'sdx-menu-flyout': HTMLSdxMenuFlyoutElement;
    'sdx-numeric-stepper': HTMLSdxNumericStepperElement;
    'sdx-pie-chart': HTMLSdxPieChartElement;
    'sdx-price': HTMLSdxPriceElement;
    'sdx-progress-full-step': HTMLSdxProgressFullStepElement;
    'sdx-progress-full': HTMLSdxProgressFullElement;
    'sdx-ribbon': HTMLSdxRibbonElement;
    'sdx-scroll-to-top': HTMLSdxScrollToTopElement;
    'sdx-search': HTMLSdxSearchElement;
    'sdx-select-optgroup': HTMLSdxSelectOptgroupElement;
    'sdx-select-option': HTMLSdxSelectOptionElement;
    'sdx-select': HTMLSdxSelectElement;
    'sdx-show-more': HTMLSdxShowMoreElement;
    'sdx-sticker-circle': HTMLSdxStickerCircleElement;
    'sdx-text-truncate': HTMLSdxTextTruncateElement;
    'sdx-validation-message': HTMLSdxValidationMessageElement;
    'sdx-itunes-autocomplete': HTMLSdxItunesAutocompleteElement;
  }


}
