(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

require("./sdx-global");

},{"./sdx-global":4}],2:[function(require,module,exports){
"use strict";
// Math.sign (used in ProgressFull)

if (!("sign" in Math)) {
    Math.sign = function (x) {
        return x > 0 ? 1 : x < 0 ? -1 : +x;
    };
}

},{}],3:[function(require,module,exports){
"use strict";

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

},{}],4:[function(require,module,exports){
"use strict";

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

require("./polyfills/Math.sign");

require("./polyfills/startsWith");

var _sdx = require("./src/sdx");

var sdxExports = _interopRequireWildcard(_sdx);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var sdx = tslib_1.__assign({}, sdxExports, window.sdx || {}, { VERSION: "1.32.0" });
/* Polyfills */

window.sdx = sdx;
sdxExports.utils.onDocumentReady(function () {
    sdxExports.initInputField();
    sdxExports.initTextarea();
    sdxExports.initSelect();
    sdxExports.initLoaderBar();
    sdxExports.initAutocomplete();
    sdxExports.initProgressLight();
    sdxExports.initProgressFull();
    sdxExports.initRange();
    sdxExports.initModal();
    sdxExports.initAccordion();
    sdxExports.initCollapse();
    sdxExports.initMenuFlyout();
    sdxExports.initNavigation();
    sdxExports.initNavigationSide();
    sdxExports.initSearchInput();
    sdxExports.initEmptyState();
    sdxExports.initCarousel();
    sdxExports.initTable();
    sdxExports.initPieChart();
    sdxExports.initBarChartHorizontal();
    sdxExports.initBarChartVertical();
});

},{"./polyfills/Math.sign":2,"./polyfills/startsWith":3,"./src/sdx":30,"tslib":113}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _DomFunctions = require("./DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var htmlEvents;
/**
 * A wrapper class for DOM Elements.
 */
var DomElement = /** @class */function () {
    /**
     * Creates a new instance.
     * @param {Element} - The element to wrap.
     * @param {String} - The DOM element to create.
     */
    function DomElement(element) {
        if (typeof element === "string") {
            this.element = document.createElement(element);
        } else {
            this.element = element;
        }
    }
    /**
     * Adds the specified CSS class to the element.
     * @param {String} - The class name to add.
     * @return {DomElement} Returns the current instance for fluent chaining of calls.
     */
    DomElement.prototype.addClass = function (name) {
        Dom.addClass(this.element, name);
        return this;
    };
    /**
     * Removes the specified CSS class from the element.
     * @param {String} - The class name to remove.
     * @return {DomElement} Returns the current instance for fluent chaining of calls.
     */
    DomElement.prototype.removeClass = function (name) {
        Dom.removeClass(this.element, name);
        return this;
    };
    DomElement.prototype.hasClass = function (name) {
        return Dom.hasClass(this.element, name);
    };
    DomElement.prototype.toggleClass = function (name) {
        Dom.toggleClass(this.element, name);
        return this;
    };
    Object.defineProperty(DomElement.prototype, "classes", {
        get: function get() {
            return this.element.classList;
        },
        enumerable: true,
        configurable: true
    });
    DomElement.prototype.setId = function (id) {
        this.element.setAttribute("id", id);
        return this;
    };
    Object.defineProperty(DomElement.prototype, "innerText", {
        get: function get() {
            return Dom.text(this.element);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomElement.prototype, "innerHtml", {
        get: function get() {
            return this.element.innerHTML;
        },
        enumerable: true,
        configurable: true
    });
    DomElement.prototype.setHtml = function (value) {
        if (typeof value !== "string") {
            throw new Error("Expected HTML string");
        }
        this.element.innerHTML = value;
        return this;
    };
    DomElement.prototype.getAttribute = function (name) {
        return this.element.getAttribute(name);
    };
    DomElement.prototype.setAttribute = function (name, value) {
        this.element.setAttribute(name, value);
        return this;
    };
    /**
     * Registers an event listener.
     */
    DomElement.prototype.addEventListener = function (type, listener) {
        this.element.addEventListener(type, listener);
    };
    /**
     * Unregisters an event listener on the component.
     */
    DomElement.prototype.removeEventListener = function (type, listener) {
        this.element.removeEventListener(type, listener);
    };
    DomElement.prototype.appendChild = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        this.element.appendChild(newChild.element);
        return this;
    };
    DomElement.prototype.prependChild = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        this.element.insertBefore(newChild.element, this.element.firstChild);
        return this;
    };
    DomElement.prototype.insertBefore = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.insertBefore(newChild.element, this.element);
        return this;
    };
    DomElement.prototype.insertAfter = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.insertBefore(newChild.element, this.element.nextSibling);
        return this;
    };
    DomElement.prototype.removeChild = function (oldChild) {
        if (!(oldChild instanceof DomElement)) {
            throw new Error("Only a DomElements child can be removed");
        }
        this.element.removeChild(oldChild.element);
    };
    DomElement.prototype.find = function (selectors) {
        var e = this.element.querySelector(selectors);
        if (e) {
            return new DomElement(e);
        }
        return undefined;
    };
    DomElement.prototype.wrapWithElement = function (wrapperElement) {
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.replaceChild(wrapperElement.element, this.element);
        wrapperElement.element.appendChild(this.element);
        return this;
    };
    DomElement.prototype.dispatchEvent = function (eventName) {
        var event;
        var el = this.element;
        if (document.createEvent) {
            event = document.createEvent("HTMLEvents");
            event.initEvent(eventName, true, true);
        } else if (document.createEventObject) {
            // IE < 9
            event = document.createEventObject();
            event.eventType = eventName;
        }
        event.eventName = eventName;
        if (el.dispatchEvent) {
            el.dispatchEvent(event);
        } else if (el.fireEvent && htmlEvents["on" + eventName]) {
            // IE < 9
            el.fireEvent("on" + event.eventType, event); // can trigger only real event (e.g. 'click')
        } else if (el[eventName]) {
            el[eventName]();
        } else if (el["on" + eventName]) {
            el["on" + eventName]();
        }
    };
    DomElement.prototype.css = function (property) {
        return Dom.css(this.element, property);
    };
    /**
     * Removes all child nodes of the current DomElement.
     */
    DomElement.prototype.empty = function () {
        Dom.empty(this.element);
    };
    return DomElement;
}();
exports.default = DomElement;

},{"./DomFunctions":6}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.hasClass = hasClass;
exports.toggleClass = toggleClass;
exports.isHidden = isHidden;
exports.text = text;
exports.parentWithClass = parentWithClass;
exports.textWidth = textWidth;
exports.css = css;
exports.getAttributeReference = getAttributeReference;
exports.getRootElement = getRootElement;
exports.empty = empty;
function addClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.add(name);
}
function removeClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.remove(name);
}
function hasClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    return element.classList.contains(name);
}
function toggleClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.toggle(name);
}
/**
 * Determines if the given element is hidden from view.
 * @param {Element} Element The dom element to check.
 * @param {boolean} includeParents If set to `true` searches up the DOM and checks parent visibility as well. Defaults to `false`.
 */
function isHidden(element, includeParents) {
    if (includeParents === void 0) {
        includeParents = false;
    }
    if (includeParents === false) {
        var style = window.getComputedStyle(element);
        return style.display === "none" || element.offsetLeft < 0;
    }
    var result;
    // tslint:disable-next-line:no-conditional-assignment
    while ((result = isHidden(element, false)) === false && element.parentElement) {
        element = element.parentElement;
    }
    return result;
}
/**
 * Gets the text of an element an makes sure this works on all browsers.
 */
function text(element) {
    return element.textContent || element.innerText;
}
function parentWithClass(element, className) {
    var current = element;
    while (!hasClass(current, className) && current.parentElement) {
        current = current.parentElement;
    }
    if (hasClass(current, className)) {
        return current;
    }
    return undefined;
}
function textWidth(text, font) {
    // NOTE: this width measuring algorithm is a lot faster
    // but does unfortunately not work on IE 10...
    // let canvas = document.createElement("canvas")
    // let context = canvas.getContext("2d")
    // context.font = font
    // let metrics = context.measureText(text)
    // return Math.round(metrics.width)
    var div = document.createElement("div");
    div.innerHTML = text;
    div.style.font = font;
    div.style.position = "absolute";
    div.style.visibility = "hidden";
    document.body.appendChild(div);
    var result = div.offsetWidth;
    document.body.removeChild(div);
    return result;
}
function css(element, property) {
    return window.getComputedStyle(element).getPropertyValue(property);
}
/**
 * Gets the single element referenced in an items data-* attribute.
 * @param {DomElement} element - The element containing the reference attribute.
 * @param {string} attribute - The name of the reference attribute.
 * @returns {DomElement} The referenced element; or `undefined` if the reference is invalid
 * or the attribute could not be found.
 */
function getAttributeReference(element, attribute) {
    var attrValue = element.getAttribute(attribute);
    if (!attrValue || attrValue === "") {
        return undefined;
    }
    return document.querySelector(attrValue);
}
/**
 * Gets the document root element (normally the body element)
 * If the document uses a sdx-container wrapper this is returned instead.
 * @returns {Element} The root dom element.
 */
function getRootElement() {
    var element = document.querySelector(".sdx-container");
    if (!element) {
        element = document.body;
    }
    return element;
}
/**
 * Removes all child nodes from the provided element.
 * @param {Element} element The Dom element
 */
function empty(element) {
    while (element.firstChild) {
        element.removeChild(element.firstChild);
    }
}

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/* Keyboard input keycode definitions */
var KEY_TAB = exports.KEY_TAB = 9;
var KEY_ENTER = exports.KEY_ENTER = 13;
var KEY_ESCAPE = exports.KEY_ESCAPE = 27;
// Arrow keys
var KEY_ARROW_UP = exports.KEY_ARROW_UP = 38;
var KEY_ARROW_DOWN = exports.KEY_ARROW_DOWN = 40;
var KEY_ARROW_LEFT = exports.KEY_ARROW_LEFT = 37;
var KEY_ARROW_RIGHT = exports.KEY_ARROW_RIGHT = 39;
// Page keys
var KEY_PAGE_UP = exports.KEY_PAGE_UP = 33;
var KEY_PAGE_DOWN = exports.KEY_PAGE_DOWN = 34;
// Numbers
var KEY_NR_0 = exports.KEY_NR_0 = 48;
var KEY_NR_1 = exports.KEY_NR_1 = 49;
var KEY_NR_9 = exports.KEY_NR_9 = 57;
// helper functions
var containsKey = exports.containsKey = function containsKey(keycode, inputsKeys) {
    var hasKey = false;
    if (inputsKeys && inputsKeys.length > 0) {
        [].forEach.call(inputsKeys, function (inputsKey) {
            if (keycode === inputsKey) {
                hasKey = true;
            }
        });
    }
    return hasKey;
};
var getKeyValue = exports.getKeyValue = function getKeyValue(keycode) {
    if (keycode < 48 || keycode > 105) {
        return "";
    }
    return String.fromCharCode(96 <= keycode && keycode <= 105 ? keycode - 48 : keycode).toLowerCase();
};

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onDocumentReady = onDocumentReady;
exports.searchAndInitialize = searchAndInitialize;
exports.clamp = clamp;
exports.preventDefault = preventDefault;
exports.remove = remove;
exports.find = find;
exports.internetExplorerOrEdgeVersion = internetExplorerOrEdgeVersion;
exports.scrollIntoView = scrollIntoView;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Calls the callback function when the document has been completely parsed.
 * @param {callback} value The callback function to execute.
 */
function onDocumentReady(callback) {
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        callback();
    }
    if (document.readyState === "complete") {
        setTimeout(callback);
    } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed, false);
    }
}
function searchAndInitialize(selector, callback, initSelector) {
    var e_1, _a;
    if (!callback) {
        throw new Error("The callback cannot be undefined");
    }
    var elements = document.querySelectorAll(selector);
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            var initElement = e;
            if (initSelector) {
                initElement = initSelector(e);
            }
            if (initElement.getAttribute("data-init") === "auto") {
                callback(e);
            }
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
}
/**
 * Returns a number whose value is limited to the given range.
 *
 * Example: limit the output of this computation to between 0 and 255
 * Utils.clamp(number, 0, 255)
 *
 * @param {Number} value The number to clamp
 * @param {Number} min The lower boundary of the output range
 * @param {Number} max The upper boundary of the output range
 * @returns A number in the range [min, max]
 * @type Number
 */
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
/**
 * A polyfill for Event.preventDefault().
 * @param {Event} event - The event to prevent the default action.
 */
function preventDefault(event) {
    if (event.preventDefault) {
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
}
/**
 * A polyfill for Node.remove().
 * @param {Node} node - The node to remove.
 */
function remove(node) {
    if (!node || !node.parentNode) {
        return;
    }
    node.parentNode.removeChild(node);
}
/**
 * A simple polyfill for the Array.find() method.
 * @param {Array} array - The array to search in.
 * @param {function} expression - The expression to evaluate. Must return true if the element matches.
 */
function find(array, expression) {
    for (var i = 0; i < array.length; i++) {
        var item = array[i];
        if (expression(item) === true) {
            return item;
        }
    }
    return undefined;
}
/**
 * Checks the useragent and returns the Microsoft Internet Explorer / Edge version.
 * If another browser is detected 0 is returned.
 */
function internetExplorerOrEdgeVersion(userAgent) {
    if (userAgent === void 0) {
        userAgent = navigator.userAgent;
    }
    // handle IE and Edge
    var ieOrEdge = userAgent.search(/MSIE |Edge[/]/);
    if (ieOrEdge > 0) {
        return parseInt(userAgent.substring(ieOrEdge + 5, userAgent.indexOf(".", ieOrEdge)), 10);
    }
    // handle IE11
    if (userAgent.indexOf("Trident/") > 0) {
        var rv = userAgent.indexOf("rv:");
        return parseInt(userAgent.substring(rv + 3, userAgent.indexOf(".", rv)), 10);
    }
    return 0;
}
/**
 * Tries to move a child element to the top by scrolling the parent element, if it is not already fully visible.
 */
function scrollIntoView(child) {
    var parent = child.parentNode;
    var parentRect = parent.getBoundingClientRect();
    var childRect = child.getBoundingClientRect();
    var isFullyVisible = childRect.top >= parentRect.top && childRect.bottom <= parentRect.top + parent.clientHeight;
    if (!isFullyVisible) {
        parent.scrollTop = childRect.top + parent.scrollTop - parentRect.top;
    }
}

},{"tslib":113}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_TOGGLE = ".accordion__toggle";
var QUERY_OPEN_SECTION = ".accordion__item.is-open";
var QUERY_COLLAPSE = ".accordion__collapse";
var CLASS_ITEM = "accordion__item";
var CLASS_OPEN = "is-open";
var CLASS_KEEP_OPEN = "accordion__keep-open";
var REGEX_HIDDEN = /accordion--hidden-.*/;
var ANIMATION_OPEN = 300;
var ANIMATION_DELAY_OPEN = 50;
var ANIMATION_VISIBLE = 150;
/**
 * The Accordion component
 */
var Accordion = /** @class */function (_super) {
    tslib_1.__extends(Accordion, _super);
    /**
     * Creates and initializes the Accordion component.
     * @param {DomElement} - The root element of the Accordion component.
     */
    function Accordion(element) {
        var _this = _super.call(this, element) || this;
        _this._sectionClickHandler = _this._handleSectionClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Accordion component.
     * @private
     */
    Accordion.prototype._initialize = function () {
        var e_1, _a;
        if (this.element.className.split(" ").some(function (c) {
            return REGEX_HIDDEN.test(c);
        })) {
            var indicator = new _DomElement2.default("input").setAttribute("type", "hidden").addClass("js-hidden");
            this.appendChild(indicator);
            this._hiddenIndicator = indicator.element;
        }
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_TOGGLE)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var toggle = _c.value;
                toggle.addEventListener("click", this._sectionClickHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Accordion.prototype._handleSectionClick = function (event) {
        if (this._hiddenIndicator) {
            var style = window.getComputedStyle(this._hiddenIndicator);
            if (style.visibility !== "visible") {
                return;
            }
        }
        var navSection = event.target.parentElement;
        while (!Dom.hasClass(navSection, CLASS_ITEM) && navSection.parentElement) {
            navSection = navSection.parentElement;
        }
        var prevSection = this.element.querySelector(QUERY_OPEN_SECTION);
        if (prevSection && prevSection !== navSection) {
            if (!Dom.hasClass(this.element, CLASS_KEEP_OPEN)) {
                this._toggleSection(prevSection);
            }
        }
        this._toggleSection(navSection);
    };
    Accordion.prototype._toggleSection = function (accSection) {
        var collapseElement = accSection.querySelector(QUERY_COLLAPSE);
        if (Dom.hasClass(accSection, CLASS_OPEN)) {
            Dom.removeClass(accSection, CLASS_OPEN);
            this._closeCollapseSection(collapseElement);
        } else {
            Dom.addClass(accSection, CLASS_OPEN);
            if (collapseElement) {
                // to ignore the case when there is no collapsible element (see sdx doku navigation, "all the basics") in a list of accordion
                this._openCollapseSection(collapseElement);
            }
        }
    };
    Accordion.prototype._openCollapseSection = function (el) {
        this._stopAnimations(el);
        el.style.display = "block";
        this.animation = _animejs2.default.timeline().add({
            targets: el,
            duration: ANIMATION_OPEN,
            height: el.scrollHeight + "px",
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                el.style.height = "auto";
                el.setAttribute("aria-expanded", "true");
                el.classList.add(CLASS_OPEN);
            }
        }).add({
            targets: el,
            duration: ANIMATION_VISIBLE,
            opacity: 1,
            easing: "linear",
            offset: ANIMATION_DELAY_OPEN
        });
    };
    Accordion.prototype._closeCollapseSection = function (el) {
        this._stopAnimations(el);
        this.animation = _animejs2.default.timeline().add({
            targets: el,
            duration: ANIMATION_OPEN,
            height: "0px",
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                el.style.removeProperty("display");
                el.style.removeProperty("opacity");
                el.style.removeProperty("height");
                el.setAttribute("aria-expanded", "false");
                el.classList.remove(CLASS_OPEN);
            }
        });
    };
    Accordion.prototype._stopAnimations = function (el) {
        if (this.lastAnimatedElement === el) {
            if (this.animation) {
                this.animation.pause();
            }
            _animejs2.default.remove(el);
        }
        this.lastAnimatedElement = el;
    };
    /**
     * Removes all event handlers and clears references.
     */
    Accordion.prototype.destroy = function () {
        var e_2, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_TOGGLE)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var toggle = _c.value;
                toggle.removeEventListener("click", this._sectionClickHandler);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._sectionClickHandler = null;
        this.element = null;
    };
    return Accordion;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".accordion", function (e) {
        new Accordion(e);
    });
}
exports.default = Accordion;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":34,"tslib":113}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _trunc = require("babel-runtime/core-js/math/trunc");

var _trunc2 = _interopRequireDefault(_trunc);

var _from = require("babel-runtime/core-js/array/from");

var _from2 = _interopRequireDefault(_from);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_SLIDER = ".carousel__container";
var QUERY_SLIDE_AREA = ".carousel__slider";
var QUERY_WRAPPER = ".carousel__slider-wrapper";
var QUERY_PAGINATION = ".carousel__pagination";
var CLASS_ACTIVE = "slide--active";
var CLASS_PREV = "slide--prev";
var CLASS_NEXT = "slide--next";
var CLASS_BULLET = "pagination-bullet";
var CLASS_BULLET_ACTIVE = "pagination-bullet--active";
var QUERY_BTN_PREV = ".carousel__button-prev";
var QUERY_BTN_NEXT = ".carousel__button-next";
var QUERY_BTN_WRAPPER = ".carousel__button-wrapper";
var ATTRIBUTE_INDEX = "js-index";
var ANIMATION_DURATION = 350;
var ANIMATION_EASING = "ease-in-out";
var TOUCH_DURATION = 300;
var TOUCH_DELTA_MIN = 25;
/**
 * The carousel component definition.
 */
var Carousel = /** @class */function (_super) {
    tslib_1.__extends(Carousel, _super);
    /**
     * Creates and initializes the carousel component.
     * @param {DomElement} element - The root element of the Carousel component.
     * @param {Number} index - The initial index.
     */
    function Carousel(element, index) {
        if (index === void 0) {
            index = 0;
        }
        var _this = _super.call(this, element) || this;
        _this._slider = _this.element.querySelector(QUERY_SLIDER);
        _this._wrapper = _this._slider.querySelector(QUERY_WRAPPER);
        _this._pagination = _this._slider.querySelector(QUERY_PAGINATION);
        _this._slideArea = _this._slider.querySelector(QUERY_SLIDE_AREA);
        _this._btnWrapper = _this.element.querySelector(QUERY_BTN_WRAPPER);
        _this._prevCtrl = _this.element.querySelector(QUERY_BTN_PREV);
        _this._nextCtrl = _this.element.querySelector(QUERY_BTN_NEXT);
        _this._slides = [];
        _this._index = index || 0;
        _this._slidesPerGroup = 1;
        _this._sliderWrapper = new SliderWrapper(_this._wrapper, _this._slideArea, _this.element);
        _this._sliderWrapper.index = _this._index;
        _this._additionalSlideMargin = 0;
        _this._resizeHandler = _this._onresize.bind(_this);
        _this._prevHandler = _this.prev.bind(_this);
        _this._nextHandler = _this.next.bind(_this);
        _this._paginationClickHandler = _this._handlePaginationClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._handleTouchstart = _this._onTouchstart.bind(_this);
        _this._handleTouchmove = _this._onTouchmove.bind(_this);
        _this._handleTouchend = _this._onTouchend.bind(_this);
        _this._initialize();
        _this.slide(_this._index, 0, false);
        _this._updateCtrlOffsets();
        return _this;
    }
    /**
     * Initializes the carousel component.
     * @private
     */
    Carousel.prototype._initialize = function () {
        // responsive helpers
        this._breakpointPhone = new _DomElement2.default("div").addClass("js-phone").element;
        this._breakpointTablet = new _DomElement2.default("div").addClass("js-tablet").element;
        this._breakpointDesktop = new _DomElement2.default("div").addClass("js-desktop").element;
        this.element.appendChild(this._breakpointPhone);
        this.element.appendChild(this._breakpointTablet);
        this.element.appendChild(this._breakpointDesktop);
        if (this._prevCtrl && this._nextCtrl) {
            this._prevCtrl.addEventListener("click", this._prevHandler);
            this._nextCtrl.addEventListener("click", this._nextHandler);
        }
        if (this._pagination) {
            this._pagination.addEventListener("click", this._paginationClickHandler);
        }
        this._slides = (0, _from2.default)(this._wrapper.children);
        if (this._slides.length === 0) {
            throw Error("Provide at least one slide to the slider");
        }
        for (var i = 0; i < this._slides.length; i++) {
            var slide = this._slides[i];
            slide.setAttribute(ATTRIBUTE_INDEX, String(i));
        }
        this._updateResponsiveOptions();
        this._sliderWrapper.initialize();
        this.reset();
        this.element.addEventListener("keydown", this._keydownHandler);
        this._slideArea.addEventListener("mousedown", this._handleTouchstart);
        this._slideArea.addEventListener("touchstart", this._handleTouchstart);
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
    };
    Carousel.prototype._isBreakpointActive = function (breakpoint) {
        var style = window.getComputedStyle(breakpoint);
        return style.visibility === "visible";
    };
    Carousel.prototype._onresize = function () {
        this.reset();
        this._updateCtrlOffsets();
    };
    /**
     * Makes sure the index is always in the range of available slide
     * In case it's to high or to low it is wrapped around
     * @param {Number} index - The index to adjust and sanitize
     * @returns {Number} index - The adjusted index
     * @private
     */
    Carousel.prototype._adjustIndex = function (index) {
        if (typeof index !== "number") {
            index = 0;
        }
        if (index < 0) {
            index = this._wrapround(index, 0, this._slides.length);
        } else if (index >= this._slides.length) {
            index %= this._slides.length;
        }
        return Math.floor(index / this._slidesPerGroup) * this._slidesPerGroup;
    };
    Carousel.prototype._wrapround = function (n, min, max) {
        if (n >= max) {
            return min;
        }
        if (n < min) {
            return max - 1;
        }
        return n;
    };
    Carousel.prototype._wraproundCount = function (a, b, min, max, direction) {
        if (direction === 0) {
            return 0;
        }
        if (a < min || a >= max) {
            throw new Error("Argument 'a' is out of range, Value: " + a + " Min: " + min + ", Max: " + max);
        }
        if (b < min || b >= max) {
            throw new Error("Argument 'b' is out of range, Value: " + b + " Min: " + min + ", Max: " + max);
        }
        var i = 0;
        while (a !== b) {
            i++;
            a = this._wrapround(a + direction, min, max);
        }
        return i;
    };
    Carousel.prototype._updateCtrlOffsets = function () {
        if (!this._nextCtrl || !this._prevCtrl || !this._btnWrapper) {
            return;
        }
        var prevCtrlMargin = 0;
        var nextCtrlMargin = 0;
        if (this._slidesPerGroup > 1) {
            var wrapperRect = this._btnWrapper.getBoundingClientRect();
            var prevSlideCount = Math.floor(0.5 * this._slidesPerGroup);
            var rightIndex = this._sliderWrapper.index + prevSlideCount + 1;
            var leftIndex = this._sliderWrapper.index - 1;
            if (this._slidesPerGroup % 2 !== 0) {
                leftIndex -= prevSlideCount;
            }
            if (leftIndex >= 0 && leftIndex < this._wrapper.children.length && rightIndex >= 0 && rightIndex < this._wrapper.children.length) {
                var leftSlide = this._sliderWrapper.getSlideProperties(leftIndex);
                var rightSlide = this._sliderWrapper.getSlideProperties(rightIndex);
                var btnWidth = this._prevCtrl.offsetWidth;
                if (btnWidth <= 0) {
                    btnWidth = 60;
                }
                prevCtrlMargin = leftSlide.right - wrapperRect.left - btnWidth;
                nextCtrlMargin = wrapperRect.right - rightSlide.left - btnWidth;
            }
        }
        var left = prevCtrlMargin !== 0 ? prevCtrlMargin + "px" : "";
        this._prevCtrl.style.left = left;
        var right = nextCtrlMargin !== 0 ? nextCtrlMargin + "px" : "";
        this._nextCtrl.style.right = right;
    };
    Carousel.prototype._updateActiveSlides = function (nextIndex) {
        var prevSlideCount = Math.floor(0.5 * (this._slidesPerGroup - 1));
        var evenGroup = this._slidesPerGroup % 2 === 0;
        for (var i = 0; i < this._wrapper.children.length; i++) {
            var slide = this._wrapper.children[i];
            if (i === nextIndex || evenGroup && i === nextIndex + 1) {
                Dom.addClass(slide, CLASS_ACTIVE);
            } else {
                Dom.removeClass(slide, CLASS_ACTIVE);
            }
            if (i < nextIndex && i >= nextIndex - prevSlideCount) {
                Dom.addClass(slide, CLASS_PREV);
            } else {
                Dom.removeClass(slide, CLASS_PREV);
            }
            if (i > nextIndex && (i <= nextIndex + prevSlideCount || evenGroup && i <= nextIndex + 1 + prevSlideCount)) {
                Dom.addClass(slide, CLASS_NEXT);
            } else {
                Dom.removeClass(slide, CLASS_NEXT);
            }
        }
    };
    /**
     * Updates and creates the pagination bullets.
     * @private
     */
    Carousel.prototype._updatePagination = function () {
        if (!this._pagination) {
            return;
        }
        var to = this._index;
        var bullets = this._pagination.children;
        var totalItems = Math.max(this._slides.length, bullets.length);
        var slideCount = Math.ceil(this._slides.length / this._slidesPerGroup);
        var activeSlideIndex = Math.floor(to / this._slidesPerGroup);
        for (var i = 0; i < totalItems; i++) {
            var bullet = void 0;
            if (bullets.length > i) {
                if (bullets.length <= slideCount) {
                    bullet = bullets[i];
                } else {
                    (0, _Utils.remove)(bullets[i]);
                }
            } else if (i < slideCount) {
                bullet = new _DomElement2.default("div").addClass(CLASS_BULLET).element;
                this._pagination.appendChild(bullet);
            }
            if (bullet && i < slideCount) {
                if (i === activeSlideIndex) {
                    Dom.addClass(bullet, CLASS_BULLET_ACTIVE);
                } else {
                    Dom.removeClass(bullet, CLASS_BULLET_ACTIVE);
                }
            }
        }
    };
    Carousel.prototype._handlePaginationClick = function (e) {
        if (!Dom.hasClass(e.target, CLASS_BULLET)) {
            return;
        }
        var index = (0, _from2.default)(this._pagination.children).indexOf(e.target);
        var slideNumber = index * this._slidesPerGroup;
        this.slideTo(slideNumber);
    };
    Carousel.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        switch (keycode) {
            case Inputs.KEY_ARROW_LEFT:
                this.prev();
                break;
            case Inputs.KEY_ARROW_RIGHT:
                this.next();
                break;
            case Inputs.KEY_ESCAPE:
                this.element.blur();
                break;
            default:
        }
    };
    Carousel.prototype._onTouchstart = function (event) {
        var touch = event.touches ? event.touches[0] : event;
        this._slideArea.removeEventListener("mousedown", this._handleTouchstart);
        this._slideArea.removeEventListener("touchstart", this._handleTouchstart);
        this._sliderWrapper.beginDrag();
        var pageX = touch.pageX;
        this._touchOffset = {
            x: pageX,
            time: Date.now()
        };
        this._delta = {
            x: 0,
            lastMove: pageX
        };
        document.addEventListener("mousemove", this._handleTouchmove);
        document.addEventListener("touchmove", this._handleTouchmove);
        document.addEventListener("mouseup", this._handleTouchend);
        document.addEventListener("mouseleave", this._handleTouchend);
        document.addEventListener("touchend", this._handleTouchend);
    };
    Carousel.prototype._onTouchmove = function (event) {
        var touch = event.touches ? event.touches[0] : event;
        var pageX = touch.pageX;
        var deltaMove = pageX - this._delta.lastMove;
        this._delta = {
            x: pageX - this._touchOffset.x,
            lastMove: pageX
        };
        if (this._touchOffset) {
            (0, _Utils.preventDefault)(event);
            this._sliderWrapper.move(deltaMove);
            this._cloneSlidesToFitWrapper(false, deltaMove);
        }
    };
    Carousel.prototype._onTouchend = function () {
        var duration = this._touchOffset ? Date.now() - this._touchOffset.time : undefined;
        var isValid = Number(duration) < TOUCH_DURATION && Math.abs(this._delta.x) > TOUCH_DELTA_MIN || Math.abs(this._delta.x) > this._frameWidth / 3;
        if (isValid) {
            var direction = (0, _Utils.clamp)(this._delta.x, -1, 1) * -1;
            this.slide(false, direction, true);
            this._sliderWrapper.endDrag();
        } else {
            // Slide back to the starting point of the drag operation
            this._sliderWrapper.cancelDrag();
        }
        this._touchOffset = undefined;
        this._slideArea.addEventListener("mousedown", this._handleTouchstart);
        this._slideArea.addEventListener("touchstart", this._handleTouchstart);
        document.removeEventListener("mousemove", this._handleTouchmove);
        document.removeEventListener("mouseup", this._handleTouchend);
        document.removeEventListener("mouseleave", this._handleTouchend);
        document.removeEventListener("touchmove", this._handleTouchmove);
        document.removeEventListener("touchend", this._handleTouchend);
    };
    /**
     * Updated parameters in regard to the currently active responsive
     * breakpoint.
     * @private
     */
    Carousel.prototype._updateResponsiveOptions = function () {
        if (this._isBreakpointActive(this._breakpointPhone)) {
            this._slidesPerGroup = 1;
        }
        if (this._isBreakpointActive(this._breakpointTablet)) {
            this._slidesPerGroup = 2;
        }
        if (this._isBreakpointActive(this._breakpointDesktop)) {
            this._slidesPerGroup = 3;
        }
        this._sliderWrapper.slidesPerGroup = this._slidesPerGroup;
    };
    /**
     * Clones the requested slide and adds it to the slider.
     * @param {Number} index - The original slide index of the template slide
     * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
     * @private
     */
    Carousel.prototype._cloneSlide = function (index, direction) {
        var clone = this._slides[index].cloneNode(true);
        Dom.removeClass(clone, CLASS_ACTIVE);
        Dom.removeClass(clone, CLASS_PREV);
        Dom.removeClass(clone, CLASS_NEXT);
        this._sliderWrapper.addSlide(clone, direction);
        var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
        clone.style.marginLeft = slideMargin;
        clone.style.marginRight = slideMargin;
        return clone.offsetWidth;
    };
    /**
     * Clones and adds the requested ammount of slides.
     * @param {Number} slideCount - The number of slides to add
     * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
     * @private
     */
    Carousel.prototype._cloneSlidesByCount = function (slideCount, direction) {
        var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
        var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);
        while (slideCount > 0) {
            index = this._wrapround(index + direction, 0, this._slides.length);
            this._cloneSlide(index, direction);
            slideCount--;
        }
    };
    /**
     * Calculates the scroll clount and inserts the required ammount of slides
     * in the apropriate direction.
     * @param {Number} nextIndex - The slide to scroll to
     * @param {Number} direction - The direction of the scroll
     * @private
     */
    Carousel.prototype._cloneSlidesByScrollCount = function (nextIndex, direction) {
        var scrollCount = this._wraproundCount(this._index, nextIndex, 0, this._slides.length, direction);
        var outerSlideProps = this._sliderWrapper.getSlideProperties(direction > 0 ? this._wrapper.children.length - 1 : 0);
        var indexToOuterSlideCount = this._wraproundCount(this._index, outerSlideProps.index, 0, this._slides.length, direction);
        var slidesToInsert = scrollCount - indexToOuterSlideCount;
        if (slidesToInsert > 0) {
            this._cloneSlidesByCount(slidesToInsert, direction);
        }
    };
    Carousel.prototype._cloneSlidesByToFill = function (spaceToFill, direction) {
        var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
        var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);
        while (spaceToFill > 0) {
            index = this._wrapround(index + direction, 0, this._slides.length);
            spaceToFill -= this._cloneSlide(index, direction);
        }
    };
    Carousel.prototype._cloneSlidesToFitWrapper = function (cleanup, slideDelta) {
        if (cleanup === void 0) {
            cleanup = true;
        }
        if (slideDelta === void 0) {
            slideDelta = 0;
        }
        var realIndex = this._sliderWrapper.index;
        var first;
        var last;
        if (cleanup === false) {
            first = this._sliderWrapper.getSlideProperties(0);
            last = this._sliderWrapper.getSlideProperties(this._wrapper.children.length - 1);
        } else {
            var result = this._sliderWrapper.getRemovableSlides(slideDelta);
            first = result.first;
            last = result.last;
            // Remove the slides from view
            for (var i = result.slides.length - 1; i >= 0; i--) {
                if (result.slides[i] === true) {
                    this._sliderWrapper.removeSlide(i);
                }
            }
        }
        var spaceToFill = this._sliderWrapper.getEmptySpace(first.left, last.right);
        // Check if additional slides are required on the left
        if (first.visible === true && spaceToFill.left > 0) {
            this._cloneSlidesByToFill(spaceToFill.left, -1);
        }
        // Check if additional slides are required on the right
        if (last.visible === true && spaceToFill.right > 0) {
            this._cloneSlidesByToFill(spaceToFill.right, 1);
        }
        return realIndex - this._sliderWrapper.index;
    };
    /**
     * Gets the real (wrapper) index for the slide with the given original index
     * @param {Number} index - The index to search for
     * @param {Number} direction - The direction in which to search
     * @returns {Number} The wrapper index
     * @private
     */
    Carousel.prototype._getRealIndexFor = function (index, direction) {
        var i = this._sliderWrapper.index;
        while (i >= 0 && i < this._wrapper.children.length) {
            var slideIndex = parseInt(this._wrapper.children[i].getAttribute(ATTRIBUTE_INDEX), 10);
            if (slideIndex === index) {
                return i;
            }
            i += direction;
        }
        throw new Error("Cloud not find real index for slide " + index + " in direction " + direction);
    };
    Object.defineProperty(Carousel.prototype, "index", {
        /**
         * Gets the index of the current active slide. If the slides are grouped evenly
         * the active slide is always the first in the group.
         * @returns {Number} The index of the active slide.
         */
        get: function get() {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    Carousel.prototype.reset = function () {
        this._frameWidth = this._slider.getBoundingClientRect().width || this._slider.offsetWidth;
        this._updateResponsiveOptions();
        if (this._nextCtrl) {
            this._nextCtrl.disabled = false;
        }
        if (this._prevCtrl) {
            this._prevCtrl.disabled = false;
        }
        if (this._slidesPerGroup === 1) {
            var style = window.getComputedStyle(this._slider.parentElement);
            var parentWidth = this._slider.parentElement.clientWidth + (parseFloat(style.marginLeft) || 0) + (parseFloat(style.marginRight) || 0);
            var outerMargin = Math.ceil(parentWidth - this._frameWidth);
            this._additionalSlideMargin = Math.ceil(outerMargin * 0.5) + 1;
        } else {
            this._additionalSlideMargin = 0;
        }
        var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
        for (var i = 0; i < this._wrapper.children.length; i++) {
            var slide = this._wrapper.children[i];
            slide.style.marginLeft = slideMargin;
            slide.style.marginRight = slideMargin;
        }
        this._sliderWrapper.onresize();
        this._cloneSlidesToFitWrapper(false);
        this._sliderWrapper.moveTo(this._sliderWrapper.index);
        this._updatePagination();
        this._updateActiveSlides(this._sliderWrapper.index);
    };
    /**
     * Moves the slider to the next item.
     */
    Carousel.prototype.prev = function () {
        this.slide(false, -1);
    };
    /**
     * Moves the slider to the previous item.
     */
    Carousel.prototype.next = function () {
        this.slide(false, 1);
    };
    Carousel.prototype.slide = function (nextIndex, direction, animate) {
        if (animate === void 0) {
            animate = true;
        }
        if (typeof nextIndex !== "number") {
            if (direction > 0) {
                nextIndex = this._index + this._slidesPerGroup;
                direction = 1;
            } else {
                nextIndex = this._index - this._slidesPerGroup;
                direction = -1;
            }
        }
        nextIndex = this._adjustIndex(nextIndex);
        if (!direction) {
            direction = (0, _Utils.clamp)(nextIndex - this._index, -1, 1);
        }
        // Make sure there are enought slides on screen
        this._cloneSlidesToFitWrapper(false);
        // Make sure there are enough slides for the scroll operation
        this._cloneSlidesByScrollCount(nextIndex, direction);
        var realIndex = this._getRealIndexFor(nextIndex, direction);
        var slideDelta = this._sliderWrapper.getSlideDelta(realIndex);
        realIndex = Math.max(realIndex - this._cloneSlidesToFitWrapper(true, slideDelta), 0);
        this._sliderWrapper.moveTo(realIndex, undefined, animate);
        // Update the active index
        this._index = nextIndex;
        // Mark slides as active
        this._updatePagination();
        this._updateActiveSlides(realIndex);
        // console.log(`Performed slide to ${this._index}, realIndex: ${this._sliderWrapper.index}`)
    };
    /**
     * Moves the slider to the selected slide.
     * @param {Number} index - The index of the slide to slide to.
     * @param {Boolean} animate - `True` if the slide should be animated; otherwise `false`. Defaults to `true`.
     */
    Carousel.prototype.slideTo = function (index, animate) {
        if (animate === void 0) {
            animate = true;
        }
        this.slide(index, undefined, animate);
    };
    /**
     * Destroys the components and frees all references.
     */
    Carousel.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this.element.removeEventListener("keydown", this._keydownHandler);
        this._slideArea.removeEventListener("mousedown", this._handleTouchstart);
        this._slideArea.removeEventListener("touchstart", this._handleTouchstart);
        this._breakpointPhone.remove();
        this._breakpointTablet.remove();
        this._breakpointDesktop.remove();
        if (this._prevCtrl && this._nextCtrl) {
            this._prevCtrl.removeEventListener("click", this._prevHandler);
            this._nextCtrl.removeEventListener("click", this._nextHandler);
        }
        this._prevCtrl = undefined;
        this._nextCtrl = undefined;
        if (this._pagination) {
            this._pagination.removeEventListener("click", this._paginationClickHandler);
            this._pagination = undefined;
        }
        this._sliderWrapper.destroy();
        this._sliderWrapper = undefined;
    };
    return Carousel;
}(_DomElement2.default);
var TRANSFORM = "transform";
var DURATION = "transitionDuration";
var TIMING = "transitionTimingFunction";
var SliderWrapper = /** @class */function () {
    function SliderWrapper(wrapperElement, slideAreaElement, carouselElement) {
        this._wrapperElement = wrapperElement;
        this._slideAreaElement = slideAreaElement;
        this._carouselElement = carouselElement;
        this._position = 0;
        this._index = 0;
        this._isdragging = false;
    }
    SliderWrapper.prototype._getSlide = function (index) {
        if (index < 0 || index >= this._wrapperElement.children.length) {
            throw new Error("Argument 'index' is out of range, Value: " + index + " Min: 0, Max: " + (this._wrapperElement.children.length - 1));
        }
        return this._wrapperElement.children[index];
    };
    SliderWrapper.prototype._setTransform = function (targetPosition, animated, duration, ease) {
        if (animated === void 0) {
            animated = false;
        }
        if (duration === void 0) {
            duration = ANIMATION_DURATION;
        }
        if (ease === void 0) {
            ease = ANIMATION_EASING;
        }
        if (animated === false) {
            duration = 0;
        }
        var style = this._wrapperElement.style;
        if (style) {
            style[DURATION] = duration + "ms";
            style[TIMING] = ease;
            // No sub pixel transitions.
            targetPosition = Math.floor(targetPosition);
            style[TRANSFORM] = "translate(" + targetPosition + "px, 0)";
            this._position = targetPosition;
        }
    };
    SliderWrapper.prototype._getWrapperSlidePosition = function (index) {
        var wrapperCenter = 0.5 * this._wrapperElement.offsetWidth;
        var slide = this._getSlide(index);
        var result = 0;
        // Calculate the position of the slide (centered)
        if (this._slidesPerGroup % 2 === 0) {
            var slideStyle = window.getComputedStyle(slide);
            var slideMargin = slideStyle ? parseInt(slideStyle.marginRight, 10) : 0;
            // Centered to the space between the two center slides of the group
            result = -slide.offsetLeft - slide.clientWidth + wrapperCenter - slideMargin;
        } else {
            result = -slide.offsetLeft - 0.5 * slide.clientWidth + wrapperCenter;
        }
        return result;
    };
    Object.defineProperty(SliderWrapper.prototype, "position", {
        get: function get() {
            return this._position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderWrapper.prototype, "index", {
        get: function get() {
            return this._index;
        },
        set: function set(index) {
            this._index = index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderWrapper.prototype, "slidesPerGroup", {
        set: function set(value) {
            this._slidesPerGroup = value;
        },
        enumerable: true,
        configurable: true
    });
    SliderWrapper.prototype.initialize = function () {
        this.onresize();
    };
    SliderWrapper.prototype.onresize = function () {
        // update the area offset for slide position calculation
        this._areaOffset = this._slideAreaElement.getBoundingClientRect().left;
        // Get the container dimensions
        var containerRect = this._carouselElement.getBoundingClientRect();
        this._containerMin = containerRect.left;
        this._containerMax = containerRect.right;
    };
    SliderWrapper.prototype.beginDrag = function () {
        this._isdragging = true;
        this._dragStartPosition = this._position;
    };
    SliderWrapper.prototype.cancelDrag = function () {
        this._isdragging = false;
        this._setTransform(this._dragStartPosition, true, ANIMATION_DURATION, ANIMATION_EASING);
        this._dragStartPosition = undefined;
    };
    SliderWrapper.prototype.endDrag = function () {
        this._isdragging = false;
        this._dragStartPosition = undefined;
    };
    SliderWrapper.prototype.move = function (delta, animated, duration, ease) {
        if (animated === void 0) {
            animated = false;
        }
        if (duration === void 0) {
            duration = ANIMATION_DURATION;
        }
        if (ease === void 0) {
            ease = ANIMATION_EASING;
        }
        delta = (0, _trunc2.default)(delta);
        if (Math.abs(delta) <= 0) {
            return;
        }
        var targetPosition = this._position += delta;
        this._setTransform(targetPosition, animated, duration, ease);
    };
    SliderWrapper.prototype.moveTo = function (index, delta, animated) {
        if (animated === void 0) {
            animated = false;
        }
        var newPosition = 0;
        if (!delta) {
            newPosition = this._getWrapperSlidePosition(index);
        } else {
            newPosition = this._position += delta;
        }
        this._index = index;
        this._setTransform(newPosition, animated);
    };
    SliderWrapper.prototype.addSlide = function (slide, position) {
        if (!slide) {
            throw new Error("Cannot add an undefined slide");
        }
        if (position !== -1 && position !== 1) {
            throw new Error("Argument out of range, 'position' must be either 1 or -1. Value " + position);
        }
        if (position > 0) {
            this._wrapperElement.appendChild(slide);
        } else {
            this._wrapperElement.insertBefore(slide, this._wrapperElement.children[0]);
            this._index++;
        }
        if (position < 0) {
            var width = slide.offsetWidth;
            var style = window.getComputedStyle(slide);
            var marginLeft = style ? parseInt(style.marginLeft, 10) : 0;
            var marginRight = style ? parseInt(style.marginRight, 10) : 0;
            this.move(-(width + marginLeft + marginRight));
        }
    };
    SliderWrapper.prototype.removeSlide = function (index) {
        var slide = this._getSlide(index);
        var width = slide.offsetWidth;
        if (index <= this._index) {
            width *= -1;
            this._index--;
        }
        (0, _Utils.remove)(slide);
        if (width < 0) {
            this.move(-width);
        }
    };
    SliderWrapper.prototype.getSlideDelta = function (index) {
        var currentPosition = this._position;
        if (this._isdragging === true) {
            currentPosition = this._dragStartPosition - this._position;
        }
        var newPosition = this._getWrapperSlidePosition(index);
        return newPosition - currentPosition;
    };
    SliderWrapper.prototype.getSlideProperties = function (index, delta) {
        if (delta === void 0) {
            delta = 0;
        }
        var currentOffset = this._areaOffset + this._position + delta;
        var currentLeft = currentOffset;
        var currentRight = currentOffset;
        var _a = tslib_1.__read([0, 0], 2),
            currentMarginLeft = _a[0],
            currentMarginRight = _a[1];
        var slide = this._getSlide(index);
        var slideIndex = parseInt(slide.getAttribute(ATTRIBUTE_INDEX), 10);
        for (var i = 0; i <= index; i++) {
            slide = this._getSlide(i);
            var slideStyle = window.getComputedStyle(slide);
            currentMarginLeft = parseInt(slideStyle.marginLeft, 10);
            currentMarginRight = parseInt(slideStyle.marginRight, 10);
            currentOffset += currentMarginLeft;
            currentLeft = currentOffset;
            currentRight = currentLeft + slide.offsetWidth;
            if (i < index) {
                currentOffset = currentRight + currentMarginRight;
            }
        }
        var visible = false;
        if (currentLeft > this._containerMin && currentLeft < this._containerMax || currentRight > this._containerMin && currentRight < this._containerMax) {
            visible = true;
        }
        return {
            visible: visible,
            index: slideIndex,
            left: currentLeft,
            right: currentRight,
            width: currentRight - currentLeft,
            marginLeft: currentMarginLeft,
            marginRight: currentMarginRight
        };
    };
    SliderWrapper.prototype.getRemovableSlides = function (delta) {
        var slides = [];
        var first;
        var last;
        var index = this._wrapperElement.children.length;
        while (index > 0) {
            index--;
            var propsNow = this.getSlideProperties(index);
            var propsNew = this.getSlideProperties(index, delta);
            if (index === this._wrapperElement.children.length - 1) {
                last = propsNew;
            }
            if (index === 0) {
                first = propsNew;
            }
            if (propsNow.visible === false && propsNew.visible === false && index !== this._index && this._isdragging === false) {
                slides.push(true);
            } else {
                slides.push(false);
            }
        }
        slides.reverse();
        var firstToKeep = slides.indexOf(false);
        var lastToKeep = slides.lastIndexOf(false);
        for (var i = firstToKeep; i < lastToKeep; i++) {
            slides[i] = false;
        }
        return {
            slides: slides,
            first: first,
            last: last
        };
    };
    SliderWrapper.prototype.getEmptySpace = function (left, right) {
        return {
            left: Math.max(Math.ceil(left - this._containerMin), 0),
            right: Math.max(Math.ceil(this._containerMax - right), 0)
        };
    };
    SliderWrapper.prototype.destroy = function () {
        this._wrapperElement = null;
        this._slideAreaElement = null;
        this._carouselElement = null;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    SliderWrapper.prototype.destory = function () {
        this.destroy();
    };
    return SliderWrapper;
}();
function init() {
    (0, _Utils.searchAndInitialize)(".carousel", function (e) {
        new Carousel(e);
    });
}
exports.default = Carousel;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/math/trunc":37,"tslib":113}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DETAIL_RIGHT = ".detail-right";
var QUERY_DETAIL_BOTTOM = ".detail-bottom";
var QUERY_PROGRESS = ".bar-chart__progress";
var CLASS_UNLIMITED = "bar-chart-horizontal--unlimited";
var CLASS_LIMITED = "bar-chart-horizontal--limited";
var CLASS_DETAIL_VALUE = "value";
var CLASS_DETAIL_UNIT = "unit";
var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";
var ANIMATION_DURATION = 500;
/**
 * Bar Chart Horizontal Component.
 */
var BarChartHorizontal = /** @class */function (_super) {
    tslib_1.__extends(BarChartHorizontal, _super);
    /**
     * Creates and initializes the bar chart horizontal component.
     * @param {DomElement} - root element of the chart.
     */
    function BarChartHorizontal(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._legendItems = [];
        _this._initialize();
        return _this;
    }
    BarChartHorizontal.prototype._initialize = function () {
        this._unit = this.getAttribute("data-unit") || "";
        this._maxValue = parseFloat(this.getAttribute("data-max"));
        this._precision = parseInt(this.getAttribute("data-precision"), 10) || 0;
        this._isUnlimited = this.hasClass(CLASS_UNLIMITED);
        this._isLimited = this.hasClass(CLASS_LIMITED);
        this._progessWrapper = this.element.querySelector(QUERY_PROGRESS);
        if (this._isLimited === true) {
            this._detailRight = this.element.querySelector(QUERY_DETAIL_BOTTOM);
        } else {
            this._detailRight = this.element.querySelector(QUERY_DETAIL_RIGHT);
        }
        if (this._isUnlimited === false && this._isLimited === false) {
            this._legend = (0, _DomFunctions.getAttributeReference)(this.element, "data-legend");
        }
        if (!this._data) {
            this._data = (0, _ChartFunctions.tryGetData)(this.element);
        }
        this._render();
    };
    BarChartHorizontal.prototype._render = function () {
        var e_1, _a;
        var dataOne = this._data[0];
        var dataTwo = this._data[1];
        var tooltip = this._isLimited === false ? this._getTooltipContent(this._data) : undefined;
        var animatedValueElement;
        // Cleanup
        (0, _ChartFunctions.removeAllChildren)(this._detailRight);
        (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);
        try {
            // Clear only own legend items
            for (var _b = tslib_1.__values(this._legendItems), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                (0, _Utils.remove)(item);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._legendItems = [];
        if (dataOne) {
            if (this._isUnlimited === false || this._isUnlimited === true && !dataTwo) {
                var valElement = animatedValueElement = this._createValueElement(dataOne);
                this._detailRight.appendChild(valElement);
                if (this._isLimited === false) {
                    var separatorElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
                    separatorElement.innerText = " " + this._unit;
                    this._detailRight.appendChild(separatorElement);
                }
            }
            // Add the indicator
            var indicator = this._addIndicator(dataOne, tooltip);
            this._animateIndicator(indicator, 0);
            // Animate the value if required
            if (animatedValueElement && this._isLimited === true) {
                this._animateValueElement(animatedValueElement, dataOne.value);
            }
            // Add the legend
            if (this._legend) {
                var legendItem = (0, _ChartFunctions.createLegendItem)(dataOne);
                this._legend.appendChild(legendItem);
                this._legendItems.push(legendItem);
                this._animateLegend(legendItem, 0);
            }
        }
        if (dataTwo) {
            var valElement = this._createValueElement(dataTwo);
            var unitElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
            unitElement.innerText = " " + this._unit;
            this._detailRight.appendChild(valElement);
            this._detailRight.appendChild(unitElement);
            // Add the indicator
            var indicator = this._addIndicator(dataTwo, tooltip);
            this._animateIndicator(indicator, ANIMATION_DURATION);
            // Add the legend
            if (this._legend) {
                var legendItem = (0, _ChartFunctions.createLegendItem)(dataTwo);
                this._legend.appendChild(legendItem);
                this._legendItems.push(legendItem);
                this._animateLegend(legendItem, ANIMATION_DURATION);
            }
        }
        if (this._isLimited === true) {
            var valElement = this._createValueElement({ value: this._maxValue });
            var unitElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
            unitElement.innerText = " " + this._unit;
            this._detailRight.appendChild(valElement);
            this._detailRight.appendChild(unitElement);
        }
    };
    BarChartHorizontal.prototype._animateValueElement = function (animatedValueElement, toValue) {
        var counter = { var: 0 };
        (0, _animejs2.default)({
            targets: counter,
            var: toValue,
            duration: ANIMATION_DURATION,
            easing: "easeOutQuint",
            round: 1,
            update: function update() {
                animatedValueElement.innerText = "" + counter.var;
            }
        });
    };
    BarChartHorizontal.prototype._animateIndicator = function (indicatorWrapper, animationOffset) {
        var indicator = indicatorWrapper.getElementsByClassName("indicator")[0];
        var indicatorWidth = indicator.scrollWidth;
        indicator.style.width = "0px";
        (0, _animejs2.default)({
            targets: indicator,
            duration: ANIMATION_DURATION,
            width: indicatorWidth + "px",
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                indicator.style.width = "";
            }
        });
    };
    BarChartHorizontal.prototype._animateLegend = function (legendItem, animationOffset) {
        legendItem.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legendItem,
            duration: ANIMATION_DURATION,
            opacity: 1,
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                legendItem.style.opacity = null;
            }
        });
    };
    BarChartHorizontal.prototype._createValueElement = function (data) {
        var unlimitedPrefix = "";
        if (this._isUnlimited === true) {
            unlimitedPrefix = "+";
        }
        var value = parseFloat(data.value);
        if (value <= 0) {
            if (this._precision === 0) {
                value = "0";
            } else {
                value = ".";
                for (var i = 0; i < this._precision; i++) {
                    value += "0";
                }
            }
        } else {
            value = value.toFixed(this._precision);
        }
        var valueElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_VALUE).element;
        valueElement.innerText = "" + unlimitedPrefix + value;
        return valueElement;
    };
    BarChartHorizontal.prototype._addIndicator = function (data, tooltip) {
        var width = 100.0 / this._maxValue * data.value;
        var indicator = new _DomElement2.default("div").addClass(CLASS_INDICATOR);
        if ((0, _ChartFunctions.isColor)(data.color) === true) {
            indicator.setAttribute("style", "background-color: " + data.color + ";");
        } else {
            indicator.addClass(data.color);
        }
        var indicatorWrapper = new _DomElement2.default("div").addClass(CLASS_INDICATOR_WRAPPER).setAttribute("style", "width: " + width + "%").appendChild(indicator).setAttribute("onclick", "void(0)");
        if (tooltip && tooltip !== "") {
            indicatorWrapper.addClass(CLASS_TOOLTIP).addClass(CLASS_TOOLTIP_MULTILINE).setAttribute("aria-label", tooltip);
        }
        this._progessWrapper.appendChild(indicatorWrapper.element);
        return indicatorWrapper.element;
    };
    BarChartHorizontal.prototype._getTooltipContent = function (dataList) {
        var e_2, _a;
        var tooltip = "";
        try {
            for (var dataList_1 = tslib_1.__values(dataList), dataList_1_1 = dataList_1.next(); !dataList_1_1.done; dataList_1_1 = dataList_1.next()) {
                var data = dataList_1_1.value;
                tooltip += data.title + ": " + data.value + " " + this._unit + "\n";
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (dataList_1_1 && !dataList_1_1.done && (_a = dataList_1.return)) _a.call(dataList_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        return tooltip.trim();
    };
    /**
     * Updates the bar chart with the specified data definitions.
     * @param {Array} - bar chart data definitions.
     */
    BarChartHorizontal.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    BarChartHorizontal.prototype.destroy = function () {
        var e_3, _a;
        this._data = undefined;
        (0, _ChartFunctions.removeAllChildren)(this._detailRight);
        (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);
        this._detailRight = undefined;
        this._progessWrapper = undefined;
        try {
            for (var _b = tslib_1.__values(this._legendItems), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                (0, _Utils.remove)(item);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        this._legendItems = undefined;
        this._legend = undefined;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    BarChartHorizontal.prototype.destory = function () {
        this.destroy();
    };
    return BarChartHorizontal;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".bar-chart-horizontal", function (e) {
        new BarChartHorizontal(e);
    });
}
exports.default = BarChartHorizontal;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"./ChartFunctions":13,"animejs":34,"tslib":113}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DATA_CATEGORIES = ".js-data-list .js-category";
var QUERY_DATA_ITEMS = ".js-data-list .js-data";
var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".bar-chart__legend";
var CLASS_INDICATOR = "indicator";
var CLASS_LABEL_X = "axis-x-label";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_INDICATOR_INNER_WRAPPER = "indicator-wrapper-inner";
var CLASS_INDICATOR_EMPTY = "empty";
var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_LEFT = "tooltip--left";
var CLASS_TOOLTIP_RIGHT = "tooltip--right";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";
var ANIMATION_DURATION = 500;
/**
 * Bar Chart Horizontal Component.
 */
var BarChartVertical = /** @class */function (_super) {
    tslib_1.__extends(BarChartVertical, _super);
    /**
     * Creates and initializes the bar chart horizontal component.
     * @param element - root element of the chart.
     * @param data - data for the chart.
     */
    function BarChartVertical(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._initialize();
        return _this;
    }
    BarChartVertical.prototype._initialize = function () {
        this._unit = this.getAttribute("data-unit") || "";
        this._maxValue = parseFloat(this.getAttribute("data-max")) || 100;
        this._chart = this.element.querySelector(QUERY_CHART);
        this._legend = this.element.querySelector(QUERY_LEGEND);
        if (!this._data) {
            this._data = this._tryGetData(this.element);
        }
        this._render();
    };
    BarChartVertical.prototype._tryGetData = function (element) {
        var e_1, _a, e_2, _b, e_3, _c;
        var data = {
            categories: [],
            items: []
        };
        var categories = element.querySelectorAll(QUERY_DATA_CATEGORIES);
        var items = element.querySelectorAll(QUERY_DATA_ITEMS);
        try {
            for (var categories_1 = tslib_1.__values(categories), categories_1_1 = categories_1.next(); !categories_1_1.done; categories_1_1 = categories_1.next()) {
                var category = categories_1_1.value;
                data.categories.push({
                    title: (0, _DomFunctions.text)(category),
                    color: category.getAttribute("data-color")
                });
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (categories_1_1 && !categories_1_1.done && (_a = categories_1.return)) _a.call(categories_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        try {
            for (var items_1 = tslib_1.__values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                var item = items_1_1.value;
                var dataEnty = {
                    title: (0, _DomFunctions.text)(item),
                    class: item.getAttribute("data-class"),
                    values: []
                };
                var vals = item.getAttribute("data-value");
                if (vals) {
                    try {
                        for (var _d = (e_3 = void 0, tslib_1.__values(vals.split(","))), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var val = _e.value;
                            dataEnty.values.push(parseFloat(val));
                        }
                    } catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    } finally {
                        try {
                            if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                        } finally {
                            if (e_3) throw e_3.error;
                        }
                    }
                }
                data.items.push(dataEnty);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (items_1_1 && !items_1_1.done && (_b = items_1.return)) _b.call(items_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        return data;
    };
    BarChartVertical.prototype._getTooltipContent = function (entry, categories) {
        var tooltip = "";
        for (var i = 0; i < entry.values.length; i++) {
            tooltip += categories[i].title + ": " + entry.values[i] + " " + this._unit + "\n";
        }
        return tooltip.trim();
    };
    BarChartVertical.prototype._render = function () {
        var e_4, _a, e_5, _b;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            try {
                for (var _c = tslib_1.__values(this._data.categories), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var category = _d.value;
                    var legendItem = (0, _ChartFunctions.createLegendItem)(category);
                    this._legend.appendChild(legendItem);
                }
            } catch (e_4_1) {
                e_4 = { error: e_4_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_4) throw e_4.error;
                }
            }
        }
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        var animationStages = [];
        var leftSideItems = Math.floor(this._data.items.length / 2);
        try {
            for (var _e = tslib_1.__values(this._data.items), _f = _e.next(); !_f.done; _f = _e.next()) {
                var item = _f.value;
                var element = new _DomElement2.default("li");
                if (item.class) {
                    element.addClass(item.class);
                }
                var listElement = new _DomElement2.default("ul").addClass(CLASS_INDICATOR_WRAPPER);
                var wrapper = new _DomElement2.default("div").addClass(CLASS_INDICATOR_INNER_WRAPPER);
                listElement.appendChild(wrapper);
                element.appendChild(listElement);
                var tooltip = this._getTooltipContent(item, this._data.categories);
                if (tooltip) {
                    wrapper.addClass(CLASS_TOOLTIP).addClass(leftSideItems <= 0 ? CLASS_TOOLTIP_LEFT : CLASS_TOOLTIP_RIGHT).setAttribute("aria-label", tooltip);
                    if (item.values.length > 1) {
                        wrapper.addClass(CLASS_TOOLTIP_MULTILINE);
                    }
                }
                for (var i = 0; i < item.values.length; i++) {
                    var height = this._chart.offsetHeight / this._maxValue * item.values[i];
                    var indicator = new _DomElement2.default("li").addClass(CLASS_INDICATOR).setAttribute("style", "height: " + height + "px;");
                    if (height > 0) {
                        var color = this._data.categories[i].color;
                        if ((0, _ChartFunctions.isColor)(color)) {
                            indicator.setAttribute("style", "background-color: " + color + ";");
                        } else {
                            indicator.addClass(color);
                        }
                        if (animationStages.length <= i) {
                            animationStages.push([]);
                        }
                        animationStages[i].push(indicator.element);
                    } else {
                        indicator.addClass(CLASS_INDICATOR_EMPTY);
                    }
                    wrapper.appendChild(indicator);
                }
                var titleDomElement = new _DomElement2.default("div").addClass(CLASS_LABEL_X);
                var titleElement = titleDomElement.element;
                titleElement.innerText = item.title;
                element.appendChild(titleDomElement);
                this._chart.appendChild(element.element);
                leftSideItems -= 1;
            }
        } catch (e_5_1) {
            e_5 = { error: e_5_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_5) throw e_5.error;
            }
        }
        for (var i = 0; i < animationStages.length; i++) {
            var offset = ANIMATION_DURATION * i;
            this._animateBars(animationStages[i], offset);
            if (this._legend) {
                this._animateLegend(this._legend.children[i], offset);
            }
        }
    };
    BarChartVertical.prototype._animateBars = function (bars, animationOffset) {
        for (var i = 0; i < bars.length; i++) {
            var bar = bars[i];
            var barHeight = bar.style.height;
            bar.style.height = "0";
            (0, _animejs2.default)({
                targets: bars[i],
                height: barHeight,
                easing: "easeInOutQuint",
                duration: ANIMATION_DURATION,
                delay: animationOffset
            });
        }
    };
    BarChartVertical.prototype._animateLegend = function (legend, animationOffset) {
        legend.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legend,
            opacity: 1,
            easing: "easeInOutQuint",
            duration: ANIMATION_DURATION,
            delay: animationOffset
        });
    };
    /**
     * Updates the bar chart with the specified data definitions.
     * @param {Array} - bar chart data definitions.
     */
    BarChartVertical.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    BarChartVertical.prototype.destroy = function () {
        this._data = undefined;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            this._legend = undefined;
        }
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    BarChartVertical.prototype.destory = function () {
        this.destroy();
    };
    return BarChartVertical;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".bar-chart-vertical", function (e) {
        new BarChartVertical(e);
    });
}
exports.default = BarChartVertical;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"./ChartFunctions":13,"animejs":34,"tslib":113}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tryGetData = tryGetData;
exports.removeAllChildren = removeAllChildren;
exports.createLegendItem = createLegendItem;
exports.isColor = isColor;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DATA = ".js-data";
function tryGetData(element) {
    var e_1, _a;
    var data = [];
    var elements = element.querySelectorAll(QUERY_DATA);
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var entry = elements_1_1.value;
            var value = parseFloat(entry.getAttribute("data-value"));
            var color = entry.getAttribute("data-color");
            var title = (0, _DomFunctions.text)(entry);
            var item = {
                title: title,
                value: value,
                color: color
            };
            data.push(item);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    return data;
}
function removeAllChildren(node) {
    while (node.firstChild) {
        node.removeChild(node.firstChild);
    }
}
function createLegendItem(data) {
    var bullet = new _DomElement2.default("span").addClass("bullet");
    if (isColor(data.color) === true) {
        bullet.setAttribute("style", "background-color: " + data.color + ";");
    } else {
        bullet.addClass(data.color);
    }
    var caption = new _DomElement2.default("span").setHtml(data.title);
    return new _DomElement2.default("li").appendChild(bullet).appendChild(caption).element;
}
function isColor(str) {
    var pattern = /^#/i;
    return pattern.test(str);
}

},{"../DomElement":5,"../DomFunctions":6,"tslib":113}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".js-legend";
var DASH_SEPARATOR_WIDTH = 3;
var ANIMATION_DURATION = 1500;
var ANIMATION_DURATION_LEGEND = 500;
var QUERY_META_TITLE = ".meta .title";
var QUERY_META_SUBTITLE = ".meta .subtitle";
/**
 * Pie Chart Component.
 */
var PieChart = /** @class */function (_super) {
    tslib_1.__extends(PieChart, _super);
    /**
     * Creates and initializes the Pie Chart component.
     * @param {DomElement} - root element of the chart.
     * @param {Array} - pie chart data definitions.
     */
    function PieChart(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._initialize();
        return _this;
    }
    PieChart.prototype._initialize = function () {
        this._chart = this.element.querySelector(QUERY_CHART);
        this._legend = this.element.querySelector(QUERY_LEGEND);
        this._title = this.element.querySelector(QUERY_META_TITLE);
        this._subtitle = this.element.querySelector(QUERY_META_SUBTITLE);
        this._unit = this.getAttribute("data-unit") || "";
        this._alwaysShowLegend = this.element.hasAttribute("data-always-show-legend");
        if (!this._data) {
            this._data = (0, _ChartFunctions.tryGetData)(this.element);
        }
        this._render();
    };
    PieChart.prototype._render = function () {
        var total = this._data.reduce(function (a, b) {
            return a + b.value;
        }, 0);
        var r = 16;
        var dashTotal = 2 * r * Math.PI;
        var currentRotate = 9;
        // Cleanup
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
        }
        var percentageAdjustTotal = 0;
        var percentageAdjust = 0;
        var separatorPercentage = DASH_SEPARATOR_WIDTH / 100;
        for (var i = 0; i < this._data.length; i++) {
            var entry = this._data[i];
            var percentage = entry.value / total;
            if (percentage < separatorPercentage) {
                percentageAdjustTotal += separatorPercentage - percentage;
                percentageAdjust++;
            }
        }
        if (percentageAdjust > 0) {
            percentageAdjust = percentageAdjustTotal / (this._data.length - percentageAdjust);
        }
        var animations = _animejs2.default.timeline();
        var animationOffset = 0;
        var _loop_1 = function _loop_1(i) {
            var entry = this_1._data[i];
            var displayPercentage = entry.value / total;
            var percentage = Math.max(separatorPercentage, displayPercentage - percentageAdjust);
            var dashWidth = percentage * dashTotal - DASH_SEPARATOR_WIDTH;
            var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("viewBox", "0 0 34 34");
            svg.setAttribute("role", "img");
            svg.setAttribute("aria-labelledby", "title desc");
            var title = document.createElementNS("http://www.w3.org/2000/svg", "title");
            title.setAttribute("id", "title");
            title.innerHTML = "Pie chart segment " + Math.floor(displayPercentage * 100) + "%";
            var description = document.createElementNS("http://www.w3.org/2000/svg", "desc");
            description.setAttribute("id", "desc");
            description.innerHTML = entry.title + ": " + entry.value;
            var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", "17");
            circle.setAttribute("cy", "17");
            circle.setAttribute("r", String(r));
            if ((0, _ChartFunctions.isColor)(entry.color) === true) {
                circle.setAttribute("stroke", "" + entry.color);
            } else {
                circle.setAttribute("class", entry.color);
            }
            circle.setAttribute("role", "presentation");
            svg.setAttribute("style", "transform: rotate(" + currentRotate + "deg);");
            svg.appendChild(title);
            svg.appendChild(description);
            svg.appendChild(circle);
            this_1._chart.appendChild(svg);
            var animationDuration = ANIMATION_DURATION * percentage;
            circle.style.display = "none";
            var counter = { var: 0.5 };
            animations.add({
                targets: counter,
                var: dashWidth,
                begin: function begin() {
                    circle.style.display = "";
                },
                update: function update() {
                    circle.setAttribute("stroke-dasharray", counter.var + " " + dashTotal);
                },
                duration: animationDuration,
                easing: "easeInQuint"
            });
            // Legend
            if (this_1._legend && this_1._data.length > 1 || this_1._alwaysShowLegend) {
                var bullet = new _DomElement2.default("span").addClass("bullet");
                if ((0, _ChartFunctions.isColor)(entry.color) === true) {
                    bullet.setAttribute("style", "background-color: " + entry.color);
                } else {
                    bullet.addClass(entry.color);
                }
                var caption = new _DomElement2.default("span");
                var captionElement = caption.element;
                captionElement.innerText = entry.title;
                var legendItem = new _DomElement2.default("li").appendChild(bullet).appendChild(caption);
                this_1._legend.appendChild(legendItem.element);
                this_1._animateLegend(legendItem.element, animationOffset);
            }
            animationOffset += animationDuration;
            currentRotate += 360 * percentage;
            if (i === this_1._data.length - 1) {
                this_1._title.innerHTML = entry.value + " " + this_1._unit;
                this_1._subtitle.innerHTML = entry.title;
            }
        };
        var this_1 = this;
        for (var i = 0; i < this._data.length; i++) {
            _loop_1(i);
        }
    };
    PieChart.prototype._animateLegend = function (legendItem, animationOffset) {
        legendItem.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legendItem,
            duration: ANIMATION_DURATION_LEGEND,
            opacity: 1,
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                legendItem.style.opacity = null;
            }
        });
    };
    /**
     * Updates the pie chart with the specified data definitions.
     * @param {Array} - pie chart data definitions.
     */
    PieChart.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    PieChart.prototype.destroy = function () {
        this._data = undefined;
        this._title = undefined;
        this._subtitle = undefined;
        this._unit = undefined;
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        this._chart = undefined;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            this._legend = undefined;
        }
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    PieChart.prototype.destory = function () {
        this.destroy();
    };
    return PieChart;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".pie-chart", function (e) {
        new PieChart(e);
    });
}
exports.default = PieChart;

},{"../DomElement":5,"../Utils":8,"./ChartFunctions":13,"animejs":34,"tslib":113}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var ANIMATION_OPEN = 300;
/**
 * The Collapse component.
 */
var Collapse = /** @class */function (_super) {
    tslib_1.__extends(Collapse, _super);
    /**
     * Creates and initializes the Collapse component.
     * @param {DomElement} - The root element of the Collapse component.
     */
    function Collapse(element) {
        var _this = _super.call(this, element) || this;
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Collapse component.
     * @private
     */
    Collapse.prototype._initialize = function () {
        var dataTarget = this.element.getAttribute("data-target");
        if (dataTarget === null || dataTarget === "") {
            /* tslint:disable:no-console */
            console.error("A collapsible element requires a 'data-target' that specifies the element to collapse");
            console.info(this.element);
            /* tslint:enable:no-console */
            return;
        }
        var hiddenTarget = this.element.getAttribute("data-hidden");
        if (hiddenTarget !== null && hiddenTarget !== "") {
            this._hiddenIndicator = document.querySelector(hiddenTarget);
        }
        this._collapsibleElements = document.querySelectorAll(dataTarget);
        this.element.addEventListener("click", this._clickHandler);
    };
    Collapse.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.toggle();
    };
    /**
     * Toggles the collapseible.
     */
    Collapse.prototype.toggle = function () {
        var e_1, _a, e_2, _b;
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
            try {
                for (var _c = tslib_1.__values(this._collapsibleElements), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var s = _d.value;
                    this._openCollapse(s);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
        } else {
            (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
            try {
                for (var _e = tslib_1.__values(this._collapsibleElements), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var s = _f.value;
                    this._closeCollapse(s);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
        }
    };
    Collapse.prototype._openCollapse = function (el) {
        _animejs2.default.remove(el);
        el.style.display = "block";
        (0, _animejs2.default)({
            targets: el,
            duration: ANIMATION_OPEN,
            height: el.scrollHeight + "px",
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                var domEl = new _DomElement2.default(el);
                domEl.addClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "true");
    };
    Collapse.prototype._closeCollapse = function (el) {
        _animejs2.default.remove(el);
        (0, _animejs2.default)({
            targets: el,
            duration: ANIMATION_OPEN,
            height: 0,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                var domEl = new _DomElement2.default(el);
                domEl.removeClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "false");
    };
    /**
     * Removes all event handlers and clears references.
     */
    Collapse.prototype.destroy = function () {
        this._collapsibleElements = null;
        if (this._clickHandler) {
            this.element.removeEventListener("click", this._clickHandler);
        }
        this.element = null;
    };
    return Collapse;
}(_DomElement2.default);
function init() {
    var e_3, _a;
    var elements = document.querySelectorAll("[data-toggle='collapse']");
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            if (e.getAttribute("data-init") === "auto") {
                new Collapse(e);
            }
        }
    } catch (e_3_1) {
        e_3 = { error: e_3_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_3) throw e_3.error;
        }
    }
}
exports.default = Collapse;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":34,"tslib":113}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BORDER = "empty-state__border";
var CLASS_BORDER_MODAL = "empty-state__border--modal";
var CLASS_ACTIVE = "is-active";
var CLASS_HASFILES = "has-files";
var CLASS_MODAL = "empty-state--modal";
var CLASS_MODAL_CONTENT = "modal__content";
var QUERY_MODAL_BODY = ".modal__body";
var QUERY_FILE = "input[type='file']";
/**
 * Empty state pattern
 */
var EmptyState = /** @class */function (_super) {
    tslib_1.__extends(EmptyState, _super);
    /**
     * Creates and initializes the Empty-State pattern component.
     * @param {DomElement} - root element of the empty-state pattern.
     */
    function EmptyState(element) {
        var _this = _super.call(this, element) || this;
        _this._fileInput = _this.element.querySelector(QUERY_FILE);
        _this._button = _this.element.querySelector("label");
        _this._fileChangedHandler = _this._handleFileChanged.bind(_this);
        _this._preventEventsHandler = _this._preventDragEvents.bind(_this);
        _this._dragEnterHandler = _this._handleDragEnter.bind(_this);
        _this._dragLeaveHandler = _this._handleDragLeave.bind(_this);
        _this._dropHandler = _this._handleDrop.bind(_this);
        _this._isDragging = false;
        _this._initialize();
        return _this;
    }
    EmptyState.prototype._initialize = function () {
        var e_1, _a;
        if (this.hasClass(CLASS_MODAL)) {
            // handle modal dialogs
            this._dragArea = (0, _DomFunctions.parentWithClass)(this.element, CLASS_MODAL_CONTENT);
            var borderArea = this._dragArea.querySelector(QUERY_MODAL_BODY);
            borderArea.setAttribute("style", "pointer-events: none;");
            this._border = new _DomElement2.default("div").addClass(CLASS_BORDER).addClass(CLASS_BORDER_MODAL);
            borderArea.appendChild(this._border.element);
        } else {
            // normal modal dialog
            this._dragArea = this.element;
            var borderArea = (0, _DomFunctions.getRootElement)();
            this._border = new _DomElement2.default("div").addClass(CLASS_BORDER);
            if (!borderArea.querySelector("." + CLASS_BORDER)) {
                borderArea.appendChild(this._border.element);
            }
        }
        var form = this.element.querySelector("form");
        try {
            for (var _b = tslib_1.__values(["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var event_1 = _c.value;
                this.element.addEventListener(event_1, this._preventEventsHandler);
                form.addEventListener(event_1, this._preventEventsHandler);
                this._dragArea.addEventListener(event_1, this._preventEventsHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._dragArea.addEventListener("dragover", this._dragEnterHandler);
        this._dragArea.addEventListener("dragenter", this._dragEnterHandler);
        this._dragArea.addEventListener("dragleave", this._dragLeaveHandler);
        this._dragArea.addEventListener("dragend", this._dragLeaveHandler);
        this._dragArea.addEventListener("drop", this._dragLeaveHandler);
        this._dragArea.addEventListener("drop", this._dropHandler);
        this._fileInput.addEventListener("change", this._fileChangedHandler);
    };
    EmptyState.prototype._preventDragEvents = function (e) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    };
    EmptyState.prototype._handleDragEnter = function () {
        if (this._isDragging === true) {
            return;
        }
        this._isDragging = true;
        this._button.setAttribute("style", "pointer-events: none;");
        this.addClass(CLASS_ACTIVE);
        this._border.addClass(CLASS_ACTIVE);
    };
    EmptyState.prototype._handleDragLeave = function () {
        if (this._isDragging === false) {
            return;
        }
        this._isDragging = false;
        this._button.setAttribute("style", "");
        this.removeClass(CLASS_ACTIVE);
        this._border.removeClass(CLASS_ACTIVE);
    };
    EmptyState.prototype._handleDrop = function (e) {
        var dragEvent = e;
        this._fileInput.files = dragEvent.dataTransfer.files;
    };
    EmptyState.prototype._handleFileChanged = function () {
        var files = this._fileInput.files;
        if (files && files.length > 0) {
            this.addClass(CLASS_HASFILES);
        } else {
            this.removeClass(CLASS_HASFILES);
        }
    };
    Object.defineProperty(EmptyState.prototype, "files", {
        /**
         * Gets the currently selected files.
         */
        get: function get() {
            return this._fileInput.files;
        },
        enumerable: true,
        configurable: true
    });
    return EmptyState;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".empty-state", function (e) {
        new EmptyState(e);
    });
}
exports.default = EmptyState;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"tslib":113}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DROPDOWN = ".js-autocomplete";
var CLASS_RESULT = "autocomplete__result";
var CLASS_OPEN = "is-open";
var CLASS_HOVER = "js-hover";
var ATTRIBUTE_VALUE = "data-value";
var TIMEOUT_BLUR = 400;
/**
 * Autocomplete component
 * @fires Autocomplete#change
 */
var Autocomplete = /** @class */function (_super) {
    tslib_1.__extends(Autocomplete, _super);
    function Autocomplete(element, configuration) {
        var _this = _super.call(this, element) || this;
        _this._input = _this.element.querySelector("input");
        _this._dropdown = _this.element.querySelector(QUERY_DROPDOWN);
        // Setup event context
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._keyUpHandler = _this._handleKeyUp.bind(_this);
        _this._keyDownHandler = _this._handleKeyDown.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        if (configuration) {
            _this._minChars = configuration.minChars;
            _this._source = configuration.source;
        }
        if (!_this._minChars || _this._minChars < 0) {
            _this._minChars = 2;
        }
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Autocomplete component.
     * @private
     */
    Autocomplete.prototype._initialize = function () {
        this._clearSuggestions();
        if (this._input.getAttribute("disabled")) {
            this.disable();
        } else {
            this.enable();
        }
        // Disable browser autofill
        this._input.setAttribute("autocomplete", "off");
    };
    /**
     * The Autocomplete component configuration object
     * @callback Autocomplete~Suggest
     * @property {String} term - The current search term.
     * @property {String[]} matches - The list of matching strings.
     */
    /**
     * The Autocomplete component configuration object
     * @callback Autocomplete~Source
     * @property {String} term - The current search term.
     * @property {Autocomplete~Suggest} suggest - The autocomplete callback function to report the results.
     */
    /**
     * The Autocomplete component configuration object
     * @typedef {Object} Autocomplete~Config
     * @property {Number} minChars - The minimal required characters to start querying for autocomplete matches.
     * @property {Autocomplete~Source} source - The autocomplete source function.
     */
    /**
     * Updates the autocomplete component configuration for the current instance
     * @param {Autocomplete~Config} configuration The configuration object
     */
    Autocomplete.prototype.configure = function (configuration) {
        if (!configuration) {
            return;
        }
        if (configuration.minChars) {
            this._minChars = Math.min(configuration.minChars, 1);
        }
        if (configuration.source) {
            this._source = configuration.source;
        }
        this._clearSuggestions();
    };
    /**
     * Sets the select control to the enabled state.
     */
    Autocomplete.prototype.enable = function () {
        if (!this._input) {
            return;
        }
        this._input.removeAttribute("disabled");
        this._input.addEventListener("keyup", this._keyUpHandler);
        this._input.addEventListener("keydown", this._keyDownHandler);
        this._input.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the select control to the disabled state.
     */
    Autocomplete.prototype.disable = function () {
        if (!this._input) {
            return;
        }
        this._input.setAttribute("disabled", "true");
        this._input.removeEventListener("keyup", this._keyUpHandler);
        this._input.removeEventListener("keydown", this._keyDownHandler);
        this._input.removeEventListener("blur", this._blurHandler);
        this.close();
    };
    /**
     * Destroys the component and frees all references.
     */
    Autocomplete.prototype.destroy = function () {
        this.disable();
        this._keyUpHandler = undefined;
        this._keyDownHandler = undefined;
        this._windowClickHandler = undefined;
        this._blurHandler = undefined;
        this._input = undefined;
    };
    /**
     * Closes the suggestions dropdown.
     */
    Autocomplete.prototype.open = function () {
        this._dropdown.addEventListener("click", this._clickHandler);
        window.addEventListener("click", this._windowClickHandler);
        this.addClass(CLASS_OPEN);
    };
    /**
     * Opens the suggestions dropdown.
     */
    Autocomplete.prototype.close = function () {
        this._dropdown.removeEventListener("click", this._clickHandler);
        window.removeEventListener("click", this._windowClickHandler);
        this.removeClass(CLASS_OPEN);
    };
    Object.defineProperty(Autocomplete.prototype, "value", {
        /**
         * Gets the value of the input field.
         * @returns {String} The value of the input field.
         */
        get: function get() {
            return this._input.value;
        },
        enumerable: true,
        configurable: true
    });
    Autocomplete.prototype._handleClick = function (event) {
        if (!this._isDropdownTarget(event.target)) {
            return;
        }
        var current = event.target;
        while (current.nodeName !== "LI" && current.parentNode) {
            current = current.parentNode;
        }
        if (current.nodeName === "LI") {
            (0, _Utils.preventDefault)(event);
            this._selectItem(current);
        }
    };
    Autocomplete.prototype._handleBlur = function () {
        var _this = this;
        setTimeout(function () {
            _this.close();
        }, TIMEOUT_BLUR);
    };
    Autocomplete.prototype._handleKeyUp = function (evt) {
        var keycode = evt.which || evt.keyCode;
        if (Inputs.containsKey(keycode, [Inputs.KEY_ARROW_UP, Inputs.KEY_ARROW_DOWN, Inputs.KEY_ENTER, Inputs.KEY_TAB])) {
            // Do not handle these events on keyup
            (0, _Utils.preventDefault)(evt);
            return;
        }
        var target = evt.currentTarget;
        if (evt.currentTarget && target.value && target.value.length >= this._minChars) {
            this._getSuggestion(target.value);
        } else {
            this.close();
        }
    };
    Autocomplete.prototype._handleKeyDown = function (evt) {
        var keycode = evt.which || evt.keyCode;
        var isOpen = (0, _DomFunctions.hasClass)(this.element, CLASS_OPEN);
        if (keycode === Inputs.KEY_ESCAPE && isOpen === true) {
            // handle Escape key (ESC)
            this.close();
            (0, _Utils.preventDefault)(evt);
            return;
        }
        if (isOpen === true && Inputs.containsKey(keycode, [Inputs.KEY_ENTER, Inputs.KEY_TAB])) {
            var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);
            (0, _Utils.preventDefault)(evt);
            this._selectItem(focusedElement);
            return;
        }
        if (isOpen === true && Inputs.containsKey(keycode, [Inputs.KEY_ARROW_UP, Inputs.KEY_ARROW_DOWN])) {
            // Up and down arrows
            var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);
            if (focusedElement) {
                (0, _DomFunctions.removeClass)(focusedElement, CLASS_HOVER);
                var children = Array.prototype.slice.call(this._suggestionList.childNodes);
                var totalNodes = children.length - 1;
                var direction = keycode === Inputs.KEY_ARROW_UP ? -1 : 1;
                var index = children.indexOf(focusedElement);
                index = Math.max(Math.min(index + direction, totalNodes), 0);
                focusedElement = this._suggestionList.childNodes[index];
            } else {
                focusedElement = this._suggestionList.querySelector("li");
            }
            (0, _DomFunctions.addClass)(focusedElement, CLASS_HOVER);
            (0, _Utils.preventDefault)(evt);
            return;
        }
    };
    Autocomplete.prototype._handleWindowClick = function (event) {
        if (this._isDropdownTarget(event.target)) {
            return;
        }
        this.close();
    };
    Autocomplete.prototype._selectItem = function (item) {
        if (!item) {
            return;
        }
        var text = item.getAttribute(ATTRIBUTE_VALUE);
        if (text) {
            this._input.value = text;
            // Dispatch the changed event
            this.dispatchEvent("change");
        }
        this.close();
    };
    Autocomplete.prototype._isDropdownTarget = function (target) {
        var current = target;
        while (current !== this._dropdown && current.parentNode) {
            current = current.parentNode;
        }
        return current === this._dropdown;
    };
    Autocomplete.prototype._clearSuggestions = function () {
        // Clear the dropdown item
        (0, _DomFunctions.empty)(this._dropdown);
        this._suggestionList = document.createElement("ul");
        this._dropdown.appendChild(this._suggestionList);
    };
    Autocomplete.prototype._addSuggestion = function (text, term) {
        var sanitizedTerm = term.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
        var html = text.replace(new RegExp("(" + sanitizedTerm + ")", "gi"), "<strong>$1</strong>");
        var textElement = new _DomElement2.default("span").setHtml(html);
        var innerElement = new _DomElement2.default("div").addClass(CLASS_RESULT).appendChild(textElement);
        var liElement = new _DomElement2.default("li").setAttribute(ATTRIBUTE_VALUE, text).appendChild(innerElement);
        this._suggestionList.appendChild(liElement.element);
    };
    Autocomplete.prototype._getSuggestion = function (term) {
        var _this = this;
        if (!this._source) {
            throw new Error("The source function is undefined, cannot load suggestions");
        }
        this._source(term, function (matches, termused) {
            _this._onMatchesReceived(matches, termused);
        });
    };
    Autocomplete.prototype._onMatchesReceived = function (matches, term) {
        var e_1, _a;
        this._clearSuggestions();
        if (!matches || matches.length === 0) {
            this.close();
        } else {
            // Clear the dropdown item
            (0, _DomFunctions.empty)(this._suggestionList);
            try {
                for (var matches_1 = tslib_1.__values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
                    var match = matches_1_1.value;
                    this._addSuggestion(match, term);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return)) _a.call(matches_1);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            this.open();
        }
    };
    return Autocomplete;
}(_DomElement2.default);
/**
 * Change event
 *
 * @event Autocomplete#change
 * @type {object}
 */
function init() {
    (0, _Utils.searchAndInitialize)(".input-field--autocomplete", function (e) {
        new Autocomplete(e);
    });
}
exports.default = Autocomplete;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"tslib":113}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _flatpickr = require("flatpickr");

var _flatpickr2 = _interopRequireDefault(_flatpickr);

var _it = require("flatpickr/dist/l10n/it.js");

var _fr = require("flatpickr/dist/l10n/fr.js");

var _de = require("flatpickr/dist/l10n/de.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_flatpickr2.default.localize(_it.Italian);
_flatpickr2.default.localize(_fr.French);
_flatpickr2.default.localize(_de.German);
var DEFAULTS_FLATPICKR = {
    wrap: true,
    allowInput: true,
    locale: "de",
    dateFormat: "d.m.Y",
    time_24hr: true
};
var CLASS_HAS_VALUE = "is-fixed";
var CLASS_MESSAGE = ".message";
/**
 * Input field component
 */
var InputField = /** @class */function (_super) {
    tslib_1.__extends(InputField, _super);
    function InputField(element, datePickerOptions) {
        var _this = _super.call(this, element) || this;
        _this._changedHandler = _this.onValueChanged.bind(_this);
        _this._animationStartHandler = _this._onAnimationStart.bind(_this);
        _this._datePickerOptions = datePickerOptions;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the input field component.
     * @private
     */
    InputField.prototype._initialize = function () {
        this.element.addEventListener("input", this._changedHandler);
        if (this.element.getAttribute("type") === "password") {
            this.element.addEventListener("animationstart", this._animationStartHandler);
        }
        this._initializeDatePicker();
        this.onValueChanged();
    };
    InputField.prototype._initializeDatePicker = function () {
        var picker = this.element.parentElement;
        if (!picker || !picker.classList.contains("flatpickr")) {
            return;
        }
        if (!this._datePickerOptions) {
            try {
                this._datePickerOptions = JSON.parse(picker.dataset.options || "{}");
            } catch (e) {
                this._datePickerOptions = {};
                // tslint:disable-next-line:no-console
                console.warn("_initializeDatePicker JSON.parse failed", picker.dataset.options, e);
            }
        }
        this._flatpickrInstance = (0, _flatpickr2.default)(picker, (0, _assign2.default)({}, DEFAULTS_FLATPICKR, this._datePickerOptions));
    };
    InputField.prototype._destroyDatePicker = function () {
        if (this._flatpickrInstance) {
            this._flatpickrInstance.destroy();
        }
    };
    InputField.prototype._onAnimationStart = function (e) {
        if (e.animationName === "onAutoFillStart") {
            this.onValueChanged(true);
        }
    };
    /**
     * Notifies the input field component that it's value has been changed.
     */
    InputField.prototype.onValueChanged = function (force) {
        if (force === void 0) {
            force = false;
        }
        if (this.element.value && this.element.value !== "" || force === true) {
            this.addClass(CLASS_HAS_VALUE);
        } else {
            this.removeClass(CLASS_HAS_VALUE);
            this.element.value = "";
        }
    };
    /**
     * Destroys the component and frees all references.
     */
    InputField.prototype.destroy = function () {
        this.element.removeEventListener("input", this._changedHandler);
        if (this.element.getAttribute("type") === "password") {
            this.element.removeEventListener("animationstart", this._animationStartHandler);
        }
        this._changedHandler = undefined;
        this._animationStartHandler = undefined;
        this._destroyDatePicker();
    };
    /**
     * Displays the specified error text underneath the input field.
     * @param {text} text The error text/html to display; or undefined to hide the message.
     */
    InputField.prototype.showError = function (text) {
        var message;
        if (this.element.parentElement) {
            var msg_1 = this.element.parentElement.querySelector(CLASS_MESSAGE);
            if (msg_1) {
                message = new _DomElement2.default(msg_1);
            }
        }
        if (!text || text === "") {
            if (message) {
                (0, _Utils.remove)(message.element);
            }
            this.removeClass("invalid");
            return;
        }
        this.addClass("invalid");
        if (!message) {
            message = new _DomElement2.default("div").addClass("message");
            this.element.parentElement.appendChild(message.element);
        } else {
            message.empty();
        }
        var icon = new _DomElement2.default("i").addClass("icon").addClass("icon-026-exclamation-mark-circle").setAttribute("aria-hidden", "true");
        var msg = new _DomElement2.default("span").setHtml(text);
        message.appendChild(icon);
        message.appendChild(msg);
    };
    return InputField;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".input-field input", function (e) {
        new InputField(e);
    }, function (e) {
        return e.parentElement;
    });
}
exports.default = InputField;

},{"../DomElement":5,"../Utils":8,"babel-runtime/core-js/object/assign":40,"flatpickr":108,"flatpickr/dist/l10n/de.js":109,"flatpickr/dist/l10n/fr.js":110,"flatpickr/dist/l10n/it.js":111,"tslib":113}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isNan = require("babel-runtime/core-js/number/is-nan");

var _isNan2 = _interopRequireDefault(_isNan);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MARGIN_TICK = 32;
var CLASS_HTML5 = "html5";
var RANGE_LIGHT = "range--light";
var CLASS_CONTAINER = "range-container";
var CLASS_SLIDER = "range-slider";
var CLASS_ACTIVE = "range--active";
var CLASS_TRACK = "range-track";
var CLASS_TRACK_PROGRESS = "range-track__progress";
var CLASS_TICK = "range-tick";
var CLASS_TICK_LABEL = "range-tick__label";
var CLASS_TICK_ACTIVE = "range-tick--active";
var CLASS_THUMB = "range-thumb";
var CLASS_THUMB_VALUE = "range-thumb__value";
var CLASS_DISABLED = "range--disabled";
var CLASS_DRAGGING = "range--dragging";
/**
 * The range slider component definition.
 */
var Range = /** @class */function (_super) {
    tslib_1.__extends(Range, _super);
    function Range(element) {
        var _this = _super.call(this, element) || this;
        // Setup event context
        _this._downHandler = _this._handleDown.bind(_this);
        _this._moveHandler = _this._handleMove.bind(_this);
        _this._endHandler = _this._handleEnd.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._focusHandler = _this._handleFocus.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        _this._resizeHandler = _this.layout.bind(_this);
        _this._initialize();
        if (_this.element.disabled) {
            _this.disable();
        } else {
            _this.enable();
        }
        return _this;
    }
    /**
     * Initializes the range slider component.
     *
     * This method inspects the select definition and its options and
     * generates new stylable DOM elements around the original range input-element
     * definitions.
     * @private
     */
    Range.prototype._initialize = function () {
        if (this.hasClass(CLASS_HTML5)) {
            // This element uses HTML5 styling, do not touch it...
            return;
        }
        this._wrapperElement = new _DomElement2.default(this.element.parentElement);
        this._rangeContainer = new _DomElement2.default("div").addClass(CLASS_CONTAINER);
        this._rangeTrack = new _DomElement2.default("div").addClass(CLASS_TRACK);
        // check if range--light slider then add progress
        if (this._wrapperElement.hasClass(RANGE_LIGHT)) {
            this._rangeProgress = new _DomElement2.default("div").addClass(CLASS_TRACK_PROGRESS);
            this._rangeTrack.appendChild(this._rangeProgress);
        }
        this._rangeThumb = new _DomElement2.default("div").addClass(CLASS_THUMB);
        this._ticksWrapper = new _DomElement2.default("div").addClass(CLASS_SLIDER);
        this._rangeContainer.appendChild(this._rangeTrack);
        this._rangeContainer.appendChild(this._ticksWrapper);
        this._rangeContainer.appendChild(this._rangeThumb);
        // add container to wrapper
        this._wrapperElement.appendChild(this._rangeContainer);
        // get min & max definitions
        this._minValue = parseFloat(this.element.min) || 0;
        this._maxValue = parseFloat(this.element.max) || 1;
        // get the label/output format string
        this._formatter = window[this.getAttribute("formatter")];
        // get the output label and move it below the container
        if (this.element.id) {
            this._outputLabel = this._wrapperElement.find("output[for='" + this.element.id + "']");
            if (this._outputLabel) {
                this._wrapperElement.appendChild(this._outputLabel);
            }
        }
        if (!this.element.step) {
            // fix issues with float sliders if the step is undefined
            this.element.step = "any";
        }
        var options = this._getOptionsList();
        if (options && options.length) {
            this._addTicks(options);
        }
        if (this._rangeContainer.element.querySelectorAll("." + CLASS_TICK_LABEL).length <= 1) {
            this._thumbValue = new _DomElement2.default("div").addClass(CLASS_THUMB_VALUE);
            this._rangeThumb.appendChild(this._thumbValue);
        }
        this._trackValueTotal = this._maxValue - this._minValue;
        this.layout();
        this._updateTickState();
        // Apply the tab index
        var tabIndex = this.element.getAttribute("tabindex");
        if (tabIndex) {
            this._rangeContainer.setAttribute("tabindex", tabIndex);
        }
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
    };
    Range.prototype._getOptionsList = function () {
        var e_1, _a;
        var options = [];
        var listId = this.getAttribute("list");
        if (listId) {
            var dataList = document.querySelector("#" + listId);
            if (dataList) {
                try {
                    for (var _b = tslib_1.__values(dataList.querySelectorAll("option")), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var entry = _c.value;
                        var value = parseFloat(entry.innerText);
                        var label = entry.getAttribute("label") || parseFloat(value.toFixed(2));
                        options.push({
                            value: value,
                            label: label
                        });
                    }
                } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                } finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
            }
        }
        // Sort the list to enable snapping
        options = options.sort(function (a, b) {
            return a.value - b.value;
        });
        if (options.length > 1) {
            this._minValue = Number.MAX_VALUE;
            this._maxValue = Number.MIN_VALUE;
            for (var i = 0; i < options.length; i++) {
                this._minValue = Math.min(this._minValue, options[i].value);
                this._maxValue = Math.max(this._maxValue, options[i].value);
            }
        }
        return options;
    };
    Range.prototype._addTicks = function (dataItems) {
        var e_2, _a;
        try {
            for (var dataItems_1 = tslib_1.__values(dataItems), dataItems_1_1 = dataItems_1.next(); !dataItems_1_1.done; dataItems_1_1 = dataItems_1.next()) {
                var entry = dataItems_1_1.value;
                var tickElement = new _DomElement2.default("div").setAttribute("data-value", String(entry.value)).addClass(CLASS_TICK);
                var tickLabel = new _DomElement2.default("span").addClass(CLASS_TICK_LABEL).setHtml(String(entry.label));
                tickElement.appendChild(tickLabel);
                this._ticksWrapper.appendChild(tickElement);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (dataItems_1_1 && !dataItems_1_1.done && (_a = dataItems_1.return)) _a.call(dataItems_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    Range.prototype._isEventOnLabel = function (event) {
        return event.target.classList.contains(CLASS_TICK_LABEL);
    };
    Range.prototype._handleDown = function (event) {
        this._wrapperElement.addClass(CLASS_DRAGGING);
        this._rangeContainer.element.addEventListener("mouseup", this._endHandler);
        document.addEventListener("mousemove", this._moveHandler);
        document.addEventListener("mouseup", this._endHandler);
        this._rangeContainer.element.addEventListener("touchmove", this._moveHandler);
        document.addEventListener("touchend", this._endHandler);
        // Ignore clicks directly on the thumb
        if (event.target !== this._rangeThumb.element && !this._isEventOnLabel(event)) {
            var pos = this._getRelativePosition(event);
            this._setPosition(pos, true, false, false);
        }
    };
    Range.prototype._handleMove = function (event) {
        (0, _Utils.preventDefault)(event);
        this._unfocus();
        if (!this._isEventOnLabel(event)) {
            var pos = this._getRelativePosition(event);
            this._setPosition(pos, true, false, false);
        }
    };
    Range.prototype._handleEnd = function (event) {
        this._wrapperElement.removeClass(CLASS_DRAGGING);
        this._rangeContainer.element.removeEventListener("mouseup", this._endHandler);
        document.removeEventListener("mouseup", this._endHandler);
        document.removeEventListener("mousemove", this._moveHandler);
        this._rangeContainer.element.removeEventListener("touchmove", this._moveHandler);
        document.removeEventListener("touchend", this._endHandler);
        var pos = this._getRelativePosition(event);
        this._setPosition(pos, true, true, true);
        this._handleBlur();
    };
    Range.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            this._rangeContainer.element.blur();
            return;
        }
        var isUp = keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_RIGHT || keycode === Inputs.KEY_PAGE_UP;
        var isDown = keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_ARROW_LEFT || keycode === Inputs.KEY_PAGE_DOWN;
        if (isUp || isDown) {
            event.preventDefault();
            var direction = isDown ? -1 : 1;
            // make a larger step if its the vertical arrow or page keys
            if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_PAGE_UP || keycode === Inputs.KEY_PAGE_DOWN) {
                direction *= 10;
            }
            var val = this.value;
            if (this._ticksWrapper.element.childNodes.length > 1) {
                val = this._getNextValue(val, direction);
            } else {
                var step = this.element.step;
                if (!step || step === "any") {
                    step = "0.1";
                }
                var newVal = val + parseFloat(step) * direction;
                val = newVal;
            }
            this._setValue(val, true, true);
            return;
        }
    };
    Range.prototype._handleFocus = function () {
        this._rangeContainer.addClass(CLASS_ACTIVE);
    };
    Range.prototype._handleBlur = function () {
        this._rangeContainer.removeClass(CLASS_ACTIVE);
    };
    Range.prototype._unfocus = function () {
        if (document.selection) {
            document.selection.empty();
        } else {
            window.getSelection().removeAllRanges();
        }
    };
    Range.prototype._getRelativePosition = function (event) {
        var pageX;
        if ("pageX" in event) {
            pageX = event.pageX;
        } else {
            pageX = (event.touches[0] || event.changedTouches[0]).pageX;
        }
        return pageX - this._trackLeftPosition + this._grabPosition;
    };
    /**
     * Validates and updates the position and sets the corresponding value on the slider.
     * @param {position} the new position to set.
     * @param {updateValue} true if the value should be updated as well; otherwise false.
     * @param {snap} true if snapping should be used; otherwise false.
     * @param {animate} true if the UI update should be animated; otherwise false.
     * @private
     */
    Range.prototype._setPosition = function (position, updateValue, snap, animate) {
        if (updateValue === void 0) {
            updateValue = true;
        }
        if (snap === void 0) {
            snap = false;
        }
        if (animate === void 0) {
            animate = true;
        }
        if (position === undefined || position === null || (0, _isNan2.default)(position)) {
            throw new Error("Position is not a number");
        }
        // Clamp to min and max range
        var newPos = (0, _Utils.clamp)(position, this._trackPositionMin, this._trackPositionMax);
        if (updateValue) {
            var value = this._trackValueTotal / this._trackWidth * newPos + this._minValue;
            if (this._ticksWrapper.element.childNodes.length > 1 && snap) {
                var snapPos = this._getSnapPosition(newPos);
                newPos = snapPos.position;
                value = snapPos.value;
            } else if (this.element.step && this.element.step !== "any") {
                var step = parseFloat(this.element.step);
                value = Math.round(value / step) * step;
            }
            this._setValue(value, false, false);
        }
        if (animate && updateValue) {
            this._updateTickState();
        }
        if (animate) {
            (0, _animejs2.default)({
                targets: this._rangeThumb.element,
                duration: 200,
                left: newPos,
                easing: "easeInOutQuint"
            });
            if (this._rangeProgress) {
                (0, _animejs2.default)({
                    targets: this._rangeProgress.element,
                    duration: 200,
                    width: newPos,
                    easing: "easeInOutQuint"
                });
            }
        } else {
            this._rangeThumb.element.style.left = newPos + "px";
            if (this._rangeProgress) {
                this._rangeProgress.element.style.width = newPos + "px";
            }
        }
    };
    /**
     * Gets the snap value corresponding to the given value.
     * @param {value} the target value.
     * @returns an object containing the snap position and the corresponding value.
     * @private
     */
    Range.prototype._getSnapValue = function (value) {
        var ticks = this._ticksWrapper.element.children;
        var currentPosition = 0;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentValue = parseFloat(currentElement.getAttribute("data-value"));
            var currentWidth = currentElement.element.clientWidth;
            var nextElement = void 0;
            var nextValue = Number.MAX_VALUE;
            if (i < ticks.length - 1) {
                nextElement = new _DomElement2.default(ticks[i + 1]);
                nextValue = parseFloat(nextElement.getAttribute("data-value"));
            }
            // left most element
            if (i === 0 && value <= currentValue) {
                return {
                    value: currentValue,
                    position: MARGIN_TICK - this._grabPosition
                };
            }
            // right most element
            if (!nextElement && value >= currentValue) {
                return {
                    value: currentValue,
                    position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1
                };
            }
            if (value >= currentValue && value < nextValue) {
                return {
                    value: currentValue,
                    position: currentPosition + 0.5 * currentWidth - this._grabPosition
                };
            }
            currentPosition += currentWidth;
        }
        throw new Error("Could not determine snap value");
    };
    /**
     * Gets the snap position corresponding to the given position.
     * @param {position} the target position.
     * @returns an object containing the snap position and the corresponding value.
     * @private
     */
    Range.prototype._getSnapPosition = function (position) {
        if (position === undefined || position === null || (0, _isNan2.default)(position)) {
            throw new Error("position is not a number");
        }
        var ticks = this._ticksWrapper.element.children;
        var currentPosition = 0;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentValue = parseFloat(currentElement.getAttribute("data-value"));
            var currentWidth = currentElement.element.clientWidth;
            var nextElement = void 0;
            if (i < ticks.length - 1) {
                nextElement = new _DomElement2.default(ticks[i + 1]);
            }
            // left most element
            if (i === 0 && position <= currentPosition + currentWidth) {
                return {
                    value: currentValue,
                    position: MARGIN_TICK - this._grabPosition
                };
            }
            // right most element
            if (!nextElement && position >= currentPosition) {
                return {
                    value: currentValue,
                    position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1
                };
            }
            if (position >= currentPosition && position < currentPosition + currentWidth) {
                return {
                    value: currentValue,
                    position: currentPosition + 0.5 * currentWidth - this._grabPosition
                };
            }
            currentPosition += currentWidth;
        }
        throw new Error("Could not determine snap position");
    };
    /**
     * Gets the next value in the given direction with regards to snapping.
     * @param {value} The current value.
     * @param {direction} The direction (positive or negative integer).
     * @returns The next value.
     * @private
     */
    Range.prototype._getNextValue = function (value, direction) {
        var ticks = this._ticksWrapper.element.children;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentVal = parseFloat(currentElement.getAttribute("data-value"));
            if (value === currentVal) {
                var index = (0, _Utils.clamp)(i + direction, 0, ticks.length - 1);
                value = parseFloat(ticks[index].getAttribute("data-value"));
            }
        }
        return value;
    };
    Range.prototype._updateTickState = function () {
        if (this._ticksWrapper.element.childNodes.length > 1) {
            var activeTick = this._ticksWrapper.find("." + CLASS_TICK_ACTIVE);
            if (activeTick) {
                activeTick.removeClass(CLASS_TICK_ACTIVE);
            }
            var newActiveTick = this._ticksWrapper.find("." + CLASS_TICK + "[data-value='" + this.value + "']");
            if (newActiveTick) {
                newActiveTick.addClass(CLASS_TICK_ACTIVE);
            }
        }
    };
    Range.prototype._adjustTickLabelPosition = function (tickItem, left) {
        var label = new _DomElement2.default(tickItem.querySelector("." + CLASS_TICK_LABEL));
        var dummyElement = new _DomElement2.default("span").addClass(CLASS_TICK_LABEL).setAttribute("style", "visibility: hidden; display: inline-block;").setHtml(label.innerText);
        this._rangeContainer.appendChild(dummyElement);
        var width = dummyElement.element.clientWidth / 2;
        this._rangeContainer.removeChild(dummyElement);
        var floatPosition = left ? "left" : "right";
        if (width < MARGIN_TICK) {
            // center small items on the tick
            label.setAttribute("style", floatPosition + ": " + (MARGIN_TICK - Math.floor(width)) + "px; text-align: " + floatPosition + ";");
        }
    };
    Range.prototype._formatOutput = function (value, short) {
        if (this._formatter) {
            return this._formatter(value, short);
        }
        var str = parseFloat(value.toFixed(2));
        return str.toString();
    };
    /**
     * Validates and updates the range value.
     * @param {value} the new value to set.
     * @param {update} true if the UI should be updated; otherwise false.
     * @param {animate} true if the UI update should be animated; otherwise false.
     * @private
     */
    Range.prototype._setValue = function (value, update, animate) {
        if (update === void 0) {
            update = true;
        }
        if (animate === void 0) {
            animate = false;
        }
        var val = (0, _Utils.clamp)(value, this._minValue, this._maxValue);
        var position;
        if (this._ticksWrapper.element.childNodes.length > 1) {
            var snapValue = this._getSnapValue(val);
            position = snapValue.position;
            val = snapValue.value;
        } else {
            position = this._trackWidth / this._trackValueTotal * (value - this._minValue);
        }
        // If the calculation failed, fall back to the first tick position and disable the component
        if (!position) {
            position = this._getSnapPosition(val).position;
            this.disable();
        }
        this.element.value = String(val);
        if (this._thumbValue) {
            this._thumbValue.setHtml(this._formatOutput(val, true));
        }
        if (this._outputLabel) {
            this._outputLabel.setHtml(this._formatOutput(val, false));
        }
        if (update) {
            this._setPosition(position, false, false, animate);
            this._updateTickState();
        }
        this.dispatchEvent("input");
    };
    Object.defineProperty(Range.prototype, "value", {
        /**
         * Gets the current value.
         */
        get: function get() {
            return parseFloat(this.element.value);
        },
        /**
         * Sets the value of the range slider.
         */
        set: function set(value) {
            this._setValue(value, true, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Force the component to re-layout itself.
     */
    Range.prototype.layout = function () {
        this._grabPosition = Math.round(this._rangeThumb.element.offsetWidth / 2);
        var tickItems = this._rangeContainer.element.querySelectorAll("." + CLASS_TICK);
        var ticksOffset = tickItems && tickItems.length > 0 ? 2 * MARGIN_TICK : MARGIN_TICK;
        this._trackWidth = this._rangeTrack.element.offsetWidth - ticksOffset;
        this._trackPositionMin = 0;
        this._trackPositionMax = this._rangeTrack.element.clientWidth - this._rangeThumb.element.offsetWidth + 1;
        this._trackLeftPosition = this._rangeTrack.element.getBoundingClientRect().left + MARGIN_TICK;
        var itemCount = tickItems.length - 1;
        this._itemWidth = this._trackWidth / itemCount;
        var outerItemsWidth = this._itemWidth * 0.5 + MARGIN_TICK;
        for (var i = 0; i <= itemCount; i++) {
            var width = this._itemWidth;
            if (i === 0 || i === itemCount) {
                width = outerItemsWidth;
            }
            var item = new _DomElement2.default(tickItems[i]);
            item.setAttribute("style", "width: " + Math.floor(width) + "px;");
        }
        // adjust first and last label positions
        if (tickItems.length > 1) {
            this._adjustTickLabelPosition(tickItems[0], true);
            this._adjustTickLabelPosition(tickItems[tickItems.length - 1], false);
        }
        // update the value
        this._setValue(parseFloat(this.element.value), true, false);
    };
    /**
     * Destroys the components and frees all references.
     */
    Range.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this._downHandler = null;
        this._moveHandler = null;
        this._endHandler = null;
        this._focusHandler = null;
        this._blurHandler = null;
        this.element = null;
        this._rangeContainer = null;
        this._wrapperElement = null;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    Range.prototype.destoy = function () {
        this.destroy();
    };
    /**
     * Sets the component to the enabled state.
     */
    Range.prototype.enable = function () {
        this.element.removeAttribute("disabled");
        this._wrapperElement.removeClass(CLASS_DISABLED);
        this._rangeContainer.element.addEventListener("mousedown", this._downHandler);
        this._rangeContainer.element.addEventListener("touchstart", this._downHandler);
        this._rangeContainer.element.addEventListener("keydown", this._keydownHandler);
        this._rangeContainer.element.addEventListener("focus", this._focusHandler);
        this._rangeContainer.element.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the component to the disabled state.
     */
    Range.prototype.disable = function () {
        this.element.setAttribute("disabled", "");
        this._wrapperElement.addClass(CLASS_DISABLED);
        this._rangeContainer.element.removeEventListener("mousedown", this._downHandler);
        this._rangeContainer.element.removeEventListener("mouseup", this._endHandler);
        this._rangeContainer.element.removeEventListener("mousemove", this._moveHandler);
        this._rangeContainer.element.removeEventListener("touchstart", this._downHandler);
        this._rangeContainer.element.removeEventListener("focus", this._focusHandler);
        this._rangeContainer.element.removeEventListener("blur", this._blurHandler);
    };
    return Range;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("input[type='range']", function (e) {
        new Range(e);
    });
}
exports.default = Range;

},{"../DomElement":5,"../Inputs":7,"../Utils":8,"animejs":34,"babel-runtime/core-js/number/is-nan":38,"tslib":113}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_PLACEHOLDER = "select__placeholder";
var CLASS_THUMB = "select__thumb";
var CLASS_BUTTON = "select__button";
var CLASS_DROPDOWN = "select__dropdown";
var CLASS_OPEN = "select--open";
var CLASS_CLOSED = "select--closed";
var CLASS_DISABLED = "select--disabled";
var CLASS_FILTERABLE = "select--filterable";
var CLASS_ITEM = "dropdown-item";
var CLASS_ITEM_SELECTED = "dropdown-item--selected";
var CLASS_ITEM_FOCUSED = "dropdown-item--focused";
var CLASS_ITEM_DISABLED = "dropdown-item--disabled";
var CLASS_GROUP_ITEM = "dropdown-group";
var CLASS_GROUP_HEADER = "dropdown-group__item";
var QUERY_MESSAGE = ".message";
var TIMEOUT_CLOSE = 150;
var TIMEOUT_BLUR = 400;
/**
 * The select component API.
 */
var Select = /** @class */function (_super) {
    tslib_1.__extends(Select, _super);
    function Select(element) {
        var _this = _super.call(this, element) || this;
        // Minimum filter length
        _this._minFilterLength = 2;
        // The options the Select was initially created upon
        // These will be used as a basis for filtering
        _this._initialOptions = Array.prototype.slice.call(_this.element.children);
        _this._openByFocus = false;
        // Check for multi-selection
        _this._multiselection = _this.element.hasAttribute("multiple") === true;
        // Setup event context
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._handleDropdownClick = _this._handleClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._focusHandler = _this._handleFocus.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._filterKeydownHandler = _this._handleFilterKeydown.bind(_this);
        _this._filterKeyupHandler = _this._handleFilterKeyup.bind(_this);
        _this._filterFocusHandler = _this._handleFilterFocus.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the select component.
     *
     * This method inspects the select definition and its options and
     * generates new stylable DOM elements around the original select-element
     * definitions.
     * @private
     */
    Select.prototype._initialize = function () {
        var e_1, _a;
        var selectedOption = this.element.querySelector("option[selected]");
        var firstOption = this.element.querySelector("option");
        // Per default, set the last selected option to either the option with a "selected" attribute,
        // or, if not found, to the first available option
        this._lastSelectedOption = selectedOption || firstOption;
        this._wrapperElement = new _DomElement2.default(this.element.parentElement).addClass(CLASS_CLOSED);
        try {
            for (var _b = tslib_1.__values(this.classes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var cls = _c.value;
                this._wrapperElement.addClass(cls);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._dropdownElement = new _DomElement2.default("div").addClass(CLASS_DROPDOWN);
        if ((0, _Utils.internetExplorerOrEdgeVersion)() > 0 && (0, _Utils.internetExplorerOrEdgeVersion)() < 12) {
            // This is a workaround for IE browsers 11 and earlier where focusing
            // a scrollable dropdown list will close the dropdown prematurely.
            this._dropdownElement.element.addEventListener("mousedown", function (event) {
                return event.preventDefault();
            });
        }
        this._setupTarget();
        this._setupPlaceholder();
        this._wrapperElement.appendChild(this._dropdownElement);
        this._createOptions(this.element);
        this._updateSize();
        this._updateMessage();
        if (this.element.disabled) {
            this.disable();
        } else {
            this.enable();
        }
    };
    Select.prototype._setupTarget = function () {
        // move the id from the select element to the wrapper
        var id = this.element.getAttribute("id");
        if (id) {
            this.element.removeAttribute("id");
            this._wrapperElement.setAttribute("id", id);
        }
        // Apply the tab index
        var tabIndex = this.element.getAttribute("tabindex");
        if (tabIndex) {
            this._wrapperElement.setAttribute("tabIndex", tabIndex);
        }
    };
    Select.prototype._setupPlaceholder = function () {
        var _this = this;
        if (!this._selectButtonElement) {
            this._selectButtonElement = new _DomElement2.default("div").addClass(CLASS_BUTTON);
            this._wrapperElement.appendChild(this._selectButtonElement);
        }
        if (!this._thumbElement) {
            this._thumbElement = new _DomElement2.default("div").addClass(CLASS_THUMB);
            var thumbIcon = new _DomElement2.default("div").addClass("thumb-icon");
            var loader = new _DomElement2.default("div").addClass("loader-spinner").addClass("loader-spinner--small");
            this._thumbElement.appendChild(loader);
            this._thumbElement.appendChild(thumbIcon);
            this._selectButtonElement.appendChild(this._thumbElement);
        }
        var placeholderText = "";
        this._placeholderOption = this.element.querySelector("option[selected][disabled]") || undefined;
        if (this._placeholderOption) {
            placeholderText = Dom.text(this._placeholderOption);
            if (this._multiselection === true) {
                this._placeholderOption.selected = false;
            }
        }
        var selectedOption = this.element.querySelector("option[selected]:not([disabled])");
        if (selectedOption) {
            placeholderText = Dom.text(selectedOption);
        }
        if (!this._placeholderElement) {
            // When the Select is filterable, create an "input" as the placeholder element, otherwise a "span"
            if (this._isFilterable()) {
                this._placeholderElement = new _DomElement2.default("input");
                this._placeholderElement.addEventListener("keyup", function (e) {
                    return _this._handleFilterKeyup(e);
                });
                this._placeholderElement.addEventListener("keydown", function (e) {
                    return _this._handleFilterKeydown(e);
                });
                this._placeholderElement.addEventListener("focus", function (e) {
                    return _this._handleFilterFocus(e);
                });
            } else {
                this._placeholderElement = new _DomElement2.default("span");
            }
            this._placeholderElement.addClass(CLASS_PLACEHOLDER);
            this._selectButtonElement.appendChild(this._placeholderElement);
        }
        this._setPlaceholder(placeholderText);
        this._placeholderText = placeholderText;
        if (selectedOption && selectedOption !== this._placeholderOption) {
            this._updatePlaceholder(true);
        }
    };
    Select.prototype._updateMessage = function () {
        var messageNode = this._wrapperElement.element.querySelector(QUERY_MESSAGE);
        if (messageNode !== null) {
            this._wrapperElement.appendChild(new _DomElement2.default(messageNode));
        }
    };
    Select.prototype._isOptGroup = function (element) {
        return element.tagName.toUpperCase() === "OPTGROUP";
    };
    Select.prototype._isOption = function (element) {
        return element.tagName.toUpperCase() === "OPTION";
    };
    Select.prototype._createOptions = function (element) {
        for (var i = 0; i < element.children.length; i++) {
            var child = element.children[i];
            if (this._isOptGroup(child)) {
                this._appendGroup(child);
            }
            if (this._isOption(child)) {
                var option = this._createOption(child);
                if (option) {
                    this._dropdownElement.appendChild(option);
                }
            }
        }
    };
    Select.prototype._createOption = function (option) {
        var html = option.innerHTML;
        if (this._activeFilter) {
            var sanitizedActiveFilter = this._activeFilter.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
            html = html.replace(new RegExp("(" + sanitizedActiveFilter + ")", "gi"), "<strong>$1</strong>");
        }
        var opt = new _DomElement2.default("div").addClass(CLASS_ITEM).setHtml(html);
        if (option.selected) {
            opt.addClass(CLASS_ITEM_SELECTED);
        }
        if (option.disabled) {
            opt.addClass(CLASS_ITEM_DISABLED);
        }
        if (!this._isPlaceholder(option)) {
            opt.setAttribute("data-value", option.value);
            return opt;
        }
        return undefined;
    };
    Select.prototype._appendGroup = function (optgroup) {
        var e_2, _a;
        var label = optgroup.getAttribute("label");
        var group = new _DomElement2.default("div").addClass(CLASS_GROUP_ITEM);
        var groupHeader = new _DomElement2.default("div").addClass(CLASS_GROUP_HEADER).setHtml(label);
        group.appendChild(groupHeader);
        var options = optgroup.querySelectorAll("option");
        try {
            for (var options_1 = tslib_1.__values(options), options_1_1 = options_1.next(); !options_1_1.done; options_1_1 = options_1.next()) {
                var entry = options_1_1.value;
                var option = this._createOption(entry);
                if (option) {
                    group.appendChild(option);
                }
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (options_1_1 && !options_1_1.done && (_a = options_1.return)) _a.call(options_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._dropdownElement.appendChild(group);
        return group;
    };
    Select.prototype._updateSize = function () {
        var e_3, _a;
        // Note: Mirroring the DOM and measuring the items using their clientWidth was very
        // unreliable, therefore measuring was switched to the new HTML5 measureText method
        // margins and paddings arround the text are copied from the original placeholder items
        // dimension
        var placeholderStyle = window.getComputedStyle(this._placeholderElement.element);
        var paddingRight = parseFloat(placeholderStyle.paddingRight);
        var paddingLeft = parseFloat(placeholderStyle.paddingLeft);
        var font = this._placeholderElement.css("font");
        var textWidth = Dom.textWidth(this._placeholderText, font);
        var maxWidth = paddingLeft + paddingRight + textWidth;
        var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
        try {
            for (var options_2 = tslib_1.__values(options), options_2_1 = options_2.next(); !options_2_1.done; options_2_1 = options_2.next()) {
                var entry = options_2_1.value;
                var width = Dom.textWidth(Dom.text(entry), font) + paddingLeft + paddingRight;
                if (width > maxWidth) {
                    maxWidth = width;
                }
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (options_2_1 && !options_2_1.done && (_a = options_2.return)) _a.call(options_2);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
    };
    Select.prototype._isButtonTarget = function (target) {
        return target === this._wrapperElement.element || target === this._placeholderElement.element || target === this._selectButtonElement.element || target === this._thumbElement.element;
    };
    Select.prototype._isDropdownTarget = function (target) {
        var current = target;
        while (current !== this._dropdownElement.element && current.parentElement) {
            current = current.parentElement;
        }
        return current === this._dropdownElement.element;
    };
    /**
     * Updates the UI if the selection has changed and makes sure the
     * select control and the generated markup are synchronized.
     * @private
     */
    Select.prototype._selectedItemChanged = function (newItem, autoClose, multiselect) {
        var _this = this;
        if (autoClose === void 0) {
            autoClose = true;
        }
        if (multiselect === void 0) {
            multiselect = false;
        }
        var oldItems = this._dropdownElement.element.querySelectorAll("." + CLASS_ITEM_SELECTED);
        if (!newItem) {
            setTimeout(function () {
                return _this.close();
            }, TIMEOUT_CLOSE);
            return;
        }
        if (Dom.hasClass(newItem, CLASS_ITEM_DISABLED)) {
            return;
        }
        if (oldItems.length === 0 && !newItem) {
            throw new Error("Can not select undefined elements");
        }
        var oldItem = oldItems[0];
        if (multiselect === true) {
            oldItem = (0, _Utils.find)(oldItems, function (x) {
                return x.getAttribute("data-value") === newItem.getAttribute("data-value");
            });
        }
        var isDeselect = false;
        if (newItem && oldItem && oldItem === newItem) {
            // Click on a previously selected element -> deselect
            isDeselect = true;
            if (!this._placeholderOption && !multiselect) {
                // If there is no placeholder option, non multiselect options cannot be deselected
                return;
            }
            delete this._lastSelectedOption;
        }
        if (oldItem) {
            // Remove selection on the element
            var oldValue_1 = oldItem.getAttribute("data-value");
            var optElement = (0, _Utils.find)(this.element.options, function (x) {
                return !x.disabled && x.value === oldValue_1;
            });
            if (!optElement) {
                throw new Error("The option with value " + oldValue_1 + " does not exist");
            }
            // Unset Select value
            optElement.selected = false;
            Dom.removeClass(oldItem, CLASS_ITEM_SELECTED);
        }
        if (!isDeselect) {
            // Select an option
            // Select a new item
            var newValue_1 = newItem.getAttribute("data-value");
            var optElement = (0, _Utils.find)(this.element.options, function (x) {
                return !x.disabled && x.value === newValue_1;
            });
            if (!optElement) {
                throw new Error("The option with value " + newValue_1 + " does not exist");
            }
            // Set Select value
            optElement.selected = true;
            Dom.addClass(newItem, CLASS_ITEM_SELECTED);
            // Preserve selection
            this._lastSelectedOption = optElement;
        } else {
            // Deselect an option
            // Keep track of falling back to the placeholder (if any)
            if (this._placeholderOption) {
                this._lastSelectedOption = this._placeholderOption;
            }
        }
        var hasSelectedItems = true;
        if (this._multiselection === false && isDeselect) {
            // Handle no selection for non-multiselect states
            this._placeholderOption.selected = true;
            hasSelectedItems = false;
        }
        if (this._multiselection === true && this._getSelectedOptions().length === 0) {
            hasSelectedItems = false;
        }
        // Reset the filter if filterable
        if (this._activeFilter) {
            this._clearFilter();
        }
        this._updatePlaceholder(hasSelectedItems);
        // Dispatch the changed event
        this.dispatchEvent("change");
        if (autoClose && !multiselect) {
            setTimeout(function () {
                _this.close();
            }, TIMEOUT_CLOSE);
        }
    };
    Select.prototype._updatePlaceholder = function (hasSelectedItems) {
        var e_4, _a;
        var text = this._placeholderOption ? Dom.text(this._placeholderOption) : " ";
        if (hasSelectedItems === true) {
            var selectedItems = this._getSelectedOptions();
            if (selectedItems.length > 0) {
                text = "";
                try {
                    for (var selectedItems_1 = tslib_1.__values(selectedItems), selectedItems_1_1 = selectedItems_1.next(); !selectedItems_1_1.done; selectedItems_1_1 = selectedItems_1.next()) {
                        var item = selectedItems_1_1.value;
                        text += Dom.text(item) + ", ";
                    }
                } catch (e_4_1) {
                    e_4 = { error: e_4_1 };
                } finally {
                    try {
                        if (selectedItems_1_1 && !selectedItems_1_1.done && (_a = selectedItems_1.return)) _a.call(selectedItems_1);
                    } finally {
                        if (e_4) throw e_4.error;
                    }
                }
                text = text.substring(0, text.length - 2);
            }
        }
        this._setPlaceholder(text);
    };
    Select.prototype._getSelectedOptions = function () {
        var selectedOptions = [];
        if (this.element.options) {
            [].forEach.call(this.element.options, function (option) {
                if (option.selected && !option.disabled) {
                    selectedOptions.push(option);
                }
            });
        }
        return selectedOptions;
    };
    /**
     * Clone all of the initially set options (and optgroups) and returns them in a new array.
     * This serves as the basis for filtering. If a filter is present, it will be respected.
     */
    Select.prototype.getInitialOptions = function () {
        var filter = this._activeFilter || "";
        var filtered = [];
        var initialOptions = this._initialOptions;
        for (var i = 0; i < initialOptions.length; i++) {
            var child = initialOptions[i];
            if (this._isOptGroup(child)) {
                // handle <optgroup>
                var optGroupClone = child.cloneNode(false);
                var found = false;
                for (var j = 0; j < child.children.length; j++) {
                    var optionClone = child.children[j].cloneNode(true);
                    // Append on match
                    if (this._containsWord(optionClone.innerHTML, filter)) {
                        optGroupClone.appendChild(optionClone);
                        found = true;
                    }
                }
                // Push if any matches found
                if (found) {
                    filtered.push(optGroupClone);
                }
            } else if (this._isOption(child)) {
                // handle <option>
                var optionClone = child.cloneNode(true);
                // Push on match
                if (this._containsWord(optionClone.innerHTML, filter)) {
                    filtered.push(optionClone);
                }
            }
        }
        return filtered;
    };
    /**
     * Returns true if a text contains a given keyword, e.g. in "ca" in "Car"
     */
    Select.prototype._containsWord = function (text, keyword) {
        return text.toLowerCase().indexOf(keyword.toLowerCase()) > -1;
    };
    Select.prototype._handleFocus = function () {
        var _this = this;
        this.open();
        this._openByFocus = true;
        setTimeout(function () {
            _this._openByFocus = false;
        }, TIMEOUT_BLUR);
    };
    Select.prototype._handleBlur = function () {
        this.close();
    };
    Select.prototype._handleClick = function (event) {
        var handled = false;
        if (this._lastHandledEvent === event) {
            this._lastHandledEvent = undefined;
            return;
        }
        if (this._isButtonTarget(event.target) && this._openByFocus === false) {
            // handle header item clicks and toggle dropdown
            this.toggle();
            handled = true;
        }
        var newItem = event.target;
        if (!handled && Dom.hasClass(newItem, CLASS_ITEM)) {
            // handle clicks on dropdown items
            this._selectedItemChanged(newItem, true, this._multiselection);
            handled = true;
        }
        if (handled) {
            this._lastHandledEvent = event;
            (0, _Utils.preventDefault)(event);
        }
    };
    Select.prototype._handleWindowClick = function (event) {
        if (this._isDropdownTarget(event.target) || this._isButtonTarget(event.target)) {
            return;
        }
        this.close();
    };
    Select.prototype._focusOptionStartingWith = function (keycode, startIndex, options) {
        for (var index = startIndex; index < options.length; index++) {
            var item = new _DomElement2.default(options[index]);
            var value = item.innerText.toLowerCase();
            if (index > options.length) {
                index = 0;
            }
            if (value.startsWith(Inputs.getKeyValue(keycode))) {
                var newOption = new _DomElement2.default(options[index]);
                if (!newOption.hasClass(CLASS_ITEM_DISABLED)) {
                    (0, _Utils.scrollIntoView)(options[index]);
                    newOption.addClass(CLASS_ITEM_FOCUSED);
                    return newOption;
                }
            }
        }
        return undefined;
    };
    Select.prototype._handleKeydown = function (event) {
        var keyboardEvent = event;
        var evt = keyboardEvent || window.event;
        var keycode = keyboardEvent.which || keyboardEvent.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            if (this.isOpen()) {
                this.close();
            }
            evt.preventDefault();
            return;
        }
        if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN) {
            // Up and down arrows
            var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
            if (options.length > 0) {
                var newIndex = 0;
                var oldOption = void 0;
                var focusedElement = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);
                var searchFor = focusedElement ? CLASS_ITEM_FOCUSED : CLASS_ITEM_SELECTED;
                var newElement = void 0;
                for (var index = 0; index < options.length; index++) {
                    var direction = keycode === Inputs.KEY_ARROW_DOWN ? 1 : -1;
                    var item = new _DomElement2.default(options[index]);
                    // search for selected or focusedElement elements
                    if (item.hasClass(searchFor)) {
                        oldOption = item;
                        newIndex = index;
                        // get the next not disabled element in the appropriate direction
                        for (var count = 0; count < options.length; count++) {
                            newIndex += direction;
                            newIndex %= options.length;
                            if (newIndex < 0) {
                                newIndex = options.length - 1;
                            }
                            newElement = new _DomElement2.default(options[newIndex]);
                            if (!newElement.hasClass(CLASS_ITEM_DISABLED)) {
                                break;
                            }
                        }
                    }
                }
                // set the new element focused
                (0, _Utils.scrollIntoView)(options[newIndex]);
                var newOption = new _DomElement2.default(options[newIndex]);
                newOption.addClass(CLASS_ITEM_FOCUSED);
                if (oldOption) {
                    oldOption.removeClass(CLASS_ITEM_FOCUSED);
                }
            }
            evt.preventDefault();
            return;
        }
        if (Inputs.getKeyValue(keycode) && !this._isFilterable()) {
            // Keyboard keys
            var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
            if (options.length > 0) {
                var oldFocusIndex = 0;
                var hasFocusedOption = false;
                for (var index = 0; index < options.length; index++) {
                    var item = new _DomElement2.default(options[index]);
                    if (item.hasClass(CLASS_ITEM_FOCUSED)) {
                        item.removeClass(CLASS_ITEM_FOCUSED);
                        var value = item.innerText.toLowerCase();
                        if (value.startsWith(Inputs.getKeyValue(keycode))) {
                            hasFocusedOption = true;
                            oldFocusIndex = index;
                        }
                    }
                }
                var newOption = this._focusOptionStartingWith(keycode, hasFocusedOption ? oldFocusIndex + 1 : 0, options);
                if (newOption === undefined) {
                    this._focusOptionStartingWith(keycode, 0, options);
                }
            }
            evt.preventDefault();
            return;
        }
        if (keycode === Inputs.KEY_ENTER || keycode === Inputs.KEY_TAB) {
            // Handle enter and tab key by selecting the currently focused element
            var newItem = this._dropdownElement.element.querySelector("." + CLASS_ITEM_FOCUSED);
            this._selectedItemChanged(newItem, true, this._multiselection);
        }
    };
    /**
     * Fired when the user presses a key in the filter field
     */
    Select.prototype._handleFilterKeydown = function (e) {
        var keyboardEvent = e;
        var keycode = keyboardEvent.which || keyboardEvent.keyCode;
        // If the user hits the enter key while filtering and there's a single match, select it
        if (keycode === Inputs.KEY_ENTER) {
            var dropdownElements = this._dropdownElement.element.querySelectorAll("." + CLASS_ITEM);
            if (dropdownElements.length === 1) {
                this._selectedItemChanged(dropdownElements[0], true, this._multiselection);
                e.stopPropagation();
            }
        }
    };
    /**
     * Fired when the user releases a key in the filter field
     */
    Select.prototype._handleFilterKeyup = function (e) {
        var target = e.target;
        // Filter has changed
        if (target.value !== this._activeFilter && target.value !== this._placeholderText && target.value !== this._lastSelectedOption.innerHTML) {
            this._setFilter(target.value);
        }
    };
    /**
     * Fired when the user focusses the filter input field
     */
    Select.prototype._handleFilterFocus = function (e) {
        var target = e.target;
        setTimeout(function () {
            target.select();
        });
    };
    /**
     * Filters the Select by a given filter keyword
     * @param filter Keyword to filter by
     */
    Select.prototype._setFilter = function (filter) {
        if (filter === void 0) {
            filter = "";
        }
        this._activeFilter = filter.length >= this._minFilterLength ? filter : "";
        this.setOptions(this.getInitialOptions());
    };
    /**
     * Resets the filter
     */
    Select.prototype._clearFilter = function () {
        delete this._activeFilter;
        this.setOptions(this.getInitialOptions());
    };
    /**
     * Set new content and reload the Select
     * @param elements Array of new option (or optgroup) elements to display
     */
    Select.prototype.setOptions = function (options) {
        var _this = this;
        this._emptyNode(this.element);
        options.forEach(function (option) {
            _this.element.appendChild(option);
        });
        // Preserve selected value if the selected
        this.element.value = this._lastSelectedOption.value;
        this.reload();
    };
    /**
     * Clear all children of a given node
     * @param node Node
     */
    Select.prototype._emptyNode = function (node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    };
    /**
     * Returns whether an option is a placeholder option
     */
    Select.prototype._isPlaceholder = function (option) {
        return option.hasAttribute("disabled") && option.hasAttribute("selected");
    };
    /**
     * Update placeholder value
     * @param text Content of the placeholder
     */
    Select.prototype._setPlaceholder = function (text) {
        if (this._placeholderElement && text) {
            if (this._isFilterable()) {
                this._placeholderElement.element.value = text;
            } else {
                this._placeholderElement.setHtml(text);
            }
        }
    };
    Object.defineProperty(Select.prototype, "value", {
        /**
         * Gets the value of the currently selected option.
         * If multiple selection is enabled this property returns an array of values.
         */
        get: function get() {
            if (this._multiselection) {
                return this._getSelectedOptions().map(function (x) {
                    return x.value;
                });
            }
            if (this.element.value === "") {
                return null;
            }
            return this.element.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Select.prototype, "disabled", {
        /**
         * Enables or disables the select component depending on the
         * 'value' parameter.
         * @param {value} If true disables the control; false enables it.
         */
        set: function set(value) {
            if (value) {
                this.disable();
            } else {
                this.enable();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reloads the dropdown's option data definitions from the DOM and updates
     * the generated dropdown display items.
     */
    Select.prototype.reload = function () {
        // Remove all existing child elements
        this._emptyNode(this._dropdownElement.element);
        if (this._activeFilter === undefined) {
            // If the user is filtering, let the placeholder "input" alive
            this._setupPlaceholder();
        }
        this._createOptions(this.element);
        this._updateSize();
        this._updateMessage();
        if (!this._isFilterable()) {
            this._updatePlaceholder(!!this.value);
        }
    };
    /**
     * Sets the select control to the enabled state.
     */
    Select.prototype.enable = function () {
        this.element.removeAttribute("disabled");
        this._wrapperElement.removeClass(CLASS_DISABLED);
        window.addEventListener("click", this._windowClickHandler);
        this._wrapperElement.element.addEventListener("click", this._clickHandler);
        this._wrapperElement.element.addEventListener("keydown", this._keydownHandler);
        this._wrapperElement.element.addEventListener("focus", this._focusHandler);
        this._wrapperElement.element.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the select control to the disabled state.
     */
    Select.prototype.disable = function () {
        this.element.setAttribute("disabled", "");
        this._wrapperElement.addClass(CLASS_DISABLED);
        window.removeEventListener("click", this._windowClickHandler);
        this._wrapperElement.element.removeEventListener("click", this._clickHandler);
        this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);
        this._wrapperElement.element.removeEventListener("focus", this._focusHandler);
        this._wrapperElement.element.removeEventListener("blur", this._blurHandler);
        this.close();
    };
    /**
     * Toggles the open/closed state of the select dropdown.
     */
    Select.prototype.toggle = function () {
        if (this.isOpen()) {
            this.close();
        } else {
            this.open();
        }
    };
    /**
     * Gets if the select dropdown is open or closed.
     * @return {boolean} True if open; otherwise false.
     */
    Select.prototype.isOpen = function () {
        return this._wrapperElement.hasClass(CLASS_OPEN);
    };
    /**
     * Opens the select dropdown.
     */
    Select.prototype.open = function () {
        if (!this.isOpen()) {
            this._openByFocus = false;
            this._wrapperElement.removeClass(CLASS_CLOSED);
            this._wrapperElement.addClass(CLASS_OPEN);
            this._dropdownElement.element.addEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.addEventListener("tap", this._handleDropdownClick);
        }
    };
    /**
     * Closes the select dropdown.
     */
    Select.prototype.close = function () {
        if (this.isOpen()) {
            this._openByFocus = false;
            this._wrapperElement.removeClass(CLASS_OPEN);
            this._wrapperElement.addClass(CLASS_CLOSED);
            // If the Select is filterable and therefore has an input field,
            // reset the value of it to the chosen option
            if (this._isFilterable()) {
                // Unfocus input field
                this._placeholderElement.element.blur();
                if (!this._activeFilter || this._activeFilter === this._lastSelectedOption.innerHTML) {
                    this._setPlaceholder(this._lastSelectedOption.innerHTML);
                }
            }
            this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);
            var focusedItem = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);
            if (focusedItem) {
                focusedItem.removeClass(CLASS_ITEM_FOCUSED);
            }
        }
    };
    /**
     * Returns true when the element has the filter modifier class
     */
    Select.prototype._isFilterable = function () {
        return this._wrapperElement.hasClass(CLASS_FILTERABLE);
    };
    /**
     * Destroys the component and clears all references.
     */
    Select.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        if (this._dropdownElement) {
            this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);
            (0, _Utils.remove)(this._dropdownElement.element);
            this._dropdownElement = undefined;
        }
        if (this._placeholderElement) {
            this._placeholderElement.removeEventListener("keydown", this._filterKeydownHandler);
            this._placeholderElement.removeEventListener("keyup", this._filterKeyupHandler);
            this._placeholderElement.removeEventListener("focus", this._filterFocusHandler);
        }
        if (this._wrapperElement) {
            this._wrapperElement.element.removeEventListener("click", this._clickHandler);
            this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);
            this._wrapperElement.element.removeEventListener("focus", this._focusHandler);
            this._wrapperElement.element.removeEventListener("blur", this._blurHandler);
            this._wrapperElement = undefined;
        }
        if (this._selectButtonElement) {
            (0, _Utils.remove)(this._selectButtonElement.element);
            this._selectButtonElement = undefined;
        }
        this.removeClass(CLASS_CLOSED);
    };
    return Select;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("select", function (e) {
        new Select(e);
    });
}
exports.default = Select;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"tslib":113}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _maxSafeInteger = require("babel-runtime/core-js/number/max-safe-integer");

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_TEXTAREA = "textarea";
var CLASS_HAS_VALUE = "is-fixed";
/**
 * Textarea component
 */
var Textarea = /** @class */function (_super) {
    tslib_1.__extends(Textarea, _super);
    function Textarea(element) {
        var _this = _super.call(this, element) || this;
        _this._area = _this.element.querySelector(QUERY_TEXTAREA);
        _this._focusChangedHandler = _this._focusChanged.bind(_this);
        _this._valueChangedHandler = _this._onValueChanged.bind(_this);
        _this._resizeHandler = _this._updateHeight.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the textarea component.
     * @private
     */
    Textarea.prototype._initialize = function () {
        this._minRows = parseInt(this._area.getAttribute("data-min-rows") || "3", 10);
        this._maxRows = parseInt(this._area.getAttribute("data-max-rows"), 10) || _maxSafeInteger2.default;
        // Make sure min an max are property specified
        this._minRows = Math.min(this._minRows, this._maxRows);
        this._maxRows = Math.max(this._minRows, this._maxRows);
        this._lineHeight = parseInt(Dom.css(this._area, "line-height"), 10);
        this._updateBaseHeight = Dom.isHidden(this._area, true);
        this._calculateBaseHeight();
        // add event listeners
        this._area.addEventListener("focus", this._focusChangedHandler);
        this._area.addEventListener("blur", this._focusChangedHandler);
        this._area.addEventListener("input", this._valueChangedHandler);
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
        this._onValueChanged();
    };
    Textarea.prototype._calculateBaseHeight = function () {
        // temporary clear the content to take measurements
        var value = this._area.value;
        this._area.value = "";
        this._baseHeight = this._area.offsetHeight - this._lineHeight;
        this._baseScrollHeight = this._area.scrollHeight - this._lineHeight;
        // restore initial content
        this._area.value = value;
    };
    Textarea.prototype._focusChanged = function () {
        this._updateHeight();
    };
    Textarea.prototype._updateHeight = function () {
        var hasFocus = this._area === document.activeElement;
        var maxRows,
            rows = 0;
        if (this._updateBaseHeight === true && Dom.isHidden(this._area, true) === false) {
            this._calculateBaseHeight();
            this._updateBaseHeight = false;
        }
        // Calculate the apropriate size for the control
        if (!this._hasValue()) {
            // Handle empty states
            rows = hasFocus === true ? this._minRows : 1;
            maxRows = rows;
        } else {
            // Reset the height for calculation of the row count
            this._area.style.height = "auto";
            // Get the new height
            rows = Math.ceil((this._area.scrollHeight - this._baseScrollHeight) / this._lineHeight) + 1;
            maxRows = Math.max(Math.min(this._maxRows, rows), this._minRows);
        }
        if (rows > this._maxRows) {
            this._area.style.overflow = "auto";
        } else {
            this._area.style.overflow = "hidden";
        }
        var height = (maxRows - 1) * this._lineHeight + this._baseHeight;
        this._area.style.height = height + "px";
    };
    Textarea.prototype._hasValue = function () {
        return this._area.value && this._area.value.length > 0;
    };
    Textarea.prototype._onValueChanged = function () {
        if (this._hasValue()) {
            Dom.addClass(this._area, CLASS_HAS_VALUE);
        } else {
            Dom.removeClass(this._area, CLASS_HAS_VALUE);
            this._area.value = "";
        }
        this._updateHeight();
    };
    /**
     * Destroys the component and clears all references.
     */
    Textarea.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this._area.removeEventListener("focus", this._focusChangedHandler);
        this._area.removeEventListener("blur", this._focusChangedHandler);
        this._area.removeEventListener("input", this._valueChangedHandler);
        this._focusChangedHandler = null;
        this._valueChangedHander = null;
        this._area = null;
        this._minRows = null;
        this._maxRows = null;
        this._lineHeight = null;
        this._baseHeight = null;
        this._baseScrollHeight = null;
        this.element = null;
    };
    return Textarea;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".input-multiline, .input-field--multiline", function (e) {
        new Textarea(e);
    });
}
exports.default = Textarea;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"babel-runtime/core-js/number/max-safe-integer":39,"tslib":113}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Loader bar component
 */
var LoaderBar = /** @class */function (_super) {
    tslib_1.__extends(LoaderBar, _super);
    /**
     * Creates and initializes the LoaderBar component.
     * @param {Element} - The root element of the LoaderBar component.
     */
    function LoaderBar(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    LoaderBar.prototype._initialize = function () {
        this.progressElement = this.find(".indicator") || this;
        this.fileNameElement = this.find(".detail > .name");
        this.progressLabelElement = this.find(".progress");
        this.totalProgressElement = this.find(".progress > .file-size");
    };
    Object.defineProperty(LoaderBar.prototype, "progress", {
        /**
         * Gets the current progress value in the range of 0..1.
         */
        get: function get() {
            return this.value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 0..1.
         */
        set: function set(val) {
            // val = clamp(val, 0, 1)
            var percentage = (val * 100).toFixed(0);
            this.value = val;
            this.element.value = String(val);
            this.progressElement.setAttribute("style", "width: " + val * 100 + "%");
            if (this.progressLabelElement) {
                this.progressLabelElement.element.textContent = percentage + "%";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderBar.prototype, "filename", {
        /**
         * Gets the filename.
         * @returns {string} - The filename.
         */
        get: function get() {
            if (!this.fileNameElement) {
                return undefined;
            }
            return this.fileNameElement.element.innerHTML;
        },
        /**
         * Sets the filename.
         */
        set: function set(val) {
            if (!this.fileNameElement) {
                throw new Error("Cannot set the filename, missing detail element");
            }
            this.fileNameElement.setHtml(val || "");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderBar.prototype, "fileSize", {
        /**
         * Sets the file size label.
         */
        set: function set(val) {
            if (!this.totalProgressElement) {
                throw new Error("Cannot set the fileSize, missing detail element");
            }
            this.totalProgressElement.setHtml(val);
        },
        enumerable: true,
        configurable: true
    });
    return LoaderBar;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".loader-bar", function (e) {
        new LoaderBar(e);
    });
}
exports.default = LoaderBar;

},{"../DomElement":5,"../Utils":8,"tslib":113}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _popper = require("popper.js");

var _popper2 = _interopRequireDefault(_popper);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_MENU = "js-flyout";
var CLASS_TABS = "tabs";
var ANIMATION_OPEN = 300;
/**
 * A component for the flyout menu.
 */
var MenuFlyout = /** @class */function (_super) {
    tslib_1.__extends(MenuFlyout, _super);
    /**
     * Creates and initializes the flyout component.
     * @param element - The root element of the flyout menu component.
     */
    function MenuFlyout(element) {
        var _this = _super.call(this, element) || this;
        _this._animationDuration = ANIMATION_OPEN;
        _this._dynamicPlacement = false;
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the flyout component.
     * @private
     */
    MenuFlyout.prototype._initialize = function () {
        var dataTarget = this.element.getAttribute("data-target");
        if (dataTarget === null || dataTarget === "") {
            /* tslint:disable:no-console */
            console.error("A flyout menu element requires a 'data-target' that specifies the element to collapse");
            console.info(this.element);
            /* tslint:enable:no-console */
            return;
        }
        if (this._useDynamicPlacement()) {
            this._dynamicPlacement = true;
        }
        var hiddenTarget = this.element.getAttribute("data-hidden");
        if (hiddenTarget !== null && hiddenTarget !== "") {
            this._hiddenIndicator = document.querySelector(hiddenTarget) || undefined;
        }
        this._initFlyoutElement(dataTarget);
        this.element.addEventListener("click", this._clickHandler);
    };
    MenuFlyout.prototype._initFlyoutElement = function (dataTarget) {
        this._flyoutElement = document.querySelector(dataTarget);
        this._flyoutElement.style.opacity = "0";
        this._flyoutElement.style.transform = "translateY(-20px)";
    };
    MenuFlyout.prototype._handleClick = function () {
        this.toggle();
    };
    MenuFlyout.prototype._handleWindowClick = function (event) {
        var target = event.target;
        if ((0, _DomFunctions.parentWithClass)(target, CLASS_MENU) === this._flyoutElement) {
            return false;
        }
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    MenuFlyout.prototype._useDynamicPlacement = function () {
        return (0, _DomFunctions.parentWithClass)(this.element, CLASS_TABS);
    };
    MenuFlyout.prototype._openMenu = function (el) {
        _animejs2.default.remove(el);
        if (this._dynamicPlacement === true) {
            var popperOptions = {
                placement: "bottom",
                modifiers: {
                    flip: {
                        enabled: false
                    }
                },
                eventsEnabled: false
            };
            this._popperInstance = new _popper2.default(this.element, this._flyoutElement, popperOptions);
        }
        (0, _animejs2.default)({
            targets: el,
            duration: this._animationDuration,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            opacity: 1,
            translateY: "0px",
            begin: function begin() {
                el.style.display = "block";
            },
            complete: function complete() {
                (0, _DomFunctions.addClass)(el, CLASS_OPEN);
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "true");
        this.dispatchEvent("opened");
    };
    MenuFlyout.prototype._closeMenu = function (el) {
        _animejs2.default.remove(el);
        if (this._popperInstance) {
            this._popperInstance.destroy();
            this._popperInstance = undefined;
        }
        (0, _animejs2.default)({
            targets: el,
            duration: this._animationDuration,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            opacity: 0,
            translateY: "-20px",
            complete: function complete() {
                el.style.display = "none";
                (0, _DomFunctions.removeClass)(el, CLASS_OPEN);
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "false");
        this.dispatchEvent("closed");
    };
    Object.defineProperty(MenuFlyout.prototype, "animationDuration", {
        /**
         * Sets the opening animation duration.
         * @param {durationInSeconds} - The animation duration in seconds.
         */
        set: function set(durationInSeconds) {
            this._animationDuration = durationInSeconds;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens the flyout menu.
     * @fires Modal#opened
     */
    MenuFlyout.prototype.open = function () {
        var _this = this;
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === true) {
            return;
        }
        (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
        this._openMenu(this._flyoutElement);
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
        }, 50);
    };
    /**
     * Closes the flyout menu.
     * @fires Modal#closed
     */
    MenuFlyout.prototype.close = function () {
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            return;
        }
        (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        this._closeMenu(this._flyoutElement);
    };
    /**
     * Toggles the flyout menu.
     * @fires Modal#opened
     * @fires Modal#closed
     */
    MenuFlyout.prototype.toggle = function () {
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            this.open();
        } else {
            this.close();
        }
    };
    /**
     * Removes all event handlers and clears references.
     */
    MenuFlyout.prototype.destroy = function () {
        this._flyoutElement = null;
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        if (this._clickHandler) {
            this.element.removeEventListener("click", this._clickHandler);
        }
        if (this._popperInstance) {
            this._popperInstance.destroy();
            this._popperInstance = undefined;
        }
        this._clickHandler = null;
        this._windowClickHandler = null;
        this.element = null;
    };
    return MenuFlyout;
}(_DomElement2.default);
function init() {
    var e_1, _a;
    var elements = document.querySelectorAll("[data-toggle='flyout']");
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            if (e.getAttribute("data-init") === "auto") {
                new MenuFlyout(e);
            }
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
}
exports.default = MenuFlyout;

},{"../DomElement":5,"../DomFunctions":6,"animejs":34,"popper.js":112,"tslib":113}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _bodyScrollLock = require("body-scroll-lock");

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BACKDROP = "backdrop";
var CLASS_BACKDROP_OPEN = "backdrop--open";
var CLASS_OPEN = "modal--open";
var CLASS_TRIGGER = "modal-trigger";
var CLASS_BODY = "modal__body";
var CLASS_BUTTONS_OKAY = ".modal-close";
var CLASS_BUTTONS_CLOSE = ".modal-cancel";
/**
 * A component to open and close modal dialogs. It also handles cancellation and makes
 * sure that the modal background is present in the DOM.
 */
var Modal = /** @class */function (_super) {
    tslib_1.__extends(Modal, _super);
    function Modal(element) {
        var _this = _super.call(this, element) || this;
        _this._okayHandler = _this.close.bind(_this);
        _this._cancelHandler = _this._handleClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the range modal component.
     * @private
     */
    Modal.prototype._initialize = function () {
        // Create the backdrop
        this._backdrop = new _DomElement2.default("div").addClass(CLASS_BACKDROP);
        this._backdropParent = (0, _DomFunctions.getRootElement)();
        this._subscribeToTrigger();
    };
    Modal.prototype._subscribeToTrigger = function () {
        var e_1, _a;
        var triggerId = this.element.id;
        if (!triggerId) {
            return;
        }
        this._triggerClickHandler = this.open.bind(this);
        var triggerElements = document.querySelectorAll("." + CLASS_TRIGGER + "[href=" + triggerId + "]");
        try {
            for (var triggerElements_1 = tslib_1.__values(triggerElements), triggerElements_1_1 = triggerElements_1.next(); !triggerElements_1_1.done; triggerElements_1_1 = triggerElements_1.next()) {
                var triggerElement = triggerElements_1_1.value;
                triggerElement.addEventListener("click", this._triggerClickHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (triggerElements_1_1 && !triggerElements_1_1.done && (_a = triggerElements_1.return)) _a.call(triggerElements_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Modal.prototype._unsubscribeFromTrigger = function () {
        var e_2, _a;
        var triggerId = this.element.id;
        if (!triggerId) {
            return;
        }
        var triggerElements = document.querySelectorAll("." + CLASS_TRIGGER + "[href=" + triggerId + "]");
        try {
            for (var triggerElements_2 = tslib_1.__values(triggerElements), triggerElements_2_1 = triggerElements_2.next(); !triggerElements_2_1.done; triggerElements_2_1 = triggerElements_2.next()) {
                var triggerElement = triggerElements_2_1.value;
                triggerElement.removeEventListener("click", this._windowClickHandler);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (triggerElements_2_1 && !triggerElements_2_1.done && (_a = triggerElements_2.return)) _a.call(triggerElements_2);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._triggerClickHandler = undefined;
    };
    Modal.prototype._handleKeydown = function (event) {
        var keyboardEvent = event;
        var keycode = keyboardEvent.which || keyboardEvent.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            this.cancel();
            return;
        }
    };
    Modal.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.cancel();
    };
    Modal.prototype._close = function () {
        var e_3, _a, e_4, _b;
        var _this = this;
        (0, _bodyScrollLock.enableBodyScroll)(this.element);
        document.removeEventListener("keydown", this._keydownHandler);
        this._backdrop.element.removeEventListener("click", this._cancelHandler);
        this._backdrop.removeClass(CLASS_BACKDROP_OPEN);
        this.removeClass(CLASS_OPEN);
        try {
            for (var _c = tslib_1.__values(this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var closeButton = _d.value;
                closeButton.removeEventListener("click", this._cancelHandler);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        try {
            for (var _e = tslib_1.__values(this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var okayButton = _f.value;
                okayButton.removeEventListener("click", this._okayHandler);
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        setTimeout(function () {
            // remove the backdrop from the body
            _this._backdropParent.removeChild(_this._backdrop.element);
        }, 300);
    };
    /**
     * Opens the modal dialog.
     * @fires Modal#opened
     */
    Modal.prototype.open = function () {
        var _this = this;
        (0, _bodyScrollLock.disableBodyScroll)(this.element, {
            allowTouchMove: function allowTouchMove(el) {
                var currentEl = el;
                while (currentEl && currentEl !== document.body) {
                    // Check if the user is scrolling the modal body
                    if (currentEl.classList.contains(CLASS_BODY)) {
                        // Check if the element overflows
                        if (currentEl.scrollHeight > currentEl.clientHeight) {
                            return true;
                        }
                    }
                    currentEl = currentEl.parentNode;
                }
                return false;
            }
        });
        // add the backdrop to the body
        this._backdropParent.appendChild(this._backdrop.element);
        // set the element to flex as it is initially hidden
        this.element.style.display = "flex";
        // remove the style after the animation completes
        setTimeout(function () {
            _this.element.style.display = "";
        }, 800);
        // wait a bit to allow the browser to catch up and show the animation
        setTimeout(function () {
            var e_5, _a, e_6, _b;
            _this.addClass(CLASS_OPEN);
            _this._backdrop.addClass(CLASS_BACKDROP_OPEN);
            document.addEventListener("keydown", _this._keydownHandler);
            _this._backdrop.element.addEventListener("click", _this._cancelHandler);
            try {
                for (var _c = tslib_1.__values(_this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var closeButton = _d.value;
                    closeButton.addEventListener("click", _this._cancelHandler);
                }
            } catch (e_5_1) {
                e_5 = { error: e_5_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_5) throw e_5.error;
                }
            }
            try {
                for (var _e = tslib_1.__values(_this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var okayButton = _f.value;
                    okayButton.addEventListener("click", _this._okayHandler);
                }
            } catch (e_6_1) {
                e_6 = { error: e_6_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                    if (e_6) throw e_6.error;
                }
            }
            _this.element.addEventListener("click", function (e) {
                return e.stopPropagation();
            });
            _this.dispatchEvent("opened");
        }, 50);
    };
    /**
     * Cancels (and closes) the modal dialog.
     * @fires Modal#cancelled
     * @fires Modal#closed
     */
    Modal.prototype.cancel = function () {
        this.dispatchEvent("cancelled");
        this._close();
    };
    /**
     * Closes the modal dialog.
     * @fires Modal#closed
     */
    Modal.prototype.close = function () {
        this._close();
        this.dispatchEvent("closed");
    };
    /**
     * Destroys the component and frees all references.
     */
    Modal.prototype.destroy = function () {
        this.cancel();
        this._unsubscribeFromTrigger();
    };
    return Modal;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".modal", function (e) {
        new Modal(e);
    });
}
exports.default = Modal;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"body-scroll-lock":41,"tslib":113}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

var _SearchInput = require("../search/SearchInput");

var _SearchInput2 = _interopRequireDefault(_SearchInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";
var QUERY_NAV_HAMBURGER = ".nav-hamburger";
var QUERY_NAV_HB_BODY = ".nav__primary";
var CLASS_NAV_LINK = "nav-link--header";
var QUERY_NAV_LINK_ACTIVE = ".nav-link--header.is-active";
var QUERY_NAV_MOBILE = ".nav__level1 .nav__mainnav .nav__primary";
var QUERY_NAV_LEVEL0 = ".nav__level0";
var QUERY_NAV_LEVEL0_CONTAINER = ".nav__level0 .nav__subnav";
var QUERY_SECTION_OPEN = ".nav-section.is-open";
var QUERY_NAV_LEVEL1 = ".nav__level1 .nav__mainnav";
var QUERY_NAV_LEVEL0_LINK = ".nav-link.nav-link--header";
var QUERY_NAV_LEVEL1_LINK = ".nav-link--header";
var QUERY_NAV_COLUMN = ".nav-col";
var QUERY_NAV_COLUMN_ACTIVE = ".nav-col.is-active";
var QUERY_NAV_BODY = ".nav-body";
var QUERY_NAV_FOOTER = ".nav-footer";
var QUERY_SEARCH_ICON = ".nav-search";
var QUERY_SEARCH_FIELD = ".search__input";
var CLASS_SEARCH_DESKTOP = "search--desktop";
var ANIMATION_START_DELAY = 200;
var ANIMATION_OFFSET = 50;
var ANIMATION_BODY_DURATION = 300;
var ANIMATION_FOOTER_DURATION = 100;
/**
 * The navigation component definition.
 */
var Navigation = /** @class */function (_super) {
    tslib_1.__extends(Navigation, _super);
    function Navigation(element) {
        var _this = _super.call(this, element) || this;
        _this.animation = _animejs2.default.timeline();
        _this._navLevel0 = _this.element.querySelector(QUERY_NAV_LEVEL0) || document.createElement("div");
        _this._navLevel0Body = _this.element.querySelector(QUERY_NAV_LEVEL0_CONTAINER) || document.createElement("div");
        _this._navLevel1 = _this.element.querySelector(QUERY_NAV_LEVEL1) || document.createElement("div");
        _this._navMobile = _this.element.querySelector(QUERY_NAV_MOBILE) || document.createElement("div");
        if (!_this._navMobile.parentElement) {
            var dummyParent = document.createElement("div");
            dummyParent.appendChild(_this._navMobile);
        }
        _this._hamburgerElement = _this.element.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
        _this._searchComponents = [];
        _this._level0ClickHandler = _this._handleLevel0Click.bind(_this);
        _this._level1ClickHandler = _this._handleLevel1Click.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._searchClickHandler = _this._handleSearchClick.bind(_this);
        _this._initialize();
        return _this;
    }
    Navigation.prototype._resetMainTimeline = function () {
        var e_1, _a;
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i] = arguments[_i];
        }
        this.animation.pause();
        try {
            for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
                var el = elements_1_1.value;
                _animejs2.default.remove(el);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this.animation = _animejs2.default.timeline();
    };
    Navigation.prototype._isMobile = function () {
        return Dom.isHidden(this._hamburgerElement, true) === false;
    };
    Navigation.prototype._handleLevel0Click = function (event) {
        var isDesktop = !this._isMobile();
        if (isDesktop) {
            var navItems = new NavigationItems(this).fromLevel0(event.target);
            if (!navItems.section) {
                return;
            }
            var previousNavLink = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);
            var previousNavSection = this._navLevel0.querySelector(QUERY_SECTION_OPEN);
            this._toggleContainer(navItems.link, this._navLevel0Body, navItems.section, undefined, previousNavLink, this._navLevel0Body, previousNavSection, undefined, true);
        }
    };
    Navigation.prototype._handleLevel1Click = function (event) {
        var navItems = new NavigationItems(this).fromLevel1(event.target);
        var prevItems = navItems.previousLevel1();
        this._toggleContainer(navItems.link, navItems.container, navItems.section, navItems.footer, prevItems.link, prevItems.container, prevItems.section, prevItems.footer, false);
        return false;
    };
    Navigation.prototype._toggleContainer = function (navLink, navContainer, navSection, navFooter, previousNavLink, previousNavContainer, previousNavSection, previousNavFooter, animateContainer) {
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        var isDesktop = !this._isMobile();
        if (previousNavLink && previousNavLink !== navLink && navLink !== this._hamburgerElement) {
            Dom.removeClass(previousNavLink, CLASS_ACTIVE);
        }
        this._resetMainTimeline(navContainer, navSection, navFooter, previousNavContainer, previousNavSection, previousNavFooter);
        if (Dom.hasClass(navLink, CLASS_ACTIVE)) {
            Dom.removeClass(navLink, CLASS_ACTIVE);
            if (isDesktop) {
                this._onNavigationClosed();
                this._closeSection(navContainer, navSection, navFooter, true, animateContainer);
            } else if (navLink === this._hamburgerElement) {
                // Close mobile navigation
                this._onNavigationClosed();
                this._closeSection(navContainer, navSection, undefined, false, false);
            } else if (!isDesktop) {
                // Close the section
                this._closeSection(navContainer, navSection, navFooter, true, animateContainer);
            }
        } else {
            Dom.addClass(navLink, CLASS_ACTIVE);
            if (isDesktop) {
                Dom.addClass(this._navMobile, CLASS_OPEN);
                this._onNavigationOpened();
                if (previousNavContainer && previousNavSection) {
                    this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, true, animateContainer);
                }
                this._openSection(navContainer, navSection, navFooter, true, animateContainer);
            } else if (navLink === this._hamburgerElement) {
                // Open mobile navigation
                this._onNavigationOpened();
                this._openSection(navContainer, navSection, undefined, false, false);
            } else if (!isDesktop) {
                // Open section
                if (previousNavContainer && previousNavSection) {
                    this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, true, animateContainer);
                    this.animation = _animejs2.default.timeline();
                }
                this._openSection(navContainer, navSection, navFooter, true, animateContainer);
            }
        }
    };
    Navigation.prototype._onNavigationOpened = function () {
        Dom.addClass(this._navMobile, CLASS_OPEN);
        Dom.addClass(this._navMobile.parentElement, CLASS_OPEN);
        Dom.addClass(this._hamburgerElement, CLASS_ACTIVE);
        window.addEventListener("click", this._windowClickHandler);
        window.addEventListener("touchend", this._windowClickHandler);
    };
    Navigation.prototype._onNavigationClosed = function () {
        Dom.removeClass(this._navMobile, CLASS_OPEN);
        Dom.removeClass(this._navMobile.parentElement, CLASS_OPEN);
        Dom.removeClass(this._hamburgerElement, CLASS_ACTIVE);
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
    };
    Navigation.prototype._handleWindowClick = function (event) {
        var target = event.target;
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    Navigation.prototype._openSection = function (navContainer, navSection, navFooter, animateColumns, animateContainer) {
        var e_2, _a, e_3, _b;
        if (animateColumns === void 0) {
            animateColumns = true;
        }
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        if (!navSection || !navContainer) {
            return;
        }
        var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN);
        if (animateContainer === true) {
            var container = navContainer;
            navContainer = navSection;
            navSection = container;
        }
        Dom.addClass(navContainer, CLASS_OPEN);
        navSection.style.display = "block";
        this.animation.add({
            targets: navSection,
            duration: ANIMATION_BODY_DURATION,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            height: animateContainer ? navContainer.scrollHeight : navSection.scrollHeight,
            complete: function complete() {
                Dom.addClass(navSection, CLASS_OPEN);
                new _DomElement2.default(navSection).setAttribute("style", "");
            }
        });
        if (navFooter) {
            var navItems = navFooter.querySelectorAll(QUERY_NAV_COLUMN);
            try {
                for (var navItems_1 = tslib_1.__values(navItems), navItems_1_1 = navItems_1.next(); !navItems_1_1.done; navItems_1_1 = navItems_1.next()) {
                    var item = navItems_1_1.value;
                    Dom.addClass(item, CLASS_ACTIVE);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (navItems_1_1 && !navItems_1_1.done && (_a = navItems_1.return)) _a.call(navItems_1);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
            navFooter.style.display = "block";
            this.animation.add({
                targets: navFooter,
                duration: ANIMATION_FOOTER_DURATION,
                easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
                height: navFooter.scrollHeight,
                offset: "-=" + ANIMATION_FOOTER_DURATION,
                complete: function complete() {
                    Dom.addClass(navFooter, CLASS_OPEN);
                    new _DomElement2.default(navFooter).setAttribute("style", "");
                }
            });
        }
        if (animateColumns === true) {
            var delay = ANIMATION_START_DELAY;
            var _loop_1 = function _loop_1(item) {
                this_1.animation.add({
                    targets: item,
                    duration: 0,
                    offset: delay,
                    complete: function complete() {
                        Dom.addClass(item, CLASS_ACTIVE);
                    }
                });
                delay += ANIMATION_OFFSET;
            };
            var this_1 = this;
            try {
                for (var activeItems_1 = tslib_1.__values(activeItems), activeItems_1_1 = activeItems_1.next(); !activeItems_1_1.done; activeItems_1_1 = activeItems_1.next()) {
                    var item = activeItems_1_1.value;
                    _loop_1(item);
                }
            } catch (e_3_1) {
                e_3 = { error: e_3_1 };
            } finally {
                try {
                    if (activeItems_1_1 && !activeItems_1_1.done && (_b = activeItems_1.return)) _b.call(activeItems_1);
                } finally {
                    if (e_3) throw e_3.error;
                }
            }
        }
    };
    Navigation.prototype._closeSection = function (navContainer, navSection, navFooter, animateColumns, animateContainer) {
        var e_4, _a, e_5, _b;
        if (animateColumns === void 0) {
            animateColumns = true;
        }
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        if (!navSection || !navContainer) {
            return;
        }
        var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE);
        if (animateContainer === true) {
            var container = navContainer;
            navContainer = navSection;
            navSection = container;
        }
        if (animateColumns === true) {
            try {
                for (var activeItems_2 = tslib_1.__values(activeItems), activeItems_2_1 = activeItems_2.next(); !activeItems_2_1.done; activeItems_2_1 = activeItems_2.next()) {
                    var active = activeItems_2_1.value;
                    Dom.removeClass(active, CLASS_ACTIVE);
                }
            } catch (e_4_1) {
                e_4 = { error: e_4_1 };
            } finally {
                try {
                    if (activeItems_2_1 && !activeItems_2_1.done && (_a = activeItems_2.return)) _a.call(activeItems_2);
                } finally {
                    if (e_4) throw e_4.error;
                }
            }
        }
        this.animation.add({
            targets: navSection,
            duration: ANIMATION_BODY_DURATION,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            height: 0,
            offset: 0,
            complete: function complete() {
                Dom.removeClass(navContainer, CLASS_OPEN);
                Dom.removeClass(navSection, CLASS_OPEN);
                navSection.style.height = "";
            }
        });
        if (navFooter) {
            try {
                for (var _c = tslib_1.__values(navFooter.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var active = _d.value;
                    Dom.removeClass(active, CLASS_ACTIVE);
                }
            } catch (e_5_1) {
                e_5 = { error: e_5_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                } finally {
                    if (e_5) throw e_5.error;
                }
            }
            this.animation.add({
                targets: navFooter,
                duration: ANIMATION_FOOTER_DURATION,
                easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
                height: 0,
                offset: 0,
                complete: function complete() {
                    Dom.removeClass(navFooter, CLASS_OPEN);
                    navFooter.style.height = "";
                }
            });
        }
    };
    Navigation.prototype._handleSearchClick = function () {
        if (this._searchDesktop) {
            this._searchDesktop.open();
        }
    };
    /**
     * Initializes the navigation component.
     * @private
     */
    Navigation.prototype._initialize = function () {
        var e_6, _a, e_7, _b, e_8, _c;
        try {
            for (var _d = tslib_1.__values(this._navLevel0.querySelectorAll(QUERY_NAV_LEVEL0_LINK)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var navLink = _e.value;
                navLink.addEventListener("click", this._level0ClickHandler);
            }
        } catch (e_6_1) {
            e_6 = { error: e_6_1 };
        } finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            } finally {
                if (e_6) throw e_6.error;
            }
        }
        try {
            for (var _f = tslib_1.__values(this._navLevel1.querySelectorAll(QUERY_NAV_LEVEL1_LINK)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var navLink = _g.value;
                navLink.addEventListener("click", this._level1ClickHandler);
            }
        } catch (e_7_1) {
            e_7 = { error: e_7_1 };
        } finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            } finally {
                if (e_7) throw e_7.error;
            }
        }
        this._hamburgerElement.addEventListener("click", this._level1ClickHandler);
        // Desktop search icon
        var searchIcon = this.element.querySelector(QUERY_SEARCH_ICON);
        if (searchIcon) {
            searchIcon.addEventListener("click", this._searchClickHandler);
        }
        try {
            for (var _h = tslib_1.__values(this.element.querySelectorAll(QUERY_SEARCH_FIELD)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var search = _j.value;
                var searchComponent = new _SearchInput2.default(search);
                if (Dom.hasClass(search, CLASS_SEARCH_DESKTOP) || Dom.hasClass(search.parentElement, CLASS_SEARCH_DESKTOP)) {
                    this._searchDesktop = searchComponent;
                }
                this._searchComponents.push(searchComponent);
            }
        } catch (e_8_1) {
            e_8 = { error: e_8_1 };
        } finally {
            try {
                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            } finally {
                if (e_8) throw e_8.error;
            }
        }
    };
    /**
     * Closes the navigation.
     */
    Navigation.prototype.close = function () {
        var isMoble = this._isMobile();
        var level1 = this._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
        var level0 = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);
        if (!level1 && isMoble && Dom.hasClass(this._hamburgerElement, CLASS_ACTIVE)) {
            level1 = this._hamburgerElement;
        }
        var navItems;
        if (level1) {
            navItems = new NavigationItems(this).fromLevel1(level1);
        } else if (level0) {
            navItems = new NavigationItems(this).fromLevel0(level0);
        }
        if (navItems) {
            this._resetMainTimeline(navItems.container, navItems.section, navItems.footer);
            Dom.removeClass(navItems.link, CLASS_ACTIVE);
            this._onNavigationClosed();
            this._closeSection(navItems.container, navItems.section, navItems.footer, !isMoble, false);
        }
    };
    return Navigation;
}(_DomElement2.default);
var NavigationItems = /** @class */function () {
    function NavigationItems(nav) {
        this._navigation = nav;
    }
    Object.defineProperty(NavigationItems.prototype, "link", {
        get: function get() {
            return this._link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "container", {
        get: function get() {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "section", {
        get: function get() {
            return this._section;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "footer", {
        get: function get() {
            return this._footer;
        },
        enumerable: true,
        configurable: true
    });
    NavigationItems.prototype.fromLevel0 = function (navLink) {
        while (!Dom.hasClass(navLink, CLASS_NAV_LINK) && navLink.parentElement) {
            navLink = navLink.parentElement;
        }
        this._link = navLink;
        var toggleId = navLink.getAttribute("data-toggle");
        this._container = this._navigation._navLevel0Body;
        this._section = this._navigation._navLevel0.querySelector("#" + toggleId);
        return this;
    };
    NavigationItems.prototype.fromLevel1 = function (navLink) {
        while (navLink.parentElement) {
            if (navLink === this._navigation._hamburgerElement || Dom.hasClass(navLink, CLASS_NAV_LINK)) {
                break;
            }
            navLink = navLink.parentElement;
        }
        this._link = navLink;
        this._container = navLink.parentElement;
        this._section = this._container.querySelector(QUERY_NAV_BODY);
        this._footer = this._container.querySelector(QUERY_NAV_FOOTER);
        if (navLink === this._navigation._hamburgerElement) {
            this._container = this._navigation._navLevel1;
            this._section = this._container.querySelector(QUERY_NAV_HB_BODY);
        }
        return this;
    };
    NavigationItems.prototype.previousLevel1 = function () {
        var prev = new NavigationItems(this._navigation);
        prev._link = this._navigation._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
        prev._container = prev._link ? prev._link.parentElement : undefined;
        prev._section = prev._container ? prev._container.querySelector(QUERY_NAV_BODY) : undefined;
        prev._footer = prev._container ? prev._container.querySelector(QUERY_NAV_FOOTER) : undefined;
        return prev;
    };
    NavigationItems.prototype.isHamburger = function () {
        return this._link === this._navigation._hamburgerElement;
    };
    return NavigationItems;
}();
function init() {
    (0, _Utils.searchAndInitialize)(".nav", function (e) {
        new Navigation(e);
    });
}
exports.default = Navigation;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"../search/SearchInput":31,"animejs":34,"tslib":113}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomFunctions = require("../DomFunctions");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";
var QUERY_SITE_WRAPPER = ".js-site-wrapper";
var QUERY_NAV_HAMBURGER = ".js-site-wrapper .js-hamburger";
var QUERY_NAV_ITEM = ".js-nav-item";
var NAV_LINK_INITIAL_SCALE = 0.9;
var ANIMATION_DURATION_LINKS = 100;
var ANIMATION_DURATION_NAV = 300;
var ANIMATION_STAGGER_DELAY = 50;
/**
 * The navigation side component definition.
 */
var NavigationSide = /** @class */function (_super) {
    tslib_1.__extends(NavigationSide, _super);
    function NavigationSide(element) {
        var _this = _super.call(this, element) || this;
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._siteWrapper = document.querySelector(QUERY_SITE_WRAPPER);
        _this._hamburgerElement = document.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
        _this._navItems = _this.element.querySelectorAll(QUERY_NAV_ITEM);
        _this._initialize();
        return _this;
    }
    NavigationSide.prototype._initialize = function () {
        this._hamburgerElement.addEventListener("click", this._clickHandler);
        this._hamburgerElement.addEventListener("touchend", this._clickHandler);
    };
    NavigationSide.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.toggle();
    };
    NavigationSide.prototype._handleWindowClick = function (event) {
        var target = event.target;
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    /**
     * Toggles the side navigation.
     */
    NavigationSide.prototype.toggle = function () {
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            this.open();
        } else {
            this.close();
        }
    };
    /**
     * Opens the slide navigation.
     */
    NavigationSide.prototype.open = function () {
        var _this = this;
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
        }, 50);
        (0, _DomFunctions.addClass)(this._hamburgerElement, CLASS_ACTIVE);
        (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
        (0, _DomFunctions.addClass)(this._siteWrapper, CLASS_OPEN);
        var x = _animejs2.default.timeline();
        var off = ANIMATION_DURATION_NAV;
        this._navItems.forEach(function (element) {
            var el = element;
            el.style.opacity = "0";
            el.style.transform = "scale(" + NAV_LINK_INITIAL_SCALE + ")";
            x.add({
                targets: el,
                duration: ANIMATION_DURATION_LINKS,
                opacity: 1,
                scale: 1,
                easing: "linear",
                offset: off
            });
            off += ANIMATION_STAGGER_DELAY;
        });
    };
    /**
     * Closes the side navigation.
     */
    NavigationSide.prototype.close = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        (0, _DomFunctions.removeClass)(this._hamburgerElement, CLASS_ACTIVE);
        (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
        (0, _DomFunctions.removeClass)(this._siteWrapper, CLASS_OPEN);
    };
    /**
     * Destroys the component and removes all event
     * subscriptions and references.
     */
    NavigationSide.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        this._windowClickHandler = null;
        this._clickHandler = null;
        this._siteWrapper = null;
        this._hamburgerElement = null;
        this._navItems = null;
    };
    return NavigationSide;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".nav-side", function (e) {
        new NavigationSide(e);
    });
}
exports.default = NavigationSide;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":34,"tslib":113}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NotificationHeader = undefined;
exports.showOnHeader = showOnHeader;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_NOTIFICATION = "notification-header";
var CLASS_OPEN = "notification--open";
var CLASS_BUTTON_CLOSE = "notification__close";
/**
 * Creates and shows a notification with the specified message.
 * @memberof Notification
 * @param {String} containerId - The id of the container on where to show the notification.
 * @param {String} message - The message to show.
 * @param {Notification~Click} messageClickCallback - The callback that gets called when the user clicks on the notification message text.
 * @param {Notification~Cancel} cancelCallback - The callback that gets called when the user cancels the notification by closing it.
 * @param {String} modifierClass - The css modifier class for the notification; this is an optional parameter
 * @returns {NotificationHeader} The notification header item instance.
 */
function showOnHeader(containerId, message, messageClickCallback, cancelCallback, modifierClass) {
    var containerE = document.querySelector("#" + containerId);
    if (!containerE) {
        throw new Error("Could not find the container with id " + containerId);
    }
    var containerElement = new _DomElement2.default(containerE);
    var notificationElement = new NotificationHeader();
    if (modifierClass) {
        notificationElement.addClass(modifierClass);
    }
    notificationElement.message = message;
    notificationElement.messageClickCallback = messageClickCallback;
    notificationElement.cancelCallback = cancelCallback;
    containerElement.appendChild(notificationElement);
    notificationElement._open();
    return notificationElement;
}
/**
 * A component for displaying notifications on the page-header.
 * @inner
 * @memberof Notification
 */
var NotificationHeader = /** @class */function (_super) {
    tslib_1.__extends(NotificationHeader, _super);
    function NotificationHeader() {
        var _this = _super.call(this, "div") || this;
        _this._closeHandler = _this._handleClose.bind(_this);
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the range modal component.
     * @private
     */
    NotificationHeader.prototype._initialize = function () {
        this.addClass(CLASS_NOTIFICATION);
        this.addClass(CLASS_OPEN);
        var notificationContent = new _DomElement2.default("div").addClass("notification__content");
        this.appendChild(notificationContent);
        this._notificationBody = new _DomElement2.default("div").addClass("notification__body");
        notificationContent.appendChild(this._notificationBody);
        this._closeButton = new _DomElement2.default("button").addClass(CLASS_BUTTON_CLOSE).addClass("notification-cancel").setAttribute("aria-label", "Close");
        var closeIcon = new _DomElement2.default("i").addClass("icon").addClass("icon-022-close").setAttribute("aria-hidden", "true");
        this._closeButton.appendChild(closeIcon);
        notificationContent.appendChild(this._closeButton);
        this.element.addEventListener("click", this._clickHandler);
    };
    NotificationHeader.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        var closeNotification = true;
        if (this._callback) {
            if (this._callback(this) === false) {
                closeNotification = false;
            }
        }
        if (closeNotification === true) {
            this.close();
        }
    };
    NotificationHeader.prototype._handleClose = function (event) {
        (0, _Utils.preventDefault)(event);
        event.stopPropagation();
        if (this._cancelCallback) {
            this._cancelCallback(this);
        }
        this.close();
    };
    NotificationHeader.prototype._close = function () {
        this.removeClass(CLASS_OPEN);
        this._closeButton.element.removeEventListener("click", this._closeHandler);
        var el = this.element;
        setTimeout(function () {
            // remove the element from the dom
            if (el && el.parentElement) {
                el.parentElement.removeChild(el);
            }
        }, 300);
    };
    // called by showOnHeader
    NotificationHeader.prototype._open = function () {
        this.addClass(CLASS_OPEN);
        this._closeButton.element.addEventListener("click", this._closeHandler);
        this.dispatchEvent("opened");
    };
    Object.defineProperty(NotificationHeader.prototype, "messageClickCallback", {
        set: function set(callback) {
            this._callback = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationHeader.prototype, "cancelCallback", {
        /**
         * Sets the cancel callback function.
         * @param {function} - The callback function to call.
         */
        set: function set(callback) {
            this._cancelCallback = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationHeader.prototype, "message", {
        /**
         * Sets the notification message.
         * @param {String} - The message to set.
         */
        set: function set(value) {
            this._notificationBody.setHtml(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Closes the notification.
     */
    NotificationHeader.prototype.close = function () {
        this._close();
        this.dispatchEvent("closed");
    };
    return NotificationHeader;
}(_DomElement2.default);
exports.NotificationHeader = NotificationHeader;

},{"../DomElement":5,"../Utils":8,"tslib":113}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _sign = require("babel-runtime/core-js/math/sign");

var _sign2 = _interopRequireDefault(_sign);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_HEADER = ".progress-full__bar";
var CLASS_SECTIONS = ".progress-full__sections > span";
var CLASS_SECTION_ACTIVE = "section--active";
var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_CURRENT = "indicator--current";
var CLASS_INDICATOR_COMPLETED = "indicator--completed";
/**
 * Full progress bar component
 */
var ProgressFull = /** @class */function (_super) {
    tslib_1.__extends(ProgressFull, _super);
    /**
     * Creates and initializes the ProgressFull component.
     * @param {DomElement} - The root element of the ProgressFull component.
     */
    function ProgressFull(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    ProgressFull.prototype._initialize = function () {
        this._buttonClickHandler = this._handleButtonClick.bind(this);
        this._keydownHandler = this._handleKeydown.bind(this);
        this._headerElement = this.find(CLASS_HEADER);
        this._pages = this.element.querySelectorAll(CLASS_SECTIONS);
        this._minValue = 1;
        this._value = 1;
        this._total = this._pages.length;
        for (var index = 0; index < this._pages.length; index++) {
            if (this._pages[index].classList.contains(CLASS_SECTION_ACTIVE)) {
                this._value = index + 1;
            }
        }
        this._addIncicators();
        this._update(-1, this._value, false);
        // Apply the tab index
        var tabIndex = this.getAttribute("tabindex");
        if (tabIndex) {
            this.setAttribute("tabindex", "");
            this._headerElement.setAttribute("tabindex", tabIndex);
        }
        this._headerElement.element.addEventListener("click", this._buttonClickHandler);
        this._headerElement.element.addEventListener("keydown", this._keydownHandler);
    };
    ProgressFull.prototype._addIncicators = function () {
        for (var i = this._pages.length - 1; i >= 0; i--) {
            var indicatorElement = new _DomElement2.default("button").addClass(CLASS_INDICATOR).setAttribute("data-value", "" + (i + 1)).setHtml((i + 1).toString());
            this._headerElement.prependChild(indicatorElement);
        }
    };
    ProgressFull.prototype._update = function (oldValue, newValue, animate) {
        if (animate === void 0) {
            animate = true;
        }
        var indicators = this._headerElement.element.childNodes;
        for (var index = 0; index < indicators.length; index++) {
            var indicatorElement = new _DomElement2.default(indicators[index]);
            if (index + 1 < this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_CURRENT).addClass(CLASS_INDICATOR_COMPLETED);
            }
            if (index + 1 === this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).addClass(CLASS_INDICATOR_CURRENT);
            }
            if (index + 1 > this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).removeClass(CLASS_INDICATOR_CURRENT);
            }
        }
        if (oldValue !== newValue) {
            var direction = (0, _sign2.default)(oldValue - newValue);
            if (oldValue > 0 && oldValue !== newValue) {
                var oldSection_1 = new _DomElement2.default(this._pages[oldValue - 1]);
                if (animate) {
                    (0, _animejs2.default)({
                        targets: oldSection_1.element,
                        duration: 300,
                        left: 100 * direction,
                        opacity: 0,
                        easing: "easeInOutQuint",
                        complete: function complete() {
                            oldSection_1.removeClass(CLASS_SECTION_ACTIVE);
                            oldSection_1.setAttribute("style", "");
                        }
                    });
                } else {
                    oldSection_1.removeClass(CLASS_SECTION_ACTIVE);
                    oldSection_1.setAttribute("style", "");
                }
            }
            var newSection_1 = new _DomElement2.default(this._pages[newValue - 1]);
            if (animate) {
                var el = newSection_1.element;
                el.style.left = -100 * direction + "px";
                el.style.opacity = "0";
                newSection_1.addClass(CLASS_SECTION_ACTIVE);
                (0, _animejs2.default)({
                    targets: newSection_1.element,
                    duration: 300,
                    left: 0,
                    opacity: 1,
                    easing: "easeInOutQuint",
                    complete: function complete() {
                        newSection_1.setAttribute("style", "");
                    }
                });
            } else {
                newSection_1.addClass(CLASS_SECTION_ACTIVE);
                newSection_1.setAttribute("style", "");
            }
        }
    };
    ProgressFull.prototype._handleButtonClick = function (event) {
        var element = new _DomElement2.default(event.target);
        if (!element.hasClass(CLASS_INDICATOR)) {
            return;
        }
        var value = element.getAttribute("data-value");
        this.value = parseFloat(value);
    };
    ProgressFull.prototype._handleKeydown = function (event) {
        var keyboardEvent = event;
        var keycode = keyboardEvent.which || keyboardEvent.keyCode;
        if (keycode === Inputs.KEY_ARROW_RIGHT) {
            this.value++;
            (0, _Utils.preventDefault)(keyboardEvent);
            return;
        }
        if (keycode === Inputs.KEY_ARROW_LEFT) {
            this.value--;
            (0, _Utils.preventDefault)(keyboardEvent);
            return;
        }
        if (keycode >= Inputs.KEY_NR_0 && keycode <= Inputs.KEY_NR_9) {
            this.value = keycode - Inputs.KEY_NR_0;
            (0, _Utils.preventDefault)(keyboardEvent);
            return;
        }
    };
    Object.defineProperty(ProgressFull.prototype, "value", {
        /**
         * Gets the current progress value in the range of 1..total.
         */
        get: function get() {
            return this._value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 1..total.
         */
        set: function set(val) {
            var oldValue = this._value;
            this._value = (0, _Utils.clamp)(val, this._minValue, this._total);
            this._update(oldValue, this._value, true);
            this.dispatchEvent("changed");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProgressFull.prototype, "total", {
        /**
         * Gets the total progress value.
         */
        get: function get() {
            return this._total;
        },
        enumerable: true,
        configurable: true
    });
    return ProgressFull;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".progress-full", function (e) {
        new ProgressFull(e);
    });
}
exports.default = ProgressFull;

},{"../DomElement":5,"../Inputs":7,"../Utils":8,"animejs":34,"babel-runtime/core-js/math/sign":36,"tslib":113}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BAR = ".progress-light__bar";
var CLASS_PROGRESS = ".bar__progress";
var CLASS_PROGRESS_COMPLETED = "bar__progress--complete";
var CLASS_TICK = "bar__tick";
var CLASS_PAGE_CURRENT = ".detail__currentpage";
var CLASS_PAGE_TOTAL = ".detail__totalpage";
var CLASS_DISABLED = "arrow--disabled";
var CLASS_BUTTON_LEFT = ".arrow--left";
var CLASS_BUTTON_RIGHT = ".arrow--right";
/**
 * Light progress bar component
 */
var ProgressLight = /** @class */function (_super) {
    tslib_1.__extends(ProgressLight, _super);
    /**
     * Creates and initializes the ProgressLight component.
     * @param {DomElement} - The root element of the ProgressLight component.
     */
    function ProgressLight(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    ProgressLight.prototype._initialize = function () {
        this._buttonClickHandler = this._handleButtonClick.bind(this);
        this._animationCompletedHandler = this._handleAnimationCompleted.bind(this);
        this._barElement = this.find(CLASS_BAR);
        this._progressElement = this.find(CLASS_PROGRESS);
        this._pageCurrentElement = this.find(CLASS_PAGE_CURRENT);
        this._pageTotalElement = this.find(CLASS_PAGE_TOTAL);
        this._buttonLeft = this.find(CLASS_BUTTON_LEFT);
        this._buttonRight = this.find(CLASS_BUTTON_RIGHT);
        this._minValue = 1;
        this._total = Math.max(parseInt(this.getAttribute("total") || "100", 10), this._minValue);
        this._value = (0, _Utils.clamp)(parseInt(this.getAttribute("value") || "1", 10), this._minValue, this._total);
        this._layout();
        this._addTicks();
        this._update(false);
        this.enable();
    };
    ProgressLight.prototype._addTicks = function () {
        for (var i = 1; i < this._total; i++) {
            var position = this._itemWidth * i;
            var tickElement = new _DomElement2.default("div").addClass(CLASS_TICK).setAttribute("style", "left: " + position + "%");
            this._barElement.prependChild(tickElement);
        }
    };
    ProgressLight.prototype._update = function (animate) {
        var _this = this;
        if (animate === void 0) {
            animate = true;
        }
        this._pageCurrentElement.setHtml(this._value.toString());
        this._pageTotalElement.setHtml(this._total.toString());
        var position = this._value * this._itemWidth;
        // Add additional width to the last element to make sure
        // the rounded border on the left is filled as well
        if (this._value === this._total) {
            position += 5;
        }
        if (this._value >= this._total) {
            this._buttonRight.addClass(CLASS_DISABLED);
        } else {
            this._buttonRight.removeClass(CLASS_DISABLED);
        }
        if (this._value <= this._minValue) {
            this._buttonLeft.addClass(CLASS_DISABLED);
        } else {
            this._buttonLeft.removeClass(CLASS_DISABLED);
        }
        var el = this._progressElement.element;
        if (animate) {
            (0, _animejs2.default)({
                targets: this._progressElement.element,
                duration: 200,
                easing: "easeInOutQuint",
                width: this._barElement.element.clientWidth * position / 100,
                complete: function complete() {
                    el.style.width = position + "%";
                    _this._animationCompletedHandler({});
                }
            });
        } else {
            el.style.width = position + "%";
            this._animationCompletedHandler({});
        }
    };
    ProgressLight.prototype._layout = function () {
        this._itemWidth = Math.floor(100 / this._total);
    };
    ProgressLight.prototype._handleButtonClick = function (event) {
        if (event.target === this._buttonLeft.element) {
            this.value = this._value - 1;
        } else if (event.target === this._buttonRight.element) {
            this.value = this._value + 1;
        }
    };
    ProgressLight.prototype._handleAnimationCompleted = function () {
        if (this._value === this._total) {
            this._progressElement.addClass(CLASS_PROGRESS_COMPLETED);
        } else {
            this._progressElement.removeClass(CLASS_PROGRESS_COMPLETED);
        }
    };
    Object.defineProperty(ProgressLight.prototype, "value", {
        /**
         * Gets the current progress value in the range of 1..total.
         */
        get: function get() {
            return this._value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 1..total.
         */
        set: function set(val) {
            this._value = (0, _Utils.clamp)(val, this._minValue, this._total);
            this._update(true);
            this.dispatchEvent("changed");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProgressLight.prototype, "total", {
        /**
         * Gets the total progress value.
         */
        get: function get() {
            return this._total;
        },
        /**
         * Sets the total progress value and updates the UI accordingly.
         * @param {number} - The total progress positive integer value.
         */
        set: function set(value) {
            var e_1, _a;
            if (this._total === value) {
                return;
            }
            this._total = Math.max(value, this._minValue);
            this._value = (0, _Utils.clamp)(this._value, this._minValue, this._total);
            try {
                // Clear the ticks
                for (var _b = tslib_1.__values(this.element.querySelectorAll("." + CLASS_TICK)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var tick = _c.value;
                    this._barElement.element.removeChild(tick);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            this._layout();
            this._addTicks();
            this._update(false);
            this.dispatchEvent("totalchanged");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Enables the component.
     */
    ProgressLight.prototype.enable = function () {
        this._buttonLeft.element.addEventListener("click", this._buttonClickHandler);
        this._buttonRight.element.addEventListener("click", this._buttonClickHandler);
    };
    /**
     * Disables the component.
     */
    ProgressLight.prototype.disable = function () {
        this._buttonLeft.element.removeEventListener("click", this._buttonClickHandler);
        this._buttonRight.element.removeEventListener("click", this._buttonClickHandler);
    };
    return ProgressLight;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".progress-light", function (e) {
        new ProgressLight(e);
    });
}
exports.default = ProgressLight;

},{"../DomElement":5,"../Utils":8,"animejs":34,"tslib":113}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initBarChartVertical = exports.BarChartVertical = exports.initBarChartHorizontal = exports.BarChartHorizontal = exports.initPieChart = exports.PieChart = exports.initTable = exports.Table = exports.initCarousel = exports.Carousel = exports.initEmptyState = exports.EmptyState = exports.initSearchInput = exports.SearchInput = exports.initNavigationSide = exports.NavigationSide = exports.initNavigation = exports.Navigation = exports.initMenuFlyout = exports.MenuFlyout = exports.initAccordion = exports.Accordion = exports.initCollapse = exports.Collapse = exports.Notification = exports.Toolbar = exports.initModal = exports.Modal = exports.initProgressFull = exports.ProgressFull = exports.initProgressLight = exports.ProgressLight = exports.initAutocomplete = exports.Autocomplete = exports.initRange = exports.Range = exports.initSelect = exports.Select = exports.initTextarea = exports.Textarea = exports.initInputField = exports.InputField = exports.initLoaderBar = exports.LoaderBar = exports.utils = undefined;

var _Utils = require("./Utils");

var utils = _interopRequireWildcard(_Utils);

var _LoaderBar = require("./loader/LoaderBar");

var _LoaderBar2 = _interopRequireDefault(_LoaderBar);

var _InputField = require("./form/InputField");

var _InputField2 = _interopRequireDefault(_InputField);

var _Textarea = require("./form/Textarea");

var _Textarea2 = _interopRequireDefault(_Textarea);

var _Select = require("./form/Select");

var _Select2 = _interopRequireDefault(_Select);

var _Range = require("./form/Range");

var _Range2 = _interopRequireDefault(_Range);

var _Autocomplete = require("./form/Autocomplete");

var _Autocomplete2 = _interopRequireDefault(_Autocomplete);

var _ProgressLight = require("./progress/ProgressLight");

var _ProgressLight2 = _interopRequireDefault(_ProgressLight);

var _ProgressFull = require("./progress/ProgressFull");

var _ProgressFull2 = _interopRequireDefault(_ProgressFull);

var _Modal = require("./modal/Modal");

var _Modal2 = _interopRequireDefault(_Modal);

var _Toolbar = require("./toolbar/Toolbar");

var _Toolbar2 = _interopRequireDefault(_Toolbar);

var _Notification = require("./notification/Notification");

var Notification = _interopRequireWildcard(_Notification);

var _Collapse = require("./collapse/Collapse");

var _Collapse2 = _interopRequireDefault(_Collapse);

var _Accordion = require("./accordion/Accordion");

var _Accordion2 = _interopRequireDefault(_Accordion);

var _MenuFlyout = require("./menu/MenuFlyout");

var _MenuFlyout2 = _interopRequireDefault(_MenuFlyout);

var _Navigation = require("./navigation/Navigation");

var _Navigation2 = _interopRequireDefault(_Navigation);

var _NavigationSide = require("./navigation/NavigationSide");

var _NavigationSide2 = _interopRequireDefault(_NavigationSide);

var _SearchInput = require("./search/SearchInput");

var _SearchInput2 = _interopRequireDefault(_SearchInput);

var _EmptyState = require("./empty-states/EmptyState");

var _EmptyState2 = _interopRequireDefault(_EmptyState);

var _Carousel = require("./carousel/Carousel");

var _Carousel2 = _interopRequireDefault(_Carousel);

var _Table = require("./table/Table");

var _Table2 = _interopRequireDefault(_Table);

var _PieChart = require("./charts/PieChart");

var _PieChart2 = _interopRequireDefault(_PieChart);

var _BarChartHorizontal = require("./charts/BarChartHorizontal");

var _BarChartHorizontal2 = _interopRequireDefault(_BarChartHorizontal);

var _BarChartVertical = require("./charts/BarChartVertical");

var _BarChartVertical2 = _interopRequireDefault(_BarChartVertical);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* Form Components */
exports.utils = utils;
exports.LoaderBar = _LoaderBar2.default;
exports.initLoaderBar = _LoaderBar.init;
exports.InputField = _InputField2.default;
exports.initInputField = _InputField.init;
exports.Textarea = _Textarea2.default;
exports.initTextarea = _Textarea.init;
exports.Select = _Select2.default;
exports.initSelect = _Select.init;
exports.Range = _Range2.default;
exports.initRange = _Range.init;
exports.Autocomplete = _Autocomplete2.default;
exports.initAutocomplete = _Autocomplete.init;
exports.ProgressLight = _ProgressLight2.default;
exports.initProgressLight = _ProgressLight.init;
exports.ProgressFull = _ProgressFull2.default;
exports.initProgressFull = _ProgressFull.init;
exports.Modal = _Modal2.default;
exports.initModal = _Modal.init;
exports.Toolbar = _Toolbar2.default;
exports.Notification = Notification;
exports.Collapse = _Collapse2.default;
exports.initCollapse = _Collapse.init;
exports.Accordion = _Accordion2.default;
exports.initAccordion = _Accordion.init;
exports.MenuFlyout = _MenuFlyout2.default;
exports.initMenuFlyout = _MenuFlyout.init;
exports.Navigation = _Navigation2.default;
exports.initNavigation = _Navigation.init;
exports.NavigationSide = _NavigationSide2.default;
exports.initNavigationSide = _NavigationSide.init;
exports.SearchInput = _SearchInput2.default;
exports.initSearchInput = _SearchInput.init;
exports.EmptyState = _EmptyState2.default;
exports.initEmptyState = _EmptyState.init;
exports.Carousel = _Carousel2.default;
exports.initCarousel = _Carousel.init;
exports.Table = _Table2.default;
exports.initTable = _Table.init;
exports.PieChart = _PieChart2.default;
exports.initPieChart = _PieChart.init;
exports.BarChartHorizontal = _BarChartHorizontal2.default;
exports.initBarChartHorizontal = _BarChartHorizontal.init;
exports.BarChartVertical = _BarChartVertical2.default;
exports.initBarChartVertical = _BarChartVertical.init;

},{"./Utils":8,"./accordion/Accordion":9,"./carousel/Carousel":10,"./charts/BarChartHorizontal":11,"./charts/BarChartVertical":12,"./charts/PieChart":14,"./collapse/Collapse":15,"./empty-states/EmptyState":16,"./form/Autocomplete":17,"./form/InputField":18,"./form/Range":19,"./form/Select":20,"./form/Textarea":21,"./loader/LoaderBar":22,"./menu/MenuFlyout":23,"./modal/Modal":24,"./navigation/Navigation":25,"./navigation/NavigationSide":26,"./notification/Notification":27,"./progress/ProgressFull":28,"./progress/ProgressLight":29,"./search/SearchInput":31,"./table/Table":32,"./toolbar/Toolbar":33}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_SEARCH_INPUT = "input.search__field";
var QUERY_BTN_CLOSE = ".search__icon-close";
var QUERY_LIVE_SUGESTIONS = ".js-suggestions";
var QUERY_LIVE_FOOTER = ".js-footer";
var CLASS_ACTIVE = "is-active";
var CLASS_OPEN = "is-open";
var CLASS_SEARCH = "search";
var ANIMATION_SUGGESTIONS_DURATION = 300;
var ANIMATION_FOOTER_DURATION = 100;
var ANIMATION_FOOTER_DELAY = ANIMATION_SUGGESTIONS_DURATION - ANIMATION_FOOTER_DURATION;
/**
 * The search input component definition.
 */
var SearchInput = /** @class */function (_super) {
    tslib_1.__extends(SearchInput, _super);
    function SearchInput(element) {
        var _this = _super.call(this, element) || this;
        _this._isOpen = false;
        _this._input = _this.element.querySelector(QUERY_SEARCH_INPUT);
        _this._form = _this.element.querySelector("form");
        _this._btnClose = _this.element.querySelector(QUERY_BTN_CLOSE);
        var liveSearch = (0, _DomFunctions.getAttributeReference)(_this.element, "data-live");
        if (liveSearch) {
            _this._liveSuggestions = liveSearch.querySelector(QUERY_LIVE_SUGESTIONS) || undefined;
            _this._liveFooter = liveSearch.querySelector(QUERY_LIVE_FOOTER) || undefined;
            if (_this._liveSuggestions) {
                _this._liveContainer = _this._liveSuggestions.parentNode || undefined;
            }
        }
        _this._focusHandler = _this._handleInputFocus.bind(_this);
        _this._blurHandler = _this._handleInputBlur.bind(_this);
        _this._closeHandler = _this.close.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._resizeHandler = _this._handleResize.bind(_this);
        _this._initialize();
        return _this;
    }
    SearchInput.prototype._initialize = function () {
        this._input.addEventListener("focus", this._focusHandler);
        this._input.addEventListener("blur", this._blurHandler);
        if ((0, _Utils.internetExplorerOrEdgeVersion)() > 0) {
            // This is a workaround for IE browsers where a focused
            // input's cursor bleeds trough even if hidden
            window.addEventListener("resize", this._resizeHandler);
            window.addEventListener("orientationchange", this._resizeHandler);
        }
        if (this._btnClose) {
            this._btnClose.addEventListener("click", this._closeHandler);
        }
    };
    SearchInput.prototype._handleInputFocus = function () {
        this.addClass(CLASS_ACTIVE);
    };
    SearchInput.prototype._handleInputBlur = function () {
        this.removeClass(CLASS_ACTIVE);
    };
    SearchInput.prototype._handleWindowClick = function (event) {
        var target = event.target;
        if (!(0, _DomFunctions.parentWithClass)(target, CLASS_SEARCH)) {
            this.close();
            return false;
        }
        return true;
    };
    SearchInput.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            this.close();
            (0, _Utils.preventDefault)(event);
        }
    };
    SearchInput.prototype._handleResize = function () {
        var style = window.getComputedStyle(this.element);
        if (style.display === "none") {
            this._input.blur();
        }
    };
    SearchInput.prototype._resetMainTimeline = function () {
        if (this.animation) {
            this.animation.pause();
        }
        _animejs2.default.remove(this._liveSuggestions);
        _animejs2.default.remove(this._liveFooter);
        this.animation = _animejs2.default.timeline();
    };
    Object.defineProperty(SearchInput.prototype, "value", {
        /**
         * Gets the search input text content.
         * @returns {String} The input text.
         */
        get: function get() {
            return this._input.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens/activates the search input.
     */
    SearchInput.prototype.open = function () {
        var _this = this;
        this.addClass(CLASS_OPEN);
        this._input.focus();
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
            window.addEventListener("keydown", _this._keydownHandler);
        }, 50);
    };
    /**
     * Closes/deactivates the search input.
     */
    SearchInput.prototype.close = function () {
        this._form.reset();
        this.removeClass(CLASS_OPEN);
        this.closeLiveSearch();
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        window.removeEventListener("keydown", this._keydownHandler);
    };
    /**
     * Opens the live search suggestions.
     */
    SearchInput.prototype.openLiveSearch = function () {
        var _this = this;
        if (!this._liveSuggestions || this._isOpen) {
            return;
        }
        this._isOpen = true;
        (0, _DomFunctions.addClass)(this._liveContainer, CLASS_OPEN);
        this._resetMainTimeline();
        this._liveSuggestions.style.display = "block";
        this.animation.add({
            targets: this._liveSuggestions,
            duration: ANIMATION_SUGGESTIONS_DURATION,
            height: this._liveSuggestions.scrollHeight + "px",
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                var domEl = new _DomElement2.default(_this._liveSuggestions);
                domEl.addClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        if (this._liveFooter) {
            this._liveFooter.style.display = "block";
            this.animation.add({
                targets: this._liveFooter,
                duration: ANIMATION_FOOTER_DURATION,
                height: this._liveFooter.scrollHeight + "px",
                easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
                offset: ANIMATION_FOOTER_DELAY,
                complete: function complete() {
                    var domEl = new _DomElement2.default(_this._liveFooter);
                    domEl.addClass(CLASS_OPEN);
                    domEl.setAttribute("style", "");
                }
            });
        }
    };
    /**
     * Closes the live search suggestions.
     */
    SearchInput.prototype.closeLiveSearch = function () {
        var _this = this;
        if (!this._liveSuggestions || !this.isOpen) {
            return;
        }
        this._isOpen = false;
        this._resetMainTimeline();
        this._liveSuggestions.style.display = "block";
        this.animation.add({
            targets: this._liveSuggestions,
            duration: ANIMATION_SUGGESTIONS_DURATION,
            height: 0,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                var domEl = new _DomElement2.default(_this._liveSuggestions);
                domEl.removeClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
                (0, _DomFunctions.removeClass)(_this._liveContainer, CLASS_OPEN);
            }
        });
        if (this._liveFooter) {
            this._liveFooter.style.display = "block";
            this.animation.add({
                targets: this._liveFooter,
                duration: ANIMATION_FOOTER_DURATION,
                height: 0,
                easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
                offset: 0,
                complete: function complete() {
                    var domEl = new _DomElement2.default(_this._liveFooter);
                    domEl.removeClass(CLASS_OPEN);
                    domEl.setAttribute("style", "");
                }
            });
        }
    };
    /**
     * Destroys the component and clears all references.
     */
    SearchInput.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        window.removeEventListener("keydown", this._keydownHandler);
        this._input.removeEventListener("focus", this._focusHandler);
        this._input.removeEventListener("blur", this._blurHandler);
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        if (this._btnClose) {
            this._btnClose.removeEventListener("click", this._closeHandler);
        }
        this._input = null;
        this._form = null;
        this._btnClose = null;
        this._focusHandler = null;
        this._blurHandler = null;
        this._closeHandler = null;
        this._windowClickHandler = null;
        this._keydownHandler = null;
        this._liveSuggestions = null;
        this._liveFooter = null;
    };
    /**
     * Determines if the SearchInput is open/visible.
     * @return {Boolean} - True if open; otherwise false.
     */
    SearchInput.prototype.isOpen = function () {
        return this.hasClass(CLASS_OPEN);
    };
    return SearchInput;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".search.search__input", function (e) {
        new SearchInput(e);
    });
}
exports.default = SearchInput;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"animejs":34,"tslib":113}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_HEADER = "thead th";
var CLASS_SORTED_ASCENDING = "js-ascending";
var CLASS_SORTED_DESCENDING = "js-descending";
var CLASS_ARROW = "arrow-icon";
/**
 * The Table component. Adds additional capabilities to standard HTML 5 tables.
 */
var Table = /** @class */function (_super) {
    tslib_1.__extends(Table, _super);
    /**
     * Creates a new instance of the table component.
     */
    function Table(element) {
        var _this = _super.call(this, element) || this;
        _this._headerClickHandler = _this._handleHeaderClick.bind(_this);
        _this._body = _this.element.querySelector("tbody");
        _this._rows = _this._body.getElementsByTagName("tr");
        _this._initialize();
        return _this;
    }
    Table.prototype._initialize = function () {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                if (header.getAttribute("data-type")) {
                    header.addEventListener("click", this._headerClickHandler);
                    var arrowElement = new _DomElement2.default("div").addClass(CLASS_ARROW).element;
                    header.appendChild(arrowElement);
                }
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Table.prototype._handleHeaderClick = function (e) {
        var th = e.target;
        this.sort(th);
    };
    /**
     * Sorts the table according to the specified table header element.
     * The column is sorted ascending by default if no direction is specified and no
     * existing sort order class is found in the markup.
     *
     * If the displayed data is not suitable for sorting `<td/>` elements can define a `data-value` attribute
     * which is then used for the data-source.
     *
     * @param {TableHeader} tableHeader The header element of the row to sort by.
     * @param {Number} direction The direction to sort, `1` for ascending, `-1` for descending order. This parameter is optional.
     * @param {function} equalityComparer The equiality comparer function to compare individual cell values.
     */
    Table.prototype.sort = function (tableHeader, direction, equalityComparer) {
        var e_2, _a;
        if (!tableHeader || tableHeader.tagName !== "TH") {
            throw new Error("The parameter 'tableHeader' must be a valid column header node");
        }
        if (direction !== 1 && direction !== -1 && direction) {
            throw new Error("Parameter out of range, parameter 'direction' with value '" + direction + "' must be either -1, 1 or undefined");
        }
        var columnIndex = tableHeader.cellIndex;
        if (!equalityComparer) {
            var dataType = tableHeader.getAttribute("data-type");
            equalityComparer = this._getComparer(dataType);
        }
        if (columnIndex >= this.element.querySelectorAll(QUERY_HEADER).length) {
            throw new Error("Column out of range");
        }
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                if (header !== tableHeader) {
                    Dom.removeClass(header, CLASS_SORTED_ASCENDING);
                    Dom.removeClass(header, CLASS_SORTED_DESCENDING);
                }
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        if (Dom.hasClass(tableHeader, CLASS_SORTED_ASCENDING)) {
            Dom.removeClass(tableHeader, CLASS_SORTED_ASCENDING);
            Dom.addClass(tableHeader, CLASS_SORTED_DESCENDING);
            direction = direction || -1;
        } else {
            Dom.removeClass(tableHeader, CLASS_SORTED_DESCENDING);
            Dom.addClass(tableHeader, CLASS_SORTED_ASCENDING);
            direction = direction || 1;
        }
        this._quicksort(columnIndex, 0, this._rows.length - 1, direction, equalityComparer);
    };
    Table.prototype._getCell = function (column, row) {
        return this._rows[row].cells[column];
    };
    Table.prototype._getRow = function (row) {
        return this._rows[row];
    };
    Table.prototype._getComparer = function (dataType) {
        switch (dataType) {
            case "number":
                {
                    // parse the string as a number
                    return function (a, b) {
                        return parseFloat(a) - parseFloat(b);
                    };
                }
            default:
                {
                    // compare strings
                    return function (a, b) {
                        if (a < b) {
                            return -1;
                        }
                        if (a > b) {
                            return 1;
                        }
                        return 0;
                    };
                }
        }
    };
    Table.prototype._quicksort = function (column, left, right, direction, equalityComparer) {
        if (direction === void 0) {
            direction = 1;
        }
        if (right - left > 0) {
            var partition = this._partition(column, left, right, direction, equalityComparer);
            if (left < partition - 1) {
                this._quicksort(column, left, partition - 1, direction, equalityComparer);
            }
            if (partition < right) {
                this._quicksort(column, partition, right, direction, equalityComparer);
            }
        }
    };
    Table.prototype._partition = function (column, left, right, direction, equalityComparer) {
        if (direction === void 0) {
            direction = 1;
        }
        var pivot = this._getCell(column, Math.floor((right + left) / 2));
        var i = left;
        var j = right;
        while (i <= j) {
            while (this._equals(this._getCell(column, i), pivot, equalityComparer) * direction < 0) {
                i++;
            }
            while (this._equals(this._getCell(column, j), pivot, equalityComparer) * direction > 0) {
                j--;
            }
            if (i <= j) {
                this._swap(i, j);
                i++;
                j--;
            }
        }
        return i;
    };
    Table.prototype._equals = function (a, b, equalityComparer) {
        var dataA = a.getAttribute("data-value");
        var dataB = b.getAttribute("data-value");
        dataA = dataA || a.textContent || a.innerText;
        dataB = dataB || b.textContent || b.innerText;
        return equalityComparer(dataA, dataB);
    };
    Table.prototype._swap = function (i, j) {
        var tmpNode = this._body.replaceChild(this._getRow(i), this._getRow(j));
        var referenceRow = this._getRow(i);
        if (!referenceRow) {
            this._body.appendChild(tmpNode);
        } else {
            this._body.insertBefore(tmpNode, referenceRow);
        }
    };
    /**
     * Destroys the component and clears all references.
     */
    Table.prototype.destroy = function () {
        var e_3, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                header.removeEventListener("click", this._headerClickHandler);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        this._headerClickHandler = null;
        this._body = null;
        this._rows = null;
    };
    return Table;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("table", function (e) {
        new Table(e);
    });
}
exports.default = Table;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"tslib":113}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_ITEMS = ".toolbar__item";
var CLASS_SHOW = "item--show";
var ANIMATION_START_DELAY = 100;
var ANIMATION_OFFSET = 50;
/**
 * Toolbar component. Use this component to show and hide the
 * individual toolbar items.
 */
var Toolbar = /** @class */function (_super) {
    tslib_1.__extends(Toolbar, _super);
    function Toolbar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Makes the toolbar items visible.
     */
    Toolbar.prototype.show = function () {
        var delay = ANIMATION_START_DELAY;
        var items = this.element.querySelectorAll(CLASS_ITEMS);
        var timeline = _animejs2.default.timeline();
        var _loop_1 = function _loop_1(index) {
            timeline.add({
                targets: items[index],
                duration: 0,
                offset: delay,
                complete: function complete() {
                    items[index].classList.add(CLASS_SHOW);
                }
            });
            delay += ANIMATION_OFFSET;
        };
        for (var index = 0; index < items.length; index++) {
            _loop_1(index);
        }
    };
    /**
     * Hides the toolbar items.
     */
    Toolbar.prototype.hide = function () {
        var delay = ANIMATION_START_DELAY;
        var items = this.element.querySelectorAll(CLASS_ITEMS);
        var timeline = _animejs2.default.timeline();
        var _loop_2 = function _loop_2(index) {
            timeline.add({
                targets: items[index],
                duration: 0,
                offset: delay,
                complete: function complete() {
                    items[index].classList.remove(CLASS_SHOW);
                }
            });
            delay += ANIMATION_OFFSET;
        };
        for (var index = items.length - 1; index >= 0; index--) {
            _loop_2(index);
        }
    };
    /**
     * Toggles the toolbar items visibility.
     */
    Toolbar.prototype.toggle = function () {
        if (this.element.querySelectorAll("." + CLASS_SHOW).length === 0) {
            this.show();
        } else {
            this.hide();
        }
    };
    return Toolbar;
}(_DomElement2.default);
exports.default = Toolbar;

},{"../DomElement":5,"animejs":34,"tslib":113}],34:[function(require,module,exports){
/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

'use strict';

// Defaults

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};

var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};

var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];

// Caching

var cache = {
  CSS: {},
  springs: {}
};

// Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) { return Array.isArray(a); },
  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
  svg: function (a) { return a instanceof SVGElement; },
  inp: function (a) { return a instanceof HTMLInputElement; },
  dom: function (a) { return a.nodeType || is.svg(a); },
  str: function (a) { return typeof a === 'string'; },
  fnc: function (a) { return typeof a === 'function'; },
  und: function (a) { return typeof a === 'undefined'; },
  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
  rgb: function (a) { return /^rgb/.test(a); },
  hsl: function (a) { return /^hsl/.test(a); },
  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }
};

// Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
}

// Spring solver inspired by Webkit Copyright  2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

function spring(string, duration) {

  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? (duration * t) / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) { return t; }
    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];
    if (cached) { return cached; }
    var frame = 1/6;
    var elapsed = 0;
    var rest = 0;
    while(true) {
      elapsed += frame;
      if (solver(elapsed) === 1) {
        rest++;
        if (rest >= 16) { break; }
      } else {
        rest = 0;
      }
    }
    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;

}

// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

function steps(steps) {
  if ( steps === void 0 ) steps = 10;

  return function (t) { return Math.round(t * steps) * (1 / steps); };
}

// BezierEasing https://github.com/gre/bezier-easing

var bezier = (function () {

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
  function C(aA1)      { return 3.0 * aA1 }

  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) { return aGuessT; }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {

    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {

      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) { return x; }
      if (x === 0 || x === 1) { return x; }
      return calcBezier(getTForX(x), mY1, mY2);
    }

  }

  return bezier;

})();

var penner = (function () {

  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)

  var eases = { linear: function () { return function (t) { return t; }; } };

  var functionEasings = {
    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
    Bounce: function () { return function (t) {
      var pow2, b = 4;
      while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
      return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)
    }; },
    Elastic: function (amplitude, period) {
      if ( amplitude === void 0 ) amplitude = 1;
      if ( period === void 0 ) period = .5;

      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return (t === 0 || t === 1) ? t : 
          -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
      }
    }
  };

  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];

  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
  });

  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;
    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
    eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 
      1 - easeIn(a, b)(t * -2 + 2) / 2; }; };
  });

  return eases;

})();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) { return easing; }
  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);
  switch (name) {
    case 'spring' : return spring(easing, duration);
    case 'cubicBezier' : return applyArguments(bezier, args);
    case 'steps' : return applyArguments(steps, args);
    default : return applyArguments(ease, args);
  }
}

// Strings

function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch(e) {
    return;
  }
}

// Arrays

function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];
  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];
      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }
  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
}

function toArray(o) {
  if (is.arr(o)) { return o; }
  if (is.str(o)) { o = selectString(o) || o; }
  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) { return a === val; });
}

// Objects

function cloneObject(o) {
  var clone = {};
  for (var p in o) { clone[p] = o[p]; }
  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
  return o;
}

// Colors

function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return ("rgba(" + r + "," + g + "," + b + ",1)");
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;
  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
}

function colorToRgb(val) {
  if (is.rgb(val)) { return rgbToRgba(val); }
  if (is.hex(val)) { return hexToRgba(val); }
  if (is.hsl(val)) { return hslToRgba(val); }
}

// Units

function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
  if (split) { return split[1]; }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
}

// Values

function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) { return val; }
  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);
  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
  var cached = cache.CSS[value + unit];
  if (!is.und(cached)) { return cached; }
  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) { return 'attribute'; }
  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
  if (el[prop] != null) { return 'object'; }
}

function getElementTransforms(el) {
  if (!is.dom(el)) { return; }
  var str = el.style.transform || '';
  var reg  = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;
  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }
  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform': return getTransformValue(target, propName, animatable, unit);
    case 'css': return getCSSValue(target, propName, unit);
    case 'attribute': return getAttribute(target, propName);
    default: return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);
  if (!operator) { return to; }
  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));
  switch (operator[0][0]) {
    case '+': return x + y + u;
    case '-': return x - y + u;
    case '*': return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) { return colorToRgb(val); }
  if (/\s/g.test(val)) { return val; }
  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
  if (unit) { return unitLess + unit; }
  return unitLess;
}

// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
}

function getLineLength(el) {
  return getDistance(
    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
  );
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;
  for (var i = 0 ; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
    previousPos = currentPos;
  }
  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}

// Path animation

function getTotalLength(el) {
  if (el.getTotalLength) { return el.getTotalLength(); }
  switch(el.tagName.toLowerCase()) {
    case 'circle': return getCircleLength(el);
    case 'rect': return getRectLength(el);
    case 'line': return getLineLength(el);
    case 'polyline': return getPolylineLength(el);
    case 'polygon': return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
}

// Motion path

function getParentSvgEl(el) {
  var parentEl = el.parentNode;
  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) { break; }
    parentEl = parentEl.parentNode;
  }
  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  }
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function(property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    }
  }
}

function getPathProgress(path, progress) {
  function point(offset) {
    if ( offset === void 0 ) offset = 0;

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }
  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  switch (path.property) {
    case 'x': return (p.x - svg.x) * svg.w;
    case 'y': return (p.y - svg.y) * svg.h;
    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
}

// Decompose value

function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: (is.str(val) || unit) ? value.split(rgx) : []
  }
}

// Animatables

function parseTargets(targets) {
  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
  });
}

// Properties

function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings);
  // Override duration if easing is a spring
  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = (l === 2 && !is.obj(prop[0]));
    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {value: prop};
    }
  }
  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
    // Default delay value should only be applied to the first tween
    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
    // Default endDelay value should only be applied to the last tween
    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
    return obj;
  }).map(function (k) { return mergeObjects(k, settings); });
}


function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
  var properties = {};
  var loop = function ( i ) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};
      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) { newKey.value = key[p]; }
        } else {
          newKey[p] = key[p];
        }
      }
      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop( i );
  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;
  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }
  return properties;
}

// Tweens

function normalizeTweenValues(tween, animatable) {
  var t = {};
  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);
    if (is.arr(value)) {
      value = value.map(function (v) { return getFunctionValue(v, animatable); });
      if (value.length === 1) { value = value[0]; }
    }
    t[p] = value;
  }
  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;
    if (is.und(to)) { to = previousValue; }
    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);
    if (tween.isColor) { tween.round = 1; }
    previousTween = tween;
    return tween;
  });
}

// Tween progress

var setProgressValue = {
  css: function (t, p, v) { return t.style[p] = v; },
  attribute: function (t, p, v) { return t.setAttribute(p, v); },
  object: function (t, p, v) { return t[p] = v; },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);
    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
      t.style.transform = str;
    }
  }
};

// Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
}

// Animations

function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);
  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    }
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) { return !is.und(a); });
}

// Create Instance

function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;
  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
}

// Core

var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = (function () {
  function play() { 
    raf = requestAnimationFrame(step);
  }
  function step(t) {
    var activeInstancesLength = activeInstances.length;
    if (activeInstancesLength) {
      var i = 0;
      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];
        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);
          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }
        i++;
      }
      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }
  return play;
})();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) { return ins.pause(); });
    pausedInstances = activeInstances.slice(0);
    anime.running = activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) { return ins.play(); });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
}

// Public Instance

function anime(params) {
  if ( params === void 0 ) params = {};


  var startTime = 0, lastTime = 0, now = 0;
  var children, childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;
    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }
    instance.reversed = !instance.reversed;
    children.forEach(function (child) { return child.reversed = instance.reversed; });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) { child.seek(time - child.timelineOffset); }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }
    } else {
      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;
    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength];
      // Only check for keyframes if there is more than one tween
      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = (void 0);
      for (var n = 0; n < toNumbersLength; n++) {
        var value = (void 0);
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;
        if (!tween.isPath) {
          value = fromNumber + (eased * (toNumber - fromNumber));
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }
        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }
        numbers.push(value);
      }
      // Manual Array.reduce for better performances
      var stringsLength = strings.length;
      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];
        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];
          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }
      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;
    if (children) { syncInstanceChildren(insTime); }
    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }
    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }
    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }
    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
      setAnimationsProgress(insDuration);
    }
    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }
      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }
    instance.currentTime = minMax(insTime, 0, insDuration);
    if (instance.began) { setCallback('update'); }
    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();
      if (!instance.remaining) {
        instance.paused = true;
        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');
          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;
        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function() {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;
    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  };

  // Set Value helper

  instance.set = function(targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function(t) {
    now = t;
    if (!startTime) { startTime = now; }
    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function(time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function() {
    instance.paused = true;
    resetTime();
  };

  instance.play = function() {
    if (!instance.paused) { return; }
    if (instance.completed) { instance.reset(); }
    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    if (!raf) { engine(); }
  };

  instance.reverse = function() {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function() {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) { instance.play(); }

  return instance;

}

// Remove targets from animation

function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);
  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);
    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);
      if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
    }
    if (!animations.length && !children.length) { instance.pause(); }
  }
}

// Stagger helpers

function stagger(val, params) {
  if ( params === void 0 ) params = {};

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) { fromIndex = 0; }
    if (fromCenter) { fromIndex = (t - 1) / 2; }
    if (fromLast) { fromIndex = t - 1; }
    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
          var toX = index%grid[0];
          var toY = Math.floor(index/grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') { value = -distanceX; }
          if (axis === 'y') { value = -distanceY; }
          values.push(value);
        }
        maxValue = Math.max.apply(Math, values);
      }
      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
    }
    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
  }
}

// Timeline

function timeline(params) {
  if ( params === void 0 ) params = {};

  var tl = anime(params);
  tl.duration = 0;
  tl.add = function(instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;
    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
    function passThrough(ins) { ins.passThrough = true; }
    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();
    if (tl.autoplay) { tl.play(); }
    return tl;
  };
  return tl;
}

anime.version = '3.1.0';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

module.exports = anime;

},{}],35:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":42}],36:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/sign"), __esModule: true };
},{"core-js/library/fn/math/sign":43}],37:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/trunc"), __esModule: true };
},{"core-js/library/fn/math/trunc":44}],38:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-nan"), __esModule: true };
},{"core-js/library/fn/number/is-nan":45}],39:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/max-safe-integer"), __esModule: true };
},{"core-js/library/fn/number/max-safe-integer":46}],40:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":47}],41:[function(require,module,exports){
!function(e,t){if("function"==typeof define&&define.amd)define(["exports"],t);else if("undefined"!=typeof exports)t(exports);else{var o={};t(o),e.bodyScrollLock=o}}(this,function(exports){"use strict";function r(e){if(Array.isArray(e)){for(var t=0,o=Array(e.length);t<e.length;t++)o[t]=e[t];return o}return Array.from(e)}Object.defineProperty(exports,"__esModule",{value:!0});var l=!1;if("undefined"!=typeof window){var e={get passive(){l=!0}};window.addEventListener("testPassive",null,e),window.removeEventListener("testPassive",null,e)}var d="undefined"!=typeof window&&window.navigator&&window.navigator.platform&&/iP(ad|hone|od)/.test(window.navigator.platform),c=[],u=!1,a=-1,s=void 0,v=void 0,f=function(t){return c.some(function(e){return!(!e.options.allowTouchMove||!e.options.allowTouchMove(t))})},m=function(e){var t=e||window.event;return!!f(t.target)||(1<t.touches.length||(t.preventDefault&&t.preventDefault(),!1))},o=function(){setTimeout(function(){void 0!==v&&(document.body.style.paddingRight=v,v=void 0),void 0!==s&&(document.body.style.overflow=s,s=void 0)})};exports.disableBodyScroll=function(i,e){if(d){if(!i)return void console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");if(i&&!c.some(function(e){return e.targetElement===i})){var t={targetElement:i,options:e||{}};c=[].concat(r(c),[t]),i.ontouchstart=function(e){1===e.targetTouches.length&&(a=e.targetTouches[0].clientY)},i.ontouchmove=function(e){var t,o,n,r;1===e.targetTouches.length&&(o=i,r=(t=e).targetTouches[0].clientY-a,!f(t.target)&&(o&&0===o.scrollTop&&0<r?m(t):(n=o)&&n.scrollHeight-n.scrollTop<=n.clientHeight&&r<0?m(t):t.stopPropagation()))},u||(document.addEventListener("touchmove",m,l?{passive:!1}:void 0),u=!0)}}else{n=e,setTimeout(function(){if(void 0===v){var e=!!n&&!0===n.reserveScrollBarGap,t=window.innerWidth-document.documentElement.clientWidth;e&&0<t&&(v=document.body.style.paddingRight,document.body.style.paddingRight=t+"px")}void 0===s&&(s=document.body.style.overflow,document.body.style.overflow="hidden")});var o={targetElement:i,options:e||{}};c=[].concat(r(c),[o])}var n},exports.clearAllBodyScrollLocks=function(){d?(c.forEach(function(e){e.targetElement.ontouchstart=null,e.targetElement.ontouchmove=null}),u&&(document.removeEventListener("touchmove",m,l?{passive:!1}:void 0),u=!1),c=[],a=-1):(o(),c=[])},exports.enableBodyScroll=function(t){if(d){if(!t)return void console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");t.ontouchstart=null,t.ontouchmove=null,c=c.filter(function(e){return e.targetElement!==t}),u&&0===c.length&&(document.removeEventListener("touchmove",m,l?{passive:!1}:void 0),u=!1)}else 1===c.length&&c[0].targetElement===t?(o(),c=[]):c=c.filter(function(e){return e.targetElement!==t})}});

},{}],42:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;

},{"../../modules/_core":53,"../../modules/es6.array.from":101,"../../modules/es6.string.iterator":107}],43:[function(require,module,exports){
require('../../modules/es6.math.sign');
module.exports = require('../../modules/_core').Math.sign;

},{"../../modules/_core":53,"../../modules/es6.math.sign":102}],44:[function(require,module,exports){
require('../../modules/es6.math.trunc');
module.exports = require('../../modules/_core').Math.trunc;

},{"../../modules/_core":53,"../../modules/es6.math.trunc":103}],45:[function(require,module,exports){
require('../../modules/es6.number.is-nan');
module.exports = require('../../modules/_core').Number.isNaN;

},{"../../modules/_core":53,"../../modules/es6.number.is-nan":104}],46:[function(require,module,exports){
require('../../modules/es6.number.max-safe-integer');
module.exports = 0x1fffffffffffff;

},{"../../modules/es6.number.max-safe-integer":105}],47:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":53,"../../modules/es6.object.assign":106}],48:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],49:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":69}],50:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":92,"./_to-iobject":94,"./_to-length":95}],51:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":52,"./_wks":99}],52:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],53:[function(require,module,exports){
var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],54:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":79,"./_property-desc":86}],55:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":48}],56:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],57:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":61}],58:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":62,"./_is-object":69}],59:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],60:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":53,"./_ctx":55,"./_global":62,"./_has":63,"./_hide":64}],61:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],62:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],63:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],64:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":57,"./_object-dp":79,"./_property-desc":86}],65:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":62}],66:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":57,"./_dom-create":58,"./_fails":61}],67:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":52}],68:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":74,"./_wks":99}],69:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],70:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":49}],71:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":64,"./_object-create":78,"./_property-desc":86,"./_set-to-string-tag":88,"./_wks":99}],72:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":60,"./_hide":64,"./_iter-create":71,"./_iterators":74,"./_library":75,"./_object-gpo":82,"./_redefine":87,"./_set-to-string-tag":88,"./_wks":99}],73:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":99}],74:[function(require,module,exports){
module.exports = {};

},{}],75:[function(require,module,exports){
module.exports = true;

},{}],76:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],77:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":57,"./_fails":61,"./_iobject":67,"./_object-gops":81,"./_object-keys":84,"./_object-pie":85,"./_to-object":96}],78:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":49,"./_dom-create":58,"./_enum-bug-keys":59,"./_html":65,"./_object-dps":80,"./_shared-key":89}],79:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":49,"./_descriptors":57,"./_ie8-dom-define":66,"./_to-primitive":97}],80:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":49,"./_descriptors":57,"./_object-dp":79,"./_object-keys":84}],81:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],82:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":63,"./_shared-key":89,"./_to-object":96}],83:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":50,"./_has":63,"./_shared-key":89,"./_to-iobject":94}],84:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":59,"./_object-keys-internal":83}],85:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],86:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],87:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":64}],88:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":63,"./_object-dp":79,"./_wks":99}],89:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":90,"./_uid":98}],90:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":53,"./_global":62,"./_library":75}],91:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":56,"./_to-integer":93}],92:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":93}],93:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],94:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":56,"./_iobject":67}],95:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":93}],96:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":56}],97:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":69}],98:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],99:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":62,"./_shared":90,"./_uid":98}],100:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":51,"./_core":53,"./_iterators":74,"./_wks":99}],101:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":54,"./_ctx":55,"./_export":60,"./_is-array-iter":68,"./_iter-call":70,"./_iter-detect":73,"./_to-length":95,"./_to-object":96,"./core.get-iterator-method":100}],102:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":60,"./_math-sign":76}],103:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":60}],104:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":60}],105:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":60}],106:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":60,"./_object-assign":77}],107:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":72,"./_string-at":91}],108:[function(require,module,exports){
/* flatpickr v4.5.7, @license MIT */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.flatpickr = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition",
    ];
    var defaults = {
        _disable: [],
        _enable: [],
        allowInput: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" &&
            window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enable: [],
        enableSeconds: false,
        enableTime: false,
        errorHandler: function (err) {
            return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function (givenDate) {
            var date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0);
            // Thursday in current week decides the year.
            date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
            // January 4 is always in week 1.
            var week1 = new Date(date.getFullYear(), 0, 4);
            // Adjust to Thursday in week 1 and count number of weeks from date to week1.
            return (1 +
                Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                    3 +
                    ((week1.getDay() + 6) % 7)) /
                    7));
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: undefined,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
    };

    var english = {
        weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ]
        },
        months: {
            shorthand: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ],
            longhand: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function (nth) {
            var s = nth % 100;
            if (s > 3 && s < 21)
                return "th";
            switch (s % 10) {
                case 1:
                    return "st";
                case 2:
                    return "nd";
                case 3:
                    return "rd";
                default:
                    return "th";
            }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year"
    };

    var pad = function (number) { return ("0" + number).slice(-2); };
    var int = function (bool) { return (bool === true ? 1 : 0); };
    /* istanbul ignore next */
    function debounce(func, wait, immediate) {
        if (immediate === void 0) { immediate = false; }
        var timeout;
        return function () {
            var context = this, args = arguments;
            timeout !== null && clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            }, wait);
            if (immediate && !timeout)
                func.apply(context, args);
        };
    }
    var arrayify = function (obj) {
        return obj instanceof Array ? obj : [obj];
    };

    function toggleClass(elem, className, bool) {
        if (bool === true)
            return elem.classList.add(className);
        elem.classList.remove(className);
    }
    function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== undefined)
            e.textContent = content;
        return e;
    }
    function clearNode(node) {
        while (node.firstChild)
            node.removeChild(node.firstChild);
    }
    function findParent(node, condition) {
        if (condition(node))
            return node;
        else if (node.parentNode)
            return findParent(node.parentNode, condition);
        return undefined; // nothing found
    }
    function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
            numInput.type = "number";
        }
        else {
            numInput.type = "text";
            numInput.pattern = "\\d*";
        }
        if (opts !== undefined)
            for (var key in opts)
                numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
    }
    function getEventTarget(event) {
        if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
        }
        return event.target;
    }

    var do_nothing = function () { return undefined; };
    var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
    var revFormat = {
        D: do_nothing,
        F: function (dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        H: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        J: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        K: function (dateObj, amPM, locale) {
            dateObj.setHours((dateObj.getHours() % 12) +
                12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function (dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
        W: function (dateObj, weekNum) {
            var weekNumber = parseInt(weekNum);
            return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        },
        Y: function (dateObj, year) {
            dateObj.setFullYear(parseFloat(year));
        },
        Z: function (_, ISODate) { return new Date(ISODate); },
        d: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        h: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        i: function (dateObj, minutes) {
            dateObj.setMinutes(parseFloat(minutes));
        },
        j: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        l: do_nothing,
        m: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        u: function (_, unixMillSeconds) {
            return new Date(parseFloat(unixMillSeconds));
        },
        w: do_nothing,
        y: function (dateObj, year) {
            dateObj.setFullYear(2000 + parseFloat(year));
        }
    };
    var tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
    };
    var formats = {
        // get the date in UTC
        Z: function (date) { return date.toISOString(); },
        // weekday name, short, e.g. Thu
        D: function (date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        // full month name e.g. January
        F: function (date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        // padded hour 1-12
        G: function (date, locale, options) {
            return pad(formats.h(date, locale, options));
        },
        // hours with leading zero e.g. 03
        H: function (date) { return pad(date.getHours()); },
        // day (1-30) with ordinal suffix e.g. 1st, 2nd
        J: function (date, locale) {
            return locale.ordinal !== undefined
                ? date.getDate() + locale.ordinal(date.getDate())
                : date.getDate();
        },
        // AM/PM
        K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
        // shorthand month e.g. Jan, Sep, Oct, etc
        M: function (date, locale) {
            return monthToStr(date.getMonth(), true, locale);
        },
        // seconds 00-59
        S: function (date) { return pad(date.getSeconds()); },
        // unix timestamp
        U: function (date) { return date.getTime() / 1000; },
        W: function (date, _, options) {
            return options.getWeek(date);
        },
        // full year e.g. 2016
        Y: function (date) { return date.getFullYear(); },
        // day in month, padded (01-30)
        d: function (date) { return pad(date.getDate()); },
        // hour from 1-12 (am/pm)
        h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
        // minutes, padded with leading zero e.g. 09
        i: function (date) { return pad(date.getMinutes()); },
        // day in month (1-30)
        j: function (date) { return date.getDate(); },
        // weekday name, full, e.g. Thursday
        l: function (date, locale) {
            return locale.weekdays.longhand[date.getDay()];
        },
        // padded month number (01-12)
        m: function (date) { return pad(date.getMonth() + 1); },
        // the month number (1-12)
        n: function (date) { return date.getMonth() + 1; },
        // seconds 0-59
        s: function (date) { return date.getSeconds(); },
        // Unix Milliseconds
        u: function (date) { return date.getTime(); },
        // number of the day of the week
        w: function (date) { return date.getDay(); },
        // last two digits of year e.g. 16 for 2016
        y: function (date) { return String(date.getFullYear()).substring(2); }
    };

    var createDateFormatter = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (dateObj, frmt, overrideLocale) {
            var locale = overrideLocale || l10n;
            if (config.formatDate !== undefined) {
                return config.formatDate(dateObj, frmt, locale);
            }
            return frmt
                .split("")
                .map(function (c, i, arr) {
                return formats[c] && arr[i - 1] !== "\\"
                    ? formats[c](dateObj, locale, config)
                    : c !== "\\"
                        ? c
                        : "";
            })
                .join("");
        };
    };
    var createDateParser = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (date, givenFormat, timeless, customLocale) {
            if (date !== 0 && !date)
                return undefined;
            var locale = customLocale || l10n;
            var parsedDate;
            var date_orig = date;
            if (date instanceof Date)
                parsedDate = new Date(date.getTime());
            else if (typeof date !== "string" &&
                date.toFixed !== undefined // timestamp
            )
                // create a copy
                parsedDate = new Date(date);
            else if (typeof date === "string") {
                // date string
                var format = givenFormat || (config || defaults).dateFormat;
                var datestr = String(date).trim();
                if (datestr === "today") {
                    parsedDate = new Date();
                    timeless = true;
                }
                else if (/Z$/.test(datestr) ||
                    /GMT$/.test(datestr) // datestrings w/ timezone
                )
                    parsedDate = new Date(date);
                else if (config && config.parseDate)
                    parsedDate = config.parseDate(date, format);
                else {
                    parsedDate =
                        !config || !config.noCalendar
                            ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                            : new Date(new Date().setHours(0, 0, 0, 0));
                    var matched = void 0, ops = [];
                    for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                        var token_1 = format[i];
                        var isBackSlash = token_1 === "\\";
                        var escaped = format[i - 1] === "\\" || isBackSlash;
                        if (tokenRegex[token_1] && !escaped) {
                            regexStr += tokenRegex[token_1];
                            var match = new RegExp(regexStr).exec(date);
                            if (match && (matched = true)) {
                                ops[token_1 !== "Y" ? "push" : "unshift"]({
                                    fn: revFormat[token_1],
                                    val: match[++matchIndex]
                                });
                            }
                        }
                        else if (!isBackSlash)
                            regexStr += "."; // don't really care
                        ops.forEach(function (_a) {
                            var fn = _a.fn, val = _a.val;
                            return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                        });
                    }
                    parsedDate = matched ? parsedDate : undefined;
                }
            }
            /* istanbul ignore next */
            if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                config.errorHandler(new Error("Invalid date provided: " + date_orig));
                return undefined;
            }
            if (timeless === true)
                parsedDate.setHours(0, 0, 0, 0);
            return parsedDate;
        };
    };
    /**
     * Compute the difference in dates, measured in ms
     */
    function compareDates(date1, date2, timeless) {
        if (timeless === void 0) { timeless = true; }
        if (timeless !== false) {
            return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                new Date(date2.getTime()).setHours(0, 0, 0, 0));
        }
        return date1.getTime() - date2.getTime();
    }
    var isBetween = function (ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
    };
    var duration = {
        DAY: 86400000
    };

    if (typeof Object.assign !== "function") {
        Object.assign = function (target) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!target) {
                throw TypeError("Cannot convert undefined or null to object");
            }
            var _loop_1 = function (source) {
                if (source) {
                    Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
                }
            };
            for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                var source = args_1[_a];
                _loop_1(source);
            }
            return target;
        };
    }

    var DEBOUNCED_CHANGE_MS = 300;
    function FlatpickrInstance(element, instanceConfig) {
        var self = {
            config: __assign({}, flatpickr.defaultConfig),
            l10n: english
        };
        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        self._handlers = [];
        self._bind = bind;
        self._setHoursFromDate = setHoursFromDate;
        self._positionCalendar = positionCalendar;
        self.changeMonth = changeMonth;
        self.changeYear = changeYear;
        self.clear = clear;
        self.close = close;
        self._createElement = createElement;
        self.destroy = destroy;
        self.isEnabled = isEnabled;
        self.jumpToDate = jumpToDate;
        self.open = open;
        self.redraw = redraw;
        self.set = set;
        self.setDate = setDate;
        self.toggle = toggle;
        function setupHelperFunctions() {
            self.utils = {
                getDaysInMonth: function (month, yr) {
                    if (month === void 0) { month = self.currentMonth; }
                    if (yr === void 0) { yr = self.currentYear; }
                    if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                        return 29;
                    return self.l10n.daysInMonth[month];
                }
            };
        }
        function init() {
            self.element = self.input = element;
            self.isOpen = false;
            parseConfig();
            setupLocale();
            setupInputs();
            setupDates();
            setupHelperFunctions();
            if (!self.isMobile)
                build();
            bindEvents();
            if (self.selectedDates.length || self.config.noCalendar) {
                if (self.config.enableTime) {
                    setHoursFromDate(self.config.noCalendar
                        ? self.latestSelectedDateObj || self.config.minDate
                        : undefined);
                }
                updateValue(false);
            }
            setCalendarWidth();
            self.showTimeInput =
                self.selectedDates.length > 0 || self.config.noCalendar;
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            /* TODO: investigate this further
        
              Currently, there is weird positioning behavior in safari causing pages
              to scroll up. https://github.com/chmln/flatpickr/issues/563
        
              However, most browsers are not Safari and positioning is expensive when used
              in scale. https://github.com/chmln/flatpickr/issues/1096
            */
            if (!self.isMobile && isSafari) {
                positionCalendar();
            }
            triggerEvent("onReady");
        }
        function bindToInstance(fn) {
            return fn.bind(self);
        }
        function setCalendarWidth() {
            var config = self.config;
            if (config.weekNumbers === false && config.showMonths === 1)
                return;
            else if (config.noCalendar !== true) {
                window.requestAnimationFrame(function () {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.style.visibility = "hidden";
                        self.calendarContainer.style.display = "block";
                    }
                    if (self.daysContainer !== undefined) {
                        var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                        self.daysContainer.style.width = daysWidth + "px";
                        self.calendarContainer.style.width =
                            daysWidth +
                                (self.weekWrapper !== undefined
                                    ? self.weekWrapper.offsetWidth
                                    : 0) +
                                "px";
                        self.calendarContainer.style.removeProperty("visibility");
                        self.calendarContainer.style.removeProperty("display");
                    }
                });
            }
        }
        /**
         * The handler for all events targeting the time inputs
         */
        function updateTime(e) {
            if (self.selectedDates.length === 0) {
                setDefaultTime();
            }
            if (e !== undefined && e.type !== "blur") {
                timeWrapper(e);
            }
            var prevValue = self._input.value;
            setHoursFromInputs();
            updateValue();
            if (self._input.value !== prevValue) {
                self._debouncedChange();
            }
        }
        function ampm2military(hour, amPM) {
            return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
        }
        function military2ampm(hour) {
            switch (hour % 24) {
                case 0:
                case 12:
                    return 12;
                default:
                    return hour % 12;
            }
        }
        /**
         * Syncs the selected date object time with user's time input
         */
        function setHoursFromInputs() {
            if (self.hourElement === undefined || self.minuteElement === undefined)
                return;
            var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                ? (parseInt(self.secondElement.value, 10) || 0) % 60
                : 0;
            if (self.amPM !== undefined) {
                hours = ampm2military(hours, self.amPM.textContent);
            }
            var limitMinHours = self.config.minTime !== undefined ||
                (self.config.minDate &&
                    self.minDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                        0);
            var limitMaxHours = self.config.maxTime !== undefined ||
                (self.config.maxDate &&
                    self.maxDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                        0);
            if (limitMaxHours) {
                var maxTime = self.config.maxTime !== undefined
                    ? self.config.maxTime
                    : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                    minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                    seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                var minTime = self.config.minTime !== undefined
                    ? self.config.minTime
                    : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours())
                    minutes = Math.max(minutes, minTime.getMinutes());
                if (minutes === minTime.getMinutes())
                    seconds = Math.max(seconds, minTime.getSeconds());
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Syncs time input values with a date
         */
        function setHoursFromDate(dateObj) {
            var date = dateObj || self.latestSelectedDateObj;
            if (date)
                setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }
        function setDefaultHours() {
            var hours = self.config.defaultHour;
            var minutes = self.config.defaultMinute;
            var seconds = self.config.defaultSeconds;
            if (self.config.minDate !== undefined) {
                var min_hr = self.config.minDate.getHours();
                var min_minutes = self.config.minDate.getMinutes();
                hours = Math.max(hours, min_hr);
                if (hours === min_hr)
                    minutes = Math.max(min_minutes, minutes);
                if (hours === min_hr && minutes === min_minutes)
                    seconds = self.config.minDate.getSeconds();
            }
            if (self.config.maxDate !== undefined) {
                var max_hr = self.config.maxDate.getHours();
                var max_minutes = self.config.maxDate.getMinutes();
                hours = Math.min(hours, max_hr);
                if (hours === max_hr)
                    minutes = Math.min(max_minutes, minutes);
                if (hours === max_hr && minutes === max_minutes)
                    seconds = self.config.maxDate.getSeconds();
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Sets the hours, minutes, and optionally seconds
         * of the latest selected date object and the
         * corresponding time inputs
         * @param {Number} hours the hour. whether its military
         *                 or am-pm gets inferred from config
         * @param {Number} minutes the minutes
         * @param {Number} seconds the seconds (optional)
         */
        function setHours(hours, minutes, seconds) {
            if (self.latestSelectedDateObj !== undefined) {
                self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
            }
            if (!self.hourElement || !self.minuteElement || self.isMobile)
                return;
            self.hourElement.value = pad(!self.config.time_24hr
                ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
                : hours);
            self.minuteElement.value = pad(minutes);
            if (self.amPM !== undefined)
                self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
            if (self.secondElement !== undefined)
                self.secondElement.value = pad(seconds);
        }
        /**
         * Handles the year input and incrementing events
         * @param {Event} event the keyup or increment event
         */
        function onYearInput(event) {
            var year = parseInt(event.target.value) + (event.delta || 0);
            if (year / 1000 > 1 ||
                (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                changeYear(year);
            }
        }
        /**
         * Essentially addEventListener + tracking
         * @param {Element} element the element to addEventListener to
         * @param {String} event the event name
         * @param {Function} handler the event handler
         */
        function bind(element, event, handler, options) {
            if (event instanceof Array)
                return event.forEach(function (ev) { return bind(element, ev, handler, options); });
            if (element instanceof Array)
                return element.forEach(function (el) { return bind(el, event, handler, options); });
            element.addEventListener(event, handler, options);
            self._handlers.push({
                element: element,
                event: event,
                handler: handler,
                options: options
            });
        }
        /**
         * A mousedown handler which mimics click.
         * Minimizes latency, since we don't need to wait for mouseup in most cases.
         * Also, avoids handling right clicks.
         *
         * @param {Function} handler the event handler
         */
        function onClick(handler) {
            return function (evt) {
                evt.which === 1 && handler(evt);
            };
        }
        function triggerChange() {
            triggerEvent("onChange");
        }
        /**
         * Adds all the necessary event listeners
         */
        function bindEvents() {
            if (self.config.wrap) {
                ["open", "close", "toggle", "clear"].forEach(function (evt) {
                    Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                        return bind(el, "click", self[evt]);
                    });
                });
            }
            if (self.isMobile) {
                setupMobile();
                return;
            }
            var debouncedResize = debounce(onResize, 50);
            self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
            if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                bind(self.daysContainer, "mouseover", function (e) {
                    if (self.config.mode === "range")
                        onMouseOver(e.target);
                });
            bind(window.document.body, "keydown", onKeyDown);
            if (!self.config.static)
                bind(self._input, "keydown", onKeyDown);
            if (!self.config.inline && !self.config.static)
                bind(window, "resize", debouncedResize);
            if (window.ontouchstart !== undefined)
                bind(window.document, "click", documentClick);
            else
                bind(window.document, "mousedown", onClick(documentClick));
            bind(window.document, "focus", documentClick, { capture: true });
            if (self.config.clickOpens === true) {
                bind(self._input, "focus", self.open);
                bind(self._input, "mousedown", onClick(self.open));
            }
            if (self.daysContainer !== undefined) {
                bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
                bind(self.monthNav, ["keyup", "increment"], onYearInput);
                bind(self.daysContainer, "mousedown", onClick(selectDate));
            }
            if (self.timeContainer !== undefined &&
                self.minuteElement !== undefined &&
                self.hourElement !== undefined) {
                var selText = function (e) {
                    return e.target.select();
                };
                bind(self.timeContainer, ["increment"], updateTime);
                bind(self.timeContainer, "blur", updateTime, { capture: true });
                bind(self.timeContainer, "mousedown", onClick(timeIncrement));
                bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                if (self.secondElement !== undefined)
                    bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
                if (self.amPM !== undefined) {
                    bind(self.amPM, "mousedown", onClick(function (e) {
                        updateTime(e);
                        triggerChange();
                    }));
                }
            }
        }
        /**
         * Set the calendar view to a particular date.
         * @param {Date} jumpDate the date to set the view to
         */
        function jumpToDate(jumpDate) {
            var jumpTo = jumpDate !== undefined
                ? self.parseDate(jumpDate)
                : self.latestSelectedDateObj ||
                    (self.config.minDate && self.config.minDate > self.now
                        ? self.config.minDate
                        : self.config.maxDate && self.config.maxDate < self.now
                            ? self.config.maxDate
                            : self.now);
            try {
                if (jumpTo !== undefined) {
                    self.currentYear = jumpTo.getFullYear();
                    self.currentMonth = jumpTo.getMonth();
                }
            }
            catch (e) {
                /* istanbul ignore next */
                e.message = "Invalid date supplied: " + jumpTo;
                self.config.errorHandler(e);
            }
            self.redraw();
        }
        /**
         * The up/down arrow handler for time inputs
         * @param {Event} e the click event
         */
        function timeIncrement(e) {
            if (~e.target.className.indexOf("arrow"))
                incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
        }
        /**
         * Increments/decrements the value of input associ-
         * ated with the up/down arrow by dispatching an
         * "increment" event on the input.
         *
         * @param {Event} e the click event
         * @param {Number} delta the diff (usually 1 or -1)
         * @param {Element} inputElem the input element
         */
        function incrementNumInput(e, delta, inputElem) {
            var target = e && e.target;
            var input = inputElem ||
                (target && target.parentNode && target.parentNode.firstChild);
            var event = createEvent("increment");
            event.delta = delta;
            input && input.dispatchEvent(event);
        }
        function build() {
            var fragment = window.document.createDocumentFragment();
            self.calendarContainer = createElement("div", "flatpickr-calendar");
            self.calendarContainer.tabIndex = -1;
            if (!self.config.noCalendar) {
                fragment.appendChild(buildMonthNav());
                self.innerContainer = createElement("div", "flatpickr-innerContainer");
                if (self.config.weekNumbers) {
                    var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                    self.innerContainer.appendChild(weekWrapper);
                    self.weekNumbers = weekNumbers;
                    self.weekWrapper = weekWrapper;
                }
                self.rContainer = createElement("div", "flatpickr-rContainer");
                self.rContainer.appendChild(buildWeekdays());
                if (!self.daysContainer) {
                    self.daysContainer = createElement("div", "flatpickr-days");
                    self.daysContainer.tabIndex = -1;
                }
                buildDays();
                self.rContainer.appendChild(self.daysContainer);
                self.innerContainer.appendChild(self.rContainer);
                fragment.appendChild(self.innerContainer);
            }
            if (self.config.enableTime) {
                fragment.appendChild(buildTime());
            }
            toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
            toggleClass(self.calendarContainer, "animate", self.config.animate === true);
            toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
            self.calendarContainer.appendChild(fragment);
            var customAppend = self.config.appendTo !== undefined &&
                self.config.appendTo.nodeType !== undefined;
            if (self.config.inline || self.config.static) {
                self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                if (self.config.inline) {
                    if (!customAppend && self.element.parentNode)
                        self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                    else if (self.config.appendTo !== undefined)
                        self.config.appendTo.appendChild(self.calendarContainer);
                }
                if (self.config.static) {
                    var wrapper = createElement("div", "flatpickr-wrapper");
                    if (self.element.parentNode)
                        self.element.parentNode.insertBefore(wrapper, self.element);
                    wrapper.appendChild(self.element);
                    if (self.altInput)
                        wrapper.appendChild(self.altInput);
                    wrapper.appendChild(self.calendarContainer);
                }
            }
            if (!self.config.static && !self.config.inline)
                (self.config.appendTo !== undefined
                    ? self.config.appendTo
                    : window.document.body).appendChild(self.calendarContainer);
        }
        function createDay(className, date, dayNumber, i) {
            var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
            dayElement.dateObj = date;
            dayElement.$i = i;
            dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
            if (className.indexOf("hidden") === -1 &&
                compareDates(date, self.now) === 0) {
                self.todayDateElem = dayElement;
                dayElement.classList.add("today");
                dayElement.setAttribute("aria-current", "date");
            }
            if (dateIsEnabled) {
                dayElement.tabIndex = -1;
                if (isDateSelected(date)) {
                    dayElement.classList.add("selected");
                    self.selectedDateElem = dayElement;
                    if (self.config.mode === "range") {
                        toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                            compareDates(date, self.selectedDates[0], true) === 0);
                        toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                            compareDates(date, self.selectedDates[1], true) === 0);
                        if (className === "nextMonthDay")
                            dayElement.classList.add("inRange");
                    }
                }
            }
            else {
                dayElement.classList.add("disabled");
            }
            if (self.config.mode === "range") {
                if (isDateInRange(date) && !isDateSelected(date))
                    dayElement.classList.add("inRange");
            }
            if (self.weekNumbers &&
                self.config.showMonths === 1 &&
                className !== "prevMonthDay" &&
                dayNumber % 7 === 1) {
                self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
            }
            triggerEvent("onDayCreate", dayElement);
            return dayElement;
        }
        function focusOnDayElem(targetNode) {
            targetNode.focus();
            if (self.config.mode === "range")
                onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
            var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            for (var m = startMonth; m != endMonth; m += delta) {
                var month = self.daysContainer.children[m];
                var startIndex = delta > 0 ? 0 : month.children.length - 1;
                var endIndex = delta > 0 ? month.children.length : -1;
                for (var i = startIndex; i != endIndex; i += delta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                        return c;
                }
            }
            return undefined;
        }
        function getNextAvailableDay(current, delta) {
            var givenMonth = current.className.indexOf("Month") === -1
                ? current.dateObj.getMonth()
                : self.currentMonth;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            var loopDelta = delta > 0 ? 1 : -1;
            for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                var month = self.daysContainer.children[m];
                var startIndex = givenMonth - self.currentMonth === m
                    ? current.$i + delta
                    : delta < 0
                        ? month.children.length - 1
                        : 0;
                var numMonthDays = month.children.length;
                for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 &&
                        isEnabled(c.dateObj) &&
                        Math.abs(current.$i - i) >= Math.abs(delta))
                        return focusOnDayElem(c);
                }
            }
            self.changeMonth(loopDelta);
            focusOnDay(getFirstAvailableDay(loopDelta), 0);
            return undefined;
        }
        function focusOnDay(current, offset) {
            var dayFocused = isInView(document.activeElement || document.body);
            var startElem = current !== undefined
                ? current
                : dayFocused
                    ? document.activeElement
                    : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                        ? self.selectedDateElem
                        : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                            ? self.todayDateElem
                            : getFirstAvailableDay(offset > 0 ? 1 : -1);
            if (startElem === undefined)
                return self._input.focus();
            if (!dayFocused)
                return focusOnDayElem(startElem);
            getNextAvailableDay(startElem, offset);
        }
        function buildMonthDays(year, month) {
            var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
            var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
            var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
            var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
            // prepend days from the ending of previous month
            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
            }
            // Start at 1 since there is no 0th day
            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
            }
            // append days from the next month
            for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
            }
            //updateNavigationCurrentMonth();
            var dayContainer = createElement("div", "dayContainer");
            dayContainer.appendChild(days);
            return dayContainer;
        }
        function buildDays() {
            if (self.daysContainer === undefined) {
                return;
            }
            clearNode(self.daysContainer);
            // TODO: week numbers for each month
            if (self.weekNumbers)
                clearNode(self.weekNumbers);
            var frag = document.createDocumentFragment();
            for (var i = 0; i < self.config.showMonths; i++) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
            }
            self.daysContainer.appendChild(frag);
            self.days = self.daysContainer.firstChild;
            if (self.config.mode === "range" && self.selectedDates.length === 1) {
                onMouseOver();
            }
        }
        function buildMonth() {
            var container = createElement("div", "flatpickr-month");
            var monthNavFragment = window.document.createDocumentFragment();
            var monthElement = createElement("span", "cur-month");
            var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
            var yearElement = yearInput.getElementsByTagName("input")[0];
            yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
            if (self.config.minDate) {
                yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
            }
            if (self.config.maxDate) {
                yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                yearElement.disabled =
                    !!self.config.minDate &&
                        self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
            }
            var currentMonth = createElement("div", "flatpickr-current-month");
            currentMonth.appendChild(monthElement);
            currentMonth.appendChild(yearInput);
            monthNavFragment.appendChild(currentMonth);
            container.appendChild(monthNavFragment);
            return {
                container: container,
                yearElement: yearElement,
                monthElement: monthElement
            };
        }
        function buildMonths() {
            clearNode(self.monthNav);
            self.monthNav.appendChild(self.prevMonthNav);
            if (self.config.showMonths) {
                self.yearElements = [];
                self.monthElements = [];
            }
            for (var m = self.config.showMonths; m--;) {
                var month = buildMonth();
                self.yearElements.push(month.yearElement);
                self.monthElements.push(month.monthElement);
                self.monthNav.appendChild(month.container);
            }
            self.monthNav.appendChild(self.nextMonthNav);
        }
        function buildMonthNav() {
            self.monthNav = createElement("div", "flatpickr-months");
            self.yearElements = [];
            self.monthElements = [];
            self.prevMonthNav = createElement("span", "flatpickr-prev-month");
            self.prevMonthNav.innerHTML = self.config.prevArrow;
            self.nextMonthNav = createElement("span", "flatpickr-next-month");
            self.nextMonthNav.innerHTML = self.config.nextArrow;
            buildMonths();
            Object.defineProperty(self, "_hidePrevMonthArrow", {
                get: function () { return self.__hidePrevMonthArrow; },
                set: function (bool) {
                    if (self.__hidePrevMonthArrow !== bool) {
                        toggleClass(self.prevMonthNav, "disabled", bool);
                        self.__hidePrevMonthArrow = bool;
                    }
                }
            });
            Object.defineProperty(self, "_hideNextMonthArrow", {
                get: function () { return self.__hideNextMonthArrow; },
                set: function (bool) {
                    if (self.__hideNextMonthArrow !== bool) {
                        toggleClass(self.nextMonthNav, "disabled", bool);
                        self.__hideNextMonthArrow = bool;
                    }
                }
            });
            self.currentYearElement = self.yearElements[0];
            updateNavigationCurrentMonth();
            return self.monthNav;
        }
        function buildTime() {
            self.calendarContainer.classList.add("hasTime");
            if (self.config.noCalendar)
                self.calendarContainer.classList.add("noCalendar");
            self.timeContainer = createElement("div", "flatpickr-time");
            self.timeContainer.tabIndex = -1;
            var separator = createElement("span", "flatpickr-time-separator", ":");
            var hourInput = createNumberInput("flatpickr-hour");
            self.hourElement = hourInput.getElementsByTagName("input")[0];
            var minuteInput = createNumberInput("flatpickr-minute");
            self.minuteElement = minuteInput.getElementsByTagName("input")[0];
            self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
            self.hourElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getHours()
                : self.config.time_24hr
                    ? self.config.defaultHour
                    : military2ampm(self.config.defaultHour));
            self.minuteElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getMinutes()
                : self.config.defaultMinute);
            self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
            self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
            self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
            self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
            self.minuteElement.setAttribute("min", "0");
            self.minuteElement.setAttribute("max", "59");
            self.timeContainer.appendChild(hourInput);
            self.timeContainer.appendChild(separator);
            self.timeContainer.appendChild(minuteInput);
            if (self.config.time_24hr)
                self.timeContainer.classList.add("time24hr");
            if (self.config.enableSeconds) {
                self.timeContainer.classList.add("hasSeconds");
                var secondInput = createNumberInput("flatpickr-second");
                self.secondElement = secondInput.getElementsByTagName("input")[0];
                self.secondElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getSeconds()
                    : self.config.defaultSeconds);
                self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                self.secondElement.setAttribute("min", "0");
                self.secondElement.setAttribute("max", "59");
                self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                self.timeContainer.appendChild(secondInput);
            }
            if (!self.config.time_24hr) {
                // add self.amPM if appropriate
                self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                    ? self.hourElement.value
                    : self.config.defaultHour) > 11)]);
                self.amPM.title = self.l10n.toggleTitle;
                self.amPM.tabIndex = -1;
                self.timeContainer.appendChild(self.amPM);
            }
            return self.timeContainer;
        }
        function buildWeekdays() {
            if (!self.weekdayContainer)
                self.weekdayContainer = createElement("div", "flatpickr-weekdays");
            else
                clearNode(self.weekdayContainer);
            for (var i = self.config.showMonths; i--;) {
                var container = createElement("div", "flatpickr-weekdaycontainer");
                self.weekdayContainer.appendChild(container);
            }
            updateWeekdays();
            return self.weekdayContainer;
        }
        function updateWeekdays() {
            var firstDayOfWeek = self.l10n.firstDayOfWeek;
            var weekdays = self.l10n.weekdays.shorthand.slice();
            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
            }
            for (var i = self.config.showMonths; i--;) {
                self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
            }
        }
        /* istanbul ignore next */
        function buildWeeks() {
            self.calendarContainer.classList.add("hasWeeks");
            var weekWrapper = createElement("div", "flatpickr-weekwrapper");
            weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
            var weekNumbers = createElement("div", "flatpickr-weeks");
            weekWrapper.appendChild(weekNumbers);
            return {
                weekWrapper: weekWrapper,
                weekNumbers: weekNumbers
            };
        }
        function changeMonth(value, is_offset) {
            if (is_offset === void 0) { is_offset = true; }
            var delta = is_offset ? value : value - self.currentMonth;
            if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                (delta > 0 && self._hideNextMonthArrow === true))
                return;
            self.currentMonth += delta;
            if (self.currentMonth < 0 || self.currentMonth > 11) {
                self.currentYear += self.currentMonth > 11 ? 1 : -1;
                self.currentMonth = (self.currentMonth + 12) % 12;
                triggerEvent("onYearChange");
            }
            buildDays();
            triggerEvent("onMonthChange");
            updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent, toInitial) {
            if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
            if (toInitial === void 0) { toInitial = true; }
            self.input.value = "";
            if (self.altInput !== undefined)
                self.altInput.value = "";
            if (self.mobileInput !== undefined)
                self.mobileInput.value = "";
            self.selectedDates = [];
            self.latestSelectedDateObj = undefined;
            if (toInitial === true) {
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
            }
            self.showTimeInput = false;
            if (self.config.enableTime === true) {
                setDefaultHours();
            }
            self.redraw();
            if (triggerChangeEvent)
                // triggerChangeEvent is true (default) or an Event
                triggerEvent("onChange");
        }
        function close() {
            self.isOpen = false;
            if (!self.isMobile) {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.classList.remove("open");
                }
                if (self._input !== undefined) {
                    self._input.classList.remove("active");
                }
            }
            triggerEvent("onClose");
        }
        function destroy() {
            if (self.config !== undefined)
                triggerEvent("onDestroy");
            for (var i = self._handlers.length; i--;) {
                var h = self._handlers[i];
                h.element.removeEventListener(h.event, h.handler, h.options);
            }
            self._handlers = [];
            if (self.mobileInput) {
                if (self.mobileInput.parentNode)
                    self.mobileInput.parentNode.removeChild(self.mobileInput);
                self.mobileInput = undefined;
            }
            else if (self.calendarContainer && self.calendarContainer.parentNode) {
                if (self.config.static && self.calendarContainer.parentNode) {
                    var wrapper = self.calendarContainer.parentNode;
                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                    if (wrapper.parentNode) {
                        while (wrapper.firstChild)
                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                    }
                }
                else
                    self.calendarContainer.parentNode.removeChild(self.calendarContainer);
            }
            if (self.altInput) {
                self.input.type = "text";
                if (self.altInput.parentNode)
                    self.altInput.parentNode.removeChild(self.altInput);
                delete self.altInput;
            }
            if (self.input) {
                self.input.type = self.input._type;
                self.input.classList.remove("flatpickr-input");
                self.input.removeAttribute("readonly");
                self.input.value = "";
            }
            [
                "_showTimeInput",
                "latestSelectedDateObj",
                "_hideNextMonthArrow",
                "_hidePrevMonthArrow",
                "__hideNextMonthArrow",
                "__hidePrevMonthArrow",
                "isMobile",
                "isOpen",
                "selectedDateElem",
                "minDateHasTime",
                "maxDateHasTime",
                "days",
                "daysContainer",
                "_input",
                "_positionElement",
                "innerContainer",
                "rContainer",
                "monthNav",
                "todayDateElem",
                "calendarContainer",
                "weekdayContainer",
                "prevMonthNav",
                "nextMonthNav",
                "currentMonthElement",
                "currentYearElement",
                "navigationCurrentMonth",
                "selectedDateElem",
                "config",
            ].forEach(function (k) {
                try {
                    delete self[k];
                }
                catch (_) { }
            });
        }
        function isCalendarElem(elem) {
            if (self.config.appendTo && self.config.appendTo.contains(elem))
                return true;
            return self.calendarContainer.contains(elem);
        }
        function documentClick(e) {
            if (self.isOpen && !self.config.inline) {
                var eventTarget_1 = getEventTarget(e);
                var isCalendarElement = isCalendarElem(eventTarget_1);
                var isInput = eventTarget_1 === self.input ||
                    eventTarget_1 === self.altInput ||
                    self.element.contains(eventTarget_1) ||
                    // web components
                    // e.path is not present in all browsers. circumventing typechecks
                    (e.path &&
                        e.path.indexOf &&
                        (~e.path.indexOf(self.input) ||
                            ~e.path.indexOf(self.altInput)));
                var lostFocus = e.type === "blur"
                    ? isInput &&
                        e.relatedTarget &&
                        !isCalendarElem(e.relatedTarget)
                    : !isInput &&
                        !isCalendarElement &&
                        !isCalendarElem(e.relatedTarget);
                var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                    return elem.contains(eventTarget_1);
                });
                if (lostFocus && isIgnored) {
                    self.close();
                    if (self.config.mode === "range" && self.selectedDates.length === 1) {
                        self.clear(false);
                        self.redraw();
                    }
                }
            }
        }
        function changeYear(newYear) {
            if (!newYear ||
                (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                return;
            var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
            self.currentYear = newYearNum || self.currentYear;
            if (self.config.maxDate &&
                self.currentYear === self.config.maxDate.getFullYear()) {
                self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
            }
            else if (self.config.minDate &&
                self.currentYear === self.config.minDate.getFullYear()) {
                self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
            }
            if (isNewYear) {
                self.redraw();
                triggerEvent("onYearChange");
            }
        }
        function isEnabled(date, timeless) {
            if (timeless === void 0) { timeless = true; }
            var dateToCheck = self.parseDate(date, undefined, timeless); // timeless
            if ((self.config.minDate &&
                dateToCheck &&
                compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                (self.config.maxDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                return false;
            if (self.config.enable.length === 0 && self.config.disable.length === 0)
                return true;
            if (dateToCheck === undefined)
                return false;
            var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;
            for (var i = 0, d = void 0; i < array.length; i++) {
                d = array[i];
                if (typeof d === "function" &&
                    d(dateToCheck) // disabled by function
                )
                    return bool;
                else if (d instanceof Date &&
                    dateToCheck !== undefined &&
                    d.getTime() === dateToCheck.getTime())
                    // disabled by date
                    return bool;
                else if (typeof d === "string" && dateToCheck !== undefined) {
                    // disabled by date string
                    var parsed = self.parseDate(d, undefined, true);
                    return parsed && parsed.getTime() === dateToCheck.getTime()
                        ? bool
                        : !bool;
                }
                else if (
                // disabled by range
                typeof d === "object" &&
                    dateToCheck !== undefined &&
                    d.from &&
                    d.to &&
                    dateToCheck.getTime() >= d.from.getTime() &&
                    dateToCheck.getTime() <= d.to.getTime())
                    return bool;
            }
            return !bool;
        }
        function isInView(elem) {
            if (self.daysContainer !== undefined)
                return (elem.className.indexOf("hidden") === -1 &&
                    self.daysContainer.contains(elem));
            return false;
        }
        function onKeyDown(e) {
            // e.key                      e.keyCode
            // "Backspace"                        8
            // "Tab"                              9
            // "Enter"                           13
            // "Escape"     (IE "Esc")           27
            // "ArrowLeft"  (IE "Left")          37
            // "ArrowUp"    (IE "Up")            38
            // "ArrowRight" (IE "Right")         39
            // "ArrowDown"  (IE "Down")          40
            // "Delete"     (IE "Del")           46
            var isInput = e.target === self._input;
            var allowInput = self.config.allowInput;
            var allowKeydown = self.isOpen && (!allowInput || !isInput);
            var allowInlineKeydown = self.config.inline && isInput && !allowInput;
            if (e.keyCode === 13 && isInput) {
                if (allowInput) {
                    self.setDate(self._input.value, true, e.target === self.altInput
                        ? self.config.altFormat
                        : self.config.dateFormat);
                    return e.target.blur();
                }
                else
                    self.open();
            }
            else if (isCalendarElem(e.target) ||
                allowKeydown ||
                allowInlineKeydown) {
                var isTimeObj = !!self.timeContainer &&
                    self.timeContainer.contains(e.target);
                switch (e.keyCode) {
                    case 13:
                        if (isTimeObj) {
                            updateTime();
                            focusAndClose();
                        }
                        else
                            selectDate(e);
                        break;
                    case 27: // escape
                        e.preventDefault();
                        focusAndClose();
                        break;
                    case 8:
                    case 46:
                        if (isInput && !self.config.allowInput) {
                            e.preventDefault();
                            self.clear();
                        }
                        break;
                    case 37:
                    case 39:
                        if (!isTimeObj) {
                            e.preventDefault();
                            if (self.daysContainer !== undefined &&
                                (allowInput === false ||
                                    (document.activeElement && isInView(document.activeElement)))) {
                                var delta_1 = e.keyCode === 39 ? 1 : -1;
                                if (!e.ctrlKey)
                                    focusOnDay(undefined, delta_1);
                                else {
                                    e.stopPropagation();
                                    changeMonth(delta_1);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                            }
                        }
                        else if (self.hourElement)
                            self.hourElement.focus();
                        break;
                    case 38:
                    case 40:
                        e.preventDefault();
                        var delta = e.keyCode === 40 ? 1 : -1;
                        if ((self.daysContainer && e.target.$i !== undefined) ||
                            e.target === self.input) {
                            if (e.ctrlKey) {
                                e.stopPropagation();
                                changeYear(self.currentYear - delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                            else if (!isTimeObj)
                                focusOnDay(undefined, delta * 7);
                        }
                        else if (self.config.enableTime) {
                            if (!isTimeObj && self.hourElement)
                                self.hourElement.focus();
                            updateTime(e);
                            self._debouncedChange();
                        }
                        break;
                    case 9:
                        if (isTimeObj) {
                            var elems = [
                                self.hourElement,
                                self.minuteElement,
                                self.secondElement,
                                self.amPM,
                            ].filter(function (x) { return x; });
                            var i = elems.indexOf(e.target);
                            if (i !== -1) {
                                var target = elems[i + (e.shiftKey ? -1 : 1)];
                                if (target !== undefined) {
                                    e.preventDefault();
                                    target.focus();
                                }
                                else if (e.shiftKey) {
                                    e.preventDefault();
                                    self._input.focus();
                                }
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
            if (self.amPM !== undefined && e.target === self.amPM) {
                switch (e.key) {
                    case self.l10n.amPM[0].charAt(0):
                    case self.l10n.amPM[0].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[0];
                        setHoursFromInputs();
                        updateValue();
                        break;
                    case self.l10n.amPM[1].charAt(0):
                    case self.l10n.amPM[1].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[1];
                        setHoursFromInputs();
                        updateValue();
                        break;
                }
            }
            triggerEvent("onKeyDown", e);
        }
        function onMouseOver(elem) {
            if (self.selectedDates.length !== 1 ||
                (elem &&
                    (!elem.classList.contains("flatpickr-day") ||
                        elem.classList.contains("disabled"))))
                return;
            var hoverDate = elem
                ? elem.dateObj.getTime()
                : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime()), lastDate = self.daysContainer.lastChild
                .lastChild.dateObj.getTime();
            var containsDisabled = false;
            var minRange = 0, maxRange = 0;
            for (var t = rangeStartDate; t < lastDate; t += duration.DAY) {
                if (!isEnabled(new Date(t), true)) {
                    containsDisabled =
                        containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                    if (t < initialDate && (!minRange || t > minRange))
                        minRange = t;
                    else if (t > initialDate && (!maxRange || t < maxRange))
                        maxRange = t;
                }
            }
            for (var m = 0; m < self.config.showMonths; m++) {
                var month = self.daysContainer.children[m];
                var prevMonth = self.daysContainer.children[m - 1];
                var _loop_1 = function (i, l) {
                    var dayElem = month.children[i], date = dayElem.dateObj;
                    var timestamp = date.getTime();
                    var outOfRange = (minRange > 0 && timestamp < minRange) ||
                        (maxRange > 0 && timestamp > maxRange);
                    if (outOfRange) {
                        dayElem.classList.add("notAllowed");
                        ["inRange", "startRange", "endRange"].forEach(function (c) {
                            dayElem.classList.remove(c);
                        });
                        return "continue";
                    }
                    else if (containsDisabled && !outOfRange)
                        return "continue";
                    ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                        dayElem.classList.remove(c);
                    });
                    if (elem !== undefined) {
                        elem.classList.add(hoverDate < self.selectedDates[0].getTime()
                            ? "startRange"
                            : "endRange");
                        if (month.contains(elem) ||
                            !(m > 0 &&
                                prevMonth &&
                                prevMonth.lastChild.dateObj.getTime() >= timestamp)) {
                            if (initialDate < hoverDate && timestamp === initialDate)
                                dayElem.classList.add("startRange");
                            else if (initialDate > hoverDate && timestamp === initialDate)
                                dayElem.classList.add("endRange");
                            if (timestamp >= minRange &&
                                (maxRange === 0 || timestamp <= maxRange) &&
                                isBetween(timestamp, initialDate, hoverDate))
                                dayElem.classList.add("inRange");
                        }
                    }
                };
                for (var i = 0, l = month.children.length; i < l; i++) {
                    _loop_1(i, l);
                }
            }
        }
        function onResize() {
            if (self.isOpen && !self.config.static && !self.config.inline)
                positionCalendar();
        }
        function setDefaultTime() {
            self.setDate(self.config.minDate !== undefined
                ? new Date(self.config.minDate.getTime())
                : new Date(), false);
            setDefaultHours();
            updateValue();
        }
        function open(e, positionElement) {
            if (positionElement === void 0) { positionElement = self._positionElement; }
            if (self.isMobile === true) {
                if (e) {
                    e.preventDefault();
                    e.target && e.target.blur();
                }
                if (self.mobileInput !== undefined) {
                    self.mobileInput.focus();
                    self.mobileInput.click();
                }
                triggerEvent("onOpen");
                return;
            }
            if (self._input.disabled || self.config.inline)
                return;
            var wasOpen = self.isOpen;
            self.isOpen = true;
            if (!wasOpen) {
                self.calendarContainer.classList.add("open");
                self._input.classList.add("active");
                triggerEvent("onOpen");
                positionCalendar(positionElement);
            }
            if (self.config.enableTime === true && self.config.noCalendar === true) {
                if (self.selectedDates.length === 0) {
                    setDefaultTime();
                }
                if (self.config.allowInput === false &&
                    (e === undefined ||
                        !self.timeContainer.contains(e.relatedTarget))) {
                    setTimeout(function () { return self.hourElement.select(); }, 50);
                }
            }
        }
        function minMaxDateSetter(type) {
            return function (date) {
                var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
                var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
                if (dateObj !== undefined) {
                    self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                        dateObj.getHours() > 0 ||
                            dateObj.getMinutes() > 0 ||
                            dateObj.getSeconds() > 0;
                }
                if (self.selectedDates) {
                    self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                    if (!self.selectedDates.length && type === "min")
                        setHoursFromDate(dateObj);
                    updateValue();
                }
                if (self.daysContainer) {
                    redraw();
                    if (dateObj !== undefined)
                        self.currentYearElement[type] = dateObj.getFullYear().toString();
                    else
                        self.currentYearElement.removeAttribute(type);
                    self.currentYearElement.disabled =
                        !!inverseDateObj &&
                            dateObj !== undefined &&
                            inverseDateObj.getFullYear() === dateObj.getFullYear();
                }
            };
        }
        function parseConfig() {
            var boolOpts = [
                "wrap",
                "weekNumbers",
                "allowInput",
                "clickOpens",
                "time_24hr",
                "enableTime",
                "noCalendar",
                "altInput",
                "shorthandCurrentMonth",
                "inline",
                "static",
                "enableSeconds",
                "disableMobile",
            ];
            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
            var formats = {};
            self.config.parseDate = userConfig.parseDate;
            self.config.formatDate = userConfig.formatDate;
            Object.defineProperty(self.config, "enable", {
                get: function () { return self.config._enable; },
                set: function (dates) {
                    self.config._enable = parseDateRules(dates);
                }
            });
            Object.defineProperty(self.config, "disable", {
                get: function () { return self.config._disable; },
                set: function (dates) {
                    self.config._disable = parseDateRules(dates);
                }
            });
            var timeMode = userConfig.mode === "time";
            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                formats.dateFormat =
                    userConfig.noCalendar || timeMode
                        ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                        : flatpickr.defaultConfig.dateFormat +
                            " H:i" +
                            (userConfig.enableSeconds ? ":S" : "");
            }
            if (userConfig.altInput &&
                (userConfig.enableTime || timeMode) &&
                !userConfig.altFormat) {
                formats.altFormat =
                    userConfig.noCalendar || timeMode
                        ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                        : flatpickr.defaultConfig.altFormat +
                            (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
            }
            Object.defineProperty(self.config, "minDate", {
                get: function () { return self.config._minDate; },
                set: minMaxDateSetter("min")
            });
            Object.defineProperty(self.config, "maxDate", {
                get: function () { return self.config._maxDate; },
                set: minMaxDateSetter("max")
            });
            var minMaxTimeSetter = function (type) { return function (val) {
                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
            }; };
            Object.defineProperty(self.config, "minTime", {
                get: function () { return self.config._minTime; },
                set: minMaxTimeSetter("min")
            });
            Object.defineProperty(self.config, "maxTime", {
                get: function () { return self.config._maxTime; },
                set: minMaxTimeSetter("max")
            });
            if (userConfig.mode === "time") {
                self.config.noCalendar = true;
                self.config.enableTime = true;
            }
            Object.assign(self.config, formats, userConfig);
            for (var i = 0; i < boolOpts.length; i++)
                self.config[boolOpts[i]] =
                    self.config[boolOpts[i]] === true ||
                        self.config[boolOpts[i]] === "true";
            HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
                self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
            });
            self.isMobile =
                !self.config.disableMobile &&
                    !self.config.inline &&
                    self.config.mode === "single" &&
                    !self.config.disable.length &&
                    !self.config.enable.length &&
                    !self.config.weekNumbers &&
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            for (var i = 0; i < self.config.plugins.length; i++) {
                var pluginConf = self.config.plugins[i](self) || {};
                for (var key in pluginConf) {
                    if (HOOKS.indexOf(key) > -1) {
                        self.config[key] = arrayify(pluginConf[key])
                            .map(bindToInstance)
                            .concat(self.config[key]);
                    }
                    else if (typeof userConfig[key] === "undefined")
                        self.config[key] = pluginConf[key];
                }
            }
            triggerEvent("onParseConfig");
        }
        function setupLocale() {
            if (typeof self.config.locale !== "object" &&
                typeof flatpickr.l10ns[self.config.locale] === "undefined")
                self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
            self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"
                ? self.config.locale
                : self.config.locale !== "default"
                    ? flatpickr.l10ns[self.config.locale]
                    : undefined));
            tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
            self.formatDate = createDateFormatter(self);
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        }
        function positionCalendar(customPositionElement) {
            if (self.calendarContainer === undefined)
                return;
            triggerEvent("onPreCalendarPosition");
            var positionElement = customPositionElement || self._positionElement;
            var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                (configPosVertical !== "below" &&
                    distanceFromBottom < calendarHeight &&
                    inputBounds.top > calendarHeight);
            var top = window.pageYOffset +
                inputBounds.top +
                (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
            toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
            toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
            if (self.config.inline)
                return;
            var left = window.pageXOffset +
                inputBounds.left -
                (configPosHorizontal != null && configPosHorizontal === "center"
                    ? (calendarWidth - inputBounds.width) / 2
                    : 0);
            var right = window.document.body.offsetWidth - inputBounds.right;
            var rightMost = left + calendarWidth > window.document.body.offsetWidth;
            var centerMost = right + calendarWidth > window.document.body.offsetWidth;
            toggleClass(self.calendarContainer, "rightMost", rightMost);
            if (self.config.static)
                return;
            self.calendarContainer.style.top = top + "px";
            if (!rightMost) {
                self.calendarContainer.style.left = left + "px";
                self.calendarContainer.style.right = "auto";
            }
            else if (!centerMost) {
                self.calendarContainer.style.left = "auto";
                self.calendarContainer.style.right = right + "px";
            }
            else {
                var doc = document.styleSheets[0];
                // some testing environments don't have css support
                if (doc === undefined)
                    return;
                var bodyWidth = window.document.body.offsetWidth;
                var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                var centerBefore = ".flatpickr-calendar.centerMost:before";
                var centerAfter = ".flatpickr-calendar.centerMost:after";
                var centerIndex = doc.cssRules.length;
                var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                toggleClass(self.calendarContainer, "rightMost", false);
                toggleClass(self.calendarContainer, "centerMost", true);
                doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                self.calendarContainer.style.left = centerLeft + "px";
                self.calendarContainer.style.right = "auto";
            }
        }
        function redraw() {
            if (self.config.noCalendar || self.isMobile)
                return;
            updateNavigationCurrentMonth();
            buildDays();
        }
        function focusAndClose() {
            self._input.focus();
            if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                navigator.msMaxTouchPoints !== undefined) {
                // hack - bugs in the way IE handles focus keeps the calendar open
                setTimeout(self.close, 0);
            }
            else {
                self.close();
            }
        }
        function selectDate(e) {
            e.preventDefault();
            e.stopPropagation();
            var isSelectable = function (day) {
                return day.classList &&
                    day.classList.contains("flatpickr-day") &&
                    !day.classList.contains("disabled") &&
                    !day.classList.contains("notAllowed");
            };
            var t = findParent(e.target, isSelectable);
            if (t === undefined)
                return;
            var target = t;
            var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
            var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                selectedDate.getMonth() >
                    self.currentMonth + self.config.showMonths - 1) &&
                self.config.mode !== "range";
            self.selectedDateElem = target;
            if (self.config.mode === "single")
                self.selectedDates = [selectedDate];
            else if (self.config.mode === "multiple") {
                var selectedIndex = isDateSelected(selectedDate);
                if (selectedIndex)
                    self.selectedDates.splice(parseInt(selectedIndex), 1);
                else
                    self.selectedDates.push(selectedDate);
            }
            else if (self.config.mode === "range") {
                if (self.selectedDates.length === 2) {
                    self.clear(false, false);
                }
                self.latestSelectedDateObj = selectedDate;
                self.selectedDates.push(selectedDate);
                // unless selecting same date twice, sort ascendingly
                if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
            }
            setHoursFromInputs();
            if (shouldChangeMonth) {
                var isNewYear = self.currentYear !== selectedDate.getFullYear();
                self.currentYear = selectedDate.getFullYear();
                self.currentMonth = selectedDate.getMonth();
                if (isNewYear)
                    triggerEvent("onYearChange");
                triggerEvent("onMonthChange");
            }
            updateNavigationCurrentMonth();
            buildDays();
            updateValue();
            if (self.config.enableTime)
                setTimeout(function () { return (self.showTimeInput = true); }, 50);
            // maintain focus
            if (!shouldChangeMonth &&
                self.config.mode !== "range" &&
                self.config.showMonths === 1)
                focusOnDayElem(target);
            else if (self.selectedDateElem !== undefined &&
                self.hourElement === undefined) {
                self.selectedDateElem && self.selectedDateElem.focus();
            }
            if (self.hourElement !== undefined)
                self.hourElement !== undefined && self.hourElement.focus();
            if (self.config.closeOnSelect) {
                var single = self.config.mode === "single" && !self.config.enableTime;
                var range = self.config.mode === "range" &&
                    self.selectedDates.length === 2 &&
                    !self.config.enableTime;
                if (single || range) {
                    focusAndClose();
                }
            }
            triggerChange();
        }
        var CALLBACKS = {
            locale: [setupLocale, updateWeekdays],
            showMonths: [buildMonths, setCalendarWidth, buildWeekdays]
        };
        function set(option, value) {
            if (option !== null && typeof option === "object")
                Object.assign(self.config, option);
            else {
                self.config[option] = value;
                if (CALLBACKS[option] !== undefined)
                    CALLBACKS[option].forEach(function (x) { return x(); });
                else if (HOOKS.indexOf(option) > -1)
                    self.config[option] = arrayify(value);
            }
            self.redraw();
            updateValue(false);
        }
        function setSelectedDate(inputDate, format) {
            var dates = [];
            if (inputDate instanceof Array)
                dates = inputDate.map(function (d) { return self.parseDate(d, format); });
            else if (inputDate instanceof Date || typeof inputDate === "number")
                dates = [self.parseDate(inputDate, format)];
            else if (typeof inputDate === "string") {
                switch (self.config.mode) {
                    case "single":
                    case "time":
                        dates = [self.parseDate(inputDate, format)];
                        break;
                    case "multiple":
                        dates = inputDate
                            .split(self.config.conjunction)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    case "range":
                        dates = inputDate
                            .split(self.l10n.rangeSeparator)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    default:
                        break;
                }
            }
            else
                self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
            self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });
            if (self.config.mode === "range")
                self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
        }
        function setDate(date, triggerChange, format) {
            if (triggerChange === void 0) { triggerChange = false; }
            if (format === void 0) { format = self.config.dateFormat; }
            if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                return self.clear(triggerChange);
            setSelectedDate(date, format);
            self.showTimeInput = self.selectedDates.length > 0;
            self.latestSelectedDateObj = self.selectedDates[0];
            self.redraw();
            jumpToDate();
            setHoursFromDate();
            updateValue(triggerChange);
            if (triggerChange)
                triggerEvent("onChange");
        }
        function parseDateRules(arr) {
            return arr
                .slice()
                .map(function (rule) {
                if (typeof rule === "string" ||
                    typeof rule === "number" ||
                    rule instanceof Date) {
                    return self.parseDate(rule, undefined, true);
                }
                else if (rule &&
                    typeof rule === "object" &&
                    rule.from &&
                    rule.to)
                    return {
                        from: self.parseDate(rule.from, undefined),
                        to: self.parseDate(rule.to, undefined)
                    };
                return rule;
            })
                .filter(function (x) { return x; }); // remove falsy values
        }
        function setupDates() {
            self.selectedDates = [];
            self.now = self.parseDate(self.config.now) || new Date();
            // Workaround IE11 setting placeholder as the input's value
            var preloadedDate = self.config.defaultDate ||
                ((self.input.nodeName === "INPUT" ||
                    self.input.nodeName === "TEXTAREA") &&
                    self.input.placeholder &&
                    self.input.value === self.input.placeholder
                    ? null
                    : self.input.value);
            if (preloadedDate)
                setSelectedDate(preloadedDate, self.config.dateFormat);
            self._initialDate =
                self.selectedDates.length > 0
                    ? self.selectedDates[0]
                    : self.config.minDate &&
                        self.config.minDate.getTime() > self.now.getTime()
                        ? self.config.minDate
                        : self.config.maxDate &&
                            self.config.maxDate.getTime() < self.now.getTime()
                            ? self.config.maxDate
                            : self.now;
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
            if (self.selectedDates.length > 0)
                self.latestSelectedDateObj = self.selectedDates[0];
            if (self.config.minTime !== undefined)
                self.config.minTime = self.parseDate(self.config.minTime, "H:i");
            if (self.config.maxTime !== undefined)
                self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
            self.minDateHasTime =
                !!self.config.minDate &&
                    (self.config.minDate.getHours() > 0 ||
                        self.config.minDate.getMinutes() > 0 ||
                        self.config.minDate.getSeconds() > 0);
            self.maxDateHasTime =
                !!self.config.maxDate &&
                    (self.config.maxDate.getHours() > 0 ||
                        self.config.maxDate.getMinutes() > 0 ||
                        self.config.maxDate.getSeconds() > 0);
            Object.defineProperty(self, "showTimeInput", {
                get: function () { return self._showTimeInput; },
                set: function (bool) {
                    self._showTimeInput = bool;
                    if (self.calendarContainer)
                        toggleClass(self.calendarContainer, "showTimeInput", bool);
                    self.isOpen && positionCalendar();
                }
            });
        }
        function setupInputs() {
            self.input = self.config.wrap
                ? element.querySelector("[data-input]")
                : element;
            /* istanbul ignore next */
            if (!self.input) {
                self.config.errorHandler(new Error("Invalid input element specified"));
                return;
            }
            // hack: store previous type to restore it after destroy()
            self.input._type = self.input.type;
            self.input.type = "text";
            self.input.classList.add("flatpickr-input");
            self._input = self.input;
            if (self.config.altInput) {
                // replicate self.element
                self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
                self._input = self.altInput;
                self.altInput.placeholder = self.input.placeholder;
                self.altInput.disabled = self.input.disabled;
                self.altInput.required = self.input.required;
                self.altInput.tabIndex = self.input.tabIndex;
                self.altInput.type = "text";
                self.input.setAttribute("type", "hidden");
                if (!self.config.static && self.input.parentNode)
                    self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
            }
            if (!self.config.allowInput)
                self._input.setAttribute("readonly", "readonly");
            self._positionElement = self.config.positionElement || self._input;
        }
        function setupMobile() {
            var inputType = self.config.enableTime
                ? self.config.noCalendar
                    ? "time"
                    : "datetime-local"
                : "date";
            self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
            self.mobileInput.step = self.input.getAttribute("step") || "any";
            self.mobileInput.tabIndex = 1;
            self.mobileInput.type = inputType;
            self.mobileInput.disabled = self.input.disabled;
            self.mobileInput.required = self.input.required;
            self.mobileInput.placeholder = self.input.placeholder;
            self.mobileFormatStr =
                inputType === "datetime-local"
                    ? "Y-m-d\\TH:i:S"
                    : inputType === "date"
                        ? "Y-m-d"
                        : "H:i:S";
            if (self.selectedDates.length > 0) {
                self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
            }
            if (self.config.minDate)
                self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
            if (self.config.maxDate)
                self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
            self.input.type = "hidden";
            if (self.altInput !== undefined)
                self.altInput.type = "hidden";
            try {
                if (self.input.parentNode)
                    self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
            }
            catch (_a) { }
            bind(self.mobileInput, "change", function (e) {
                self.setDate(e.target.value, false, self.mobileFormatStr);
                triggerEvent("onChange");
                triggerEvent("onClose");
            });
        }
        function toggle(e) {
            if (self.isOpen === true)
                return self.close();
            self.open(e);
        }
        function triggerEvent(event, data) {
            // If the instance has been destroyed already, all hooks have been removed
            if (self.config === undefined)
                return;
            var hooks = self.config[event];
            if (hooks !== undefined && hooks.length > 0) {
                for (var i = 0; hooks[i] && i < hooks.length; i++)
                    hooks[i](self.selectedDates, self.input.value, self, data);
            }
            if (event === "onChange") {
                self.input.dispatchEvent(createEvent("change"));
                // many front-end frameworks bind to the input event
                self.input.dispatchEvent(createEvent("input"));
            }
        }
        function createEvent(name) {
            var e = document.createEvent("Event");
            e.initEvent(name, true, true);
            return e;
        }
        function isDateSelected(date) {
            for (var i = 0; i < self.selectedDates.length; i++) {
                if (compareDates(self.selectedDates[i], date) === 0)
                    return "" + i;
            }
            return false;
        }
        function isDateInRange(date) {
            if (self.config.mode !== "range" || self.selectedDates.length < 2)
                return false;
            return (compareDates(date, self.selectedDates[0]) >= 0 &&
                compareDates(date, self.selectedDates[1]) <= 0);
        }
        function updateNavigationCurrentMonth() {
            if (self.config.noCalendar || self.isMobile || !self.monthNav)
                return;
            self.yearElements.forEach(function (yearElement, i) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                self.monthElements[i].textContent =
                    monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) +
                        " ";
                yearElement.value = d.getFullYear().toString();
            });
            self._hidePrevMonthArrow =
                self.config.minDate !== undefined &&
                    (self.currentYear === self.config.minDate.getFullYear()
                        ? self.currentMonth <= self.config.minDate.getMonth()
                        : self.currentYear < self.config.minDate.getFullYear());
            self._hideNextMonthArrow =
                self.config.maxDate !== undefined &&
                    (self.currentYear === self.config.maxDate.getFullYear()
                        ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                        : self.currentYear > self.config.maxDate.getFullYear());
        }
        function getDateStr(format) {
            return self.selectedDates
                .map(function (dObj) { return self.formatDate(dObj, format); })
                .filter(function (d, i, arr) {
                return self.config.mode !== "range" ||
                    self.config.enableTime ||
                    arr.indexOf(d) === i;
            })
                .join(self.config.mode !== "range"
                ? self.config.conjunction
                : self.l10n.rangeSeparator);
        }
        /**
         * Updates the values of inputs associated with the calendar
         */
        function updateValue(triggerChange) {
            if (triggerChange === void 0) { triggerChange = true; }
            if (self.selectedDates.length === 0)
                return self.clear(triggerChange);
            if (self.mobileInput !== undefined && self.mobileFormatStr) {
                self.mobileInput.value =
                    self.latestSelectedDateObj !== undefined
                        ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                        : "";
            }
            self.input.value = getDateStr(self.config.dateFormat);
            if (self.altInput !== undefined) {
                self.altInput.value = getDateStr(self.config.altFormat);
            }
            if (triggerChange !== false)
                triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e) {
            e.preventDefault();
            var isPrevMonth = self.prevMonthNav.contains(e.target);
            var isNextMonth = self.nextMonthNav.contains(e.target);
            if (isPrevMonth || isNextMonth) {
                changeMonth(isPrevMonth ? -1 : 1);
            }
            else if (self.yearElements.indexOf(e.target) >= 0) {
                e.target.select();
            }
            else if (e.target.classList.contains("arrowUp")) {
                self.changeYear(self.currentYear + 1);
            }
            else if (e.target.classList.contains("arrowDown")) {
                self.changeYear(self.currentYear - 1);
            }
        }
        function timeWrapper(e) {
            e.preventDefault();
            var isKeyDown = e.type === "keydown", input = e.target;
            if (self.amPM !== undefined && e.target === self.amPM) {
                self.amPM.textContent =
                    self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
            }
            var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
            var newValue = curValue + step * delta;
            if (typeof input.value !== "undefined" && input.value.length === 2) {
                var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                if (newValue < min) {
                    newValue =
                        max +
                            newValue +
                            int(!isHourElem) +
                            (int(isHourElem) && int(!self.amPM));
                    if (isMinuteElem)
                        incrementNumInput(undefined, -1, self.hourElement);
                }
                else if (newValue > max) {
                    newValue =
                        input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                    if (isMinuteElem)
                        incrementNumInput(undefined, 1, self.hourElement);
                }
                if (self.amPM &&
                    isHourElem &&
                    (step === 1
                        ? newValue + curValue === 23
                        : Math.abs(newValue - curValue) > step)) {
                    self.amPM.textContent =
                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                }
                input.value = pad(newValue);
            }
        }
        init();
        return self;
    }
    /* istanbul ignore next */
    function _flatpickr(nodeList, config) {
        // static list
        var nodes = Array.prototype.slice
            .call(nodeList)
            .filter(function (x) { return x instanceof HTMLElement; });
        var instances = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            try {
                if (node.getAttribute("data-fp-omit") !== null)
                    continue;
                if (node._flatpickr !== undefined) {
                    node._flatpickr.destroy();
                    node._flatpickr = undefined;
                }
                node._flatpickr = FlatpickrInstance(node, config || {});
                instances.push(node._flatpickr);
            }
            catch (e) {
                console.error(e);
            }
        }
        return instances.length === 1 ? instances[0] : instances;
    }
    /* istanbul ignore next */
    if (typeof HTMLElement !== "undefined") {
        // browser env
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
        HTMLElement.prototype.flatpickr = function (config) {
            return _flatpickr([this], config);
        };
    }
    /* istanbul ignore next */
    var flatpickr = function (selector, config) {
        if (typeof selector === "string") {
            return _flatpickr(window.document.querySelectorAll(selector), config);
        }
        else if (selector instanceof Node) {
            return _flatpickr([selector], config);
        }
        else {
            return _flatpickr(selector, config);
        }
    };
    /* istanbul ignore next */
    flatpickr.defaultConfig = defaults;
    flatpickr.l10ns = {
        en: __assign({}, english),
        "default": __assign({}, english)
    };
    flatpickr.localize = function (l10n) {
        flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
    };
    flatpickr.setDefaults = function (config) {
        flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
    };
    flatpickr.parseDate = createDateParser({});
    flatpickr.formatDate = createDateFormatter({});
    flatpickr.compareDates = compareDates;
    /* istanbul ignore next */
    if (typeof jQuery !== "undefined") {
        jQuery.fn.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
    }
    Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
    };
    if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
    }

    return flatpickr;

}));

},{}],109:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.de = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var German = {
      weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
              "Sonntag",
              "Montag",
              "Dienstag",
              "Mittwoch",
              "Donnerstag",
              "Freitag",
              "Samstag",
          ]
      },
      months: {
          shorthand: [
              "Jan",
              "Feb",
              "Mr",
              "Apr",
              "Mai",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Okt",
              "Nov",
              "Dez",
          ],
          longhand: [
              "Januar",
              "Februar",
              "Mrz",
              "April",
              "Mai",
              "Juni",
              "Juli",
              "August",
              "September",
              "Oktober",
              "November",
              "Dezember",
          ]
      },
      firstDayOfWeek: 1,
      weekAbbreviation: "KW",
      rangeSeparator: " bis ",
      scrollTitle: "Zum ndern scrollen",
      toggleTitle: "Zum Umschalten klicken"
  };
  fp.l10ns.de = German;
  var de = fp.l10ns;

  exports.German = German;
  exports.default = de;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],110:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.fr = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var French = {
      firstDayOfWeek: 1,
      weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: [
              "dimanche",
              "lundi",
              "mardi",
              "mercredi",
              "jeudi",
              "vendredi",
              "samedi",
          ]
      },
      months: {
          shorthand: [
              "janv",
              "fvr",
              "mars",
              "avr",
              "mai",
              "juin",
              "juil",
              "aot",
              "sept",
              "oct",
              "nov",
              "dc",
          ],
          longhand: [
              "janvier",
              "fvrier",
              "mars",
              "avril",
              "mai",
              "juin",
              "juillet",
              "aot",
              "septembre",
              "octobre",
              "novembre",
              "dcembre",
          ]
      },
      ordinal: function (nth) {
          if (nth > 1)
              return "";
          return "er";
      },
      rangeSeparator: " au ",
      weekAbbreviation: "Sem",
      scrollTitle: "Dfiler pour augmenter la valeur",
      toggleTitle: "Cliquer pour basculer"
  };
  fp.l10ns.fr = French;
  var fr = fp.l10ns;

  exports.French = French;
  exports.default = fr;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],111:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.it = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var Italian = {
      weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: [
              "Domenica",
              "Luned",
              "Marted",
              "Mercoled",
              "Gioved",
              "Venerd",
              "Sabato",
          ]
      },
      months: {
          shorthand: [
              "Gen",
              "Feb",
              "Mar",
              "Apr",
              "Mag",
              "Giu",
              "Lug",
              "Ago",
              "Set",
              "Ott",
              "Nov",
              "Dic",
          ],
          longhand: [
              "Gennaio",
              "Febbraio",
              "Marzo",
              "Aprile",
              "Maggio",
              "Giugno",
              "Luglio",
              "Agosto",
              "Settembre",
              "Ottobre",
              "Novembre",
              "Dicembre",
          ]
      },
      firstDayOfWeek: 1,
      ordinal: function () { return ""; },
      rangeSeparator: " al ",
      weekAbbreviation: "Se",
      scrollTitle: "Scrolla per aumentare",
      toggleTitle: "Clicca per cambiare"
  };
  fp.l10ns.it = Italian;
  var it = fp.l10ns;

  exports.Italian = Italian;
  exports.default = it;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],112:[function(require,module,exports){
(function (global){
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.12.9
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Popper = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element && element.offsetParent;
  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    if (element) {
      return element.ownerDocument.documentElement;
    }

    return document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

/**
 * Tells if you are running Internet Explorer 10
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean} isIE10
 */
var isIE10 = undefined;

var isIE10$1 = function () {
  if (isIE10 === undefined) {
    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
  }
  return isIE10;
};

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE10$1() && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  if (isIE10$1()) {
    try {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } catch (err) {}
  } else {
    rect = element.getBoundingClientRect();
  }

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var isIE10 = isIE10$1();
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = getScroll(html);
  var scrollLeft = getScroll(html, 'left');

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = { top: 0, left: 0 };
  var offsetParent = findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var commonOffsetParent = findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length - 1; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.left = '';
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper.
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // floor sides to avoid blurry text
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.floor(popper.top),
    bottom: Math.floor(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

return Popper;

})));


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],113:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZC90cy9tYWluL2J1bmRsZS1uby1tb2Rlcm5penIuanMiLCJtYWluL3BvbHlmaWxscy9NYXRoLnNpZ24udHMiLCJtYWluL3BvbHlmaWxscy9zdGFydHNXaXRoLnRzIiwibWFpbi9zZHgtZ2xvYmFsLnRzIiwibWFpbi9zcmMvRG9tRWxlbWVudC50cyIsIm1haW4vc3JjL0RvbUZ1bmN0aW9ucy50cyIsIm1haW4vc3JjL0lucHV0cy50cyIsIm1haW4vc3JjL1V0aWxzLnRzIiwibWFpbi9zcmMvYWNjb3JkaW9uL0FjY29yZGlvbi50cyIsIm1haW4vc3JjL2Nhcm91c2VsL0Nhcm91c2VsLnRzIiwibWFpbi9zcmMvY2hhcnRzL0JhckNoYXJ0SG9yaXpvbnRhbC50cyIsIm1haW4vc3JjL2NoYXJ0cy9CYXJDaGFydFZlcnRpY2FsLnRzIiwibWFpbi9zcmMvY2hhcnRzL0NoYXJ0RnVuY3Rpb25zLnRzIiwibWFpbi9zcmMvY2hhcnRzL1BpZUNoYXJ0LnRzIiwibWFpbi9zcmMvY29sbGFwc2UvQ29sbGFwc2UudHMiLCJtYWluL3NyYy9lbXB0eS1zdGF0ZXMvRW1wdHlTdGF0ZS50cyIsIm1haW4vc3JjL2Zvcm0vQXV0b2NvbXBsZXRlLnRzIiwibWFpbi9zcmMvZm9ybS9JbnB1dEZpZWxkLnRzIiwibWFpbi9zcmMvZm9ybS9SYW5nZS50cyIsIm1haW4vc3JjL2Zvcm0vU2VsZWN0LnRzIiwibWFpbi9zcmMvZm9ybS9UZXh0YXJlYS50cyIsIm1haW4vc3JjL2xvYWRlci9Mb2FkZXJCYXIudHMiLCJtYWluL3NyYy9tZW51L01lbnVGbHlvdXQudHMiLCJtYWluL3NyYy9tb2RhbC9Nb2RhbC50cyIsIm1haW4vc3JjL25hdmlnYXRpb24vTmF2aWdhdGlvbi50cyIsIm1haW4vc3JjL25hdmlnYXRpb24vTmF2aWdhdGlvblNpZGUudHMiLCJtYWluL3NyYy9ub3RpZmljYXRpb24vTm90aWZpY2F0aW9uLnRzIiwibWFpbi9zcmMvcHJvZ3Jlc3MvUHJvZ3Jlc3NGdWxsLnRzIiwibWFpbi9zcmMvcHJvZ3Jlc3MvUHJvZ3Jlc3NMaWdodC50cyIsIm1haW4vc3JjL3NkeC50cyIsIm1haW4vc3JjL3NlYXJjaC9TZWFyY2hJbnB1dC50cyIsIm1haW4vc3JjL3RhYmxlL1RhYmxlLnRzIiwibWFpbi9zcmMvdG9vbGJhci9Ub29sYmFyLnRzIiwibm9kZV9tb2R1bGVzL2FuaW1lanMvbGliL2FuaW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXRoL3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hdGgvdHJ1bmMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL251bWJlci9pcy1uYW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL251bWJlci9tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JvZHktc2Nyb2xsLWxvY2svbGliL2JvZHlTY3JvbGxMb2NrLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWF0aC9zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXRoL3RydW5jLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvaXMtbmFuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvbWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9mbGF0cGlja3IuanMiLCJub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9kZS5qcyIsIm5vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9sMTBuL2ZyLmpzIiwibm9kZV9tb2R1bGVzL2ZsYXRwaWNrci9kaXN0L2wxMG4vaXQuanMiLCJub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvdW1kL3BvcHBlci5qcyIsIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTs7QUFDQSxJQUFJLEVBQUUsVUFBTixJQUFJLENBQUosRUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHdDQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjhFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNzRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiLi9zZHgtZ2xvYmFsXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiWFN3aWMyOTFjbU5sVW05dmRDSTZJaTR1THk0dUx5NHVJbjA9IiwiLy8gTWF0aC5zaWduICh1c2VkIGluIFByb2dyZXNzRnVsbClcbmlmICghKFwic2lnblwiIGluIE1hdGgpKSB7XG4gIChNYXRoIGFzIGFueSkuc2lnbiA9IGZ1bmN0aW9uKHg6IG51bWJlcikge1xuICAgIHJldHVybiAoeCA+IDApID8gMSA6ICgoeCA8IDApID8gLTEgOiAreClcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24oc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgMFxuICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT09IHBvc2l0aW9uXG4gIH1cbn1cbiIsIi8qIFBvbHlmaWxscyAqL1xuaW1wb3J0IFwiLi9wb2x5ZmlsbHMvTWF0aC5zaWduXCJcbmltcG9ydCBcIi4vcG9seWZpbGxzL3N0YXJ0c1dpdGhcIlxuXG5pbXBvcnQgKiBhcyBzZHhFeHBvcnRzIGZyb20gXCIuL3NyYy9zZHhcIlxuXG5leHBvcnQgaW50ZXJmYWNlIFNEWEdsb2JhbCB7XG4gIFZFUlNJT046IHN0cmluZ1xuXG4gIExvYWRlckJhcjogdHlwZW9mIHNkeEV4cG9ydHMuTG9hZGVyQmFyXG5cbiAgU2VsZWN0OiB0eXBlb2Ygc2R4RXhwb3J0cy5TZWxlY3RcbiAgSW5wdXRGaWVsZDogdHlwZW9mIHNkeEV4cG9ydHMuSW5wdXRGaWVsZFxuICBUZXh0YXJlYTogdHlwZW9mIHNkeEV4cG9ydHMuVGV4dGFyZWFcbiAgQXV0b2NvbXBsZXRlOiB0eXBlb2Ygc2R4RXhwb3J0cy5BdXRvY29tcGxldGVcblxuICBQcm9ncmVzc0xpZ2h0OiB0eXBlb2Ygc2R4RXhwb3J0cy5Qcm9ncmVzc0xpZ2h0XG4gIFByb2dyZXNzRnVsbDogdHlwZW9mIHNkeEV4cG9ydHMuUHJvZ3Jlc3NGdWxsXG5cbiAgUmFuZ2U6IHR5cGVvZiBzZHhFeHBvcnRzLlJhbmdlXG4gIE1vZGFsOiB0eXBlb2Ygc2R4RXhwb3J0cy5Nb2RhbFxuICBUb29sYmFyOiB0eXBlb2Ygc2R4RXhwb3J0cy5Ub29sYmFyXG4gIE5vdGlmaWNhdGlvbjogdHlwZW9mIHNkeEV4cG9ydHMuTm90aWZpY2F0aW9uXG5cbiAgQ29sbGFwc2U6IHR5cGVvZiBzZHhFeHBvcnRzLkNvbGxhcHNlXG4gIEFjY29yZGlvbjogdHlwZW9mIHNkeEV4cG9ydHMuQWNjb3JkaW9uXG5cbiAgTWVudUZseW91dDogdHlwZW9mIHNkeEV4cG9ydHMuTWVudUZseW91dFxuXG4gIE5hdmlnYXRpb246IHR5cGVvZiBzZHhFeHBvcnRzLk5hdmlnYXRpb25cbiAgTmF2aWdhdGlvblNpZGU6IHR5cGVvZiBzZHhFeHBvcnRzLk5hdmlnYXRpb25TaWRlXG4gIFNlYXJjaElucHV0OiB0eXBlb2Ygc2R4RXhwb3J0cy5TZWFyY2hJbnB1dFxuICBFbXB0eVN0YXRlOiB0eXBlb2Ygc2R4RXhwb3J0cy5FbXB0eVN0YXRlXG4gIENhcm91c2VsOiB0eXBlb2Ygc2R4RXhwb3J0cy5DYXJvdXNlbFxuXG4gIFRhYmxlOiB0eXBlb2Ygc2R4RXhwb3J0cy5UYWJsZVxuXG4gIFBpZUNoYXJ0OiB0eXBlb2Ygc2R4RXhwb3J0cy5QaWVDaGFydFxuICBCYXJDaGFydEhvcml6b250YWw6IHR5cGVvZiBzZHhFeHBvcnRzLkJhckNoYXJ0SG9yaXpvbnRhbFxuICBCYXJDaGFydFZlcnRpY2FsOiB0eXBlb2Ygc2R4RXhwb3J0cy5CYXJDaGFydFZlcnRpY2FsXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgc2R4OiBTRFhHbG9iYWxcbiAgfVxufVxuXG5sZXQgc2R4ID0ge1xuICAuLi5zZHhFeHBvcnRzLFxuICAuLi4od2luZG93LnNkeCBhcyBhbnkpIHx8IHt9LFxuICBWRVJTSU9OOiBcIiRWRVJTSU9OJFwiXG59XG5cbndpbmRvdy5zZHggPSBzZHhcblxuc2R4RXhwb3J0cy51dGlscy5vbkRvY3VtZW50UmVhZHkoKCkgPT4ge1xuICBzZHhFeHBvcnRzLmluaXRJbnB1dEZpZWxkKClcbiAgc2R4RXhwb3J0cy5pbml0VGV4dGFyZWEoKVxuICBzZHhFeHBvcnRzLmluaXRTZWxlY3QoKVxuICBzZHhFeHBvcnRzLmluaXRMb2FkZXJCYXIoKVxuICBzZHhFeHBvcnRzLmluaXRBdXRvY29tcGxldGUoKVxuXG4gIHNkeEV4cG9ydHMuaW5pdFByb2dyZXNzTGlnaHQoKVxuICBzZHhFeHBvcnRzLmluaXRQcm9ncmVzc0Z1bGwoKVxuXG4gIHNkeEV4cG9ydHMuaW5pdFJhbmdlKClcbiAgc2R4RXhwb3J0cy5pbml0TW9kYWwoKVxuXG4gIHNkeEV4cG9ydHMuaW5pdEFjY29yZGlvbigpXG4gIHNkeEV4cG9ydHMuaW5pdENvbGxhcHNlKClcbiAgc2R4RXhwb3J0cy5pbml0TWVudUZseW91dCgpXG5cbiAgc2R4RXhwb3J0cy5pbml0TmF2aWdhdGlvbigpXG4gIHNkeEV4cG9ydHMuaW5pdE5hdmlnYXRpb25TaWRlKClcbiAgc2R4RXhwb3J0cy5pbml0U2VhcmNoSW5wdXQoKVxuICBzZHhFeHBvcnRzLmluaXRFbXB0eVN0YXRlKClcbiAgc2R4RXhwb3J0cy5pbml0Q2Fyb3VzZWwoKVxuICBzZHhFeHBvcnRzLmluaXRUYWJsZSgpXG5cbiAgc2R4RXhwb3J0cy5pbml0UGllQ2hhcnQoKVxuICBzZHhFeHBvcnRzLmluaXRCYXJDaGFydEhvcml6b250YWwoKVxuICBzZHhFeHBvcnRzLmluaXRCYXJDaGFydFZlcnRpY2FsKClcbn0pXG4iLCJpbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4vRG9tRnVuY3Rpb25zXCJcblxubGV0IGh0bWxFdmVudHM6IHtcbiAgW2V2ZW50TmFtZTogc3RyaW5nXTogKCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBBIHdyYXBwZXIgY2xhc3MgZm9yIERPTSBFbGVtZW50cy5cbiAqL1xuY2xhc3MgRG9tRWxlbWVudDxUIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQ+IHtcbiAgcHVibGljIGVsZW1lbnQ6IFRcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gLSBUaGUgZWxlbWVudCB0byB3cmFwLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gLSBUaGUgRE9NIGVsZW1lbnQgdG8gY3JlYXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogVCB8IGtleW9mIEVsZW1lbnRUYWdOYW1lTWFwKSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpIGFzIEVsZW1lbnQgYXMgVFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCBDU1MgY2xhc3MgdG8gdGhlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAtIFRoZSBjbGFzcyBuYW1lIHRvIGFkZC5cbiAgICogQHJldHVybiB7RG9tRWxlbWVudH0gUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgZmx1ZW50IGNoYWluaW5nIG9mIGNhbGxzLlxuICAgKi9cbiAgcHVibGljIGFkZENsYXNzKG5hbWU6IHN0cmluZykge1xuICAgIERvbS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgQ1NTIGNsYXNzIGZyb20gdGhlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAtIFRoZSBjbGFzcyBuYW1lIHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7RG9tRWxlbWVudH0gUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgZmx1ZW50IGNoYWluaW5nIG9mIGNhbGxzLlxuICAgKi9cbiAgcHVibGljIHJlbW92ZUNsYXNzKG5hbWU6IHN0cmluZykge1xuICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBoYXNDbGFzcyhuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gRG9tLmhhc0NsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSlcbiAgfVxuXG4gIHB1YmxpYyB0b2dnbGVDbGFzcyhuYW1lOiBzdHJpbmcpIHtcbiAgICBEb20udG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50LCBuYW1lKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgY2xhc3NlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdFxuICB9XG5cbiAgcHVibGljIHNldElkKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBpbm5lclRleHQoKSB7XG4gICAgcmV0dXJuIERvbS50ZXh0KHRoaXMuZWxlbWVudClcbiAgfVxuXG4gIGdldCBpbm5lckh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5pbm5lckhUTUxcbiAgfVxuXG4gIHB1YmxpYyBzZXRIdG1sKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBIVE1MIHN0cmluZ1wiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB2YWx1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgZ2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpXG4gIH1cblxuICBwdWJsaWMgc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBwdWJsaWMgYWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRFdmVudE1hcD4odHlwZTogVCwgbGlzdGVuZXI6IChlOiBFdmVudCkgPT4gdm9pZCkge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRFdmVudE1hcD4odHlwZTogVCwgbGlzdGVuZXI6IChlOiBFdmVudCkgPT4gdm9pZCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKVxuICB9XG5cbiAgcHVibGljIGFwcGVuZENoaWxkKG5ld0NoaWxkOiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCEobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb21FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvdGhlciBEb21FbGVtZW50cyBjYW4gYmUgYWRkZWQgYXMgY2hpbGRyZW5cIilcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3Q2hpbGQuZWxlbWVudClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIHByZXBlbmRDaGlsZChuZXdDaGlsZDogRG9tRWxlbWVudCkge1xuICAgIGlmICghKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb3RoZXIgRG9tRWxlbWVudHMgY2FuIGJlIGFkZGVkIGFzIGNoaWxkcmVuXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZShuZXdDaGlsZC5lbGVtZW50LCB0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIGluc2VydEJlZm9yZShuZXdDaGlsZDogRG9tRWxlbWVudCkge1xuICAgIGlmICghKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb3RoZXIgRG9tRWxlbWVudHMgY2FuIGJlIGFkZGVkIGFzIGNoaWxkcmVuXCIpXG4gICAgfVxuICAgIGlmICghdGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgaXMgbm90IGF0dGFjaGVkXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLmVsZW1lbnQsIHRoaXMuZWxlbWVudClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIGluc2VydEFmdGVyKG5ld0NoaWxkOiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCEobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb21FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvdGhlciBEb21FbGVtZW50cyBjYW4gYmUgYWRkZWQgYXMgY2hpbGRyZW5cIilcbiAgICB9XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCBpcyBub3QgYXR0YWNoZWRcIilcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQuZWxlbWVudCwgdGhpcy5lbGVtZW50Lm5leHRTaWJsaW5nKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlQ2hpbGQob2xkQ2hpbGQ6IERvbUVsZW1lbnQpIHtcbiAgICBpZiAoIShvbGRDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IGEgRG9tRWxlbWVudHMgY2hpbGQgY2FuIGJlIHJlbW92ZWRcIilcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQob2xkQ2hpbGQuZWxlbWVudClcbiAgfVxuXG4gIHB1YmxpYyBmaW5kKHNlbGVjdG9yczogc3RyaW5nKSB7XG4gICAgbGV0IGUgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcnMpXG4gICAgaWYgKGUpIHtcbiAgICAgIHJldHVybiBuZXcgRG9tRWxlbWVudChlIGFzIEVsZW1lbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcHVibGljIHdyYXBXaXRoRWxlbWVudCh3cmFwcGVyRWxlbWVudDogRG9tRWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgaXMgbm90IGF0dGFjaGVkXCIpXG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh3cmFwcGVyRWxlbWVudC5lbGVtZW50LCB0aGlzLmVsZW1lbnQpXG4gICAgd3JhcHBlckVsZW1lbnQuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIGRpc3BhdGNoRXZlbnQoZXZlbnROYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgZXZlbnRcbiAgICBsZXQgZWwgPSB0aGlzLmVsZW1lbnRcblxuICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIilcbiAgICAgIGV2ZW50LmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIHRydWUpXG4gICAgfSBlbHNlIGlmICgoZG9jdW1lbnQgYXMgYW55KS5jcmVhdGVFdmVudE9iamVjdCkgeyAvLyBJRSA8IDlcbiAgICAgIGV2ZW50ID0gKGRvY3VtZW50IGFzIGFueSkuY3JlYXRlRXZlbnRPYmplY3QoKVxuICAgICAgZXZlbnQuZXZlbnRUeXBlID0gZXZlbnROYW1lXG4gICAgfVxuICAgIGV2ZW50LmV2ZW50TmFtZSA9IGV2ZW50TmFtZVxuICAgIGlmIChlbC5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgIH0gZWxzZSBpZiAoKGVsIGFzIGFueSkuZmlyZUV2ZW50ICYmIGh0bWxFdmVudHNbYG9uJHtldmVudE5hbWV9YF0pIHsgLy8gSUUgPCA5XG4gICAgICAoZWwgYXMgYW55KS5maXJlRXZlbnQoYG9uJHtldmVudC5ldmVudFR5cGV9YCwgZXZlbnQpIC8vIGNhbiB0cmlnZ2VyIG9ubHkgcmVhbCBldmVudCAoZS5nLiAnY2xpY2snKVxuICAgIH0gZWxzZSBpZiAoZWxbZXZlbnROYW1lIGFzIGtleW9mIEVsZW1lbnRdKSB7XG4gICAgICAoZWwgYXMgYW55KVtldmVudE5hbWVdKClcbiAgICB9IGVsc2UgaWYgKGVsW2BvbiR7ZXZlbnROYW1lfWAgYXMga2V5b2YgRWxlbWVudF0pIHtcbiAgICAgIChlbCBhcyBhbnkpW2BvbiR7ZXZlbnROYW1lfWBdKClcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY3NzKHByb3BlcnR5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gRG9tLmNzcyh0aGlzLmVsZW1lbnQsIHByb3BlcnR5KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkIG5vZGVzIG9mIHRoZSBjdXJyZW50IERvbUVsZW1lbnQuXG4gICAqL1xuICBwdWJsaWMgZW1wdHkoKSB7XG4gICAgRG9tLmVtcHR5KHRoaXMuZWxlbWVudClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEb21FbGVtZW50XG4iLCJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50OiBFbGVtZW50LCBuYW1lOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGNsYXNzIG5hbWVcIilcbiAgfVxuXG4gIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudDogRWxlbWVudCwgbmFtZTogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBjbGFzcyBuYW1lXCIpXG4gIH1cblxuICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUobmFtZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQ6IEVsZW1lbnQsIG5hbWU6IHN0cmluZykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgY2xhc3MgbmFtZVwiKVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50OiBFbGVtZW50LCBuYW1lOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGNsYXNzIG5hbWVcIilcbiAgfVxuXG4gIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShuYW1lKVxufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgaGlkZGVuIGZyb20gdmlldy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gRWxlbWVudCBUaGUgZG9tIGVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVQYXJlbnRzIElmIHNldCB0byBgdHJ1ZWAgc2VhcmNoZXMgdXAgdGhlIERPTSBhbmQgY2hlY2tzIHBhcmVudCB2aXNpYmlsaXR5IGFzIHdlbGwuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hpZGRlbihlbGVtZW50OiBIVE1MRWxlbWVudCwgaW5jbHVkZVBhcmVudHMgPSBmYWxzZSk6IGJvb2xlYW4ge1xuICBpZiAoaW5jbHVkZVBhcmVudHMgPT09IGZhbHNlKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVxuICAgIHJldHVybiAoc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHx8IGVsZW1lbnQub2Zmc2V0TGVmdCA8IDBcbiAgfVxuXG4gIGxldCByZXN1bHRcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgd2hpbGUgKChyZXN1bHQgPSBpc0hpZGRlbihlbGVtZW50LCBmYWxzZSkpID09PSBmYWxzZSAmJiBlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdGV4dCBvZiBhbiBlbGVtZW50IGFuIG1ha2VzIHN1cmUgdGhpcyB3b3JrcyBvbiBhbGwgYnJvd3NlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0KGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudGV4dENvbnRlbnQgfHwgKGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmlubmVyVGV4dFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50V2l0aENsYXNzPEUgZXh0ZW5kcyBFbGVtZW50ID0gRWxlbWVudD4oZWxlbWVudDogRSwgY2xhc3NOYW1lOiBzdHJpbmcpOiBFIHwgdW5kZWZpbmVkIHtcbiAgbGV0IGN1cnJlbnQ6IEUgPSBlbGVtZW50XG5cbiAgd2hpbGUgKCFoYXNDbGFzcyhjdXJyZW50LCBjbGFzc05hbWUpICYmIGN1cnJlbnQucGFyZW50RWxlbWVudCkge1xuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnQgYXMgRWxlbWVudCBhcyBFXG4gIH1cblxuICBpZiAoaGFzQ2xhc3MoY3VycmVudCwgY2xhc3NOYW1lKSkge1xuICAgIHJldHVybiBjdXJyZW50XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0V2lkdGgodGV4dDogc3RyaW5nLCBmb250OiBzdHJpbmcpIHtcbiAgLy8gTk9URTogdGhpcyB3aWR0aCBtZWFzdXJpbmcgYWxnb3JpdGhtIGlzIGEgbG90IGZhc3RlclxuICAvLyBidXQgZG9lcyB1bmZvcnR1bmF0ZWx5IG5vdCB3b3JrIG9uIElFIDEwLi4uXG5cbiAgLy8gbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIilcbiAgLy8gbGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4gIC8vIGNvbnRleHQuZm9udCA9IGZvbnRcbiAgLy8gbGV0IG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpXG4gIC8vIHJldHVybiBNYXRoLnJvdW5kKG1ldHJpY3Mud2lkdGgpXG5cbiAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgZGl2LmlubmVySFRNTCA9IHRleHRcblxuICBkaXYuc3R5bGUuZm9udCA9IGZvbnRcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiXG4gIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIlxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KVxuXG4gIGNvbnN0IHJlc3VsdCA9IGRpdi5vZmZzZXRXaWR0aFxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdilcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3MoZWxlbWVudDogRWxlbWVudCwgcHJvcGVydHk6IHN0cmluZykge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSlcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzaW5nbGUgZWxlbWVudCByZWZlcmVuY2VkIGluIGFuIGl0ZW1zIGRhdGEtKiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0ge0RvbUVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSByZWZlcmVuY2UgYXR0cmlidXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSAtIFRoZSBuYW1lIG9mIHRoZSByZWZlcmVuY2UgYXR0cmlidXRlLlxuICogQHJldHVybnMge0RvbUVsZW1lbnR9IFRoZSByZWZlcmVuY2VkIGVsZW1lbnQ7IG9yIGB1bmRlZmluZWRgIGlmIHRoZSByZWZlcmVuY2UgaXMgaW52YWxpZFxuICogb3IgdGhlIGF0dHJpYnV0ZSBjb3VsZCBub3QgYmUgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVSZWZlcmVuY2U8SSBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50LCBPIGV4dGVuZHMgRWxlbWVudCA9IEk+KGVsZW1lbnQ6IEksIGF0dHJpYnV0ZTogc3RyaW5nKTogTyB8IG51bGwgfCB1bmRlZmluZWQge1xuICBjb25zdCBhdHRyVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpXG5cbiAgaWYgKCFhdHRyVmFsdWUgfHwgYXR0clZhbHVlID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXR0clZhbHVlKSBhcyBFbGVtZW50IGFzIE9cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkb2N1bWVudCByb290IGVsZW1lbnQgKG5vcm1hbGx5IHRoZSBib2R5IGVsZW1lbnQpXG4gKiBJZiB0aGUgZG9jdW1lbnQgdXNlcyBhIHNkeC1jb250YWluZXIgd3JhcHBlciB0aGlzIGlzIHJldHVybmVkIGluc3RlYWQuXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gVGhlIHJvb3QgZG9tIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb290RWxlbWVudCgpIHtcbiAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnNkeC1jb250YWluZXJcIilcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmJvZHlcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgY2hpbGQgbm9kZXMgZnJvbSB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgRG9tIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKVxuICB9XG59XG4iLCIvKiBLZXlib2FyZCBpbnB1dCBrZXljb2RlIGRlZmluaXRpb25zICovXG5cbmV4cG9ydCBjb25zdCBLRVlfVEFCID0gOVxuZXhwb3J0IGNvbnN0IEtFWV9FTlRFUiA9IDEzXG5leHBvcnQgY29uc3QgS0VZX0VTQ0FQRSA9IDI3XG5cbi8vIEFycm93IGtleXNcbmV4cG9ydCBjb25zdCBLRVlfQVJST1dfVVAgPSAzOFxuZXhwb3J0IGNvbnN0IEtFWV9BUlJPV19ET1dOID0gNDBcbmV4cG9ydCBjb25zdCBLRVlfQVJST1dfTEVGVCA9IDM3XG5leHBvcnQgY29uc3QgS0VZX0FSUk9XX1JJR0hUID0gMzlcblxuLy8gUGFnZSBrZXlzXG5leHBvcnQgY29uc3QgS0VZX1BBR0VfVVAgPSAzM1xuZXhwb3J0IGNvbnN0IEtFWV9QQUdFX0RPV04gPSAzNFxuXG4vLyBOdW1iZXJzXG5leHBvcnQgY29uc3QgS0VZX05SXzAgPSA0OFxuZXhwb3J0IGNvbnN0IEtFWV9OUl8xID0gNDlcbmV4cG9ydCBjb25zdCBLRVlfTlJfOSA9IDU3XG5cbi8vIGhlbHBlciBmdW5jdGlvbnNcbmV4cG9ydCBsZXQgY29udGFpbnNLZXkgPSAoa2V5Y29kZTogbnVtYmVyLCBpbnB1dHNLZXlzOiBudW1iZXJbXSkgPT4ge1xuICBsZXQgaGFzS2V5ID0gZmFsc2VcbiAgaWYgKGlucHV0c0tleXMgJiYgaW5wdXRzS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgW10uZm9yRWFjaC5jYWxsKGlucHV0c0tleXMsIChpbnB1dHNLZXk6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKGtleWNvZGUgPT09IGlucHV0c0tleSkge1xuICAgICAgICBoYXNLZXkgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICByZXR1cm4gaGFzS2V5XG59XG5cbmV4cG9ydCBsZXQgZ2V0S2V5VmFsdWUgPSAoa2V5Y29kZTogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgaWYgKGtleWNvZGUgPCA0OCB8fCBrZXljb2RlID4gMTA1KSB7XG4gICAgcmV0dXJuIFwiXCJcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NiA8PSBrZXljb2RlICYmIGtleWNvZGUgPD0gMTA1ID8ga2V5Y29kZSAtIDQ4IDoga2V5Y29kZSkudG9Mb3dlckNhc2UoKVxufVxuIiwiLyoqXG4gKiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gY29tcGxldGVseSBwYXJzZWQuXG4gKiBAcGFyYW0ge2NhbGxiYWNrfSB2YWx1ZSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRG9jdW1lbnRSZWFkeShjYWxsYmFjazogKGU/OiBFdmVudCkgPT4gdm9pZCkge1xuICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSlcbiAgICBjYWxsYmFjaygpXG4gIH1cblxuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaylcbiAgfSBlbHNlIHtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UpXG5cbiAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlKVxuICB9XG59XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yIGFuZCBjYWxscyB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uIGlmIHRoZSBgZGF0YS1pbml0YCBhdHRyaWJ1dGUgaXMgcHJlc2VudCBvbiB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7c2VsZWN0b3J9IHZhbHVlIFRoZSBxdWVyeS5cbiAqIEBwYXJhbSB7Y2FsbGJhY2t9IHZhbHVlIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBpbml0aWFsaXplIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaW5pdFNlbGVjdG9yIFRoZSBpbml0aXRhbGl6YXRpb24gZWxlbWVudCBzZWxlY3RvciBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaEFuZEluaXRpYWxpemU8XG4gIEsgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXBcbiAgPihcbiAgICBzZWxlY3RvcjogSyxcbiAgICBjYWxsYmFjazogKGVsOiBIVE1MRWxlbWVudFRhZ05hbWVNYXBbS10pID0+IHZvaWQsXG4gICAgaW5pdFNlbGVjdG9yPzogKGVsOiBIVE1MRWxlbWVudFRhZ05hbWVNYXBbS10pID0+IEVsZW1lbnRcbiAgKTogdm9pZFxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaEFuZEluaXRpYWxpemU8XG4gIEUgZXh0ZW5kcyBFbGVtZW50XG4gID4oXG4gICAgc2VsZWN0b3I6IHN0cmluZyxcbiAgICBjYWxsYmFjazogKGVsOiBFKSA9PiB2b2lkLFxuICAgIGluaXRTZWxlY3Rvcj86IChlbDogRSkgPT4gRWxlbWVudFxuICApOiB2b2lkXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoQW5kSW5pdGlhbGl6ZShcbiAgc2VsZWN0b3I6IHN0cmluZyxcbiAgY2FsbGJhY2s6IChlbDogRWxlbWVudCkgPT4gdm9pZCxcbiAgaW5pdFNlbGVjdG9yPzogKGVsOiBFbGVtZW50KSA9PiBFbGVtZW50XG4pOiB2b2lkIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjYWxsYmFjayBjYW5ub3QgYmUgdW5kZWZpbmVkXCIpXG4gIH1cblxuICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSBhcyBOb2RlTGlzdE9mPEVsZW1lbnQ+XG5cbiAgZm9yIChsZXQgZSBvZiBlbGVtZW50cykge1xuXG4gICAgbGV0IGluaXRFbGVtZW50OiBFbGVtZW50ID0gZVxuXG4gICAgaWYgKGluaXRTZWxlY3Rvcikge1xuICAgICAgaW5pdEVsZW1lbnQgPSBpbml0U2VsZWN0b3IoZSlcbiAgICB9XG5cbiAgICBpZiAoaW5pdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbml0XCIpID09PSBcImF1dG9cIikge1xuICAgICAgY2FsbGJhY2soZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIHdob3NlIHZhbHVlIGlzIGxpbWl0ZWQgdG8gdGhlIGdpdmVuIHJhbmdlLlxuICpcbiAqIEV4YW1wbGU6IGxpbWl0IHRoZSBvdXRwdXQgb2YgdGhpcyBjb21wdXRhdGlvbiB0byBiZXR3ZWVuIDAgYW5kIDI1NVxuICogVXRpbHMuY2xhbXAobnVtYmVyLCAwLCAyNTUpXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgdG8gY2xhbXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSBvdXRwdXQgcmFuZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBvdXRwdXQgcmFuZ2VcbiAqIEByZXR1cm5zIEEgbnVtYmVyIGluIHRoZSByYW5nZSBbbWluLCBtYXhdXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heClcbn1cblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBFdmVudC5wcmV2ZW50RGVmYXVsdCgpLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudDogRXZlbnQpIHtcbiAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9IGVsc2Uge1xuICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIE5vZGUucmVtb3ZlKCkuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byByZW1vdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUobm9kZTogTm9kZSkge1xuICBpZiAoIW5vZGUgfHwgIW5vZGUucGFyZW50Tm9kZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpXG59XG5cbi8qKlxuICogQSBzaW1wbGUgcG9seWZpbGwgZm9yIHRoZSBBcnJheS5maW5kKCkgbWV0aG9kLlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZXhwcmVzc2lvbiAtIFRoZSBleHByZXNzaW9uIHRvIGV2YWx1YXRlLiBNdXN0IHJldHVybiB0cnVlIGlmIHRoZSBlbGVtZW50IG1hdGNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kPFQgPSBhbnk+KFxuICBhcnJheTogVFtdIHwgeyBsZW5ndGg6IG51bWJlciwgW2k6IG51bWJlcl06IFQgfSxcbiAgZXhwcmVzc2lvbjogKGl0ZW06IFQpID0+IGJvb2xlYW5cbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGl0ZW0gPSBhcnJheVtpXVxuICAgIGlmIChleHByZXNzaW9uKGl0ZW0pID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gaXRlbVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBDaGVja3MgdGhlIHVzZXJhZ2VudCBhbmQgcmV0dXJucyB0aGUgTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyIC8gRWRnZSB2ZXJzaW9uLlxuICogSWYgYW5vdGhlciBicm93c2VyIGlzIGRldGVjdGVkIDAgaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm5ldEV4cGxvcmVyT3JFZGdlVmVyc2lvbih1c2VyQWdlbnQ6IHN0cmluZyA9IG5hdmlnYXRvci51c2VyQWdlbnQpIHtcbiAgLy8gaGFuZGxlIElFIGFuZCBFZGdlXG4gIGNvbnN0IGllT3JFZGdlID0gdXNlckFnZW50LnNlYXJjaCgvTVNJRSB8RWRnZVsvXS8pXG4gIGlmIChpZU9yRWRnZSA+IDApIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodXNlckFnZW50LnN1YnN0cmluZyhpZU9yRWRnZSArIDUsIHVzZXJBZ2VudC5pbmRleE9mKFwiLlwiLCBpZU9yRWRnZSkpLCAxMClcbiAgfVxuICAvLyBoYW5kbGUgSUUxMVxuICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJUcmlkZW50L1wiKSA+IDApIHtcbiAgICBjb25zdCBydiA9IHVzZXJBZ2VudC5pbmRleE9mKFwicnY6XCIpXG4gICAgcmV0dXJuIHBhcnNlSW50KHVzZXJBZ2VudC5zdWJzdHJpbmcocnYgKyAzLCB1c2VyQWdlbnQuaW5kZXhPZihcIi5cIiwgcnYpKSwgMTApXG4gIH1cblxuICByZXR1cm4gMFxufVxuXG4vKipcbiAqIFRyaWVzIHRvIG1vdmUgYSBjaGlsZCBlbGVtZW50IHRvIHRoZSB0b3AgYnkgc2Nyb2xsaW5nIHRoZSBwYXJlbnQgZWxlbWVudCwgaWYgaXQgaXMgbm90IGFscmVhZHkgZnVsbHkgdmlzaWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGNoaWxkOiBIVE1MRWxlbWVudCkge1xuICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50XG4gIGNvbnN0IHBhcmVudFJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgY29uc3QgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgY29uc3QgaXNGdWxseVZpc2libGUgPSBjaGlsZFJlY3QudG9wID49IHBhcmVudFJlY3QudG9wICYmIGNoaWxkUmVjdC5ib3R0b20gPD0gcGFyZW50UmVjdC50b3AgKyBwYXJlbnQuY2xpZW50SGVpZ2h0XG5cbiAgaWYgKCFpc0Z1bGx5VmlzaWJsZSkge1xuICAgIHBhcmVudC5zY3JvbGxUb3AgPSBjaGlsZFJlY3QudG9wICsgcGFyZW50LnNjcm9sbFRvcCAtIHBhcmVudFJlY3QudG9wXG4gIH1cbn1cbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IGFuaW1lLCB7IEFuaW1lVGltZWxpbmVJbnN0YW5jZSB9IGZyb20gXCJhbmltZWpzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgUVVFUllfVE9HR0xFID0gXCIuYWNjb3JkaW9uX190b2dnbGVcIlxuY29uc3QgUVVFUllfT1BFTl9TRUNUSU9OID0gXCIuYWNjb3JkaW9uX19pdGVtLmlzLW9wZW5cIlxuY29uc3QgUVVFUllfQ09MTEFQU0UgPSBcIi5hY2NvcmRpb25fX2NvbGxhcHNlXCJcblxuY29uc3QgQ0xBU1NfSVRFTSA9IFwiYWNjb3JkaW9uX19pdGVtXCJcbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfS0VFUF9PUEVOID0gXCJhY2NvcmRpb25fX2tlZXAtb3BlblwiXG5cbmNvbnN0IFJFR0VYX0hJRERFTiA9IC9hY2NvcmRpb24tLWhpZGRlbi0uKi9cblxuY29uc3QgQU5JTUFUSU9OX09QRU4gPSAzMDBcbmNvbnN0IEFOSU1BVElPTl9ERUxBWV9PUEVOID0gNTBcbmNvbnN0IEFOSU1BVElPTl9WSVNJQkxFID0gMTUwXG5cbi8qKlxuICogVGhlIEFjY29yZGlvbiBjb21wb25lbnRcbiAqL1xuY2xhc3MgQWNjb3JkaW9uIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX3NlY3Rpb25DbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9oaWRkZW5JbmRpY2F0b3IhOiBIVE1MSW5wdXRFbGVtZW50XG4gIHByaXZhdGUgYW5pbWF0aW9uITogQW5pbWVUaW1lbGluZUluc3RhbmNlXG4gIHByaXZhdGUgbGFzdEFuaW1hdGVkRWxlbWVudD86IEhUTUxFbGVtZW50XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBBY2NvcmRpb24gY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgQWNjb3JkaW9uIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fc2VjdGlvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVNlY3Rpb25DbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEFjY29yZGlvbiBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLnNvbWUoKGMpID0+IFJFR0VYX0hJRERFTi50ZXN0KGMpKSkge1xuICAgICAgbGV0IGluZGljYXRvciA9IG5ldyBEb21FbGVtZW50PEhUTUxJbnB1dEVsZW1lbnQ+KFwiaW5wdXRcIilcbiAgICAgICAgLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIilcbiAgICAgICAgLmFkZENsYXNzKFwianMtaGlkZGVuXCIpXG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKVxuICAgICAgdGhpcy5faGlkZGVuSW5kaWNhdG9yID0gaW5kaWNhdG9yLmVsZW1lbnRcbiAgICB9XG5cbiAgICBmb3IgKGxldCB0b2dnbGUgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfVE9HR0xFKSkge1xuICAgICAgdG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9zZWN0aW9uQ2xpY2tIYW5kbGVyKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlU2VjdGlvbkNsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIGlmICh0aGlzLl9oaWRkZW5JbmRpY2F0b3IpIHtcbiAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX2hpZGRlbkluZGljYXRvcilcblxuICAgICAgaWYgKHN0eWxlLnZpc2liaWxpdHkgIT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBuYXZTZWN0aW9uID0gKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkucGFyZW50RWxlbWVudCFcblxuICAgIHdoaWxlICghRG9tLmhhc0NsYXNzKG5hdlNlY3Rpb24sIENMQVNTX0lURU0pICYmIG5hdlNlY3Rpb24ucGFyZW50RWxlbWVudCkge1xuICAgICAgbmF2U2VjdGlvbiA9IG5hdlNlY3Rpb24ucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIGxldCBwcmV2U2VjdGlvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX09QRU5fU0VDVElPTilcblxuICAgIGlmIChwcmV2U2VjdGlvbiAmJiBwcmV2U2VjdGlvbiAhPT0gbmF2U2VjdGlvbikge1xuICAgICAgaWYgKCFEb20uaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19LRUVQX09QRU4pKXtcbiAgICAgICAgdGhpcy5fdG9nZ2xlU2VjdGlvbihwcmV2U2VjdGlvbilcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl90b2dnbGVTZWN0aW9uKG5hdlNlY3Rpb24pXG4gIH1cblxuICBwcm90ZWN0ZWQgX3RvZ2dsZVNlY3Rpb24oYWNjU2VjdGlvbjogRWxlbWVudCkge1xuICAgIGxldCBjb2xsYXBzZUVsZW1lbnQgPSBhY2NTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoUVVFUllfQ09MTEFQU0UpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKERvbS5oYXNDbGFzcyhhY2NTZWN0aW9uLCBDTEFTU19PUEVOKSkge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKGFjY1NlY3Rpb24sIENMQVNTX09QRU4pXG4gICAgICB0aGlzLl9jbG9zZUNvbGxhcHNlU2VjdGlvbihjb2xsYXBzZUVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5hZGRDbGFzcyhhY2NTZWN0aW9uLCBDTEFTU19PUEVOKVxuICAgICAgaWYgKGNvbGxhcHNlRWxlbWVudCkgeyAvLyB0byBpZ25vcmUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBubyBjb2xsYXBzaWJsZSBlbGVtZW50IChzZWUgc2R4IGRva3UgbmF2aWdhdGlvbiwgXCJhbGwgdGhlIGJhc2ljc1wiKSBpbiBhIGxpc3Qgb2YgYWNjb3JkaW9uXG4gICAgICAgIHRoaXMuX29wZW5Db2xsYXBzZVNlY3Rpb24oY29sbGFwc2VFbGVtZW50KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb3BlbkNvbGxhcHNlU2VjdGlvbihlbDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLl9zdG9wQW5pbWF0aW9ucyhlbClcblxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWUudGltZWxpbmUoKVxuICAgICAgLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX09QRU4sXG4gICAgICAgIGhlaWdodDogZWwuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiLFxuICAgICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpXG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChDTEFTU19PUEVOKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX1ZJU0lCTEUsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGVhc2luZzogXCJsaW5lYXJcIixcbiAgICAgICAgb2Zmc2V0OiBBTklNQVRJT05fREVMQVlfT1BFTlxuICAgICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2VDb2xsYXBzZVNlY3Rpb24oZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fc3RvcEFuaW1hdGlvbnMoZWwpXG5cbiAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICAgIC5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBlbCxcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgICBoZWlnaHQ6IFwiMHB4XCIsXG4gICAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKVxuICAgICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3BhY2l0eVwiKVxuICAgICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiaGVpZ2h0XCIpXG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpXG4gICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19PUEVOKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zdG9wQW5pbWF0aW9ucyhlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5sYXN0QW5pbWF0ZWRFbGVtZW50ID09PSBlbCkge1xuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnBhdXNlKClcbiAgICAgIH1cbiAgICAgIGFuaW1lLnJlbW92ZShlbClcbiAgICB9XG4gICAgdGhpcy5sYXN0QW5pbWF0ZWRFbGVtZW50ID0gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCB0b2dnbGUgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfVE9HR0xFKSkge1xuICAgICAgdG9nZ2xlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9zZWN0aW9uQ2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX3NlY3Rpb25DbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuZWxlbWVudCA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5hY2NvcmRpb25cIiwgKGUpID0+IHtcbiAgICBuZXcgQWNjb3JkaW9uKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFjY29yZGlvblxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgY2xhbXAsIHByZXZlbnREZWZhdWx0LCByZW1vdmUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9TTElERVIgPSBcIi5jYXJvdXNlbF9fY29udGFpbmVyXCJcbmNvbnN0IFFVRVJZX1NMSURFX0FSRUEgPSBcIi5jYXJvdXNlbF9fc2xpZGVyXCJcbmNvbnN0IFFVRVJZX1dSQVBQRVIgPSBcIi5jYXJvdXNlbF9fc2xpZGVyLXdyYXBwZXJcIlxuXG5jb25zdCBRVUVSWV9QQUdJTkFUSU9OID0gXCIuY2Fyb3VzZWxfX3BhZ2luYXRpb25cIlxuXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcInNsaWRlLS1hY3RpdmVcIlxuY29uc3QgQ0xBU1NfUFJFViA9IFwic2xpZGUtLXByZXZcIlxuY29uc3QgQ0xBU1NfTkVYVCA9IFwic2xpZGUtLW5leHRcIlxuXG5jb25zdCBDTEFTU19CVUxMRVQgPSBcInBhZ2luYXRpb24tYnVsbGV0XCJcbmNvbnN0IENMQVNTX0JVTExFVF9BQ1RJVkUgPSBcInBhZ2luYXRpb24tYnVsbGV0LS1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9CVE5fUFJFViA9IFwiLmNhcm91c2VsX19idXR0b24tcHJldlwiXG5jb25zdCBRVUVSWV9CVE5fTkVYVCA9IFwiLmNhcm91c2VsX19idXR0b24tbmV4dFwiXG5jb25zdCBRVUVSWV9CVE5fV1JBUFBFUiA9IFwiLmNhcm91c2VsX19idXR0b24td3JhcHBlclwiXG5cbmNvbnN0IEFUVFJJQlVURV9JTkRFWCA9IFwianMtaW5kZXhcIlxuXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT04gPSAzNTBcbmNvbnN0IEFOSU1BVElPTl9FQVNJTkcgPSBcImVhc2UtaW4tb3V0XCJcblxuY29uc3QgVE9VQ0hfRFVSQVRJT04gPSAzMDBcbmNvbnN0IFRPVUNIX0RFTFRBX01JTiA9IDI1XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVQcm9wZXJ0aWVzIHtcbiAgcmlnaHQ6IG51bWJlclxuICBsZWZ0OiBudW1iZXJcbiAgdmlzaWJsZTogYm9vbGVhblxuICBpbmRleDogbnVtYmVyXG4gIHdpZHRoOiBudW1iZXJcbiAgbWFyZ2luTGVmdDogbnVtYmVyXG4gIG1hcmdpblJpZ2h0OiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRGlyZWN0aW9uID0gMCB8IC0xIHwgMVxuXG4vKipcbiAqIFRoZSBjYXJvdXNlbCBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX3NsaWRlcjogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfd3JhcHBlcjogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfcGFnaW5hdGlvbj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3NsaWRlQXJlYTogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9idG5XcmFwcGVyOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9wcmV2Q3RybDogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbmV4dEN0cmw6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfc2xpZGVzOiBIVE1MRWxlbWVudFtdXG5cbiAgcHJpdmF0ZSBfaW5kZXg6IG51bWJlclxuICBwcml2YXRlIF9zbGlkZXNQZXJHcm91cDogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfc2xpZGVyV3JhcHBlcjogU2xpZGVyV3JhcHBlclxuXG4gIHByaXZhdGUgX2FkZGl0aW9uYWxTbGlkZU1hcmdpbjogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfcmVzaXplSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9wcmV2SGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9uZXh0SGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9wYWdpbmF0aW9uQ2xpY2tIYW5kbGVyOiAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2hhbmRsZVRvdWNoc3RhcnQ6IChldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfaGFuZGxlVG91Y2htb3ZlOiAoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2hhbmRsZVRvdWNoZW5kOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfYnJlYWtwb2ludFBob25lITogSFRNTERpdkVsZW1lbnRcbiAgcHJpdmF0ZSBfYnJlYWtwb2ludFRhYmxldCE6IEhUTUxEaXZFbGVtZW50XG4gIHByaXZhdGUgX2JyZWFrcG9pbnREZXNrdG9wITogSFRNTERpdkVsZW1lbnRcblxuICBwcml2YXRlIF90b3VjaE9mZnNldD86IHtcbiAgICB4OiBudW1iZXI7XG4gICAgdGltZTogbnVtYmVyO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGVsdGE/OiB7XG4gICAgeDogbnVtYmVyO1xuICAgIGxhc3RNb3ZlOiBudW1iZXI7XG4gIH1cblxuICBwcml2YXRlIF9mcmFtZVdpZHRoPzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBjYXJvdXNlbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gZWxlbWVudCAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIENhcm91c2VsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluaXRpYWwgaW5kZXguXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgaW5kZXggPSAwKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX3NsaWRlciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX1NMSURFUikhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fd3JhcHBlciA9IHRoaXMuX3NsaWRlci5xdWVyeVNlbGVjdG9yKFFVRVJZX1dSQVBQRVIpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX3BhZ2luYXRpb24gPSB0aGlzLl9zbGlkZXIucXVlcnlTZWxlY3RvcihRVUVSWV9QQUdJTkFUSU9OKSBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX3NsaWRlQXJlYSA9IHRoaXMuX3NsaWRlci5xdWVyeVNlbGVjdG9yKFFVRVJZX1NMSURFX0FSRUEpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgdGhpcy5fYnRuV3JhcHBlciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0JUTl9XUkFQUEVSKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9wcmV2Q3RybCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0JUTl9QUkVWKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9uZXh0Q3RybCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0JUTl9ORVhUKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIHRoaXMuX3NsaWRlcyA9IFtdXG5cbiAgICB0aGlzLl9pbmRleCA9IGluZGV4IHx8IDBcbiAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IDFcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIgPSBuZXcgU2xpZGVyV3JhcHBlcih0aGlzLl93cmFwcGVyLCB0aGlzLl9zbGlkZUFyZWEsIHRoaXMuZWxlbWVudClcbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4ID0gdGhpcy5faW5kZXhcbiAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSAwXG5cbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gdGhpcy5fb25yZXNpemUuYmluZCh0aGlzKVxuICAgIHRoaXMuX3ByZXZIYW5kbGVyID0gdGhpcy5wcmV2LmJpbmQodGhpcylcbiAgICB0aGlzLl9uZXh0SGFuZGxlciA9IHRoaXMubmV4dC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcGFnaW5hdGlvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVBhZ2luYXRpb25DbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQgPSB0aGlzLl9vblRvdWNoc3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2hhbmRsZVRvdWNobW92ZSA9IHRoaXMuX29uVG91Y2htb3ZlLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVUb3VjaGVuZCA9IHRoaXMuX29uVG91Y2hlbmQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gICAgdGhpcy5zbGlkZSh0aGlzLl9pbmRleCwgMCwgZmFsc2UpXG5cbiAgICB0aGlzLl91cGRhdGVDdHJsT2Zmc2V0cygpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNhcm91c2VsIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyByZXNwb25zaXZlIGhlbHBlcnNcbiAgICB0aGlzLl9icmVha3BvaW50UGhvbmUgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhcImpzLXBob25lXCIpXG4gICAgICAuZWxlbWVudFxuXG4gICAgdGhpcy5fYnJlYWtwb2ludFRhYmxldCA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwianMtdGFibGV0XCIpXG4gICAgICAuZWxlbWVudFxuXG4gICAgdGhpcy5fYnJlYWtwb2ludERlc2t0b3AgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhcImpzLWRlc2t0b3BcIilcbiAgICAgIC5lbGVtZW50XG5cbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fYnJlYWtwb2ludFBob25lKVxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9icmVha3BvaW50VGFibGV0KVxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9icmVha3BvaW50RGVza3RvcClcblxuICAgIGlmICh0aGlzLl9wcmV2Q3RybCAmJiB0aGlzLl9uZXh0Q3RybCkge1xuICAgICAgdGhpcy5fcHJldkN0cmwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3ByZXZIYW5kbGVyKVxuICAgICAgdGhpcy5fbmV4dEN0cmwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX25leHRIYW5kbGVyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYWdpbmF0aW9uKSB7XG4gICAgICB0aGlzLl9wYWdpbmF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wYWdpbmF0aW9uQ2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgIHRoaXMuX3NsaWRlcyA9IEFycmF5LmZyb20odGhpcy5fd3JhcHBlci5jaGlsZHJlbikgYXMgSFRNTEVsZW1lbnRbXVxuICAgIGlmICh0aGlzLl9zbGlkZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlByb3ZpZGUgYXQgbGVhc3Qgb25lIHNsaWRlIHRvIHRoZSBzbGlkZXJcIilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NsaWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNsaWRlID0gdGhpcy5fc2xpZGVzW2ldXG4gICAgICBzbGlkZS5zZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYLCBTdHJpbmcoaSkpXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUmVzcG9uc2l2ZU9wdGlvbnMoKVxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuaW5pdGlhbGl6ZSgpXG5cbiAgICB0aGlzLnJlc2V0KClcblxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcblxuICAgIHRoaXMuX3NsaWRlQXJlYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG4gICAgdGhpcy5fc2xpZGVBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNCcmVha3BvaW50QWN0aXZlKGJyZWFrcG9pbnQ6IEhUTUxEaXZFbGVtZW50KSB7XG4gICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoYnJlYWtwb2ludClcbiAgICByZXR1cm4gc3R5bGUudmlzaWJpbGl0eSA9PT0gXCJ2aXNpYmxlXCJcbiAgfVxuXG4gIHByb3RlY3RlZCBfb25yZXNpemUoKSB7XG4gICAgdGhpcy5yZXNldCgpXG4gICAgdGhpcy5fdXBkYXRlQ3RybE9mZnNldHMoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIHN1cmUgdGhlIGluZGV4IGlzIGFsd2F5cyBpbiB0aGUgcmFuZ2Ugb2YgYXZhaWxhYmxlIHNsaWRlXG4gICAqIEluIGNhc2UgaXQncyB0byBoaWdoIG9yIHRvIGxvdyBpdCBpcyB3cmFwcGVkIGFyb3VuZFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdG8gYWRqdXN0IGFuZCBzYW5pdGl6ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpbmRleCAtIFRoZSBhZGp1c3RlZCBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9hZGp1c3RJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgaW5kZXggPSAwXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSB0aGlzLl93cmFwcm91bmQoaW5kZXgsIDAsIHRoaXMuX3NsaWRlcy5sZW5ndGgpXG4gICAgfSBlbHNlIGlmIChpbmRleCA+PSB0aGlzLl9zbGlkZXMubGVuZ3RoKSB7XG4gICAgICBpbmRleCAlPSB0aGlzLl9zbGlkZXMubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLl9zbGlkZXNQZXJHcm91cCkgKiB0aGlzLl9zbGlkZXNQZXJHcm91cFxuICB9XG5cbiAgcHJvdGVjdGVkIF93cmFwcm91bmQobjogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgICBpZiAobiA+PSBtYXgpIHtcbiAgICAgIHJldHVybiBtaW5cbiAgICB9XG5cbiAgICBpZiAobiA8IG1pbikge1xuICAgICAgcmV0dXJuIG1heCAtIDFcbiAgICB9XG5cbiAgICByZXR1cm4gblxuICB9XG5cbiAgcHJvdGVjdGVkIF93cmFwcm91bmRDb3VudChhOiBudW1iZXIsIGI6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBkaXJlY3Rpb246IERpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IDApIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgaWYgKGEgPCBtaW4gfHwgYSA+PSBtYXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgJ2EnIGlzIG91dCBvZiByYW5nZSwgVmFsdWU6ICR7YX0gTWluOiAke21pbn0sIE1heDogJHttYXh9YClcbiAgICB9XG5cbiAgICBpZiAoYiA8IG1pbiB8fCBiID49IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAnYicgaXMgb3V0IG9mIHJhbmdlLCBWYWx1ZTogJHtifSBNaW46ICR7bWlufSwgTWF4OiAke21heH1gKVxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChhICE9PSBiKSB7XG4gICAgICBpKytcbiAgICAgIGEgPSB0aGlzLl93cmFwcm91bmQoYSArIGRpcmVjdGlvbiwgbWluLCBtYXgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGlcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlQ3RybE9mZnNldHMoKSB7XG4gICAgaWYgKCF0aGlzLl9uZXh0Q3RybCB8fCAhdGhpcy5fcHJldkN0cmwgfHwgIXRoaXMuX2J0bldyYXBwZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBwcmV2Q3RybE1hcmdpbiA9IDBcbiAgICBsZXQgbmV4dEN0cmxNYXJnaW4gPSAwXG5cbiAgICBpZiAodGhpcy5fc2xpZGVzUGVyR3JvdXAgPiAxKSB7XG4gICAgICBsZXQgd3JhcHBlclJlY3QgPSB0aGlzLl9idG5XcmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIGNvbnN0IHByZXZTbGlkZUNvdW50ID0gTWF0aC5mbG9vcigwLjUgKiB0aGlzLl9zbGlkZXNQZXJHcm91cClcbiAgICAgIGNvbnN0IHJpZ2h0SW5kZXggPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4ICsgcHJldlNsaWRlQ291bnQgKyAxXG5cbiAgICAgIGxldCBsZWZ0SW5kZXggPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4IC0gMVxuICAgICAgaWYgKHRoaXMuX3NsaWRlc1Blckdyb3VwICUgMiAhPT0gMCkge1xuICAgICAgICBsZWZ0SW5kZXggLT0gcHJldlNsaWRlQ291bnRcbiAgICAgIH1cblxuICAgICAgaWYgKChsZWZ0SW5kZXggPj0gMCAmJiBsZWZ0SW5kZXggPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCkgJiZcbiAgICAgICAgKHJpZ2h0SW5kZXggPj0gMCAmJiByaWdodEluZGV4IDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIGxldCBsZWZ0U2xpZGUgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlUHJvcGVydGllcyhsZWZ0SW5kZXgpXG4gICAgICAgIGxldCByaWdodFNsaWRlID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXMocmlnaHRJbmRleClcblxuICAgICAgICBsZXQgYnRuV2lkdGggPSB0aGlzLl9wcmV2Q3RybC5vZmZzZXRXaWR0aFxuICAgICAgICBpZiAoYnRuV2lkdGggPD0gMCkge1xuICAgICAgICAgIGJ0bldpZHRoID0gNjBcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZDdHJsTWFyZ2luID0gbGVmdFNsaWRlLnJpZ2h0IC0gd3JhcHBlclJlY3QubGVmdCAtIGJ0bldpZHRoXG4gICAgICAgIG5leHRDdHJsTWFyZ2luID0gd3JhcHBlclJlY3QucmlnaHQgLSByaWdodFNsaWRlLmxlZnQgLSBidG5XaWR0aFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBsZWZ0ID0gcHJldkN0cmxNYXJnaW4gIT09IDAgPyBgJHtwcmV2Q3RybE1hcmdpbn1weGAgOiBcIlwiXG4gICAgdGhpcy5fcHJldkN0cmwuc3R5bGUubGVmdCA9IGxlZnRcblxuICAgIGxldCByaWdodCA9IG5leHRDdHJsTWFyZ2luICE9PSAwID8gYCR7bmV4dEN0cmxNYXJnaW59cHhgIDogXCJcIlxuICAgIHRoaXMuX25leHRDdHJsLnN0eWxlLnJpZ2h0ID0gcmlnaHRcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlQWN0aXZlU2xpZGVzKG5leHRJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgcHJldlNsaWRlQ291bnQgPSBNYXRoLmZsb29yKDAuNSAqICh0aGlzLl9zbGlkZXNQZXJHcm91cCAtIDEpKVxuICAgIGNvbnN0IGV2ZW5Hcm91cCA9IHRoaXMuX3NsaWRlc1Blckdyb3VwICUgMiA9PT0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2xpZGUgPSB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2ldXG5cbiAgICAgIGlmIChpID09PSBuZXh0SW5kZXggfHwgKGV2ZW5Hcm91cCAmJiBpID09PSBuZXh0SW5kZXggKyAxKSkge1xuICAgICAgICBEb20uYWRkQ2xhc3Moc2xpZGUsIENMQVNTX0FDVElWRSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhzbGlkZSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IG5leHRJbmRleCAmJiBpID49IG5leHRJbmRleCAtIHByZXZTbGlkZUNvdW50KSB7XG4gICAgICAgIERvbS5hZGRDbGFzcyhzbGlkZSwgQ0xBU1NfUFJFVilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhzbGlkZSwgQ0xBU1NfUFJFVilcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiBuZXh0SW5kZXggJiYgKGkgPD0gbmV4dEluZGV4ICsgcHJldlNsaWRlQ291bnQgfHwgKGV2ZW5Hcm91cCAmJiBpIDw9IG5leHRJbmRleCArIDEgKyBwcmV2U2xpZGVDb3VudCkpKSB7XG4gICAgICAgIERvbS5hZGRDbGFzcyhzbGlkZSwgQ0xBU1NfTkVYVClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhzbGlkZSwgQ0xBU1NfTkVYVClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbmQgY3JlYXRlcyB0aGUgcGFnaW5hdGlvbiBidWxsZXRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF91cGRhdGVQYWdpbmF0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcGFnaW5hdGlvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRvID0gdGhpcy5faW5kZXhcblxuICAgIGxldCBidWxsZXRzID0gdGhpcy5fcGFnaW5hdGlvbi5jaGlsZHJlblxuICAgIGxldCB0b3RhbEl0ZW1zID0gTWF0aC5tYXgodGhpcy5fc2xpZGVzLmxlbmd0aCwgYnVsbGV0cy5sZW5ndGgpXG4gICAgbGV0IHNsaWRlQ291bnQgPSBNYXRoLmNlaWwodGhpcy5fc2xpZGVzLmxlbmd0aCAvIHRoaXMuX3NsaWRlc1Blckdyb3VwKVxuICAgIGxldCBhY3RpdmVTbGlkZUluZGV4ID0gTWF0aC5mbG9vcih0byAvIHRoaXMuX3NsaWRlc1Blckdyb3VwKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEl0ZW1zOyBpKyspIHtcbiAgICAgIGxldCBidWxsZXRcblxuICAgICAgaWYgKGJ1bGxldHMubGVuZ3RoID4gaSkge1xuICAgICAgICBpZiAoYnVsbGV0cy5sZW5ndGggPD0gc2xpZGVDb3VudCkge1xuICAgICAgICAgIGJ1bGxldCA9IGJ1bGxldHNbaV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmUoYnVsbGV0c1tpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpIDwgc2xpZGVDb3VudCkge1xuICAgICAgICBidWxsZXQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19CVUxMRVQpXG4gICAgICAgICAgLmVsZW1lbnRcbiAgICAgICAgdGhpcy5fcGFnaW5hdGlvbi5hcHBlbmRDaGlsZChidWxsZXQpXG4gICAgICB9XG5cbiAgICAgIGlmIChidWxsZXQgJiYgaSA8IHNsaWRlQ291bnQpIHtcbiAgICAgICAgaWYgKGkgPT09IGFjdGl2ZVNsaWRlSW5kZXgpIHtcbiAgICAgICAgICBEb20uYWRkQ2xhc3MoYnVsbGV0LCBDTEFTU19CVUxMRVRfQUNUSVZFKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERvbS5yZW1vdmVDbGFzcyhidWxsZXQsIENMQVNTX0JVTExFVF9BQ1RJVkUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVBhZ2luYXRpb25DbGljayhlOiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKCFEb20uaGFzQ2xhc3MoZS50YXJnZXQgYXMgRWxlbWVudCwgQ0xBU1NfQlVMTEVUKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gQXJyYXkuZnJvbSh0aGlzLl9wYWdpbmF0aW9uIS5jaGlsZHJlbikuaW5kZXhPZihlLnRhcmdldCBhcyBFbGVtZW50KVxuICAgIGxldCBzbGlkZU51bWJlciA9IGluZGV4ICogdGhpcy5fc2xpZGVzUGVyR3JvdXBcblxuICAgIHRoaXMuc2xpZGVUbyhzbGlkZU51bWJlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgc3dpdGNoIChrZXljb2RlKSB7XG4gICAgICBjYXNlIElucHV0cy5LRVlfQVJST1dfTEVGVDpcbiAgICAgICAgdGhpcy5wcmV2KClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgSW5wdXRzLktFWV9BUlJPV19SSUdIVDpcbiAgICAgICAgdGhpcy5uZXh0KClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgSW5wdXRzLktFWV9FU0NBUEU6XG4gICAgICAgIHRoaXMuZWxlbWVudC5ibHVyKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vblRvdWNoc3RhcnQoZXZlbnQ6IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50KSB7XG4gICAgY29uc3QgdG91Y2ggPSAoZXZlbnQgYXMgVG91Y2hFdmVudCkudG91Y2hlcyA/IChldmVudCBhcyBUb3VjaEV2ZW50KS50b3VjaGVzWzBdIDogZXZlbnQgYXMgTW91c2VFdmVudFxuXG4gICAgdGhpcy5fc2xpZGVBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcbiAgICB0aGlzLl9zbGlkZUFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuYmVnaW5EcmFnKClcbiAgICBjb25zdCB7IHBhZ2VYIH0gPSB0b3VjaFxuXG4gICAgdGhpcy5fdG91Y2hPZmZzZXQgPSB7XG4gICAgICB4OiBwYWdlWCxcbiAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICB9XG5cbiAgICB0aGlzLl9kZWx0YSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICBsYXN0TW92ZTogcGFnZVhcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2hhbmRsZVRvdWNoZW5kKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuX2hhbmRsZVRvdWNoZW5kKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgfVxuXG4gIHByb3RlY3RlZCBfb25Ub3VjaG1vdmUoZXZlbnQ6IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50KSB7XG4gICAgY29uc3QgdG91Y2ggPSAoZXZlbnQgYXMgVG91Y2hFdmVudCkudG91Y2hlcyA/IChldmVudCBhcyBUb3VjaEV2ZW50KS50b3VjaGVzWzBdIDogZXZlbnQgYXMgTW91c2VFdmVudFxuICAgIGNvbnN0IHsgcGFnZVggfSA9IHRvdWNoXG5cbiAgICBsZXQgZGVsdGFNb3ZlID0gcGFnZVggLSB0aGlzLl9kZWx0YSEubGFzdE1vdmVcblxuICAgIHRoaXMuX2RlbHRhID0ge1xuICAgICAgeDogcGFnZVggLSB0aGlzLl90b3VjaE9mZnNldCEueCxcbiAgICAgIGxhc3RNb3ZlOiBwYWdlWFxuICAgIH1cblxuICAgIGlmICh0aGlzLl90b3VjaE9mZnNldCkge1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG5cbiAgICAgIHRoaXMuX3NsaWRlcldyYXBwZXIubW92ZShkZWx0YU1vdmUpXG4gICAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSwgZGVsdGFNb3ZlKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb25Ub3VjaGVuZCgpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX3RvdWNoT2Zmc2V0ID8gRGF0ZS5ub3coKSAtIHRoaXMuX3RvdWNoT2Zmc2V0LnRpbWUgOiB1bmRlZmluZWRcblxuICAgIGNvbnN0IGlzVmFsaWQgPSBOdW1iZXIoZHVyYXRpb24pIDwgVE9VQ0hfRFVSQVRJT04gJiZcbiAgICAgIE1hdGguYWJzKHRoaXMuX2RlbHRhIS54KSA+IFRPVUNIX0RFTFRBX01JTiB8fFxuICAgICAgTWF0aC5hYnModGhpcy5fZGVsdGEhLngpID4gdGhpcy5fZnJhbWVXaWR0aCEgLyAzXG5cbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gY2xhbXAodGhpcy5fZGVsdGEhLngsIC0xLCAxKSAqIC0xIGFzIERpcmVjdGlvblxuICAgICAgdGhpcy5zbGlkZShmYWxzZSwgZGlyZWN0aW9uLCB0cnVlKVxuXG4gICAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmVuZERyYWcoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbGlkZSBiYWNrIHRvIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZyBvcGVyYXRpb25cbiAgICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuY2FuY2VsRHJhZygpXG4gICAgfVxuXG4gICAgdGhpcy5fdG91Y2hPZmZzZXQgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX3NsaWRlQXJlYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG4gICAgdGhpcy5fc2xpZGVBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlZCBwYXJhbWV0ZXJzIGluIHJlZ2FyZCB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSByZXNwb25zaXZlXG4gICAqIGJyZWFrcG9pbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX3VwZGF0ZVJlc3BvbnNpdmVPcHRpb25zKCkge1xuICAgIGlmICh0aGlzLl9pc0JyZWFrcG9pbnRBY3RpdmUodGhpcy5fYnJlYWtwb2ludFBob25lKSkge1xuICAgICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSAxXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzQnJlYWtwb2ludEFjdGl2ZSh0aGlzLl9icmVha3BvaW50VGFibGV0KSkge1xuICAgICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSAyXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzQnJlYWtwb2ludEFjdGl2ZSh0aGlzLl9icmVha3BvaW50RGVza3RvcCkpIHtcbiAgICAgIHRoaXMuX3NsaWRlc1Blckdyb3VwID0gM1xuICAgIH1cblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuc2xpZGVzUGVyR3JvdXAgPSB0aGlzLl9zbGlkZXNQZXJHcm91cFxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgcmVxdWVzdGVkIHNsaWRlIGFuZCBhZGRzIGl0IHRvIHRoZSBzbGlkZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBvcmlnaW5hbCBzbGlkZSBpbmRleCBvZiB0aGUgdGVtcGxhdGUgc2xpZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gYWRkIHRoZSBzbGlkZXMsIC0xIGZvciBsZWZ0LCAxIGZvciByaWdodFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9jbG9uZVNsaWRlKGluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogbnVtYmVyKSB7XG4gICAgbGV0IGNsb25lID0gdGhpcy5fc2xpZGVzW2luZGV4XS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnRcbiAgICBEb20ucmVtb3ZlQ2xhc3MoY2xvbmUsIENMQVNTX0FDVElWRSlcbiAgICBEb20ucmVtb3ZlQ2xhc3MoY2xvbmUsIENMQVNTX1BSRVYpXG4gICAgRG9tLnJlbW92ZUNsYXNzKGNsb25lLCBDTEFTU19ORVhUKVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5hZGRTbGlkZShjbG9uZSwgZGlyZWN0aW9uKVxuXG4gICAgbGV0IHNsaWRlTWFyZ2luID0gdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID4gMCA/IGAke3RoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbn1weGAgOiBcIlwiXG4gICAgY2xvbmUuc3R5bGUubWFyZ2luTGVmdCA9IHNsaWRlTWFyZ2luXG4gICAgY2xvbmUuc3R5bGUubWFyZ2luUmlnaHQgPSBzbGlkZU1hcmdpblxuXG4gICAgcmV0dXJuIGNsb25lLm9mZnNldFdpZHRoXG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIGFuZCBhZGRzIHRoZSByZXF1ZXN0ZWQgYW1tb3VudCBvZiBzbGlkZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzbGlkZUNvdW50IC0gVGhlIG51bWJlciBvZiBzbGlkZXMgdG8gYWRkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRvIGFkZCB0aGUgc2xpZGVzLCAtMSBmb3IgbGVmdCwgMSBmb3IgcmlnaHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfY2xvbmVTbGlkZXNCeUNvdW50KHNsaWRlQ291bnQ6IG51bWJlciwgZGlyZWN0aW9uOiBEaXJlY3Rpb24pIHtcbiAgICBsZXQgb3JpZ2luYWxJbmRleCA9IGRpcmVjdGlvbiA8IDAgPyAwIDogdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgbGV0IGluZGV4ID0gcGFyc2VJbnQodGhpcy5fd3JhcHBlci5jaGlsZHJlbltvcmlnaW5hbEluZGV4XS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSEsIDEwKVxuXG4gICAgd2hpbGUgKHNsaWRlQ291bnQgPiAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX3dyYXByb3VuZChpbmRleCArIGRpcmVjdGlvbiwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aClcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGUoaW5kZXgsIGRpcmVjdGlvbilcbiAgICAgIHNsaWRlQ291bnQtLVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgY2xvdW50IGFuZCBpbnNlcnRzIHRoZSByZXF1aXJlZCBhbW1vdW50IG9mIHNsaWRlc1xuICAgKiBpbiB0aGUgYXByb3ByaWF0ZSBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXh0SW5kZXggLSBUaGUgc2xpZGUgdG8gc2Nyb2xsIHRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzY3JvbGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfY2xvbmVTbGlkZXNCeVNjcm9sbENvdW50KG5leHRJbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IERpcmVjdGlvbikge1xuICAgIGNvbnN0IHNjcm9sbENvdW50ID0gdGhpcy5fd3JhcHJvdW5kQ291bnQodGhpcy5faW5kZXgsIG5leHRJbmRleCwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aCwgZGlyZWN0aW9uKVxuXG4gICAgY29uc3Qgb3V0ZXJTbGlkZVByb3BzID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXMoZGlyZWN0aW9uID4gMCA/IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDApXG4gICAgY29uc3QgaW5kZXhUb091dGVyU2xpZGVDb3VudCA9IHRoaXMuX3dyYXByb3VuZENvdW50KHRoaXMuX2luZGV4LCBvdXRlclNsaWRlUHJvcHMuaW5kZXgsIDAsIHRoaXMuX3NsaWRlcy5sZW5ndGgsIGRpcmVjdGlvbilcblxuICAgIGNvbnN0IHNsaWRlc1RvSW5zZXJ0ID0gc2Nyb2xsQ291bnQgLSBpbmRleFRvT3V0ZXJTbGlkZUNvdW50XG4gICAgaWYgKHNsaWRlc1RvSW5zZXJ0ID4gMCkge1xuICAgICAgdGhpcy5fY2xvbmVTbGlkZXNCeUNvdW50KHNsaWRlc1RvSW5zZXJ0LCBkaXJlY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9uZVNsaWRlc0J5VG9GaWxsKHNwYWNlVG9GaWxsOiBudW1iZXIsIGRpcmVjdGlvbjogRGlyZWN0aW9uKSB7XG4gICAgbGV0IG9yaWdpbmFsSW5kZXggPSBkaXJlY3Rpb24gPCAwID8gMCA6IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgIGxldCBpbmRleCA9IHBhcnNlSW50KHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5bb3JpZ2luYWxJbmRleF0uZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9JTkRFWCkhLCAxMClcblxuICAgIHdoaWxlIChzcGFjZVRvRmlsbCA+IDApIHtcbiAgICAgIGluZGV4ID0gdGhpcy5fd3JhcHJvdW5kKGluZGV4ICsgZGlyZWN0aW9uLCAwLCB0aGlzLl9zbGlkZXMubGVuZ3RoKVxuICAgICAgc3BhY2VUb0ZpbGwgLT0gdGhpcy5fY2xvbmVTbGlkZShpbmRleCwgZGlyZWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvbmVTbGlkZXNUb0ZpdFdyYXBwZXIoY2xlYW51cCA9IHRydWUsIHNsaWRlRGVsdGEgPSAwKSB7XG4gICAgY29uc3QgcmVhbEluZGV4ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleFxuICAgIGxldCBmaXJzdDogU2xpZGVQcm9wZXJ0aWVzXG4gICAgbGV0IGxhc3Q6IFNsaWRlUHJvcGVydGllc1xuXG4gICAgaWYgKGNsZWFudXAgPT09IGZhbHNlKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0U2xpZGVQcm9wZXJ0aWVzKDApXG4gICAgICBsYXN0ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXModGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGggLSAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRSZW1vdmFibGVTbGlkZXMoc2xpZGVEZWx0YSlcbiAgICAgIGZpcnN0ID0gcmVzdWx0LmZpcnN0IVxuICAgICAgbGFzdCA9IHJlc3VsdC5sYXN0IVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIHNsaWRlcyBmcm9tIHZpZXdcbiAgICAgIGZvciAobGV0IGkgPSByZXN1bHQuc2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChyZXN1bHQuc2xpZGVzW2ldID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fc2xpZGVyV3JhcHBlci5yZW1vdmVTbGlkZShpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNwYWNlVG9GaWxsID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRFbXB0eVNwYWNlKGZpcnN0LmxlZnQsIGxhc3QucmlnaHQpXG5cbiAgICAvLyBDaGVjayBpZiBhZGRpdGlvbmFsIHNsaWRlcyBhcmUgcmVxdWlyZWQgb24gdGhlIGxlZnRcbiAgICBpZiAoZmlyc3QudmlzaWJsZSA9PT0gdHJ1ZSAmJiBzcGFjZVRvRmlsbC5sZWZ0ID4gMCkge1xuICAgICAgdGhpcy5fY2xvbmVTbGlkZXNCeVRvRmlsbChzcGFjZVRvRmlsbC5sZWZ0LCAtMSlcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhZGRpdGlvbmFsIHNsaWRlcyBhcmUgcmVxdWlyZWQgb24gdGhlIHJpZ2h0XG4gICAgaWYgKGxhc3QudmlzaWJsZSA9PT0gdHJ1ZSAmJiBzcGFjZVRvRmlsbC5yaWdodCA+IDApIHtcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGVzQnlUb0ZpbGwoc3BhY2VUb0ZpbGwucmlnaHQsIDEpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWxJbmRleCAtIHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXhcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWFsICh3cmFwcGVyKSBpbmRleCBmb3IgdGhlIHNsaWRlIHdpdGggdGhlIGdpdmVuIG9yaWdpbmFsIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRvIHNlYXJjaFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgd3JhcHBlciBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9nZXRSZWFsSW5kZXhGb3IoaW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBEaXJlY3Rpb24pIHtcbiAgICBsZXQgaSA9IHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXhcbiAgICB3aGlsZSAoaSA+PSAwICYmIGkgPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgbGV0IHNsaWRlSW5kZXggPSBwYXJzZUludCh0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2ldLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfSU5ERVgpISwgMTApXG4gICAgICBpZiAoc2xpZGVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cblxuICAgICAgaSArPSBkaXJlY3Rpb25cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENsb3VkIG5vdCBmaW5kIHJlYWwgaW5kZXggZm9yIHNsaWRlICR7aW5kZXh9IGluIGRpcmVjdGlvbiAke2RpcmVjdGlvbn1gKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBzbGlkZS4gSWYgdGhlIHNsaWRlcyBhcmUgZ3JvdXBlZCBldmVubHlcbiAgICogdGhlIGFjdGl2ZSBzbGlkZSBpcyBhbHdheXMgdGhlIGZpcnN0IGluIHRoZSBncm91cC5cbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBhY3RpdmUgc2xpZGUuXG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKSB7XG4gICAgdGhpcy5fZnJhbWVXaWR0aCA9IHRoaXMuX3NsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgLndpZHRoIHx8IHRoaXMuX3NsaWRlci5vZmZzZXRXaWR0aFxuXG4gICAgdGhpcy5fdXBkYXRlUmVzcG9uc2l2ZU9wdGlvbnMoKVxuXG4gICAgaWYgKHRoaXMuX25leHRDdHJsKSB7XG4gICAgICAodGhpcy5fbmV4dEN0cmwgYXMgYW55KS5kaXNhYmxlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ByZXZDdHJsKSB7XG4gICAgICAodGhpcy5fcHJldkN0cmwgYXMgYW55KS5kaXNhYmxlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NsaWRlc1Blckdyb3VwID09PSAxKSB7XG4gICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9zbGlkZXIucGFyZW50RWxlbWVudCEpXG4gICAgICBsZXQgcGFyZW50V2lkdGggPSB0aGlzLl9zbGlkZXIucGFyZW50RWxlbWVudCEuY2xpZW50V2lkdGggKyAocGFyc2VGbG9hdChzdHlsZS5tYXJnaW5MZWZ0ISkgfHwgMCkgKyAocGFyc2VGbG9hdChzdHlsZS5tYXJnaW5SaWdodCEpIHx8IDApXG5cbiAgICAgIGxldCBvdXRlck1hcmdpbiA9IE1hdGguY2VpbChwYXJlbnRXaWR0aCAtIHRoaXMuX2ZyYW1lV2lkdGgpXG4gICAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSBNYXRoLmNlaWwob3V0ZXJNYXJnaW4gKiAwLjUpICsgMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSAwXG4gICAgfVxuXG4gICAgbGV0IHNsaWRlTWFyZ2luID0gdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID4gMCA/IGAke3RoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbn1weGAgOiBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2xpZGUgPSB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2ldIGFzIEhUTUxFbGVtZW50XG4gICAgICBzbGlkZS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xpZGVNYXJnaW5cbiAgICAgIHNsaWRlLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2xpZGVNYXJnaW5cbiAgICB9XG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLm9ucmVzaXplKClcbiAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSlcbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLm1vdmVUbyh0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4KVxuXG4gICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpXG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlU2xpZGVzKHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHNsaWRlciB0byB0aGUgbmV4dCBpdGVtLlxuICAgKi9cbiAgcHVibGljIHByZXYoKSB7XG4gICAgdGhpcy5zbGlkZShmYWxzZSwgLTEpXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHNsaWRlciB0byB0aGUgcHJldmlvdXMgaXRlbS5cbiAgICovXG4gIHB1YmxpYyBuZXh0KCkge1xuICAgIHRoaXMuc2xpZGUoZmFsc2UsIDEpXG4gIH1cblxuICBwdWJsaWMgc2xpZGUobmV4dEluZGV4OiBudW1iZXIgfCBmYWxzZSwgZGlyZWN0aW9uPzogRGlyZWN0aW9uLCBhbmltYXRlID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgbmV4dEluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uISA+IDApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gdGhpcy5faW5kZXggKyB0aGlzLl9zbGlkZXNQZXJHcm91cFxuICAgICAgICBkaXJlY3Rpb24gPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSB0aGlzLl9pbmRleCAtIHRoaXMuX3NsaWRlc1Blckdyb3VwXG4gICAgICAgIGRpcmVjdGlvbiA9IC0xXG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV4dEluZGV4ID0gdGhpcy5fYWRqdXN0SW5kZXgobmV4dEluZGV4KVxuXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIGRpcmVjdGlvbiA9IGNsYW1wKG5leHRJbmRleCAtIHRoaXMuX2luZGV4LCAtMSwgMSkgYXMgRGlyZWN0aW9uXG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBlbm91Z2h0IHNsaWRlcyBvbiBzY3JlZW5cbiAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSlcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgZW5vdWdoIHNsaWRlcyBmb3IgdGhlIHNjcm9sbCBvcGVyYXRpb25cbiAgICB0aGlzLl9jbG9uZVNsaWRlc0J5U2Nyb2xsQ291bnQobmV4dEluZGV4LCBkaXJlY3Rpb24pXG5cbiAgICBsZXQgcmVhbEluZGV4ID0gdGhpcy5fZ2V0UmVhbEluZGV4Rm9yKG5leHRJbmRleCwgZGlyZWN0aW9uKVxuICAgIGxldCBzbGlkZURlbHRhID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZURlbHRhKHJlYWxJbmRleClcbiAgICByZWFsSW5kZXggPSBNYXRoLm1heChyZWFsSW5kZXggLSB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcih0cnVlLCBzbGlkZURlbHRhKSwgMClcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIubW92ZVRvKHJlYWxJbmRleCwgdW5kZWZpbmVkLCBhbmltYXRlKVxuXG4gICAgLy8gVXBkYXRlIHRoZSBhY3RpdmUgaW5kZXhcbiAgICB0aGlzLl9pbmRleCA9IG5leHRJbmRleFxuXG4gICAgLy8gTWFyayBzbGlkZXMgYXMgYWN0aXZlXG4gICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpXG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlU2xpZGVzKHJlYWxJbmRleClcblxuICAgIC8vIGNvbnNvbGUubG9nKGBQZXJmb3JtZWQgc2xpZGUgdG8gJHt0aGlzLl9pbmRleH0sIHJlYWxJbmRleDogJHt0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4fWApXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHNsaWRlciB0byB0aGUgc2VsZWN0ZWQgc2xpZGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc2xpZGUgdG8gc2xpZGUgdG8uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZSAtIGBUcnVlYCBpZiB0aGUgc2xpZGUgc2hvdWxkIGJlIGFuaW1hdGVkOyBvdGhlcndpc2UgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgcHVibGljIHNsaWRlVG8oaW5kZXg6IG51bWJlciwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLnNsaWRlKGluZGV4LCB1bmRlZmluZWQsIGFuaW1hdGUpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudHMgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fc2xpZGVBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcbiAgICB0aGlzLl9zbGlkZUFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcblxuICAgIHRoaXMuX2JyZWFrcG9pbnRQaG9uZS5yZW1vdmUoKVxuICAgIHRoaXMuX2JyZWFrcG9pbnRUYWJsZXQucmVtb3ZlKClcbiAgICB0aGlzLl9icmVha3BvaW50RGVza3RvcC5yZW1vdmUoKVxuXG4gICAgaWYgKHRoaXMuX3ByZXZDdHJsICYmIHRoaXMuX25leHRDdHJsKSB7XG4gICAgICB0aGlzLl9wcmV2Q3RybC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcHJldkhhbmRsZXIpXG4gICAgICB0aGlzLl9uZXh0Q3RybC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbmV4dEhhbmRsZXIpXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5fcHJldkN0cmwgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fbmV4dEN0cmwgPSB1bmRlZmluZWRcblxuICAgIGlmICh0aGlzLl9wYWdpbmF0aW9uKSB7XG4gICAgICB0aGlzLl9wYWdpbmF0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wYWdpbmF0aW9uQ2xpY2tIYW5kbGVyKTtcbiAgICAgICh0aGlzIGFzIGFueSkuX3BhZ2luYXRpb24gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmRlc3Ryb3koKTtcbiAgICAodGhpcyBhcyBhbnkpLl9zbGlkZXJXcmFwcGVyID0gdW5kZWZpbmVkXG4gIH1cbn1cblxuY29uc3QgVFJBTlNGT1JNID0gXCJ0cmFuc2Zvcm1cIlxuY29uc3QgRFVSQVRJT04gPSBcInRyYW5zaXRpb25EdXJhdGlvblwiXG5jb25zdCBUSU1JTkcgPSBcInRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiXG5cbmNsYXNzIFNsaWRlcldyYXBwZXIge1xuICBwcml2YXRlIF93cmFwcGVyRWxlbWVudDogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfc2xpZGVBcmVhRWxlbWVudDogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfY2Fyb3VzZWxFbGVtZW50OiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3Bvc2l0aW9uOiBudW1iZXJcbiAgcHJpdmF0ZSBfaW5kZXg6IG51bWJlclxuXG4gIHByaXZhdGUgX2lzZHJhZ2dpbmc6IGJvb2xlYW5cbiAgcHJpdmF0ZSBfZHJhZ1N0YXJ0UG9zaXRpb24/OiBudW1iZXJcblxuICBwcml2YXRlIF9hcmVhT2Zmc2V0PzogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfc2xpZGVzUGVyR3JvdXAhOiBudW1iZXJcblxuICBwcml2YXRlIF9jb250YWluZXJNaW4hOiBudW1iZXJcbiAgcHJpdmF0ZSBfY29udGFpbmVyTWF4ITogbnVtYmVyXG5cbiAgY29uc3RydWN0b3Iod3JhcHBlckVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzbGlkZUFyZWFFbGVtZW50OiBIVE1MRWxlbWVudCwgY2Fyb3VzZWxFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnRcbiAgICB0aGlzLl9zbGlkZUFyZWFFbGVtZW50ID0gc2xpZGVBcmVhRWxlbWVudFxuICAgIHRoaXMuX2Nhcm91c2VsRWxlbWVudCA9IGNhcm91c2VsRWxlbWVudFxuXG4gICAgdGhpcy5fcG9zaXRpb24gPSAwXG4gICAgdGhpcy5faW5kZXggPSAwXG4gICAgdGhpcy5faXNkcmFnZ2luZyA9IGZhbHNlXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFNsaWRlKGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAnaW5kZXgnIGlzIG91dCBvZiByYW5nZSwgVmFsdWU6ICR7aW5kZXh9IE1pbjogMCwgTWF4OiAke3RoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDF9YClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5baW5kZXhdIGFzIEhUTUxFbGVtZW50XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldFRyYW5zZm9ybSh0YXJnZXRQb3NpdGlvbjogbnVtYmVyLCBhbmltYXRlZCA9IGZhbHNlLCBkdXJhdGlvbiA9IEFOSU1BVElPTl9EVVJBVElPTiwgZWFzZSA9IEFOSU1BVElPTl9FQVNJTkcpIHtcbiAgICBpZiAoYW5pbWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBkdXJhdGlvbiA9IDBcbiAgICB9XG5cbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBzdHlsZVtEVVJBVElPTl0gPSBgJHtkdXJhdGlvbn1tc2BcbiAgICAgIHN0eWxlW1RJTUlOR10gPSBlYXNlXG5cbiAgICAgIC8vIE5vIHN1YiBwaXhlbCB0cmFuc2l0aW9ucy5cbiAgICAgIHRhcmdldFBvc2l0aW9uID0gTWF0aC5mbG9vcih0YXJnZXRQb3NpdGlvbilcblxuICAgICAgc3R5bGVbVFJBTlNGT1JNXSA9IGB0cmFuc2xhdGUoJHt0YXJnZXRQb3NpdGlvbn1weCwgMClgXG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRXcmFwcGVyU2xpZGVQb3NpdGlvbihpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgd3JhcHBlckNlbnRlciA9ICgwLjUgKiB0aGlzLl93cmFwcGVyRWxlbWVudC5vZmZzZXRXaWR0aClcbiAgICBjb25zdCBzbGlkZSA9IHRoaXMuX2dldFNsaWRlKGluZGV4KVxuXG4gICAgbGV0IHJlc3VsdCA9IDBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBzbGlkZSAoY2VudGVyZWQpXG4gICAgaWYgKHRoaXMuX3NsaWRlc1Blckdyb3VwICUgMiA9PT0gMCkge1xuICAgICAgbGV0IHNsaWRlU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSlcbiAgICAgIGxldCBzbGlkZU1hcmdpbiA9IHNsaWRlU3R5bGUgPyBwYXJzZUludChzbGlkZVN0eWxlLm1hcmdpblJpZ2h0ISwgMTApIDogMFxuICAgICAgLy8gQ2VudGVyZWQgdG8gdGhlIHNwYWNlIGJldHdlZW4gdGhlIHR3byBjZW50ZXIgc2xpZGVzIG9mIHRoZSBncm91cFxuICAgICAgcmVzdWx0ID0gLXNsaWRlLm9mZnNldExlZnQgLSAoc2xpZGUuY2xpZW50V2lkdGgpICsgd3JhcHBlckNlbnRlciAtIHNsaWRlTWFyZ2luXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IC1zbGlkZS5vZmZzZXRMZWZ0IC0gKDAuNSAqIHNsaWRlLmNsaWVudFdpZHRoKSArIHdyYXBwZXJDZW50ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uXG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gIH1cblxuICBzZXQgaW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgfVxuXG4gIHNldCBzbGlkZXNQZXJHcm91cCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSB2YWx1ZVxuICB9XG5cbiAgcHVibGljIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5vbnJlc2l6ZSgpXG4gIH1cblxuICBwdWJsaWMgb25yZXNpemUoKSB7XG4gICAgLy8gdXBkYXRlIHRoZSBhcmVhIG9mZnNldCBmb3Igc2xpZGUgcG9zaXRpb24gY2FsY3VsYXRpb25cbiAgICB0aGlzLl9hcmVhT2Zmc2V0ID0gdGhpcy5fc2xpZGVBcmVhRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG5cbiAgICAvLyBHZXQgdGhlIGNvbnRhaW5lciBkaW1lbnNpb25zXG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IHRoaXMuX2Nhcm91c2VsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIHRoaXMuX2NvbnRhaW5lck1pbiA9IGNvbnRhaW5lclJlY3QubGVmdFxuICAgIHRoaXMuX2NvbnRhaW5lck1heCA9IGNvbnRhaW5lclJlY3QucmlnaHRcbiAgfVxuXG4gIHB1YmxpYyBiZWdpbkRyYWcoKSB7XG4gICAgdGhpcy5faXNkcmFnZ2luZyA9IHRydWVcbiAgICB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uXG4gIH1cblxuICBwdWJsaWMgY2FuY2VsRHJhZygpIHtcbiAgICB0aGlzLl9pc2RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLl9zZXRUcmFuc2Zvcm0odGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24hLCB0cnVlLCBBTklNQVRJT05fRFVSQVRJT04sIEFOSU1BVElPTl9FQVNJTkcpXG5cbiAgICB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcHVibGljIGVuZERyYWcoKSB7XG4gICAgdGhpcy5faXNkcmFnZ2luZyA9IGZhbHNlXG4gICAgdGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24gPSB1bmRlZmluZWRcbiAgfVxuXG4gIHB1YmxpYyBtb3ZlKGRlbHRhOiBudW1iZXIsIGFuaW1hdGVkID0gZmFsc2UsIGR1cmF0aW9uID0gQU5JTUFUSU9OX0RVUkFUSU9OLCBlYXNlID0gQU5JTUFUSU9OX0VBU0lORykge1xuICAgIGRlbHRhID0gTWF0aC50cnVuYyhkZWx0YSlcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGEpIDw9IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB0YXJnZXRQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uICs9IGRlbHRhXG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtKHRhcmdldFBvc2l0aW9uLCBhbmltYXRlZCwgZHVyYXRpb24sIGVhc2UpXG4gIH1cblxuICBwdWJsaWMgbW92ZVRvKGluZGV4OiBudW1iZXIsIGRlbHRhPzogbnVtYmVyLCBhbmltYXRlZCA9IGZhbHNlKSB7XG4gICAgbGV0IG5ld1Bvc2l0aW9uID0gMFxuICAgIGlmICghZGVsdGEpIHtcbiAgICAgIG5ld1Bvc2l0aW9uID0gdGhpcy5fZ2V0V3JhcHBlclNsaWRlUG9zaXRpb24oaW5kZXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Bvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gKz0gZGVsdGFcbiAgICB9XG5cbiAgICB0aGlzLl9pbmRleCA9IGluZGV4XG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtKG5ld1Bvc2l0aW9uLCBhbmltYXRlZClcbiAgfVxuXG4gIHB1YmxpYyBhZGRTbGlkZShzbGlkZTogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICBpZiAoIXNsaWRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGFuIHVuZGVmaW5lZCBzbGlkZVwiKVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiAhPT0gLTEgJiYgcG9zaXRpb24gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgb3V0IG9mIHJhbmdlLCAncG9zaXRpb24nIG11c3QgYmUgZWl0aGVyIDEgb3IgLTEuIFZhbHVlICR7cG9zaXRpb259YClcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPiAwKSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChzbGlkZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNsaWRlLCB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblswXSlcbiAgICAgIHRoaXMuX2luZGV4KytcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICBsZXQgd2lkdGggPSBzbGlkZS5vZmZzZXRXaWR0aFxuXG4gICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSlcbiAgICAgIGxldCBtYXJnaW5MZWZ0ID0gc3R5bGUgPyBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0ISwgMTApIDogMFxuICAgICAgbGV0IG1hcmdpblJpZ2h0ID0gc3R5bGUgPyBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCEsIDEwKSA6IDBcblxuICAgICAgdGhpcy5tb3ZlKC0od2lkdGggKyBtYXJnaW5MZWZ0ICsgbWFyZ2luUmlnaHQpKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVTbGlkZShpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc2xpZGUgPSB0aGlzLl9nZXRTbGlkZShpbmRleClcbiAgICBsZXQgd2lkdGggPSBzbGlkZS5vZmZzZXRXaWR0aFxuXG4gICAgaWYgKGluZGV4IDw9IHRoaXMuX2luZGV4KSB7XG4gICAgICB3aWR0aCAqPSAtMVxuICAgICAgdGhpcy5faW5kZXgtLVxuICAgIH1cblxuICAgIHJlbW92ZShzbGlkZSlcblxuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgIHRoaXMubW92ZSgtd2lkdGgpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFNsaWRlRGVsdGEoaW5kZXg6IG51bWJlcikge1xuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvblxuICAgIGlmICh0aGlzLl9pc2RyYWdnaW5nID09PSB0cnVlKSB7XG4gICAgICBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiEgLSB0aGlzLl9wb3NpdGlvblxuICAgIH1cblxuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5fZ2V0V3JhcHBlclNsaWRlUG9zaXRpb24oaW5kZXgpXG4gICAgcmV0dXJuIG5ld1Bvc2l0aW9uIC0gY3VycmVudFBvc2l0aW9uXG4gIH1cblxuICBwdWJsaWMgZ2V0U2xpZGVQcm9wZXJ0aWVzKGluZGV4OiBudW1iZXIsIGRlbHRhID0gMCk6IFNsaWRlUHJvcGVydGllcyB7XG4gICAgbGV0IGN1cnJlbnRPZmZzZXQgPSB0aGlzLl9hcmVhT2Zmc2V0ISArIHRoaXMuX3Bvc2l0aW9uICsgZGVsdGFcbiAgICBsZXQgY3VycmVudExlZnQgPSBjdXJyZW50T2Zmc2V0XG4gICAgbGV0IGN1cnJlbnRSaWdodCA9IGN1cnJlbnRPZmZzZXRcbiAgICBsZXQgWyBjdXJyZW50TWFyZ2luTGVmdCwgY3VycmVudE1hcmdpblJpZ2h0IF0gPSBbIDAsIDAgXVxuXG4gICAgbGV0IHNsaWRlID0gdGhpcy5fZ2V0U2xpZGUoaW5kZXgpXG4gICAgbGV0IHNsaWRlSW5kZXggPSBwYXJzZUludChzbGlkZS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSEsIDEwKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaW5kZXg7IGkrKykge1xuICAgICAgc2xpZGUgPSB0aGlzLl9nZXRTbGlkZShpKVxuICAgICAgbGV0IHNsaWRlU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSlcblxuICAgICAgY3VycmVudE1hcmdpbkxlZnQgPSBwYXJzZUludChzbGlkZVN0eWxlLm1hcmdpbkxlZnQhLCAxMClcbiAgICAgIGN1cnJlbnRNYXJnaW5SaWdodCA9IHBhcnNlSW50KHNsaWRlU3R5bGUubWFyZ2luUmlnaHQhLCAxMClcblxuICAgICAgY3VycmVudE9mZnNldCArPSBjdXJyZW50TWFyZ2luTGVmdFxuICAgICAgY3VycmVudExlZnQgPSBjdXJyZW50T2Zmc2V0XG4gICAgICBjdXJyZW50UmlnaHQgPSBjdXJyZW50TGVmdCArIHNsaWRlLm9mZnNldFdpZHRoXG5cbiAgICAgIGlmIChpIDwgaW5kZXgpIHtcbiAgICAgICAgY3VycmVudE9mZnNldCA9IGN1cnJlbnRSaWdodCArIGN1cnJlbnRNYXJnaW5SaWdodFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB2aXNpYmxlID0gZmFsc2VcbiAgICBpZiAoKGN1cnJlbnRMZWZ0ID4gdGhpcy5fY29udGFpbmVyTWluICYmIGN1cnJlbnRMZWZ0IDwgdGhpcy5fY29udGFpbmVyTWF4KSB8fFxuICAgICAgKGN1cnJlbnRSaWdodCA+IHRoaXMuX2NvbnRhaW5lck1pbiAmJiBjdXJyZW50UmlnaHQgPCB0aGlzLl9jb250YWluZXJNYXgpKSB7XG4gICAgICB2aXNpYmxlID0gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2aXNpYmxlLFxuICAgICAgaW5kZXg6IHNsaWRlSW5kZXgsXG4gICAgICBsZWZ0OiBjdXJyZW50TGVmdCxcbiAgICAgIHJpZ2h0OiBjdXJyZW50UmlnaHQsXG4gICAgICB3aWR0aDogY3VycmVudFJpZ2h0IC0gY3VycmVudExlZnQsXG4gICAgICBtYXJnaW5MZWZ0OiBjdXJyZW50TWFyZ2luTGVmdCxcbiAgICAgIG1hcmdpblJpZ2h0OiBjdXJyZW50TWFyZ2luUmlnaHRcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0UmVtb3ZhYmxlU2xpZGVzKGRlbHRhOiBudW1iZXIpIHtcbiAgICBsZXQgc2xpZGVzID0gW11cbiAgICBsZXQgZmlyc3Q6IFNsaWRlUHJvcGVydGllcyB8IHVuZGVmaW5lZFxuICAgIGxldCBsYXN0OiBTbGlkZVByb3BlcnRpZXMgfCB1bmRlZmluZWRcblxuICAgIGxldCBpbmRleCA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aFxuICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgIGluZGV4LS1cblxuICAgICAgbGV0IHByb3BzTm93ID0gdGhpcy5nZXRTbGlkZVByb3BlcnRpZXMoaW5kZXgpXG4gICAgICBsZXQgcHJvcHNOZXcgPSB0aGlzLmdldFNsaWRlUHJvcGVydGllcyhpbmRleCwgZGVsdGEpXG5cbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICBsYXN0ID0gcHJvcHNOZXdcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGZpcnN0ID0gcHJvcHNOZXdcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzTm93LnZpc2libGUgPT09IGZhbHNlICYmIHByb3BzTmV3LnZpc2libGUgPT09IGZhbHNlICYmXG4gICAgICAgIGluZGV4ICE9PSB0aGlzLl9pbmRleCAmJiB0aGlzLl9pc2RyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgICBzbGlkZXMucHVzaCh0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGVzLnB1c2goZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2xpZGVzLnJldmVyc2UoKVxuXG4gICAgbGV0IGZpcnN0VG9LZWVwID0gc2xpZGVzLmluZGV4T2YoZmFsc2UpXG4gICAgbGV0IGxhc3RUb0tlZXAgPSBzbGlkZXMubGFzdEluZGV4T2YoZmFsc2UpXG5cbiAgICBmb3IgKGxldCBpID0gZmlyc3RUb0tlZXA7IGkgPCBsYXN0VG9LZWVwOyBpKyspIHtcbiAgICAgIHNsaWRlc1tpXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNsaWRlcyxcbiAgICAgIGZpcnN0OiBmaXJzdCBhcyBTbGlkZVByb3BlcnRpZXMsXG4gICAgICBsYXN0OiBsYXN0IGFzIFNsaWRlUHJvcGVydGllc1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRFbXB0eVNwYWNlKGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlcikge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBNYXRoLm1heChNYXRoLmNlaWwobGVmdCAtIHRoaXMuX2NvbnRhaW5lck1pbiksIDApLFxuICAgICAgcmlnaHQ6IE1hdGgubWF4KE1hdGguY2VpbCh0aGlzLl9jb250YWluZXJNYXggLSByaWdodCksIDApXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fd3JhcHBlckVsZW1lbnQgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3NsaWRlQXJlYUVsZW1lbnQgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2Nhcm91c2VsRWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVzdHJveSgpIGluc3RlYWQuXG4gICAqIEB0b2RvIHJlbW92ZSBpbiB2ZXJzaW9uIDIuMC4wXG4gICAqL1xuICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmNhcm91c2VsXCIsIChlKSA9PiB7XG4gICAgbmV3IENhcm91c2VsKGUgYXMgSFRNTEVsZW1lbnQpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsXG4iLCJpbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCByZW1vdmUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IHsgZ2V0QXR0cmlidXRlUmVmZXJlbmNlIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgeyB0cnlHZXREYXRhLCBjcmVhdGVMZWdlbmRJdGVtLCBpc0NvbG9yLCByZW1vdmVBbGxDaGlsZHJlbiwgQ2hhcnREYXRhLCBDaGFydEF4aXMgfSBmcm9tIFwiLi9DaGFydEZ1bmN0aW9uc1wiXG5cbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5cbmNvbnN0IFFVRVJZX0RFVEFJTF9SSUdIVCA9IFwiLmRldGFpbC1yaWdodFwiXG5jb25zdCBRVUVSWV9ERVRBSUxfQk9UVE9NID0gXCIuZGV0YWlsLWJvdHRvbVwiXG5jb25zdCBRVUVSWV9QUk9HUkVTUyA9IFwiLmJhci1jaGFydF9fcHJvZ3Jlc3NcIlxuXG5jb25zdCBDTEFTU19VTkxJTUlURUQgPSBcImJhci1jaGFydC1ob3Jpem9udGFsLS11bmxpbWl0ZWRcIlxuY29uc3QgQ0xBU1NfTElNSVRFRCA9IFwiYmFyLWNoYXJ0LWhvcml6b250YWwtLWxpbWl0ZWRcIlxuXG5jb25zdCBDTEFTU19ERVRBSUxfVkFMVUUgPSBcInZhbHVlXCJcbmNvbnN0IENMQVNTX0RFVEFJTF9VTklUID0gXCJ1bml0XCJcblxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SID0gXCJpbmRpY2F0b3JcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX1dSQVBQRVIgPSBcImluZGljYXRvci13cmFwcGVyXCJcblxuY29uc3QgQ0xBU1NfVE9PTFRJUCA9IFwidG9vbHRpcFwiXG5jb25zdCBDTEFTU19UT09MVElQX01VTFRJTElORSA9IFwidG9vbHRpcC0tbXVsdGlsaW5lXCJcblxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OID0gNTAwXG5cbi8qKlxuICogQmFyIENoYXJ0IEhvcml6b250YWwgQ29tcG9uZW50LlxuICovXG5jbGFzcyBCYXJDaGFydEhvcml6b250YWwgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX2RhdGEhOiBDaGFydERhdGFcblxuICBwcml2YXRlIF9sZWdlbmRJdGVtczogSFRNTEVsZW1lbnRbXVxuICBwcml2YXRlIF9wcm9nZXNzV3JhcHBlciE6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfdW5pdCE6IHN0cmluZ1xuICBwcml2YXRlIF9tYXhWYWx1ZSE6IG51bWJlclxuICBwcml2YXRlIF9wcmVjaXNpb24hOiBudW1iZXJcblxuICBwcml2YXRlIF9pc1VubGltaXRlZCE6IGJvb2xlYW5cbiAgcHJpdmF0ZSBfaXNMaW1pdGVkITogYm9vbGVhblxuXG4gIHByaXZhdGUgX2RldGFpbFJpZ2h0ITogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGVnZW5kITogSFRNTEVsZW1lbnRcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIGJhciBjaGFydCBob3Jpem9udGFsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIHJvb3QgZWxlbWVudCBvZiB0aGUgY2hhcnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgZGF0YT86IENoYXJ0RGF0YSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9sZWdlbmRJdGVtcyA9IFtdXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl91bml0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVuaXRcIikgfHwgXCJcIlxuICAgIHRoaXMuX21heFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtbWF4XCIpISlcbiAgICB0aGlzLl9wcmVjaXNpb24gPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2lzaW9uXCIpISwgMTApIHx8IDBcblxuICAgIHRoaXMuX2lzVW5saW1pdGVkID0gdGhpcy5oYXNDbGFzcyhDTEFTU19VTkxJTUlURUQpXG4gICAgdGhpcy5faXNMaW1pdGVkID0gdGhpcy5oYXNDbGFzcyhDTEFTU19MSU1JVEVEKVxuXG4gICAgdGhpcy5fcHJvZ2Vzc1dyYXBwZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9QUk9HUkVTUykhIGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAodGhpcy5faXNMaW1pdGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9kZXRhaWxSaWdodCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0RFVEFJTF9CT1RUT00pISBhcyBIVE1MRWxlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZXRhaWxSaWdodCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0RFVEFJTF9SSUdIVCkhIGFzIEhUTUxFbGVtZW50XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzVW5saW1pdGVkID09PSBmYWxzZSAmJiB0aGlzLl9pc0xpbWl0ZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9sZWdlbmQgPSBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UodGhpcy5lbGVtZW50LCBcImRhdGEtbGVnZW5kXCIpIVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRyeUdldERhdGEodGhpcy5lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcigpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3JlbmRlcigpIHtcbiAgICBsZXQgZGF0YU9uZSA9IHRoaXMuX2RhdGFbMF1cbiAgICBsZXQgZGF0YVR3byA9IHRoaXMuX2RhdGFbMV1cblxuICAgIGxldCB0b29sdGlwID0gdGhpcy5faXNMaW1pdGVkID09PSBmYWxzZSA/IHRoaXMuX2dldFRvb2x0aXBDb250ZW50KHRoaXMuX2RhdGEpIDogdW5kZWZpbmVkXG5cbiAgICBsZXQgYW5pbWF0ZWRWYWx1ZUVsZW1lbnQ6IEVsZW1lbnQgfCB1bmRlZmluZWRcblxuICAgIC8vIENsZWFudXBcbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9kZXRhaWxSaWdodClcbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9wcm9nZXNzV3JhcHBlcilcblxuICAgIC8vIENsZWFyIG9ubHkgb3duIGxlZ2VuZCBpdGVtc1xuICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fbGVnZW5kSXRlbXMpIHtcbiAgICAgIHJlbW92ZShpdGVtKVxuICAgIH1cbiAgICB0aGlzLl9sZWdlbmRJdGVtcyA9IFtdXG5cbiAgICBpZiAoZGF0YU9uZSkge1xuICAgICAgaWYgKHRoaXMuX2lzVW5saW1pdGVkID09PSBmYWxzZSB8fCAodGhpcy5faXNVbmxpbWl0ZWQgPT09IHRydWUgJiYgIWRhdGFUd28pKSB7XG5cbiAgICAgICAgbGV0IHZhbEVsZW1lbnQgPSBhbmltYXRlZFZhbHVlRWxlbWVudCA9IHRoaXMuX2NyZWF0ZVZhbHVlRWxlbWVudChkYXRhT25lKVxuICAgICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh2YWxFbGVtZW50KVxuXG4gICAgICAgIGlmICh0aGlzLl9pc0xpbWl0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3Qgc2VwYXJhdG9yRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfREVUQUlMX1VOSVQpXG4gICAgICAgICAgICAuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgIHNlcGFyYXRvckVsZW1lbnQuaW5uZXJUZXh0ID0gYCAke3RoaXMuX3VuaXR9YFxuXG4gICAgICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yRWxlbWVudClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIGluZGljYXRvclxuICAgICAgbGV0IGluZGljYXRvciA9IHRoaXMuX2FkZEluZGljYXRvcihkYXRhT25lLCB0b29sdGlwKVxuICAgICAgdGhpcy5fYW5pbWF0ZUluZGljYXRvcihpbmRpY2F0b3IsIDApXG5cbiAgICAgIC8vIEFuaW1hdGUgdGhlIHZhbHVlIGlmIHJlcXVpcmVkXG4gICAgICBpZiAoYW5pbWF0ZWRWYWx1ZUVsZW1lbnQgJiYgdGhpcy5faXNMaW1pdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVWYWx1ZUVsZW1lbnQoYW5pbWF0ZWRWYWx1ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQsIGRhdGFPbmUudmFsdWUpXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgbGVnZW5kXG4gICAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRJdGVtKGRhdGFPbmUpXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtKVxuICAgICAgICB0aGlzLl9sZWdlbmRJdGVtcy5wdXNoKGxlZ2VuZEl0ZW0pXG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUxlZ2VuZChsZWdlbmRJdGVtLCAwKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhVHdvKSB7XG4gICAgICBsZXQgdmFsRWxlbWVudCA9IHRoaXMuX2NyZWF0ZVZhbHVlRWxlbWVudChkYXRhVHdvKVxuXG4gICAgICBsZXQgdW5pdEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfREVUQUlMX1VOSVQpXG4gICAgICAgIC5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICB1bml0RWxlbWVudC5pbm5lclRleHQgPSBgICR7dGhpcy5fdW5pdH1gXG5cbiAgICAgIHRoaXMuX2RldGFpbFJpZ2h0LmFwcGVuZENoaWxkKHZhbEVsZW1lbnQpXG4gICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh1bml0RWxlbWVudClcblxuICAgICAgLy8gQWRkIHRoZSBpbmRpY2F0b3JcbiAgICAgIGxldCBpbmRpY2F0b3IgPSB0aGlzLl9hZGRJbmRpY2F0b3IoZGF0YVR3bywgdG9vbHRpcClcbiAgICAgIHRoaXMuX2FuaW1hdGVJbmRpY2F0b3IoaW5kaWNhdG9yLCBBTklNQVRJT05fRFVSQVRJT04pXG5cbiAgICAgIC8vIEFkZCB0aGUgbGVnZW5kXG4gICAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRJdGVtKGRhdGFUd28pXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtKVxuICAgICAgICB0aGlzLl9sZWdlbmRJdGVtcy5wdXNoKGxlZ2VuZEl0ZW0pXG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUxlZ2VuZChsZWdlbmRJdGVtLCBBTklNQVRJT05fRFVSQVRJT04pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzTGltaXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IHZhbEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVWYWx1ZUVsZW1lbnQoeyB2YWx1ZTogdGhpcy5fbWF4VmFsdWUgfSlcblxuICAgICAgbGV0IHVuaXRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0RFVEFJTF9VTklUKVxuICAgICAgICAuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgdW5pdEVsZW1lbnQuaW5uZXJUZXh0ID0gYCAke3RoaXMuX3VuaXR9YFxuXG4gICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh2YWxFbGVtZW50KVxuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodW5pdEVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYW5pbWF0ZVZhbHVlRWxlbWVudChhbmltYXRlZFZhbHVlRWxlbWVudDogSFRNTEVsZW1lbnQsIHRvVmFsdWU6IG51bWJlcikge1xuICAgIGxldCBjb3VudGVyID0geyB2YXI6IDAgfVxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGNvdW50ZXIsXG4gICAgICB2YXI6IHRvVmFsdWUsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OLFxuICAgICAgZWFzaW5nOiBcImVhc2VPdXRRdWludFwiLFxuICAgICAgcm91bmQ6IDEsXG4gICAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgICAgYW5pbWF0ZWRWYWx1ZUVsZW1lbnQhLmlubmVyVGV4dCA9IGAke2NvdW50ZXIudmFyfWBcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBfYW5pbWF0ZUluZGljYXRvcihpbmRpY2F0b3JXcmFwcGVyOiBIVE1MRWxlbWVudCwgYW5pbWF0aW9uT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBjb25zdCBpbmRpY2F0b3IgPSBpbmRpY2F0b3JXcmFwcGVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJpbmRpY2F0b3JcIilbMF0gYXMgSFRNTEVsZW1lbnRcbiAgICBjb25zdCBpbmRpY2F0b3JXaWR0aCA9IGluZGljYXRvci5zY3JvbGxXaWR0aFxuICAgIGluZGljYXRvci5zdHlsZS53aWR0aCA9IFwiMHB4XCJcblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGluZGljYXRvcixcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT04sXG4gICAgICB3aWR0aDogaW5kaWNhdG9yV2lkdGggKyBcInB4XCIsXG4gICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgIGRlbGF5OiBhbmltYXRpb25PZmZzZXQsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBpbmRpY2F0b3Iuc3R5bGUud2lkdGggPSBcIlwiXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2FuaW1hdGVMZWdlbmQobGVnZW5kSXRlbTogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgbGVnZW5kSXRlbS5zdHlsZS5vcGFjaXR5ID0gXCIwXCJcbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBsZWdlbmRJdGVtLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTixcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgIGRlbGF5OiBhbmltYXRpb25PZmZzZXQsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBsZWdlbmRJdGVtLnN0eWxlLm9wYWNpdHkgPSBudWxsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfY3JlYXRlVmFsdWVFbGVtZW50KGRhdGE6IHsgdmFsdWU6IG51bWJlciB8IHN0cmluZyB9KSB7XG4gICAgbGV0IHVubGltaXRlZFByZWZpeCA9IFwiXCJcblxuICAgIGlmICh0aGlzLl9pc1VubGltaXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgdW5saW1pdGVkUHJlZml4ID0gXCIrXCJcbiAgICB9XG5cbiAgICBsZXQgdmFsdWU6IHN0cmluZyB8IG51bWJlciA9IHBhcnNlRmxvYXQoKGRhdGEudmFsdWUgYXMgc3RyaW5nKSlcblxuICAgIGlmICh2YWx1ZSA8PSAwKSB7XG4gICAgICBpZiAodGhpcy5fcHJlY2lzaW9uID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gXCIwXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gXCIuXCJcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3ByZWNpc2lvbjsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgKz0gXCIwXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKVxuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfREVUQUlMX1ZBTFVFKVxuICAgICAgLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICB2YWx1ZUVsZW1lbnQuaW5uZXJUZXh0ID0gYCR7dW5saW1pdGVkUHJlZml4fSR7dmFsdWV9YFxuICAgIHJldHVybiB2YWx1ZUVsZW1lbnRcbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRkSW5kaWNhdG9yKGRhdGE6IENoYXJ0QXhpcywgdG9vbHRpcD86IHN0cmluZykge1xuICAgIGxldCB3aWR0aCA9ICgoMTAwLjAgLyB0aGlzLl9tYXhWYWx1ZSkgKiBkYXRhLnZhbHVlKVxuXG4gICAgbGV0IGluZGljYXRvciA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SKVxuXG4gICAgaWYgKGlzQ29sb3IoZGF0YS5jb2xvcikgPT09IHRydWUpIHtcbiAgICAgIGluZGljYXRvci5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYmFja2dyb3VuZC1jb2xvcjogJHtkYXRhLmNvbG9yfTtgKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmRpY2F0b3IuYWRkQ2xhc3MoZGF0YS5jb2xvcilcbiAgICB9XG5cbiAgICBsZXQgaW5kaWNhdG9yV3JhcHBlciA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX1dSQVBQRVIpXG4gICAgICAuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHdpZHRoOiAke3dpZHRofSVgKVxuICAgICAgLmFwcGVuZENoaWxkKGluZGljYXRvcilcbiAgICAgIC5zZXRBdHRyaWJ1dGUoXCJvbmNsaWNrXCIsIFwidm9pZCgwKVwiKVxuXG4gICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcCAhPT0gXCJcIikge1xuICAgICAgaW5kaWNhdG9yV3JhcHBlclxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVE9PTFRJUClcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RPT0xUSVBfTVVMVElMSU5FKVxuICAgICAgICAuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0b29sdGlwKVxuICAgIH1cblxuICAgIHRoaXMuX3Byb2dlc3NXcmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvcldyYXBwZXIuZWxlbWVudClcbiAgICByZXR1cm4gaW5kaWNhdG9yV3JhcHBlci5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFRvb2x0aXBDb250ZW50KGRhdGFMaXN0OiBDaGFydERhdGEpIHtcbiAgICBsZXQgdG9vbHRpcCA9IFwiXCJcbiAgICBmb3IgKGxldCBkYXRhIG9mIGRhdGFMaXN0KSB7XG4gICAgICB0b29sdGlwICs9IGAke2RhdGEudGl0bGV9OiAke2RhdGEudmFsdWV9ICR7dGhpcy5fdW5pdH1cXG5gXG4gICAgfVxuXG4gICAgcmV0dXJuIHRvb2x0aXAudHJpbSgpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYmFyIGNoYXJ0IHdpdGggdGhlIHNwZWNpZmllZCBkYXRhIGRlZmluaXRpb25zLlxuICAgKiBAcGFyYW0ge0FycmF5fSAtIGJhciBjaGFydCBkYXRhIGRlZmluaXRpb25zLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZShkYXRhOiBDaGFydERhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICh0aGlzIGFzIGFueSkuX2RhdGEgPSB1bmRlZmluZWRcblxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2RldGFpbFJpZ2h0KVxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX3Byb2dlc3NXcmFwcGVyKTtcblxuICAgICh0aGlzIGFzIGFueSkuX2RldGFpbFJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3Byb2dlc3NXcmFwcGVyID0gdW5kZWZpbmVkXG5cbiAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuX2xlZ2VuZEl0ZW1zKSB7XG4gICAgICByZW1vdmUoaXRlbSlcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9sZWdlbmRJdGVtcyA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9sZWdlbmQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVzdHJveSgpIGluc3RlYWQuXG4gICAqIEB0b2RvIHJlbW92ZSBpbiB2ZXJzaW9uIDIuMC4wXG4gICAqL1xuICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxFbGVtZW50PihcIi5iYXItY2hhcnQtaG9yaXpvbnRhbFwiLCAoZSkgPT4ge1xuICAgIG5ldyBCYXJDaGFydEhvcml6b250YWwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFyQ2hhcnRIb3Jpem9udGFsXG4iLCJpbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IHRleHQgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCB7IGNyZWF0ZUxlZ2VuZEl0ZW0sIGlzQ29sb3IsIHJlbW92ZUFsbENoaWxkcmVuLCBDaGFydExhYmVsIH0gZnJvbSBcIi4vQ2hhcnRGdW5jdGlvbnNcIlxuXG5pbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuXG5jb25zdCBRVUVSWV9EQVRBX0NBVEVHT1JJRVMgPSBcIi5qcy1kYXRhLWxpc3QgLmpzLWNhdGVnb3J5XCJcbmNvbnN0IFFVRVJZX0RBVEFfSVRFTVMgPSBcIi5qcy1kYXRhLWxpc3QgLmpzLWRhdGFcIlxuY29uc3QgUVVFUllfQ0hBUlQgPSBcIi5qcy1jaGFydFwiXG5jb25zdCBRVUVSWV9MRUdFTkQgPSBcIi5iYXItY2hhcnRfX2xlZ2VuZFwiXG5cbmNvbnN0IENMQVNTX0lORElDQVRPUiA9IFwiaW5kaWNhdG9yXCJcbmNvbnN0IENMQVNTX0xBQkVMX1ggPSBcImF4aXMteC1sYWJlbFwiXG5jb25zdCBDTEFTU19JTkRJQ0FUT1JfV1JBUFBFUiA9IFwiaW5kaWNhdG9yLXdyYXBwZXJcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX0lOTkVSX1dSQVBQRVIgPSBcImluZGljYXRvci13cmFwcGVyLWlubmVyXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9FTVBUWSA9IFwiZW1wdHlcIlxuXG5jb25zdCBDTEFTU19UT09MVElQID0gXCJ0b29sdGlwXCJcbmNvbnN0IENMQVNTX1RPT0xUSVBfTEVGVCA9IFwidG9vbHRpcC0tbGVmdFwiXG5jb25zdCBDTEFTU19UT09MVElQX1JJR0hUID0gXCJ0b29sdGlwLS1yaWdodFwiXG5jb25zdCBDTEFTU19UT09MVElQX01VTFRJTElORSA9IFwidG9vbHRpcC0tbXVsdGlsaW5lXCJcblxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OID0gNTAwXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnkgZXh0ZW5kcyBDaGFydExhYmVsIHtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhRW50cnkge1xuICB0aXRsZTogc3RyaW5nXG4gIGNsYXNzOiBzdHJpbmdcbiAgdmFsdWVzOiBudW1iZXJbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXJ0RGF0YSB7XG4gIGNhdGVnb3JpZXM6IENhdGVnb3J5W11cbiAgaXRlbXM6IERhdGFFbnRyeVtdXG59XG5cbi8qKlxuICogQmFyIENoYXJ0IEhvcml6b250YWwgQ29tcG9uZW50LlxuICovXG5jbGFzcyBCYXJDaGFydFZlcnRpY2FsIGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MRWxlbWVudD4ge1xuICBwcml2YXRlIF9kYXRhITogQ2hhcnREYXRhXG5cbiAgcHJpdmF0ZSBfdW5pdCE6IHN0cmluZ1xuICBwcml2YXRlIF9tYXhWYWx1ZSE6IG51bWJlclxuXG4gIHByaXZhdGUgX2NoYXJ0ITogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGVnZW5kITogSFRNTEVsZW1lbnRcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIGJhciBjaGFydCBob3Jpem9udGFsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGVsZW1lbnQgLSByb290IGVsZW1lbnQgb2YgdGhlIGNoYXJ0LlxuICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgZm9yIHRoZSBjaGFydC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkYXRhPzogQ2hhcnREYXRhKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX3VuaXQgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdW5pdFwiKSB8fCBcIlwiXG5cbiAgICB0aGlzLl9tYXhWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1heFwiKSEpIHx8IDEwMFxuXG4gICAgdGhpcy5fY2hhcnQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9DSEFSVCkhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fbGVnZW5kID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTEVHRU5EKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX3RyeUdldERhdGEodGhpcy5lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcigpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3RyeUdldERhdGEoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDaGFydERhdGEge1xuICAgIGNvbnN0IGRhdGE6IENoYXJ0RGF0YSA9IHtcbiAgICAgIGNhdGVnb3JpZXM6IFtdLFxuICAgICAgaXRlbXM6IFtdXG4gICAgfVxuXG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9EQVRBX0NBVEVHT1JJRVMpXG4gICAgY29uc3QgaXRlbXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfREFUQV9JVEVNUylcblxuICAgIGZvciAoY29uc3QgY2F0ZWdvcnkgb2YgY2F0ZWdvcmllcykge1xuICAgICAgZGF0YS5jYXRlZ29yaWVzLnB1c2goXG4gICAgICAgIHtcbiAgICAgICAgICB0aXRsZTogdGV4dChjYXRlZ29yeSksXG4gICAgICAgICAgY29sb3I6IGNhdGVnb3J5LmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIikhXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IGRhdGFFbnR5OiBEYXRhRW50cnkgPSB7XG4gICAgICAgIHRpdGxlOiB0ZXh0KGl0ZW0pLFxuICAgICAgICBjbGFzczogaXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNsYXNzXCIpISxcbiAgICAgICAgdmFsdWVzOiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxzID0gaXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgICBpZiAodmFscykge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB2YWxzLnNwbGl0KFwiLFwiKSkge1xuICAgICAgICAgIGRhdGFFbnR5LnZhbHVlcy5wdXNoKHBhcnNlRmxvYXQodmFsKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXRhLml0ZW1zLnB1c2goZGF0YUVudHkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0VG9vbHRpcENvbnRlbnQoZW50cnk6IERhdGFFbnRyeSwgY2F0ZWdvcmllczogQ2F0ZWdvcnlbXSkge1xuICAgIGxldCB0b29sdGlwID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cnkudmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b29sdGlwICs9IGAke2NhdGVnb3JpZXNbaV0udGl0bGV9OiAke2VudHJ5LnZhbHVlc1tpXX0gJHt0aGlzLl91bml0fVxcbmBcbiAgICB9XG5cbiAgICByZXR1cm4gdG9vbHRpcC50cmltKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLl9sZWdlbmQpIHtcbiAgICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2xlZ2VuZClcblxuICAgICAgZm9yIChjb25zdCBjYXRlZ29yeSBvZiB0aGlzLl9kYXRhLmNhdGVnb3JpZXMpIHtcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbSA9IGNyZWF0ZUxlZ2VuZEl0ZW0oY2F0ZWdvcnkpXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2NoYXJ0KVxuXG4gICAgY29uc3QgYW5pbWF0aW9uU3RhZ2VzOiBFbGVtZW50W11bXSA9IFtdXG5cbiAgICBsZXQgbGVmdFNpZGVJdGVtcyA9IE1hdGguZmxvb3IodGhpcy5fZGF0YS5pdGVtcy5sZW5ndGggLyAyKVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9kYXRhLml0ZW1zKSB7XG4gICAgICBsZXQgZWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwibGlcIilcblxuICAgICAgaWYgKGl0ZW0uY2xhc3MpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhpdGVtLmNsYXNzKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBsaXN0RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwidWxcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9XUkFQUEVSKVxuXG4gICAgICBjb25zdCB3cmFwcGVyID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9JTk5FUl9XUkFQUEVSKVxuICAgICAgbGlzdEVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlcilcblxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChsaXN0RWxlbWVudClcblxuICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuX2dldFRvb2x0aXBDb250ZW50KGl0ZW0sIHRoaXMuX2RhdGEuY2F0ZWdvcmllcylcbiAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgIHdyYXBwZXJcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVE9PTFRJUClcbiAgICAgICAgICAuYWRkQ2xhc3MobGVmdFNpZGVJdGVtcyA8PSAwID8gQ0xBU1NfVE9PTFRJUF9MRUZUIDogQ0xBU1NfVE9PTFRJUF9SSUdIVClcbiAgICAgICAgICAuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0b29sdGlwKVxuXG4gICAgICAgIGlmIChpdGVtLnZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgd3JhcHBlci5hZGRDbGFzcyhDTEFTU19UT09MVElQX01VTFRJTElORSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW0udmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9ICh0aGlzLl9jaGFydC5vZmZzZXRIZWlnaHQgLyB0aGlzLl9tYXhWYWx1ZSkgKiBpdGVtLnZhbHVlc1tpXVxuXG4gICAgICAgIGNvbnN0IGluZGljYXRvciA9IG5ldyBEb21FbGVtZW50KFwibGlcIilcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SKVxuICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgaGVpZ2h0OiAke2hlaWdodH1weDtgKVxuXG4gICAgICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl9kYXRhLmNhdGVnb3JpZXNbaV0uY29sb3JcbiAgICAgICAgICBpZiAoaXNDb2xvcihjb2xvcikpIHtcbiAgICAgICAgICAgIGluZGljYXRvci5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvcn07YClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kaWNhdG9yLmFkZENsYXNzKGNvbG9yKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbmltYXRpb25TdGFnZXMubGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvblN0YWdlcy5wdXNoKFtdKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuaW1hdGlvblN0YWdlc1tpXS5wdXNoKGluZGljYXRvci5lbGVtZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGljYXRvci5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfRU1QVFkpXG4gICAgICAgIH1cblxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvcilcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGl0bGVEb21FbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0xBQkVMX1gpXG4gICAgICBjb25zdCB0aXRsZUVsZW1lbnQgPSB0aXRsZURvbUVsZW1lbnQuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgdGl0bGVFbGVtZW50LmlubmVyVGV4dCA9IGl0ZW0udGl0bGVcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGl0bGVEb21FbGVtZW50KVxuXG4gICAgICB0aGlzLl9jaGFydC5hcHBlbmRDaGlsZChlbGVtZW50LmVsZW1lbnQpXG4gICAgICBsZWZ0U2lkZUl0ZW1zIC09IDFcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuaW1hdGlvblN0YWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gQU5JTUFUSU9OX0RVUkFUSU9OICogaVxuICAgICAgdGhpcy5fYW5pbWF0ZUJhcnMoYW5pbWF0aW9uU3RhZ2VzW2ldIGFzIEhUTUxFbGVtZW50W10sIG9mZnNldClcblxuICAgICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgICB0aGlzLl9hbmltYXRlTGVnZW5kKHRoaXMuX2xlZ2VuZC5jaGlsZHJlbltpXSBhcyBIVE1MRWxlbWVudCwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2FuaW1hdGVCYXJzKGJhcnM6IEhUTUxFbGVtZW50W10sIGFuaW1hdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiYXIgPSBiYXJzW2ldXG4gICAgICBjb25zdCBiYXJIZWlnaHQgPSBiYXIuc3R5bGUuaGVpZ2h0XG4gICAgICBiYXIuc3R5bGUuaGVpZ2h0ID0gXCIwXCJcbiAgICAgIGFuaW1lKHtcbiAgICAgICAgdGFyZ2V0czogYmFyc1tpXSxcbiAgICAgICAgaGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OLFxuICAgICAgICBkZWxheTogYW5pbWF0aW9uT2Zmc2V0XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2FuaW1hdGVMZWdlbmQobGVnZW5kOiBIVE1MRWxlbWVudCwgYW5pbWF0aW9uT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBsZWdlbmQuc3R5bGUub3BhY2l0eSA9IFwiMFwiXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogbGVnZW5kLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTixcbiAgICAgIGRlbGF5OiBhbmltYXRpb25PZmZzZXRcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGJhciBjaGFydCB3aXRoIHRoZSBzcGVjaWZpZWQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICogQHBhcmFtIHtBcnJheX0gLSBiYXIgY2hhcnQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoZGF0YTogQ2hhcnREYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl9kYXRhID0gdW5kZWZpbmVkXG5cbiAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9sZWdlbmQpO1xuICAgICAgKHRoaXMgYXMgYW55KS5fbGVnZW5kID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBkZXN0cm95KCkgaW5zdGVhZC5cbiAgICogQHRvZG8gcmVtb3ZlIGluIHZlcnNpb24gMi4wLjBcbiAgICovXG4gIHB1YmxpYyBkZXN0b3J5KCkge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTEVsZW1lbnQ+KFwiLmJhci1jaGFydC12ZXJ0aWNhbFwiLCAoZSkgPT4ge1xuICAgIG5ldyBCYXJDaGFydFZlcnRpY2FsKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhckNoYXJ0VmVydGljYWxcbiIsImltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IHRleHQgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuZXhwb3J0IGludGVyZmFjZSBDaGFydExhYmVsIHtcbiAgdGl0bGU6IHN0cmluZ1xuICBjb2xvcjogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcnRBeGlzIGV4dGVuZHMgQ2hhcnRMYWJlbCB7XG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgQ2hhcnREYXRhID0gQ2hhcnRBeGlzW11cblxuY29uc3QgUVVFUllfREFUQSA9IFwiLmpzLWRhdGFcIlxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5R2V0RGF0YShlbGVtZW50OiBIVE1MRWxlbWVudCk6IENoYXJ0RGF0YSB7XG4gIGxldCBkYXRhID0gW11cbiAgbGV0IGVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0RBVEEpXG5cbiAgZm9yIChsZXQgZW50cnkgb2YgZWxlbWVudHMpIHtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KGVudHJ5LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikhKVxuICAgIGxldCBjb2xvciA9IGVudHJ5LmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIikhXG4gICAgbGV0IHRpdGxlID0gdGV4dChlbnRyeSlcblxuICAgIGxldCBpdGVtID0ge1xuICAgICAgdGl0bGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGNvbG9yXG4gICAgfVxuXG4gICAgZGF0YS5wdXNoKGl0ZW0pXG4gIH1cblxuICByZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsQ2hpbGRyZW4obm9kZTogTm9kZSkge1xuICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxlZ2VuZEl0ZW0oZGF0YTogQ2hhcnRMYWJlbCkge1xuICBjb25zdCBidWxsZXQgPSBuZXcgRG9tRWxlbWVudDxIVE1MU3BhbkVsZW1lbnQ+KFwic3BhblwiKVxuICAgIC5hZGRDbGFzcyhcImJ1bGxldFwiKVxuXG4gIGlmIChpc0NvbG9yKGRhdGEuY29sb3IpID09PSB0cnVlKSB7XG4gICAgYnVsbGV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke2RhdGEuY29sb3J9O2ApXG4gIH0gZWxzZSB7XG4gICAgYnVsbGV0LmFkZENsYXNzKGRhdGEuY29sb3IpXG4gIH1cblxuICBjb25zdCBjYXB0aW9uID0gbmV3IERvbUVsZW1lbnQ8SFRNTFNwYW5FbGVtZW50PihcInNwYW5cIilcbiAgICAuc2V0SHRtbChkYXRhLnRpdGxlKVxuXG4gIHJldHVybiBuZXcgRG9tRWxlbWVudDxIVE1MTElFbGVtZW50PihcImxpXCIpXG4gICAgLmFwcGVuZENoaWxkKGJ1bGxldClcbiAgICAuYXBwZW5kQ2hpbGQoY2FwdGlvbilcbiAgICAuZWxlbWVudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb2xvcihzdHI6IHN0cmluZykge1xuICBjb25zdCBwYXR0ZXJuID0gL14jL2lcbiAgcmV0dXJuIHBhdHRlcm4udGVzdChzdHIpXG59XG4iLCJpbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IHJlbW92ZUFsbENoaWxkcmVuLCB0cnlHZXREYXRhLCBpc0NvbG9yLCBDaGFydERhdGEgfSBmcm9tIFwiLi9DaGFydEZ1bmN0aW9uc1wiXG5pbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuXG5jb25zdCBRVUVSWV9DSEFSVCA9IFwiLmpzLWNoYXJ0XCJcbmNvbnN0IFFVRVJZX0xFR0VORCA9IFwiLmpzLWxlZ2VuZFwiXG5cbmNvbnN0IERBU0hfU0VQQVJBVE9SX1dJRFRIID0gM1xuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OID0gMTUwMFxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OX0xFR0VORCA9IDUwMFxuXG5jb25zdCBRVUVSWV9NRVRBX1RJVExFID0gXCIubWV0YSAudGl0bGVcIlxuY29uc3QgUVVFUllfTUVUQV9TVUJUSVRMRSA9IFwiLm1ldGEgLnN1YnRpdGxlXCJcblxuLyoqXG4gKiBQaWUgQ2hhcnQgQ29tcG9uZW50LlxuICovXG5jbGFzcyBQaWVDaGFydCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfZGF0YSE6IENoYXJ0RGF0YVxuXG4gIHByaXZhdGUgX2NoYXJ0ITogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGVnZW5kITogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfdGl0bGUhOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9zdWJ0aXRsZSE6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfdW5pdCE6IHN0cmluZ1xuICBwcml2YXRlIF9hbHdheXNTaG93TGVnZW5kITogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgUGllIENoYXJ0IGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIHJvb3QgZWxlbWVudCBvZiB0aGUgY2hhcnQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IC0gcGllIGNoYXJ0IGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgZGF0YT86IENoYXJ0RGF0YSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fY2hhcnQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9DSEFSVCkhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fbGVnZW5kID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTEVHRU5EKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl90aXRsZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX01FVEFfVElUTEUpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX3N1YnRpdGxlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTUVUQV9TVUJUSVRMRSkhIGFzIEhUTUxFbGVtZW50XG5cbiAgICB0aGlzLl91bml0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVuaXRcIikgfHwgXCJcIlxuICAgIHRoaXMuX2Fsd2F5c1Nob3dMZWdlbmQgPSB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGF0YS1hbHdheXMtc2hvdy1sZWdlbmRcIilcblxuICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRyeUdldERhdGEodGhpcy5lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcigpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3JlbmRlcigpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2RhdGEucmVkdWNlKChhLCBiKSA9PiBhICsgYi52YWx1ZSwgMClcbiAgICBjb25zdCByID0gMTZcbiAgICBjb25zdCBkYXNoVG90YWwgPSAoMiAqIHIgKiBNYXRoLlBJKVxuXG4gICAgbGV0IGN1cnJlbnRSb3RhdGUgPSA5XG5cbiAgICAvLyBDbGVhbnVwXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fY2hhcnQpXG5cbiAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9sZWdlbmQpXG4gICAgfVxuXG4gICAgbGV0IHBlcmNlbnRhZ2VBZGp1c3RUb3RhbCA9IDBcbiAgICBsZXQgcGVyY2VudGFnZUFkanVzdCA9IDBcbiAgICBjb25zdCBzZXBhcmF0b3JQZXJjZW50YWdlID0gREFTSF9TRVBBUkFUT1JfV0lEVEggLyAxMDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9kYXRhW2ldXG5cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBlbnRyeS52YWx1ZSAvIHRvdGFsXG4gICAgICBpZiAocGVyY2VudGFnZSA8IHNlcGFyYXRvclBlcmNlbnRhZ2UpIHtcbiAgICAgICAgcGVyY2VudGFnZUFkanVzdFRvdGFsICs9IChzZXBhcmF0b3JQZXJjZW50YWdlIC0gcGVyY2VudGFnZSlcbiAgICAgICAgcGVyY2VudGFnZUFkanVzdCsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBlcmNlbnRhZ2VBZGp1c3QgPiAwKSB7XG4gICAgICBwZXJjZW50YWdlQWRqdXN0ID0gcGVyY2VudGFnZUFkanVzdFRvdGFsIC8gKHRoaXMuX2RhdGEubGVuZ3RoIC0gcGVyY2VudGFnZUFkanVzdClcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gYW5pbWUudGltZWxpbmUoKVxuXG4gICAgbGV0IGFuaW1hdGlvbk9mZnNldCA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5fZGF0YVtpXVxuXG4gICAgICBjb25zdCBkaXNwbGF5UGVyY2VudGFnZSA9IGVudHJ5LnZhbHVlIC8gdG90YWxcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBNYXRoLm1heChzZXBhcmF0b3JQZXJjZW50YWdlLCBkaXNwbGF5UGVyY2VudGFnZSAtIHBlcmNlbnRhZ2VBZGp1c3QpXG5cbiAgICAgIGxldCBkYXNoV2lkdGggPSAocGVyY2VudGFnZSAqIGRhc2hUb3RhbCkgLSBEQVNIX1NFUEFSQVRPUl9XSURUSFxuXG4gICAgICBsZXQgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIilcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIDM0IDM0XCIpXG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKVxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBcInRpdGxlIGRlc2NcIilcblxuICAgICAgbGV0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0aXRsZVwiKVxuICAgICAgdGl0bGUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJ0aXRsZVwiKVxuICAgICAgdGl0bGUuaW5uZXJIVE1MID0gYFBpZSBjaGFydCBzZWdtZW50ICR7TWF0aC5mbG9vcihkaXNwbGF5UGVyY2VudGFnZSAqIDEwMCl9JWBcblxuICAgICAgbGV0IGRlc2NyaXB0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJkZXNjXCIpXG4gICAgICBkZXNjcmlwdGlvbi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImRlc2NcIilcbiAgICAgIGRlc2NyaXB0aW9uLmlubmVySFRNTCA9IGAke2VudHJ5LnRpdGxlfTogJHtlbnRyeS52YWx1ZX1gXG5cbiAgICAgIGxldCBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKVxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN4XCIsIFwiMTdcIilcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBcIjE3XCIpXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiclwiLCBTdHJpbmcocikpXG5cbiAgICAgIGlmIChpc0NvbG9yKGVudHJ5LmNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIGAke2VudHJ5LmNvbG9yfWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZW50cnkuY29sb3IpXG4gICAgICB9XG5cbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpXG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHRyYW5zZm9ybTogcm90YXRlKCR7Y3VycmVudFJvdGF0ZX1kZWcpO2ApXG5cbiAgICAgIHN2Zy5hcHBlbmRDaGlsZCh0aXRsZSlcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChkZXNjcmlwdGlvbilcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChjaXJjbGUpXG4gICAgICB0aGlzLl9jaGFydC5hcHBlbmRDaGlsZChzdmcpXG5cbiAgICAgIGxldCBhbmltYXRpb25EdXJhdGlvbiA9IEFOSU1BVElPTl9EVVJBVElPTiAqIHBlcmNlbnRhZ2VcbiAgICAgIGNpcmNsZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcblxuICAgICAgbGV0IGNvdW50ZXIgPSB7IHZhcjogMC41IH1cbiAgICAgIGFuaW1hdGlvbnMuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogY291bnRlcixcbiAgICAgICAgdmFyOiBkYXNoV2lkdGgsXG4gICAgICAgIGJlZ2luOiAoKSA9PiB7XG4gICAgICAgICAgY2lyY2xlLnN0eWxlLmRpc3BsYXkgPSBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIGAke2NvdW50ZXIudmFyfSAke2Rhc2hUb3RhbH1gKVxuICAgICAgICB9LFxuICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogXCJlYXNlSW5RdWludFwiXG4gICAgICB9KVxuXG4gICAgICAvLyBMZWdlbmRcbiAgICAgIGlmICh0aGlzLl9sZWdlbmQgJiYgKHRoaXMuX2RhdGEubGVuZ3RoID4gMSkgfHwgdGhpcy5fYWx3YXlzU2hvd0xlZ2VuZCkge1xuICAgICAgICBsZXQgYnVsbGV0ID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgICAgLmFkZENsYXNzKFwiYnVsbGV0XCIpXG5cbiAgICAgICAgaWYgKGlzQ29sb3IoZW50cnkuY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgYnVsbGV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke2VudHJ5LmNvbG9yfWApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVsbGV0LmFkZENsYXNzKGVudHJ5LmNvbG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FwdGlvbiA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgICBjb25zdCBjYXB0aW9uRWxlbWVudCA9IGNhcHRpb24uZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgICBjYXB0aW9uRWxlbWVudC5pbm5lclRleHQgPSBlbnRyeS50aXRsZVxuXG4gICAgICAgIGxldCBsZWdlbmRJdGVtID0gbmV3IERvbUVsZW1lbnQoXCJsaVwiKVxuICAgICAgICAgIC5hcHBlbmRDaGlsZChidWxsZXQpXG4gICAgICAgICAgLmFwcGVuZENoaWxkKGNhcHRpb24pXG5cbiAgICAgICAgdGhpcy5fbGVnZW5kLmFwcGVuZENoaWxkKGxlZ2VuZEl0ZW0uZWxlbWVudClcblxuICAgICAgICB0aGlzLl9hbmltYXRlTGVnZW5kKGxlZ2VuZEl0ZW0uZWxlbWVudCBhcyBIVE1MRWxlbWVudCwgYW5pbWF0aW9uT2Zmc2V0KVxuICAgICAgfVxuICAgICAgYW5pbWF0aW9uT2Zmc2V0ICs9IGFuaW1hdGlvbkR1cmF0aW9uXG5cbiAgICAgIGN1cnJlbnRSb3RhdGUgKz0gKDM2MCAqIHBlcmNlbnRhZ2UpXG5cbiAgICAgIGlmIChpID09PSB0aGlzLl9kYXRhLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy5fdGl0bGUuaW5uZXJIVE1MID0gYCR7ZW50cnkudmFsdWV9ICR7dGhpcy5fdW5pdH1gXG4gICAgICAgIHRoaXMuX3N1YnRpdGxlLmlubmVySFRNTCA9IGVudHJ5LnRpdGxlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYW5pbWF0ZUxlZ2VuZChsZWdlbmRJdGVtOiBIVE1MRWxlbWVudCwgYW5pbWF0aW9uT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBsZWdlbmRJdGVtLnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGxlZ2VuZEl0ZW0sXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OX0xFR0VORCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgIGRlbGF5OiBhbmltYXRpb25PZmZzZXQsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBsZWdlbmRJdGVtLnN0eWxlLm9wYWNpdHkgPSBudWxsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwaWUgY2hhcnQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IC0gcGllIGNoYXJ0IGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRhdGE6IENoYXJ0RGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIGNsZWFycyByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl90aXRsZSA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9zdWJ0aXRsZSA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl91bml0ID0gdW5kZWZpbmVkXG5cbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9jaGFydCk7XG4gICAgKHRoaXMgYXMgYW55KS5fY2hhcnQgPSB1bmRlZmluZWRcblxuICAgIGlmICh0aGlzLl9sZWdlbmQpIHtcbiAgICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2xlZ2VuZCk7XG4gICAgICAodGhpcyBhcyBhbnkpLl9sZWdlbmQgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGRlc3Ryb3koKSBpbnN0ZWFkLlxuICAgKiBAdG9kbyByZW1vdmUgaW4gdmVyc2lvbiAyLjAuMFxuICAgKi9cbiAgcHVibGljIGRlc3RvcnkoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIucGllLWNoYXJ0XCIsIChlKSA9PiB7XG4gICAgbmV3IFBpZUNoYXJ0KGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBpZUNoYXJ0XG4iLCJpbXBvcnQgeyBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgYWRkQ2xhc3MsIGhhc0NsYXNzLCByZW1vdmVDbGFzcywgaXNIaWRkZW4gfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5cbmNvbnN0IEFOSU1BVElPTl9PUEVOID0gMzAwXG5cbi8qKlxuICogVGhlIENvbGxhcHNlIGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgQ29sbGFwc2UgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfaGlkZGVuSW5kaWNhdG9yITogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfY29sbGFwc2libGVFbGVtZW50cyE6IE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+XG4gIHByaXZhdGUgX2NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBDb2xsYXBzZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBDb2xsYXBzZSBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIENvbGxhcHNlIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICBsZXQgZGF0YVRhcmdldCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRhcmdldFwiKVxuICAgIGlmIChkYXRhVGFyZ2V0ID09PSBudWxsIHx8IGRhdGFUYXJnZXQgPT09IFwiXCIpIHtcblxuICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgY29uc29sZS5lcnJvcihcIkEgY29sbGFwc2libGUgZWxlbWVudCByZXF1aXJlcyBhICdkYXRhLXRhcmdldCcgdGhhdCBzcGVjaWZpZXMgdGhlIGVsZW1lbnQgdG8gY29sbGFwc2VcIilcbiAgICAgIGNvbnNvbGUuaW5mbyh0aGlzLmVsZW1lbnQpXG4gICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGhpZGRlblRhcmdldCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhpZGRlblwiKVxuICAgIGlmIChoaWRkZW5UYXJnZXQgIT09IG51bGwgJiYgaGlkZGVuVGFyZ2V0ICE9PSBcIlwiKSB7XG4gICAgICB0aGlzLl9oaWRkZW5JbmRpY2F0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGhpZGRlblRhcmdldCkhIGFzIEhUTUxFbGVtZW50XG4gICAgfVxuXG4gICAgdGhpcy5fY29sbGFwc2libGVFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YVRhcmdldClcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgdGhpcy50b2dnbGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGNvbGxhcHNlaWJsZS5cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5fY29sbGFwc2libGVFbGVtZW50cykge1xuICAgICAgICB0aGlzLl9vcGVuQ29sbGFwc2UocylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuXG4gICAgICBmb3IgKGxldCBzIG9mIHRoaXMuX2NvbGxhcHNpYmxlRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VDb2xsYXBzZShzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb3BlbkNvbGxhcHNlKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGFuaW1lLnJlbW92ZShlbClcblxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgaGVpZ2h0OiBlbC5zY3JvbGxIZWlnaHQgKyBcInB4XCIsXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbUVsID0gbmV3IERvbUVsZW1lbnQoZWwpXG4gICAgICAgIGRvbUVsLmFkZENsYXNzKENMQVNTX09QRU4pXG4gICAgICAgIGRvbUVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIilcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2VDb2xsYXBzZShlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBhbmltZS5yZW1vdmUoZWwpXG5cbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBlbCxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fT1BFTixcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudChlbClcbiAgICAgICAgZG9tRWwucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gc2V0IGFyaWEgZXhwYW5kZWRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl9jb2xsYXBzaWJsZUVsZW1lbnRzID0gbnVsbFxuXG4gICAgaWYgKCh0aGlzIGFzIGFueSkuX2NsaWNrSGFuZGxlcikge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5lbGVtZW50ID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtdG9nZ2xlPSdjb2xsYXBzZSddXCIpXG4gIGZvciAobGV0IGUgb2YgZWxlbWVudHMpIHtcbiAgICBpZiAoZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluaXRcIikgPT09IFwiYXV0b1wiKSB7XG4gICAgICBuZXcgQ29sbGFwc2UoZSBhcyBIVE1MRWxlbWVudClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sbGFwc2VcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgcGFyZW50V2l0aENsYXNzLCBnZXRSb290RWxlbWVudCB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBDTEFTU19CT1JERVIgPSBcImVtcHR5LXN0YXRlX19ib3JkZXJcIlxuY29uc3QgQ0xBU1NfQk9SREVSX01PREFMID0gXCJlbXB0eS1zdGF0ZV9fYm9yZGVyLS1tb2RhbFwiXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcImlzLWFjdGl2ZVwiXG5jb25zdCBDTEFTU19IQVNGSUxFUyA9IFwiaGFzLWZpbGVzXCJcbmNvbnN0IENMQVNTX01PREFMID0gXCJlbXB0eS1zdGF0ZS0tbW9kYWxcIlxuY29uc3QgQ0xBU1NfTU9EQUxfQ09OVEVOVCA9IFwibW9kYWxfX2NvbnRlbnRcIlxuXG5jb25zdCBRVUVSWV9NT0RBTF9CT0RZID0gXCIubW9kYWxfX2JvZHlcIlxuY29uc3QgUVVFUllfRklMRSA9IFwiaW5wdXRbdHlwZT0nZmlsZSddXCJcblxuLyoqXG4gKiBFbXB0eSBzdGF0ZSBwYXR0ZXJuXG4gKi9cbmNsYXNzIEVtcHR5U3RhdGUgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfYm9yZGVyITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cblxuICBwcml2YXRlIF9maWxlSW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnRcbiAgcHJpdmF0ZSBfYnV0dG9uOiBIVE1MTGFiZWxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfZHJhZ0FyZWEhOiBFbGVtZW50XG5cbiAgcHJpdmF0ZSBfZmlsZUNoYW5nZWRIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3ByZXZlbnRFdmVudHNIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2RyYWdFbnRlckhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZHJhZ0xlYXZlSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9kcm9wSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2lzRHJhZ2dpbmc6IGJvb2xlYW5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIEVtcHR5LVN0YXRlIHBhdHRlcm4gY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gcm9vdCBlbGVtZW50IG9mIHRoZSBlbXB0eS1zdGF0ZSBwYXR0ZXJuLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9maWxlSW5wdXQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9GSUxFKSEgYXMgSFRNTElucHV0RWxlbWVudFxuICAgIHRoaXMuX2J1dHRvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwibGFiZWxcIikhXG5cbiAgICB0aGlzLl9maWxlQ2hhbmdlZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVGaWxlQ2hhbmdlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcHJldmVudEV2ZW50c0hhbmRsZXIgPSB0aGlzLl9wcmV2ZW50RHJhZ0V2ZW50cy5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZHJhZ0VudGVySGFuZGxlciA9IHRoaXMuX2hhbmRsZURyYWdFbnRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZHJhZ0xlYXZlSGFuZGxlciA9IHRoaXMuX2hhbmRsZURyYWdMZWF2ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZHJvcEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVEcm9wLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQ2xhc3MoQ0xBU1NfTU9EQUwpKSB7XG4gICAgICAvLyBoYW5kbGUgbW9kYWwgZGlhbG9nc1xuICAgICAgdGhpcy5fZHJhZ0FyZWEgPSBwYXJlbnRXaXRoQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19NT0RBTF9DT05URU5UKSFcbiAgICAgIGxldCBib3JkZXJBcmVhID0gdGhpcy5fZHJhZ0FyZWEucXVlcnlTZWxlY3RvcihRVUVSWV9NT0RBTF9CT0RZKSFcbiAgICAgIGJvcmRlckFyZWEuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJwb2ludGVyLWV2ZW50czogbm9uZTtcIilcblxuICAgICAgdGhpcy5fYm9yZGVyID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19CT1JERVIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19CT1JERVJfTU9EQUwpXG5cbiAgICAgIGJvcmRlckFyZWEuYXBwZW5kQ2hpbGQodGhpcy5fYm9yZGVyLmVsZW1lbnQpXG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9ybWFsIG1vZGFsIGRpYWxvZ1xuICAgICAgdGhpcy5fZHJhZ0FyZWEgPSB0aGlzLmVsZW1lbnRcbiAgICAgIGxldCBib3JkZXJBcmVhID0gZ2V0Um9vdEVsZW1lbnQoKVxuXG4gICAgICB0aGlzLl9ib3JkZXIgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0JPUkRFUilcblxuICAgICAgaWYgKCFib3JkZXJBcmVhLnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX0JPUkRFUn1gKSkge1xuICAgICAgICBib3JkZXJBcmVhLmFwcGVuZENoaWxkKHRoaXMuX2JvcmRlci5lbGVtZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvcm0gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcImZvcm1cIikhXG5cbiAgICBmb3IgKGxldCBldmVudCBvZiBbIFwiZHJhZ1wiLCBcImRyYWdzdGFydFwiLCBcImRyYWdlbmRcIiwgXCJkcmFnb3ZlclwiLCBcImRyYWdlbnRlclwiLCBcImRyYWdsZWF2ZVwiLCBcImRyb3BcIiBdKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5fcHJldmVudEV2ZW50c0hhbmRsZXIpXG4gICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuX3ByZXZlbnRFdmVudHNIYW5kbGVyKVxuICAgICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5fcHJldmVudEV2ZW50c0hhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuX2RyYWdFbnRlckhhbmRsZXIpXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLCB0aGlzLl9kcmFnRW50ZXJIYW5kbGVyKVxuXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCB0aGlzLl9kcmFnTGVhdmVIYW5kbGVyKVxuICAgIHRoaXMuX2RyYWdBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIHRoaXMuX2RyYWdMZWF2ZUhhbmRsZXIpXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5fZHJhZ0xlYXZlSGFuZGxlcilcblxuICAgIHRoaXMuX2RyYWdBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuX2Ryb3BIYW5kbGVyKVxuICAgIHRoaXMuX2ZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuX2ZpbGVDaGFuZ2VkSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfcHJldmVudERyYWdFdmVudHMoZTogRXZlbnQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRHJhZ0VudGVyKCkge1xuICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nID09PSB0cnVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZVxuICAgIHRoaXMuX2J1dHRvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInBvaW50ZXItZXZlbnRzOiBub25lO1wiKVxuXG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19BQ1RJVkUpXG4gICAgdGhpcy5fYm9yZGVyLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRHJhZ0xlYXZlKCkge1xuICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgdGhpcy5fYnV0dG9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX0FDVElWRSlcbiAgICB0aGlzLl9ib3JkZXIucmVtb3ZlQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVEcm9wKGU6IEV2ZW50KSB7XG4gICAgY29uc3QgZHJhZ0V2ZW50ID0gZSBhcyBEcmFnRXZlbnRcbiAgICAodGhpcy5fZmlsZUlucHV0IGFzIGFueSkuZmlsZXMgPSBkcmFnRXZlbnQuZGF0YVRyYW5zZmVyIS5maWxlc1xuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVGaWxlQ2hhbmdlZCgpIHtcbiAgICBsZXQgZmlsZXMgPSB0aGlzLl9maWxlSW5wdXQuZmlsZXNcblxuICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKENMQVNTX0hBU0ZJTEVTKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX0hBU0ZJTEVTKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmlsZXMuXG4gICAqL1xuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVJbnB1dC5maWxlc1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmVtcHR5LXN0YXRlXCIsIChlKSA9PiB7XG4gICAgbmV3IEVtcHR5U3RhdGUoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgRW1wdHlTdGF0ZVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IHsgZW1wdHksIGFkZENsYXNzLCByZW1vdmVDbGFzcywgaGFzQ2xhc3MgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi4vSW5wdXRzXCJcblxuY29uc3QgUVVFUllfRFJPUERPV04gPSBcIi5qcy1hdXRvY29tcGxldGVcIlxuY29uc3QgQ0xBU1NfUkVTVUxUID0gXCJhdXRvY29tcGxldGVfX3Jlc3VsdFwiXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcbmNvbnN0IENMQVNTX0hPVkVSID0gXCJqcy1ob3ZlclwiXG5jb25zdCBBVFRSSUJVVEVfVkFMVUUgPSBcImRhdGEtdmFsdWVcIlxuXG5jb25zdCBUSU1FT1VUX0JMVVIgPSA0MDBcblxuZXhwb3J0IGludGVyZmFjZSBTb3VyY2Uge1xuICAoXG4gICAgdGVybTogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAobWF0Y2hlczogc3RyaW5nW10sIHRlcm11c2VkOiBzdHJpbmcpID0+IHZvaWRcbiAgKTogdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9jb21wbGV0ZUNvbmZpZyB7XG4gIG1pbkNoYXJzOiBudW1iZXJcbiAgc291cmNlOiBTb3VyY2Vcbn1cblxuLyoqXG4gKiBBdXRvY29tcGxldGUgY29tcG9uZW50XG4gKiBAZmlyZXMgQXV0b2NvbXBsZXRlI2NoYW5nZVxuICovXG5jbGFzcyBBdXRvY29tcGxldGUgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX3NvdXJjZSE6IFNvdXJjZVxuICBwcml2YXRlIF9taW5DaGFycyE6IG51bWJlclxuXG4gIHByaXZhdGUgX2lucHV0OiBIVE1MSW5wdXRFbGVtZW50XG4gIHByaXZhdGUgX3N1Z2dlc3Rpb25MaXN0ITogSFRNTFVMaXN0RWxlbWVudFxuICBwcml2YXRlIF9kcm9wZG93bjogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF93aW5kb3dDbGlja0hhbmRsZXI6IChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9rZXlVcEhhbmRsZXI6IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9rZXlEb3duSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2JsdXJIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbmZpZ3VyYXRpb24/OiBBdXRvY29tcGxldGVDb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5faW5wdXQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpIVxuICAgIHRoaXMuX2Ryb3Bkb3duID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfRFJPUERPV04pISBhcyBIVE1MRWxlbWVudFxuXG4gICAgLy8gU2V0dXAgZXZlbnQgY29udGV4dFxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5VXBIYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5VXAuYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleURvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fYmx1ckhhbmRsZXIgPSB0aGlzLl9oYW5kbGVCbHVyLmJpbmQodGhpcylcblxuICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICB0aGlzLl9taW5DaGFycyA9IGNvbmZpZ3VyYXRpb24ubWluQ2hhcnNcbiAgICAgIHRoaXMuX3NvdXJjZSA9IGNvbmZpZ3VyYXRpb24uc291cmNlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9taW5DaGFycyB8fCB0aGlzLl9taW5DaGFycyA8IDApIHtcbiAgICAgIHRoaXMuX21pbkNoYXJzID0gMlxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBBdXRvY29tcGxldGUgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2NsZWFyU3VnZ2VzdGlvbnMoKVxuXG4gICAgaWYgKHRoaXMuX2lucHV0LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpXG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSBicm93c2VyIGF1dG9maWxsXG4gICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIpXG4gIH1cblxuICAvKipcbiAgICogVGhlIEF1dG9jb21wbGV0ZSBjb21wb25lbnQgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICogQGNhbGxiYWNrIEF1dG9jb21wbGV0ZX5TdWdnZXN0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0ZXJtIC0gVGhlIGN1cnJlbnQgc2VhcmNoIHRlcm0uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IG1hdGNoZXMgLSBUaGUgbGlzdCBvZiBtYXRjaGluZyBzdHJpbmdzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIEF1dG9jb21wbGV0ZSBjb21wb25lbnQgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICogQGNhbGxiYWNrIEF1dG9jb21wbGV0ZX5Tb3VyY2VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHRlcm0gLSBUaGUgY3VycmVudCBzZWFyY2ggdGVybS5cbiAgICogQHByb3BlcnR5IHtBdXRvY29tcGxldGV+U3VnZ2VzdH0gc3VnZ2VzdCAtIFRoZSBhdXRvY29tcGxldGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVwb3J0IHRoZSByZXN1bHRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIEF1dG9jb21wbGV0ZSBjb21wb25lbnQgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICogQHR5cGVkZWYge09iamVjdH0gQXV0b2NvbXBsZXRlfkNvbmZpZ1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWluQ2hhcnMgLSBUaGUgbWluaW1hbCByZXF1aXJlZCBjaGFyYWN0ZXJzIHRvIHN0YXJ0IHF1ZXJ5aW5nIGZvciBhdXRvY29tcGxldGUgbWF0Y2hlcy5cbiAgICogQHByb3BlcnR5IHtBdXRvY29tcGxldGV+U291cmNlfSBzb3VyY2UgLSBUaGUgYXV0b2NvbXBsZXRlIHNvdXJjZSBmdW5jdGlvbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGF1dG9jb21wbGV0ZSBjb21wb25lbnQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtBdXRvY29tcGxldGV+Q29uZmlnfSBjb25maWd1cmF0aW9uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgcHVibGljIGNvbmZpZ3VyZShjb25maWd1cmF0aW9uPzogQXV0b2NvbXBsZXRlQ29uZmlnKSB7XG4gICAgaWYgKCFjb25maWd1cmF0aW9uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY29uZmlndXJhdGlvbi5taW5DaGFycykge1xuICAgICAgdGhpcy5fbWluQ2hhcnMgPSBNYXRoLm1pbihjb25maWd1cmF0aW9uLm1pbkNoYXJzLCAxKVxuICAgIH1cblxuICAgIGlmIChjb25maWd1cmF0aW9uLnNvdXJjZSkge1xuICAgICAgdGhpcy5fc291cmNlID0gY29uZmlndXJhdGlvbi5zb3VyY2VcbiAgICB9XG5cbiAgICB0aGlzLl9jbGVhclN1Z2dlc3Rpb25zKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QgY29udHJvbCB0byB0aGUgZW5hYmxlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBlbmFibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIilcblxuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9rZXlVcEhhbmRsZXIpXG4gICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5RG93bkhhbmRsZXIpXG4gICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0IGNvbnRyb2wgdG8gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGRpc2FibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJ0cnVlXCIpXG5cbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5fa2V5VXBIYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleURvd25IYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgZnJlZXMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcblxuICAgICh0aGlzIGFzIGFueSkuX2tleVVwSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9rZXlEb3duSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl93aW5kb3dDbGlja0hhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fYmx1ckhhbmRsZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9pbnB1dCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc3VnZ2VzdGlvbnMgZHJvcGRvd24uXG4gICAqL1xuICBwdWJsaWMgb3BlbigpIHtcbiAgICB0aGlzLl9kcm9wZG93bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBzdWdnZXN0aW9ucyBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICB0aGlzLl9kcm9wZG93bi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQudmFsdWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2lzRHJvcGRvd25UYXJnZXQoZXZlbnQudGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgY3VycmVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuICAgIHdoaWxlIChjdXJyZW50Lm5vZGVOYW1lICE9PSBcIkxJXCIgJiYgY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQubm9kZU5hbWUgPT09IFwiTElcIikge1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICB0aGlzLl9zZWxlY3RJdGVtKGN1cnJlbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVCbHVyKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfSwgVElNRU9VVF9CTFVSKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVLZXlVcChldnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQga2V5Y29kZSA9IGV2dC53aGljaCB8fCBldnQua2V5Q29kZVxuXG4gICAgaWYgKElucHV0cy5jb250YWluc0tleShrZXljb2RlLCBbIElucHV0cy5LRVlfQVJST1dfVVAsIElucHV0cy5LRVlfQVJST1dfRE9XTiwgSW5wdXRzLktFWV9FTlRFUiwgSW5wdXRzLktFWV9UQUIgXSkpIHtcbiAgICAgIC8vIERvIG5vdCBoYW5kbGUgdGhlc2UgZXZlbnRzIG9uIGtleXVwXG4gICAgICBwcmV2ZW50RGVmYXVsdChldnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBldnQuY3VycmVudFRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50XG5cbiAgICBpZiAoZXZ0LmN1cnJlbnRUYXJnZXQgJiYgdGFyZ2V0LnZhbHVlICYmIHRhcmdldC52YWx1ZS5sZW5ndGggPj0gdGhpcy5fbWluQ2hhcnMpIHtcbiAgICAgIHRoaXMuX2dldFN1Z2dlc3Rpb24odGFyZ2V0LnZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleURvd24oZXZ0OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGtleWNvZGUgPSBldnQud2hpY2ggfHwgZXZ0LmtleUNvZGVcbiAgICBjb25zdCBpc09wZW4gPSBoYXNDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FU0NBUEUgJiYgaXNPcGVuID09PSB0cnVlKSB7XG4gICAgICAvLyBoYW5kbGUgRXNjYXBlIGtleSAoRVNDKVxuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICBwcmV2ZW50RGVmYXVsdChldnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNPcGVuID09PSB0cnVlICYmIElucHV0cy5jb250YWluc0tleShrZXljb2RlLCBbIElucHV0cy5LRVlfRU5URVIsIElucHV0cy5LRVlfVEFCIF0pKSB7XG4gICAgICBsZXQgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9zdWdnZXN0aW9uTGlzdC5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU19IT1ZFUn1gKVxuXG4gICAgICBwcmV2ZW50RGVmYXVsdChldnQpXG4gICAgICB0aGlzLl9zZWxlY3RJdGVtKGZvY3VzZWRFbGVtZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzT3BlbiA9PT0gdHJ1ZSAmJiBJbnB1dHMuY29udGFpbnNLZXkoa2V5Y29kZSwgWyBJbnB1dHMuS0VZX0FSUk9XX1VQLCBJbnB1dHMuS0VZX0FSUk9XX0RPV04gXSkpIHtcbiAgICAgIC8vIFVwIGFuZCBkb3duIGFycm93c1xuXG4gICAgICBsZXQgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9zdWdnZXN0aW9uTGlzdC5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU19IT1ZFUn1gKSFcbiAgICAgIGlmIChmb2N1c2VkRWxlbWVudCkge1xuICAgICAgICByZW1vdmVDbGFzcyhmb2N1c2VkRWxlbWVudCwgQ0xBU1NfSE9WRVIpXG5cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9zdWdnZXN0aW9uTGlzdC5jaGlsZE5vZGVzKSBhcyBFbGVtZW50W11cblxuICAgICAgICBjb25zdCB0b3RhbE5vZGVzID0gY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQID8gLTEgOiAxXG5cbiAgICAgICAgbGV0IGluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihmb2N1c2VkRWxlbWVudClcblxuICAgICAgICBpbmRleCA9IE1hdGgubWF4KE1hdGgubWluKGluZGV4ICsgZGlyZWN0aW9uLCB0b3RhbE5vZGVzKSwgMClcbiAgICAgICAgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9zdWdnZXN0aW9uTGlzdC5jaGlsZE5vZGVzW2luZGV4XSBhcyBFbGVtZW50XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fc3VnZ2VzdGlvbkxpc3QucXVlcnlTZWxlY3RvcihcImxpXCIpIGFzIEVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgYWRkQ2xhc3MoZm9jdXNlZEVsZW1lbnQsIENMQVNTX0hPVkVSKVxuICAgICAgcHJldmVudERlZmF1bHQoZXZ0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVXaW5kb3dDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIGlmICh0aGlzLl9pc0Ryb3Bkb3duVGFyZ2V0KGV2ZW50LnRhcmdldCBhcyBOb2RlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3NlbGVjdEl0ZW0oaXRlbT86IEVsZW1lbnQgfCBudWxsKSB7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gaXRlbS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX1ZBTFVFKVxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHRleHRcblxuICAgICAgLy8gRGlzcGF0Y2ggdGhlIGNoYW5nZWQgZXZlbnRcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKVxuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pc0Ryb3Bkb3duVGFyZ2V0KHRhcmdldDogTm9kZSkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0XG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IHRoaXMuX2Ryb3Bkb3duICYmIGN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZVxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50ID09PSB0aGlzLl9kcm9wZG93blxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbGVhclN1Z2dlc3Rpb25zKCkge1xuICAgIC8vIENsZWFyIHRoZSBkcm9wZG93biBpdGVtXG4gICAgZW1wdHkodGhpcy5fZHJvcGRvd24pXG5cbiAgICB0aGlzLl9zdWdnZXN0aW9uTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKVxuICAgIHRoaXMuX2Ryb3Bkb3duLmFwcGVuZENoaWxkKHRoaXMuX3N1Z2dlc3Rpb25MaXN0KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRTdWdnZXN0aW9uKHRleHQ6IHN0cmluZywgdGVybTogc3RyaW5nKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkVGVybSA9IHRlcm0ucmVwbGFjZSgvWy1cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKVxuICAgIGNvbnN0IGh0bWwgPSB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChgKCR7c2FuaXRpemVkVGVybX0pYCwgXCJnaVwiKSwgXCI8c3Ryb25nPiQxPC9zdHJvbmc+XCIpXG5cbiAgICBjb25zdCB0ZXh0RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgLnNldEh0bWwoaHRtbClcblxuICAgIGNvbnN0IGlubmVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfUkVTVUxUKVxuICAgICAgLmFwcGVuZENoaWxkKHRleHRFbGVtZW50KVxuXG4gICAgY29uc3QgbGlFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJsaVwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShBVFRSSUJVVEVfVkFMVUUsIHRleHQpXG4gICAgICAuYXBwZW5kQ2hpbGQoaW5uZXJFbGVtZW50KVxuXG4gICAgdGhpcy5fc3VnZ2VzdGlvbkxpc3QuYXBwZW5kQ2hpbGQobGlFbGVtZW50LmVsZW1lbnQpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFN1Z2dlc3Rpb24odGVybTogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLl9zb3VyY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzb3VyY2UgZnVuY3Rpb24gaXMgdW5kZWZpbmVkLCBjYW5ub3QgbG9hZCBzdWdnZXN0aW9uc1wiKVxuICAgIH1cblxuICAgIHRoaXMuX3NvdXJjZSh0ZXJtLCAobWF0Y2hlcywgdGVybXVzZWQpID0+IHtcbiAgICAgIHRoaXMuX29uTWF0Y2hlc1JlY2VpdmVkKG1hdGNoZXMsIHRlcm11c2VkKVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgX29uTWF0Y2hlc1JlY2VpdmVkKG1hdGNoZXM6IHN0cmluZ1tdLCB0ZXJtOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9jbGVhclN1Z2dlc3Rpb25zKClcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIHRoZSBkcm9wZG93biBpdGVtXG4gICAgICBlbXB0eSh0aGlzLl9zdWdnZXN0aW9uTGlzdClcblxuICAgICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICB0aGlzLl9hZGRTdWdnZXN0aW9uKG1hdGNoLCB0ZXJtKVxuICAgICAgfVxuXG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoYW5nZSBldmVudFxuICpcbiAqIEBldmVudCBBdXRvY29tcGxldGUjY2hhbmdlXG4gKiBAdHlwZSB7b2JqZWN0fVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxFbGVtZW50PihcIi5pbnB1dC1maWVsZC0tYXV0b2NvbXBsZXRlXCIsIChlKSA9PiB7XG4gICAgbmV3IEF1dG9jb21wbGV0ZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdXRvY29tcGxldGVcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHJlbW92ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgZmxhdHBpY2tyIGZyb20gXCJmbGF0cGlja3JcIlxuXG5pbXBvcnQgeyBJdGFsaWFuIH0gZnJvbSBcImZsYXRwaWNrci9kaXN0L2wxMG4vaXQuanNcIlxuaW1wb3J0IHsgRnJlbmNoIH0gZnJvbSBcImZsYXRwaWNrci9kaXN0L2wxMG4vZnIuanNcIlxuaW1wb3J0IHsgR2VybWFuIH0gZnJvbSBcImZsYXRwaWNrci9kaXN0L2wxMG4vZGUuanNcIlxuXG5mbGF0cGlja3IubG9jYWxpemUoSXRhbGlhbilcbmZsYXRwaWNrci5sb2NhbGl6ZShGcmVuY2gpXG5mbGF0cGlja3IubG9jYWxpemUoR2VybWFuKVxuXG5jb25zdCBERUZBVUxUU19GTEFUUElDS1IgPSB7XG4gIHdyYXA6IHRydWUsIC8vIGVuYWJsZSBjYWxlbmRhciB0b2dnbGUgaWNvblxuICBhbGxvd0lucHV0OiB0cnVlLCAvLyBkb24ndCBzZXQgaW5wdXQgdG8gcmVhZG9ubHlcbiAgbG9jYWxlOiBcImRlXCIsIC8vIEdlcm1hbiBpcyBkZWZhdWx0XG4gIGRhdGVGb3JtYXQ6IFwiZC5tLllcIiwgLy8gMTUuMDEuMjAxN1xuICB0aW1lXzI0aHI6IHRydWVcbn1cblxuY29uc3QgQ0xBU1NfSEFTX1ZBTFVFID0gXCJpcy1maXhlZFwiXG5jb25zdCBDTEFTU19NRVNTQUdFID0gXCIubWVzc2FnZVwiXG5cbi8qKlxuICogSW5wdXQgZmllbGQgY29tcG9uZW50XG4gKi9cbmNsYXNzIElucHV0RmllbGQgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxJbnB1dEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfY2hhbmdlZEhhbmRsZXI6ICgpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYW5pbWF0aW9uU3RhcnRIYW5kbGVyOiAoZTogQW5pbWF0aW9uRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZmxhdHBpY2tySW5zdGFuY2U6IGFueVxuICBwcml2YXRlIF9kYXRlUGlja2VyT3B0aW9uczogYW55XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTElucHV0RWxlbWVudCwgZGF0ZVBpY2tlck9wdGlvbnM/OiBhbnkpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2hhbmdlZEhhbmRsZXIgPSB0aGlzLm9uVmFsdWVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl9hbmltYXRpb25TdGFydEhhbmRsZXIgPSB0aGlzLl9vbkFuaW1hdGlvblN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLl9kYXRlUGlja2VyT3B0aW9ucyA9IGRhdGVQaWNrZXJPcHRpb25zXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGlucHV0IGZpZWxkIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuX2NoYW5nZWRIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc3RhcnRcIiwgdGhpcy5fYW5pbWF0aW9uU3RhcnRIYW5kbGVyKVxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemVEYXRlUGlja2VyKClcbiAgICB0aGlzLm9uVmFsdWVDaGFuZ2VkKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZURhdGVQaWNrZXIoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnRcbiAgICBpZiAoIXBpY2tlciB8fCAhcGlja2VyLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrclwiKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghdGhpcy5fZGF0ZVBpY2tlck9wdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXJPcHRpb25zID0gSlNPTi5wYXJzZShwaWNrZXIuZGF0YXNldC5vcHRpb25zIHx8IFwie31cIilcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlck9wdGlvbnMgPSB7fVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oXCJfaW5pdGlhbGl6ZURhdGVQaWNrZXIgSlNPTi5wYXJzZSBmYWlsZWRcIiwgcGlja2VyLmRhdGFzZXQub3B0aW9ucywgZSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmxhdHBpY2tySW5zdGFuY2UgPSBmbGF0cGlja3IocGlja2VyLCBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUU19GTEFUUElDS1IsIHRoaXMuX2RhdGVQaWNrZXJPcHRpb25zKSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfZGVzdHJveURhdGVQaWNrZXIoKSB7XG4gICAgaWYgKHRoaXMuX2ZsYXRwaWNrckluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9mbGF0cGlja3JJbnN0YW5jZS5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX29uQW5pbWF0aW9uU3RhcnQoZTogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICBpZiAoZS5hbmltYXRpb25OYW1lID09PSBcIm9uQXV0b0ZpbGxTdGFydFwiKSB7XG4gICAgICB0aGlzLm9uVmFsdWVDaGFuZ2VkKHRydWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoZSBpbnB1dCBmaWVsZCBjb21wb25lbnQgdGhhdCBpdCdzIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAqL1xuICBwdWJsaWMgb25WYWx1ZUNoYW5nZWQoZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQudmFsdWUgJiYgdGhpcy5lbGVtZW50LnZhbHVlICE9PSBcIlwiIHx8IGZvcmNlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKENMQVNTX0hBU19WQUxVRSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19IQVNfVkFMVUUpXG4gICAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBcIlwiXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl9jaGFuZ2VkSGFuZGxlcilcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJwYXNzd29yZFwiKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIHRoaXMuX2FuaW1hdGlvblN0YXJ0SGFuZGxlcilcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9jaGFuZ2VkSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9hbmltYXRpb25TdGFydEhhbmRsZXIgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX2Rlc3Ryb3lEYXRlUGlja2VyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5cyB0aGUgc3BlY2lmaWVkIGVycm9yIHRleHQgdW5kZXJuZWF0aCB0aGUgaW5wdXQgZmllbGQuXG4gICAqIEBwYXJhbSB7dGV4dH0gdGV4dCBUaGUgZXJyb3IgdGV4dC9odG1sIHRvIGRpc3BsYXk7IG9yIHVuZGVmaW5lZCB0byBoaWRlIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgcHVibGljIHNob3dFcnJvcih0ZXh0OiBzdHJpbmcpIHtcbiAgICBsZXQgbWVzc2FnZVxuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgbGV0IG1zZyA9IHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoQ0xBU1NfTUVTU0FHRSlcblxuICAgICAgaWYgKG1zZykge1xuICAgICAgICBtZXNzYWdlID0gbmV3IERvbUVsZW1lbnQobXNnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGV4dCB8fCB0ZXh0ID09PSBcIlwiKSB7XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICByZW1vdmUobWVzc2FnZS5lbGVtZW50KVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKFwiaW52YWxpZFwiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5hZGRDbGFzcyhcImludmFsaWRcIilcblxuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhcIm1lc3NhZ2VcIilcblxuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQhLmFwcGVuZENoaWxkKG1lc3NhZ2UuZWxlbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5lbXB0eSgpXG4gICAgfVxuXG4gICAgY29uc3QgaWNvbiA9IG5ldyBEb21FbGVtZW50KFwiaVwiKVxuICAgICAgLmFkZENsYXNzKFwiaWNvblwiKVxuICAgICAgLmFkZENsYXNzKFwiaWNvbi0wMjYtZXhjbGFtYXRpb24tbWFyay1jaXJjbGVcIilcbiAgICAgIC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIilcblxuICAgIGNvbnN0IG1zZyA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgLnNldEh0bWwodGV4dClcblxuICAgIG1lc3NhZ2UuYXBwZW5kQ2hpbGQoaWNvbilcbiAgICBtZXNzYWdlLmFwcGVuZENoaWxkKG1zZylcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MSW5wdXRFbGVtZW50PihcIi5pbnB1dC1maWVsZCBpbnB1dFwiLCAoZSkgPT4ge1xuICAgIG5ldyBJbnB1dEZpZWxkKGUpXG4gIH0sIChlKSA9PiBlLnBhcmVudEVsZW1lbnQhKVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEZpZWxkXG4iLCJpbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBjbGFtcCwgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBNQVJHSU5fVElDSyA9IDMyXG5jb25zdCBDTEFTU19IVE1MNSA9IFwiaHRtbDVcIlxuY29uc3QgUkFOR0VfTElHSFQgPSBcInJhbmdlLS1saWdodFwiXG5cbmNvbnN0IENMQVNTX0NPTlRBSU5FUiA9IFwicmFuZ2UtY29udGFpbmVyXCJcbmNvbnN0IENMQVNTX1NMSURFUiA9IFwicmFuZ2Utc2xpZGVyXCJcbmNvbnN0IENMQVNTX0FDVElWRSA9IFwicmFuZ2UtLWFjdGl2ZVwiXG5cbmNvbnN0IENMQVNTX1RSQUNLID0gXCJyYW5nZS10cmFja1wiXG5jb25zdCBDTEFTU19UUkFDS19QUk9HUkVTUyA9IFwicmFuZ2UtdHJhY2tfX3Byb2dyZXNzXCJcblxuY29uc3QgQ0xBU1NfVElDSyA9IFwicmFuZ2UtdGlja1wiXG5jb25zdCBDTEFTU19USUNLX0xBQkVMID0gXCJyYW5nZS10aWNrX19sYWJlbFwiXG5jb25zdCBDTEFTU19USUNLX0FDVElWRSA9IFwicmFuZ2UtdGljay0tYWN0aXZlXCJcblxuY29uc3QgQ0xBU1NfVEhVTUIgPSBcInJhbmdlLXRodW1iXCJcbmNvbnN0IENMQVNTX1RIVU1CX1ZBTFVFID0gXCJyYW5nZS10aHVtYl9fdmFsdWVcIlxuY29uc3QgQ0xBU1NfRElTQUJMRUQgPSBcInJhbmdlLS1kaXNhYmxlZFwiXG5cbmNvbnN0IENMQVNTX0RSQUdHSU5HID0gXCJyYW5nZS0tZHJhZ2dpbmdcIlxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHRlciB7XG4gICh2YWx1ZTogbnVtYmVyLCBzaG9ydDogYm9vbGVhbik6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbiB7XG4gIHZhbHVlOiBudW1iZXJcbiAgbGFiZWw6IHN0cmluZyB8IG51bWJlclxufVxuXG4vKipcbiAqIFRoZSByYW5nZSBzbGlkZXIgY29tcG9uZW50IGRlZmluaXRpb24uXG4gKi9cbmNsYXNzIFJhbmdlIGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MSW5wdXRFbGVtZW50PiB7XG4gIHByaXZhdGUgX2Rvd25IYW5kbGVyOiAoZTogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfbW92ZUhhbmRsZXI6IChlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9lbmRIYW5kbGVyOiAoZTogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2ZvY3VzSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2JsdXJIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfcmVzaXplSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfd3JhcHBlckVsZW1lbnQhOiBEb21FbGVtZW50PEhUTUxFbGVtZW50PlxuICBwcml2YXRlIF9yYW5nZUNvbnRhaW5lciE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX3JhbmdlVHJhY2shOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuICBwcml2YXRlIF9yYW5nZVByb2dyZXNzITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfdGlja3NXcmFwcGVyITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfcmFuZ2VUaHVtYiE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX3RodW1iVmFsdWUhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuICBwcml2YXRlIF9vdXRwdXRMYWJlbD86IERvbUVsZW1lbnQ8RWxlbWVudD5cblxuICBwcml2YXRlIF9taW5WYWx1ZSE6IG51bWJlclxuICBwcml2YXRlIF9tYXhWYWx1ZSE6IG51bWJlclxuICBwcml2YXRlIF90cmFja1ZhbHVlVG90YWwhOiBudW1iZXJcblxuICBwcml2YXRlIF9ncmFiUG9zaXRpb24hOiBudW1iZXJcbiAgcHJpdmF0ZSBfdHJhY2tXaWR0aCE6IG51bWJlclxuICBwcml2YXRlIF90cmFja1Bvc2l0aW9uTWluITogbnVtYmVyXG4gIHByaXZhdGUgX3RyYWNrUG9zaXRpb25NYXghOiBudW1iZXJcbiAgcHJpdmF0ZSBfdHJhY2tMZWZ0UG9zaXRpb24hOiBudW1iZXJcbiAgcHJpdmF0ZSBfaXRlbVdpZHRoITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfZm9ybWF0dGVyITogRm9ybWF0dGVyXG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTElucHV0RWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICAvLyBTZXR1cCBldmVudCBjb250ZXh0XG4gICAgdGhpcy5fZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVEb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9tb3ZlSGFuZGxlciA9IHRoaXMuX2hhbmRsZU1vdmUuYmluZCh0aGlzKVxuICAgIHRoaXMuX2VuZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVFbmQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVGb2N1cy5iaW5kKHRoaXMpXG4gICAgdGhpcy5fYmx1ckhhbmRsZXIgPSB0aGlzLl9oYW5kbGVCbHVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gdGhpcy5sYXlvdXQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG5cbiAgICBpZiAodGhpcy5lbGVtZW50LmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSByYW5nZSBzbGlkZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpbnNwZWN0cyB0aGUgc2VsZWN0IGRlZmluaXRpb24gYW5kIGl0cyBvcHRpb25zIGFuZFxuICAgKiBnZW5lcmF0ZXMgbmV3IHN0eWxhYmxlIERPTSBlbGVtZW50cyBhcm91bmQgdGhlIG9yaWdpbmFsIHJhbmdlIGlucHV0LWVsZW1lbnRcbiAgICogZGVmaW5pdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG5cbiAgICBpZiAodGhpcy5oYXNDbGFzcyhDTEFTU19IVE1MNSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB1c2VzIEhUTUw1IHN0eWxpbmcsIGRvIG5vdCB0b3VjaCBpdC4uLlxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCEpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lciA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0NPTlRBSU5FUilcblxuICAgIHRoaXMuX3JhbmdlVHJhY2sgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19UUkFDSylcblxuICAgIC8vIGNoZWNrIGlmIHJhbmdlLS1saWdodCBzbGlkZXIgdGhlbiBhZGQgcHJvZ3Jlc3NcbiAgICBpZiAodGhpcy5fd3JhcHBlckVsZW1lbnQuaGFzQ2xhc3MoUkFOR0VfTElHSFQpKSB7XG4gICAgICB0aGlzLl9yYW5nZVByb2dyZXNzID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19UUkFDS19QUk9HUkVTUylcblxuICAgICAgdGhpcy5fcmFuZ2VUcmFjay5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZVByb2dyZXNzKVxuICAgIH1cblxuICAgIHRoaXMuX3JhbmdlVGh1bWIgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19USFVNQilcblxuICAgIHRoaXMuX3RpY2tzV3JhcHBlciA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1NMSURFUilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3JhbmdlVHJhY2spXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fdGlja3NXcmFwcGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3JhbmdlVGh1bWIpXG5cbiAgICAvLyBhZGQgY29udGFpbmVyIHRvIHdyYXBwZXJcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZUNvbnRhaW5lcilcblxuICAgIC8vIGdldCBtaW4gJiBtYXggZGVmaW5pdGlvbnNcbiAgICB0aGlzLl9taW5WYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50Lm1pbikgfHwgMFxuICAgIHRoaXMuX21heFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQubWF4KSB8fCAxXG5cbiAgICAvLyBnZXQgdGhlIGxhYmVsL291dHB1dCBmb3JtYXQgc3RyaW5nXG4gICAgdGhpcy5fZm9ybWF0dGVyID0gKHdpbmRvdyBhcyBhbnkpW3RoaXMuZ2V0QXR0cmlidXRlKFwiZm9ybWF0dGVyXCIpIV1cblxuICAgIC8vIGdldCB0aGUgb3V0cHV0IGxhYmVsIGFuZCBtb3ZlIGl0IGJlbG93IHRoZSBjb250YWluZXJcbiAgICBpZiAodGhpcy5lbGVtZW50LmlkKSB7XG4gICAgICB0aGlzLl9vdXRwdXRMYWJlbCA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmZpbmQoYG91dHB1dFtmb3I9JyR7dGhpcy5lbGVtZW50LmlkfSddYClcbiAgICAgIGlmICh0aGlzLl9vdXRwdXRMYWJlbCkge1xuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9vdXRwdXRMYWJlbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZWxlbWVudC5zdGVwKSB7XG4gICAgICAvLyBmaXggaXNzdWVzIHdpdGggZmxvYXQgc2xpZGVycyBpZiB0aGUgc3RlcCBpcyB1bmRlZmluZWRcbiAgICAgIHRoaXMuZWxlbWVudC5zdGVwID0gXCJhbnlcIlxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9nZXRPcHRpb25zTGlzdCgpXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2FkZFRpY2tzKG9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVElDS19MQUJFTH1gKS5sZW5ndGggPD0gMSkge1xuICAgICAgdGhpcy5fdGh1bWJWYWx1ZSA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVEhVTUJfVkFMVUUpXG5cbiAgICAgIHRoaXMuX3JhbmdlVGh1bWIuYXBwZW5kQ2hpbGQodGhpcy5fdGh1bWJWYWx1ZSlcbiAgICB9XG5cbiAgICB0aGlzLl90cmFja1ZhbHVlVG90YWwgPSB0aGlzLl9tYXhWYWx1ZSAtIHRoaXMuX21pblZhbHVlXG4gICAgdGhpcy5sYXlvdXQoKVxuXG4gICAgdGhpcy5fdXBkYXRlVGlja1N0YXRlKClcblxuICAgIC8vIEFwcGx5IHRoZSB0YWIgaW5kZXhcbiAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKVxuICAgIGlmICh0YWJJbmRleCkge1xuICAgICAgdGhpcy5fcmFuZ2VDb250YWluZXIuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgdGFiSW5kZXgpXG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldE9wdGlvbnNMaXN0KCkge1xuICAgIGxldCBvcHRpb25zOiBPcHRpb25bXSA9IFtdXG5cbiAgICBsZXQgbGlzdElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJsaXN0XCIpXG4gICAgaWYgKGxpc3RJZCkge1xuICAgICAgbGV0IGRhdGFMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7bGlzdElkfWApXG4gICAgICBpZiAoZGF0YUxpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZGF0YUxpc3QucXVlcnlTZWxlY3RvckFsbChcIm9wdGlvblwiKSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQoZW50cnkuaW5uZXJUZXh0KVxuICAgICAgICAgIGxldCBsYWJlbCA9IGVudHJ5LmdldEF0dHJpYnV0ZShcImxhYmVsXCIpIHx8IHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZCgyKSlcblxuICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvcnQgdGhlIGxpc3QgdG8gZW5hYmxlIHNuYXBwaW5nXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMuc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpXG5cbiAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9taW5WYWx1ZSA9IE51bWJlci5NQVhfVkFMVUVcbiAgICAgIHRoaXMuX21heFZhbHVlID0gTnVtYmVyLk1JTl9WQUxVRVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbWluVmFsdWUgPSBNYXRoLm1pbih0aGlzLl9taW5WYWx1ZSwgb3B0aW9uc1tpXS52YWx1ZSlcbiAgICAgICAgdGhpcy5fbWF4VmFsdWUgPSBNYXRoLm1heCh0aGlzLl9tYXhWYWx1ZSwgb3B0aW9uc1tpXS52YWx1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRUaWNrcyhkYXRhSXRlbXM6IE9wdGlvbltdKSB7XG4gICAgZm9yIChsZXQgZW50cnkgb2YgZGF0YUl0ZW1zKSB7XG4gICAgICBsZXQgdGlja0VsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCBTdHJpbmcoZW50cnkudmFsdWUpKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVElDSylcblxuICAgICAgbGV0IHRpY2tMYWJlbCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVElDS19MQUJFTClcbiAgICAgICAgLnNldEh0bWwoU3RyaW5nKGVudHJ5LmxhYmVsKSlcblxuICAgICAgdGlja0VsZW1lbnQuYXBwZW5kQ2hpbGQodGlja0xhYmVsKVxuICAgICAgdGhpcy5fdGlja3NXcmFwcGVyLmFwcGVuZENoaWxkKHRpY2tFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNFdmVudE9uTGFiZWwoZXZlbnQ6IEV2ZW50KSB7XG4gICAgcmV0dXJuIChldmVudC50YXJnZXQgYXMgRWxlbWVudCkuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX1RJQ0tfTEFCRUwpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZURvd24oZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRFJBR0dJTkcpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX21vdmVIYW5kbGVyKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuXG4gICAgLy8gSWdub3JlIGNsaWNrcyBkaXJlY3RseSBvbiB0aGUgdGh1bWJcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQgJiYgIXRoaXMuX2lzRXZlbnRPbkxhYmVsKGV2ZW50KSkge1xuICAgICAgbGV0IHBvcyA9IHRoaXMuX2dldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQpXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3MsIHRydWUsIGZhbHNlLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgdGhpcy5fdW5mb2N1cygpXG5cbiAgICBpZiAoIXRoaXMuX2lzRXZlbnRPbkxhYmVsKGV2ZW50KSkge1xuICAgICAgbGV0IHBvcyA9IHRoaXMuX2dldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQpXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3MsIHRydWUsIGZhbHNlLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUVuZChldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19EUkFHR0lORylcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fZW5kSGFuZGxlcilcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fbW92ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fbW92ZUhhbmRsZXIpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG5cbiAgICBsZXQgcG9zID0gdGhpcy5fZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudClcbiAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3MsIHRydWUsIHRydWUsIHRydWUpXG4gICAgdGhpcy5faGFuZGxlQmx1cigpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYmx1cigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc1VwID0ga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19VUCB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1JJR0hUXG4gICAgICB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX1BBR0VfVVBcblxuICAgIGNvbnN0IGlzRG93biA9IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTiB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX0xFRlRcbiAgICAgIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfUEFHRV9ET1dOXG5cbiAgICBpZiAoaXNVcCB8fCBpc0Rvd24pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgbGV0IGRpcmVjdGlvbiA9IGlzRG93biA/IC0xIDogMVxuXG4gICAgICAvLyBtYWtlIGEgbGFyZ2VyIHN0ZXAgaWYgaXRzIHRoZSB2ZXJ0aWNhbCBhcnJvdyBvciBwYWdlIGtleXNcbiAgICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTiB8fFxuICAgICAgICBrZXljb2RlID09PSBJbnB1dHMuS0VZX1BBR0VfVVAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9QQUdFX0RPV04pIHtcbiAgICAgICAgZGlyZWN0aW9uICo9IDEwXG4gICAgICB9XG5cbiAgICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlXG4gICAgICBpZiAodGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuX2dldE5leHRWYWx1ZSh2YWwsIGRpcmVjdGlvbilcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbGV0IHN0ZXA6IHN0cmluZyB8IG51bWJlciA9IHRoaXMuZWxlbWVudC5zdGVwXG4gICAgICAgIGlmICghc3RlcCB8fCBzdGVwID09PSBcImFueVwiKSB7XG4gICAgICAgICAgc3RlcCA9IFwiMC4xXCJcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3VmFsID0gdmFsICsgKHBhcnNlRmxvYXQoc3RlcCkgKiBkaXJlY3Rpb24pXG4gICAgICAgIHZhbCA9IG5ld1ZhbFxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRWYWx1ZSh2YWwsIHRydWUsIHRydWUpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQmx1cigpIHtcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5yZW1vdmVDbGFzcyhDTEFTU19BQ1RJVkUpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VuZm9jdXMoKSB7XG4gICAgaWYgKChkb2N1bWVudCBhcyBhbnkpLnNlbGVjdGlvbikge1xuICAgICAgKGRvY3VtZW50IGFzIGFueSkuc2VsZWN0aW9uLmVtcHR5KClcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpIS5yZW1vdmVBbGxSYW5nZXMoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICBsZXQgcGFnZVhcbiAgICBpZiAoXCJwYWdlWFwiIGluIGV2ZW50KSB7XG4gICAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2VYID0gKGV2ZW50LnRvdWNoZXNbMF0gfHwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pLnBhZ2VYXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZ2VYIC0gdGhpcy5fdHJhY2tMZWZ0UG9zaXRpb24gKyB0aGlzLl9ncmFiUG9zaXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW5kIHVwZGF0ZXMgdGhlIHBvc2l0aW9uIGFuZCBzZXRzIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9uIHRoZSBzbGlkZXIuXG4gICAqIEBwYXJhbSB7cG9zaXRpb259IHRoZSBuZXcgcG9zaXRpb24gdG8gc2V0LlxuICAgKiBAcGFyYW0ge3VwZGF0ZVZhbHVlfSB0cnVlIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgdXBkYXRlZCBhcyB3ZWxsOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwYXJhbSB7c25hcH0gdHJ1ZSBpZiBzbmFwcGluZyBzaG91bGQgYmUgdXNlZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcGFyYW0ge2FuaW1hdGV9IHRydWUgaWYgdGhlIFVJIHVwZGF0ZSBzaG91bGQgYmUgYW5pbWF0ZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfc2V0UG9zaXRpb24oXG4gICAgcG9zaXRpb246IG51bWJlcixcbiAgICB1cGRhdGVWYWx1ZSA9IHRydWUsXG4gICAgc25hcCA9IGZhbHNlLFxuICAgIGFuaW1hdGUgPSB0cnVlXG4gICkge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID09PSBudWxsIHx8IE51bWJlci5pc05hTihwb3NpdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIGlzIG5vdCBhIG51bWJlclwiKVxuICAgIH1cblxuICAgIC8vIENsYW1wIHRvIG1pbiBhbmQgbWF4IHJhbmdlXG4gICAgbGV0IG5ld1BvcyA9IGNsYW1wKHBvc2l0aW9uLCB0aGlzLl90cmFja1Bvc2l0aW9uTWluLCB0aGlzLl90cmFja1Bvc2l0aW9uTWF4KVxuICAgIGlmICh1cGRhdGVWYWx1ZSkge1xuICAgICAgbGV0IHZhbHVlID0gKHRoaXMuX3RyYWNrVmFsdWVUb3RhbCAvIHRoaXMuX3RyYWNrV2lkdGgpICogbmV3UG9zICsgdGhpcy5fbWluVmFsdWVcblxuICAgICAgaWYgKHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSAmJiBzbmFwKSB7XG4gICAgICAgIGxldCBzbmFwUG9zID0gdGhpcy5fZ2V0U25hcFBvc2l0aW9uKG5ld1BvcylcbiAgICAgICAgbmV3UG9zID0gc25hcFBvcy5wb3NpdGlvblxuICAgICAgICB2YWx1ZSA9IHNuYXBQb3MudmFsdWVcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LnN0ZXAgJiYgdGhpcy5lbGVtZW50LnN0ZXAgIT09IFwiYW55XCIpIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnN0ZXApXG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIHN0ZXApICogc3RlcFxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRWYWx1ZSh2YWx1ZSwgZmFsc2UsIGZhbHNlKVxuICAgIH1cblxuICAgIGlmIChhbmltYXRlICYmIHVwZGF0ZVZhbHVlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUaWNrU3RhdGUoKVxuICAgIH1cblxuICAgIGlmIChhbmltYXRlKSB7XG4gICAgICBhbmltZSh7XG4gICAgICAgIHRhcmdldHM6IHRoaXMuX3JhbmdlVGh1bWIuZWxlbWVudCxcbiAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgbGVmdDogbmV3UG9zLFxuICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIlxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvZ3Jlc3MpIHtcbiAgICAgICAgYW5pbWUoe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuX3JhbmdlUHJvZ3Jlc3MuZWxlbWVudCxcbiAgICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICAgIHdpZHRoOiBuZXdQb3MsXG4gICAgICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmFuZ2VUaHVtYi5lbGVtZW50LnN0eWxlLmxlZnQgPSBuZXdQb3MgKyBcInB4XCJcblxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fcmFuZ2VQcm9ncmVzcy5lbGVtZW50LnN0eWxlLndpZHRoID0gbmV3UG9zICsgXCJweFwiXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNuYXAgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7dmFsdWV9IHRoZSB0YXJnZXQgdmFsdWUuXG4gICAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzbmFwIHBvc2l0aW9uIGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0U25hcFZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkcmVuXG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcblxuICAgICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaV0pXG4gICAgICBsZXQgY3VycmVudFZhbHVlID0gcGFyc2VGbG9hdChjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcbiAgICAgIGxldCBjdXJyZW50V2lkdGggPSBjdXJyZW50RWxlbWVudC5lbGVtZW50LmNsaWVudFdpZHRoXG5cbiAgICAgIGxldCBuZXh0RWxlbWVudFxuICAgICAgbGV0IG5leHRWYWx1ZSA9IE51bWJlci5NQVhfVkFMVUVcblxuICAgICAgaWYgKGkgPCB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaSArIDFdKVxuICAgICAgICBuZXh0VmFsdWUgPSBwYXJzZUZsb2F0KG5leHRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikhKVxuICAgICAgfVxuXG4gICAgICAvLyBsZWZ0IG1vc3QgZWxlbWVudFxuICAgICAgaWYgKGkgPT09IDAgJiYgdmFsdWUgPD0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogTUFSR0lOX1RJQ0sgLSB0aGlzLl9ncmFiUG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByaWdodCBtb3N0IGVsZW1lbnRcbiAgICAgIGlmICghbmV4dEVsZW1lbnQgJiYgdmFsdWUgPj0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uICsgKGN1cnJlbnRXaWR0aCAtIE1BUkdJTl9USUNLKSAtIHRoaXMuX2dyYWJQb3NpdGlvbiAtIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPj0gY3VycmVudFZhbHVlICYmIHZhbHVlIDwgbmV4dFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uICsgKDAuNSAqIGN1cnJlbnRXaWR0aCkgLSB0aGlzLl9ncmFiUG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50UG9zaXRpb24gKz0gY3VycmVudFdpZHRoXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBzbmFwIHZhbHVlXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc25hcCBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtwb3NpdGlvbn0gdGhlIHRhcmdldCBwb3NpdGlvbi5cbiAgICogQHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNuYXAgcG9zaXRpb24gYW5kIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9nZXRTbmFwUG9zaXRpb24ocG9zaXRpb24/OiBudW1iZXIgfCBudWxsKSB7XG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBvc2l0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9zaXRpb24gaXMgbm90IGEgbnVtYmVyXCIpXG4gICAgfVxuXG4gICAgY29uc3QgdGlja3MgPSB0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZHJlblxuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIGxldCBjdXJyZW50RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRpY2tzW2ldKVxuICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IHBhcnNlRmxvYXQoY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSEpXG4gICAgICBsZXQgY3VycmVudFdpZHRoID0gY3VycmVudEVsZW1lbnQuZWxlbWVudC5jbGllbnRXaWR0aFxuXG4gICAgICBsZXQgbmV4dEVsZW1lbnRcblxuICAgICAgaWYgKGkgPCB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaSArIDFdKVxuICAgICAgfVxuXG4gICAgICAvLyBsZWZ0IG1vc3QgZWxlbWVudFxuICAgICAgaWYgKGkgPT09IDAgJiYgcG9zaXRpb24gPD0gY3VycmVudFBvc2l0aW9uICsgY3VycmVudFdpZHRoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogTUFSR0lOX1RJQ0sgLSB0aGlzLl9ncmFiUG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByaWdodCBtb3N0IGVsZW1lbnRcbiAgICAgIGlmICghbmV4dEVsZW1lbnQgJiYgcG9zaXRpb24gPj0gY3VycmVudFBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uICsgKGN1cnJlbnRXaWR0aCAtIE1BUkdJTl9USUNLKSAtIHRoaXMuX2dyYWJQb3NpdGlvbiAtIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb24gPj0gY3VycmVudFBvc2l0aW9uICYmIHBvc2l0aW9uIDwgKGN1cnJlbnRQb3NpdGlvbiArIGN1cnJlbnRXaWR0aCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50UG9zaXRpb24gKyAoMC41ICogY3VycmVudFdpZHRoKSAtIHRoaXMuX2dyYWJQb3NpdGlvblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSBjdXJyZW50V2lkdGhcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHNuYXAgcG9zaXRpb25cIilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24gd2l0aCByZWdhcmRzIHRvIHNuYXBwaW5nLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSBUaGUgY3VycmVudCB2YWx1ZS5cbiAgICogQHBhcmFtIHtkaXJlY3Rpb259IFRoZSBkaXJlY3Rpb24gKHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIpLlxuICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0TmV4dFZhbHVlKHZhbHVlOiBudW1iZXIsIGRpcmVjdGlvbjogbnVtYmVyKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZHJlblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpXSlcbiAgICAgIGxldCBjdXJyZW50VmFsID0gcGFyc2VGbG9hdChjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcblxuICAgICAgaWYgKHZhbHVlID09PSBjdXJyZW50VmFsKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGNsYW1wKGkgKyBkaXJlY3Rpb24sIDAsIHRpY2tzLmxlbmd0aCAtIDEpXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh0aWNrc1tpbmRleF0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZVRpY2tTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgYWN0aXZlVGljayA9IHRoaXMuX3RpY2tzV3JhcHBlci5maW5kKGAuJHtDTEFTU19USUNLX0FDVElWRX1gKVxuICAgICAgaWYgKGFjdGl2ZVRpY2spIHtcbiAgICAgICAgYWN0aXZlVGljay5yZW1vdmVDbGFzcyhDTEFTU19USUNLX0FDVElWRSlcbiAgICAgIH1cbiAgICAgIGxldCBuZXdBY3RpdmVUaWNrID0gdGhpcy5fdGlja3NXcmFwcGVyLmZpbmQoYC4ke0NMQVNTX1RJQ0t9W2RhdGEtdmFsdWU9JyR7dGhpcy52YWx1ZX0nXWApXG4gICAgICBpZiAobmV3QWN0aXZlVGljaykge1xuICAgICAgICBuZXdBY3RpdmVUaWNrLmFkZENsYXNzKENMQVNTX1RJQ0tfQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRqdXN0VGlja0xhYmVsUG9zaXRpb24oXG4gICAgdGlja0l0ZW06IEVsZW1lbnQsXG4gICAgbGVmdDogYm9vbGVhblxuICApIHtcbiAgICBjb25zdCBsYWJlbCA9IG5ldyBEb21FbGVtZW50KHRpY2tJdGVtLnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX1RJQ0tfTEFCRUx9YCkhKVxuXG4gICAgbGV0IGR1bW15RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1RJQ0tfTEFCRUwpXG4gICAgICAuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ2aXNpYmlsaXR5OiBoaWRkZW47IGRpc3BsYXk6IGlubGluZS1ibG9jaztcIilcbiAgICAgIC5zZXRIdG1sKGxhYmVsLmlubmVyVGV4dClcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGR1bW15RWxlbWVudClcblxuICAgIGxldCB3aWR0aCA9IGR1bW15RWxlbWVudC5lbGVtZW50LmNsaWVudFdpZHRoIC8gMlxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLnJlbW92ZUNoaWxkKGR1bW15RWxlbWVudClcblxuICAgIGNvbnN0IGZsb2F0UG9zaXRpb24gPSBsZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCJcblxuICAgIGlmICh3aWR0aCA8IE1BUkdJTl9USUNLKSB7XG4gICAgICAvLyBjZW50ZXIgc21hbGwgaXRlbXMgb24gdGhlIHRpY2tcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGAke2Zsb2F0UG9zaXRpb259OiAke01BUkdJTl9USUNLIC0gTWF0aC5mbG9vcih3aWR0aCl9cHg7IHRleHQtYWxpZ246ICR7ZmxvYXRQb3NpdGlvbn07YClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Zvcm1hdE91dHB1dCh2YWx1ZTogbnVtYmVyLCBzaG9ydDogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLl9mb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZXIodmFsdWUsIHNob3J0KVxuICAgIH1cblxuICAgIGNvbnN0IHN0ciA9IHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZCgyKSlcbiAgICByZXR1cm4gc3RyLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW5kIHVwZGF0ZXMgdGhlIHJhbmdlIHZhbHVlLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSB0aGUgbmV3IHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHt1cGRhdGV9IHRydWUgaWYgdGhlIFVJIHNob3VsZCBiZSB1cGRhdGVkOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwYXJhbSB7YW5pbWF0ZX0gdHJ1ZSBpZiB0aGUgVUkgdXBkYXRlIHNob3VsZCBiZSBhbmltYXRlZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZXRWYWx1ZShcbiAgICB2YWx1ZTogbnVtYmVyLFxuICAgIHVwZGF0ZSA9IHRydWUsXG4gICAgYW5pbWF0ZSA9IGZhbHNlXG4gICkge1xuICAgIGxldCB2YWwgPSBjbGFtcCh2YWx1ZSwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX21heFZhbHVlKVxuICAgIGxldCBwb3NpdGlvblxuXG4gICAgaWYgKHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3Qgc25hcFZhbHVlID0gdGhpcy5fZ2V0U25hcFZhbHVlKHZhbClcbiAgICAgIHBvc2l0aW9uID0gc25hcFZhbHVlLnBvc2l0aW9uXG4gICAgICB2YWwgPSBzbmFwVmFsdWUudmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zaXRpb24gPSAodGhpcy5fdHJhY2tXaWR0aCAvIHRoaXMuX3RyYWNrVmFsdWVUb3RhbCkgKiAodmFsdWUgLSB0aGlzLl9taW5WYWx1ZSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgY2FsY3VsYXRpb24gZmFpbGVkLCBmYWxsIGJhY2sgdG8gdGhlIGZpcnN0IHRpY2sgcG9zaXRpb24gYW5kIGRpc2FibGUgdGhlIGNvbXBvbmVudFxuICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5fZ2V0U25hcFBvc2l0aW9uKHZhbCkucG9zaXRpb25cbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnZhbHVlID0gU3RyaW5nKHZhbClcblxuICAgIGlmICh0aGlzLl90aHVtYlZhbHVlKSB7XG4gICAgICB0aGlzLl90aHVtYlZhbHVlLnNldEh0bWwodGhpcy5fZm9ybWF0T3V0cHV0KHZhbCwgdHJ1ZSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX291dHB1dExhYmVsKSB7XG4gICAgICB0aGlzLl9vdXRwdXRMYWJlbC5zZXRIdG1sKHRoaXMuX2Zvcm1hdE91dHB1dCh2YWwsIGZhbHNlKSlcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UsIGZhbHNlLCBhbmltYXRlKVxuICAgICAgdGhpcy5fdXBkYXRlVGlja1N0YXRlKClcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJpbnB1dFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSByYW5nZSBzbGlkZXIuXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX3NldFZhbHVlKHZhbHVlLCB0cnVlLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHRoZSBjb21wb25lbnQgdG8gcmUtbGF5b3V0IGl0c2VsZi5cbiAgICovXG4gIHB1YmxpYyBsYXlvdXQoKSB7XG4gICAgdGhpcy5fZ3JhYlBvc2l0aW9uID0gTWF0aC5yb3VuZCh0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQub2Zmc2V0V2lkdGggLyAyKVxuICAgIGNvbnN0IHRpY2tJdGVtcyA9IHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVElDS31gKVxuICAgIGNvbnN0IHRpY2tzT2Zmc2V0ID0gdGlja0l0ZW1zICYmIHRpY2tJdGVtcy5sZW5ndGggPiAwID8gKDIgKiBNQVJHSU5fVElDSykgOiBNQVJHSU5fVElDS1xuXG4gICAgdGhpcy5fdHJhY2tXaWR0aCA9IHRoaXMuX3JhbmdlVHJhY2suZWxlbWVudC5vZmZzZXRXaWR0aCAtIHRpY2tzT2Zmc2V0XG5cbiAgICB0aGlzLl90cmFja1Bvc2l0aW9uTWluID0gMFxuICAgIHRoaXMuX3RyYWNrUG9zaXRpb25NYXggPSB0aGlzLl9yYW5nZVRyYWNrLmVsZW1lbnQuY2xpZW50V2lkdGggLSB0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQub2Zmc2V0V2lkdGggKyAxXG4gICAgdGhpcy5fdHJhY2tMZWZ0UG9zaXRpb24gPSB0aGlzLl9yYW5nZVRyYWNrLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIE1BUkdJTl9USUNLXG5cbiAgICBsZXQgaXRlbUNvdW50ID0gdGlja0l0ZW1zLmxlbmd0aCAtIDFcblxuICAgIHRoaXMuX2l0ZW1XaWR0aCA9IHRoaXMuX3RyYWNrV2lkdGggLyBpdGVtQ291bnRcbiAgICBjb25zdCBvdXRlckl0ZW1zV2lkdGggPSAodGhpcy5faXRlbVdpZHRoICogMC41KSArIE1BUkdJTl9USUNLXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpdGVtQ291bnQ7IGkrKykge1xuICAgICAgbGV0IHdpZHRoID0gdGhpcy5faXRlbVdpZHRoXG5cbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGl0ZW1Db3VudCkge1xuICAgICAgICB3aWR0aCA9IG91dGVySXRlbXNXaWR0aFxuICAgICAgfVxuXG4gICAgICBsZXQgaXRlbSA9IG5ldyBEb21FbGVtZW50KHRpY2tJdGVtc1tpXSlcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHdpZHRoOiAke01hdGguZmxvb3Iod2lkdGgpfXB4O2ApXG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGZpcnN0IGFuZCBsYXN0IGxhYmVsIHBvc2l0aW9uc1xuICAgIGlmICh0aWNrSXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5fYWRqdXN0VGlja0xhYmVsUG9zaXRpb24odGlja0l0ZW1zWzBdLCB0cnVlKVxuICAgICAgdGhpcy5fYWRqdXN0VGlja0xhYmVsUG9zaXRpb24odGlja0l0ZW1zW3RpY2tJdGVtcy5sZW5ndGggLSAxXSwgZmFsc2UpXG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSB2YWx1ZVxuICAgIHRoaXMuX3NldFZhbHVlKHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnZhbHVlKSwgdHJ1ZSwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudHMgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fZG93bkhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX21vdmVIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9lbmRIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9mb2N1c0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2JsdXJIYW5kbGVyID0gbnVsbDtcblxuICAgICh0aGlzIGFzIGFueSkuZWxlbWVudCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fcmFuZ2VDb250YWluZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3dyYXBwZXJFbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBkZXN0cm95KCkgaW5zdGVhZC5cbiAgICogQHRvZG8gcmVtb3ZlIGluIHZlcnNpb24gMi4wLjBcbiAgICovXG4gIHB1YmxpYyBkZXN0b3koKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGVuYWJsZWQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZW5hYmxlKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0RJU0FCTEVEKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2Rvd25IYW5kbGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fZG93bkhhbmRsZXIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0W3R5cGU9J3JhbmdlJ11cIiwgKGUpID0+IHtcbiAgICBuZXcgUmFuZ2UoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFuZ2VcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0LCBmaW5kLCByZW1vdmUsIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uLCBzY3JvbGxJbnRvVmlldyB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX1BMQUNFSE9MREVSID0gXCJzZWxlY3RfX3BsYWNlaG9sZGVyXCJcbmNvbnN0IENMQVNTX1RIVU1CID0gXCJzZWxlY3RfX3RodW1iXCJcbmNvbnN0IENMQVNTX0JVVFRPTiA9IFwic2VsZWN0X19idXR0b25cIlxuY29uc3QgQ0xBU1NfRFJPUERPV04gPSBcInNlbGVjdF9fZHJvcGRvd25cIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJzZWxlY3QtLW9wZW5cIlxuY29uc3QgQ0xBU1NfQ0xPU0VEID0gXCJzZWxlY3QtLWNsb3NlZFwiXG5jb25zdCBDTEFTU19ESVNBQkxFRCA9IFwic2VsZWN0LS1kaXNhYmxlZFwiXG5jb25zdCBDTEFTU19GSUxURVJBQkxFID0gXCJzZWxlY3QtLWZpbHRlcmFibGVcIlxuXG5jb25zdCBDTEFTU19JVEVNID0gXCJkcm9wZG93bi1pdGVtXCJcbmNvbnN0IENMQVNTX0lURU1fU0VMRUNURUQgPSBcImRyb3Bkb3duLWl0ZW0tLXNlbGVjdGVkXCJcbmNvbnN0IENMQVNTX0lURU1fRk9DVVNFRCA9IFwiZHJvcGRvd24taXRlbS0tZm9jdXNlZFwiXG5jb25zdCBDTEFTU19JVEVNX0RJU0FCTEVEID0gXCJkcm9wZG93bi1pdGVtLS1kaXNhYmxlZFwiXG5cbmNvbnN0IENMQVNTX0dST1VQX0lURU0gPSBcImRyb3Bkb3duLWdyb3VwXCJcbmNvbnN0IENMQVNTX0dST1VQX0hFQURFUiA9IFwiZHJvcGRvd24tZ3JvdXBfX2l0ZW1cIlxuXG5jb25zdCBRVUVSWV9NRVNTQUdFID0gXCIubWVzc2FnZVwiXG5cbmNvbnN0IFRJTUVPVVRfQ0xPU0UgPSAxNTBcbmNvbnN0IFRJTUVPVVRfQkxVUiA9IDQwMFxuXG4vKipcbiAqIFRoZSBzZWxlY3QgY29tcG9uZW50IEFQSS5cbiAqL1xuY2xhc3MgU2VsZWN0IGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MU2VsZWN0RWxlbWVudD4ge1xuICBwcml2YXRlIF9vcGVuQnlGb2N1czogYm9vbGVhblxuICBwcml2YXRlIF9tdWx0aXNlbGVjdGlvbjogYm9vbGVhblxuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9oYW5kbGVEcm9wZG93bkNsaWNrOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9mb2N1c0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9ibHVySGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZmlsdGVyS2V5ZG93bkhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9maWx0ZXJLZXl1cEhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9maWx0ZXJGb2N1c0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX3dyYXBwZXJFbGVtZW50ITogRG9tRWxlbWVudFxuICBwcml2YXRlIF9kcm9wZG93bkVsZW1lbnQhOiBEb21FbGVtZW50PEhUTUxFbGVtZW50PlxuXG4gIHByaXZhdGUgX3NlbGVjdEJ1dHRvbkVsZW1lbnQhOiBEb21FbGVtZW50XG4gIHByaXZhdGUgX3RodW1iRWxlbWVudCE6IERvbUVsZW1lbnRcblxuICBwcml2YXRlIF9wbGFjZWhvbGRlck9wdGlvbj86IEhUTUxPcHRpb25FbGVtZW50XG4gIHByaXZhdGUgX3BsYWNlaG9sZGVyRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSBfcGxhY2Vob2xkZXJUZXh0ITogc3RyaW5nXG5cbiAgcHJpdmF0ZSBfbGFzdEhhbmRsZWRFdmVudD86IEV2ZW50XG4gIHByaXZhdGUgX2xhc3RTZWxlY3RlZE9wdGlvbj86IEhUTUxPcHRpb25FbGVtZW50XG5cbiAgLy8gTWluaW11bSBmaWx0ZXIgbGVuZ3RoXG4gIHByaXZhdGUgX21pbkZpbHRlckxlbmd0aCA9IDJcblxuICAvLyBUaGUga2V5d29yZCB0aGUgU2VsZWN0IGlzIGN1cnJlbnRseSBmaWx0ZXJlZCBieVxuICBwcml2YXRlIF9hY3RpdmVGaWx0ZXI/OiBzdHJpbmdcblxuICAvLyBUaGUgb3B0aW9ucyB0aGUgU2VsZWN0IHdhcyBpbml0aWFsbHkgY3JlYXRlZCB1cG9uXG4gIC8vIFRoZXNlIHdpbGwgYmUgdXNlZCBhcyBhIGJhc2lzIGZvciBmaWx0ZXJpbmdcbiAgcHJpdmF0ZSBfaW5pdGlhbE9wdGlvbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmVsZW1lbnQuY2hpbGRyZW4pXG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSBmYWxzZVxuXG4gICAgLy8gQ2hlY2sgZm9yIG11bHRpLXNlbGVjdGlvblxuICAgIHRoaXMuX211bHRpc2VsZWN0aW9uID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpID09PSB0cnVlXG5cbiAgICAvLyBTZXR1cCBldmVudCBjb250ZXh0XG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2sgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVGb2N1cy5iaW5kKHRoaXMpXG4gICAgdGhpcy5fYmx1ckhhbmRsZXIgPSB0aGlzLl9oYW5kbGVCbHVyLmJpbmQodGhpcylcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZmlsdGVyS2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVGaWx0ZXJLZXlkb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9maWx0ZXJLZXl1cEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVGaWx0ZXJLZXl1cC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZmlsdGVyRm9jdXNIYW5kbGVyID0gdGhpcy5faGFuZGxlRmlsdGVyRm9jdXMuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHNlbGVjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGluc3BlY3RzIHRoZSBzZWxlY3QgZGVmaW5pdGlvbiBhbmQgaXRzIG9wdGlvbnMgYW5kXG4gICAqIGdlbmVyYXRlcyBuZXcgc3R5bGFibGUgRE9NIGVsZW1lbnRzIGFyb3VuZCB0aGUgb3JpZ2luYWwgc2VsZWN0LWVsZW1lbnRcbiAgICogZGVmaW5pdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRPcHRpb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIm9wdGlvbltzZWxlY3RlZF1cIikgYXMgSFRNTE9wdGlvbkVsZW1lbnRcbiAgICBjb25zdCBmaXJzdE9wdGlvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwib3B0aW9uXCIpIGFzIEhUTUxPcHRpb25FbGVtZW50XG5cbiAgICAvLyBQZXIgZGVmYXVsdCwgc2V0IHRoZSBsYXN0IHNlbGVjdGVkIG9wdGlvbiB0byBlaXRoZXIgdGhlIG9wdGlvbiB3aXRoIGEgXCJzZWxlY3RlZFwiIGF0dHJpYnV0ZSxcbiAgICAvLyBvciwgaWYgbm90IGZvdW5kLCB0byB0aGUgZmlyc3QgYXZhaWxhYmxlIG9wdGlvblxuICAgIHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiA9IHNlbGVjdGVkT3B0aW9uIHx8IGZpcnN0T3B0aW9uXG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50ISlcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19DTE9TRUQpXG5cbiAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzKSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hZGRDbGFzcyhjbHMpXG4gICAgfVxuXG4gICAgdGhpcy5fZHJvcGRvd25FbGVtZW50ID0gbmV3IERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfRFJPUERPV04pXG5cbiAgICBpZiAoaW50ZXJuZXRFeHBsb3Jlck9yRWRnZVZlcnNpb24oKSA+IDAgJiYgaW50ZXJuZXRFeHBsb3Jlck9yRWRnZVZlcnNpb24oKSA8IDEyKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgSUUgYnJvd3NlcnMgMTEgYW5kIGVhcmxpZXIgd2hlcmUgZm9jdXNpbmdcbiAgICAgIC8vIGEgc2Nyb2xsYWJsZSBkcm9wZG93biBsaXN0IHdpbGwgY2xvc2UgdGhlIGRyb3Bkb3duIHByZW1hdHVyZWx5LlxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpXG4gICAgfVxuXG4gICAgdGhpcy5fc2V0dXBUYXJnZXQoKVxuICAgIHRoaXMuX3NldHVwUGxhY2Vob2xkZXIoKVxuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fZHJvcGRvd25FbGVtZW50KVxuXG4gICAgdGhpcy5fY3JlYXRlT3B0aW9ucyh0aGlzLmVsZW1lbnQpXG5cbiAgICB0aGlzLl91cGRhdGVTaXplKClcbiAgICB0aGlzLl91cGRhdGVNZXNzYWdlKClcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldHVwVGFyZ2V0KCkge1xuICAgIC8vIG1vdmUgdGhlIGlkIGZyb20gdGhlIHNlbGVjdCBlbGVtZW50IHRvIHRoZSB3cmFwcGVyXG4gICAgY29uc3QgaWQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIilcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpXG4gICAgfVxuXG4gICAgLy8gQXBwbHkgdGhlIHRhYiBpbmRleFxuICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpXG4gICAgaWYgKHRhYkluZGV4KSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCB0YWJJbmRleClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldHVwUGxhY2Vob2xkZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0JVVFRPTilcblxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudClcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RodW1iRWxlbWVudCkge1xuICAgICAgdGhpcy5fdGh1bWJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RIVU1CKVxuXG4gICAgICBsZXQgdGh1bWJJY29uID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKFwidGh1bWItaWNvblwiKVxuXG4gICAgICBsZXQgbG9hZGVyID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKFwibG9hZGVyLXNwaW5uZXJcIilcbiAgICAgICAgLmFkZENsYXNzKFwibG9hZGVyLXNwaW5uZXItLXNtYWxsXCIpXG5cbiAgICAgIHRoaXMuX3RodW1iRWxlbWVudC5hcHBlbmRDaGlsZChsb2FkZXIpXG4gICAgICB0aGlzLl90aHVtYkVsZW1lbnQuYXBwZW5kQ2hpbGQodGh1bWJJY29uKVxuICAgICAgdGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl90aHVtYkVsZW1lbnQpXG4gICAgfVxuXG4gICAgbGV0IHBsYWNlaG9sZGVyVGV4dCA9IFwiXCJcblxuICAgIHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25bc2VsZWN0ZWRdW2Rpc2FibGVkXVwiKSBhcyBIVE1MT3B0aW9uRWxlbWVudCB8fCB1bmRlZmluZWRcblxuICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlck9wdGlvbikge1xuICAgICAgcGxhY2Vob2xkZXJUZXh0ID0gRG9tLnRleHQodGhpcy5fcGxhY2Vob2xkZXJPcHRpb24pXG5cbiAgICAgIGlmICh0aGlzLl9tdWx0aXNlbGVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbi5zZWxlY3RlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNlbGVjdGVkT3B0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25bc2VsZWN0ZWRdOm5vdChbZGlzYWJsZWRdKVwiKVxuXG4gICAgaWYgKHNlbGVjdGVkT3B0aW9uKSB7XG4gICAgICBwbGFjZWhvbGRlclRleHQgPSBEb20udGV4dChzZWxlY3RlZE9wdGlvbilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgLy8gV2hlbiB0aGUgU2VsZWN0IGlzIGZpbHRlcmFibGUsIGNyZWF0ZSBhbiBcImlucHV0XCIgYXMgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQsIG90aGVyd2lzZSBhIFwic3BhblwiXG4gICAgICBpZiAodGhpcy5faXNGaWx0ZXJhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJpbnB1dFwiKVxuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIChlKSA9PiB0aGlzLl9oYW5kbGVGaWx0ZXJLZXl1cChlKSlcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB0aGlzLl9oYW5kbGVGaWx0ZXJLZXlkb3duKGUpKVxuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIChlKSA9PiB0aGlzLl9oYW5kbGVGaWx0ZXJGb2N1cyhlKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfUExBQ0VIT0xERVIpXG4gICAgICB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlclRleHQpXG4gICAgdGhpcy5fcGxhY2Vob2xkZXJUZXh0ID0gcGxhY2Vob2xkZXJUZXh0XG5cbiAgICBpZiAoc2VsZWN0ZWRPcHRpb24gJiYgc2VsZWN0ZWRPcHRpb24gIT09IHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uKSB7XG4gICAgICB0aGlzLl91cGRhdGVQbGFjZWhvbGRlcih0cnVlKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlTWVzc2FnZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlTm9kZSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9NRVNTQUdFKVxuICAgIGlmIChtZXNzYWdlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3IERvbUVsZW1lbnQobWVzc2FnZU5vZGUpKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzT3B0R3JvdXAoZWxlbWVudDogRWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTE9wdEdyb3VwRWxlbWVudCB7XG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVEdST1VQXCJcbiAgfVxuXG4gIHByaXZhdGUgX2lzT3B0aW9uKGVsZW1lbnQ6IEVsZW1lbnQpOiBlbGVtZW50IGlzIEhUTUxPcHRpb25FbGVtZW50IHtcbiAgICByZXR1cm4gZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiT1BUSU9OXCJcbiAgfVxuXG4gIHByb3RlY3RlZCBfY3JlYXRlT3B0aW9ucyhlbGVtZW50OiBIVE1MU2VsZWN0RWxlbWVudCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZHJlbltpXVxuXG4gICAgICBpZiAodGhpcy5faXNPcHRHcm91cChjaGlsZCkpIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kR3JvdXAoY2hpbGQgYXMgSFRNTE9wdEdyb3VwRWxlbWVudClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzT3B0aW9uKGNoaWxkKSkge1xuICAgICAgICBsZXQgb3B0aW9uID0gdGhpcy5fY3JlYXRlT3B0aW9uKGNoaWxkIGFzIEhUTUxPcHRpb25FbGVtZW50KVxuXG4gICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuYXBwZW5kQ2hpbGQob3B0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jcmVhdGVPcHRpb24ob3B0aW9uOiBIVE1MT3B0aW9uRWxlbWVudCkge1xuICAgIGxldCBodG1sID0gb3B0aW9uLmlubmVySFRNTFxuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZUZpbHRlcikge1xuICAgICAgY29uc3Qgc2FuaXRpemVkQWN0aXZlRmlsdGVyID0gdGhpcy5fYWN0aXZlRmlsdGVyLnJlcGxhY2UoL1stXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIilcbiAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UobmV3IFJlZ0V4cChgKCR7c2FuaXRpemVkQWN0aXZlRmlsdGVyfSlgLCBcImdpXCIpLCBcIjxzdHJvbmc+JDE8L3N0cm9uZz5cIilcbiAgICB9XG5cbiAgICBsZXQgb3B0ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19JVEVNKVxuICAgICAgLnNldEh0bWwoaHRtbClcblxuICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgIG9wdC5hZGRDbGFzcyhDTEFTU19JVEVNX1NFTEVDVEVEKVxuICAgIH1cblxuICAgIGlmIChvcHRpb24uZGlzYWJsZWQpIHtcbiAgICAgIG9wdC5hZGRDbGFzcyhDTEFTU19JVEVNX0RJU0FCTEVEKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5faXNQbGFjZWhvbGRlcihvcHRpb24pKSB7XG4gICAgICBvcHQuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCBvcHRpb24udmFsdWUpXG4gICAgICByZXR1cm4gb3B0XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcHJvdGVjdGVkIF9hcHBlbmRHcm91cChvcHRncm91cDogSFRNTE9wdEdyb3VwRWxlbWVudCkge1xuICAgIGxldCBsYWJlbCA9IG9wdGdyb3VwLmdldEF0dHJpYnV0ZShcImxhYmVsXCIpIVxuXG4gICAgbGV0IGdyb3VwID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19HUk9VUF9JVEVNKVxuXG4gICAgbGV0IGdyb3VwSGVhZGVyID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19HUk9VUF9IRUFERVIpXG4gICAgICAuc2V0SHRtbChsYWJlbClcblxuICAgIGdyb3VwLmFwcGVuZENoaWxkKGdyb3VwSGVhZGVyKVxuXG4gICAgbGV0IG9wdGlvbnMgPSBvcHRncm91cC5xdWVyeVNlbGVjdG9yQWxsKFwib3B0aW9uXCIpXG4gICAgZm9yIChsZXQgZW50cnkgb2Ygb3B0aW9ucykge1xuICAgICAgbGV0IG9wdGlvbiA9IHRoaXMuX2NyZWF0ZU9wdGlvbihlbnRyeSlcbiAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQob3B0aW9uKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5hcHBlbmRDaGlsZChncm91cClcbiAgICByZXR1cm4gZ3JvdXBcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlU2l6ZSgpIHtcbiAgICAvLyBOb3RlOiBNaXJyb3JpbmcgdGhlIERPTSBhbmQgbWVhc3VyaW5nIHRoZSBpdGVtcyB1c2luZyB0aGVpciBjbGllbnRXaWR0aCB3YXMgdmVyeVxuICAgIC8vIHVucmVsaWFibGUsIHRoZXJlZm9yZSBtZWFzdXJpbmcgd2FzIHN3aXRjaGVkIHRvIHRoZSBuZXcgSFRNTDUgbWVhc3VyZVRleHQgbWV0aG9kXG4gICAgLy8gbWFyZ2lucyBhbmQgcGFkZGluZ3MgYXJyb3VuZCB0aGUgdGV4dCBhcmUgY29waWVkIGZyb20gdGhlIG9yaWdpbmFsIHBsYWNlaG9sZGVyIGl0ZW1zXG4gICAgLy8gZGltZW5zaW9uXG4gICAgY29uc3QgcGxhY2Vob2xkZXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5lbGVtZW50KVxuXG4gICAgbGV0IHBhZGRpbmdSaWdodCA9IHBhcnNlRmxvYXQocGxhY2Vob2xkZXJTdHlsZS5wYWRkaW5nUmlnaHQhKVxuICAgIGxldCBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQocGxhY2Vob2xkZXJTdHlsZS5wYWRkaW5nTGVmdCEpXG5cbiAgICBsZXQgZm9udCA9IHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5jc3MoXCJmb250XCIpXG4gICAgbGV0IHRleHRXaWR0aCA9IERvbS50ZXh0V2lkdGgodGhpcy5fcGxhY2Vob2xkZXJUZXh0LCBmb250KVxuICAgIGxldCBtYXhXaWR0aCA9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0ICsgdGV4dFdpZHRoXG5cbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfSVRFTX1gKVxuICAgIGZvciAobGV0IGVudHJ5IG9mIG9wdGlvbnMpIHtcbiAgICAgIGxldCB3aWR0aCA9IERvbS50ZXh0V2lkdGgoRG9tLnRleHQoZW50cnkpLCBmb250KSArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0XG5cbiAgICAgIGlmICh3aWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgIG1heFdpZHRoID0gd2lkdGhcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNCdXR0b25UYXJnZXQodGFyZ2V0OiBFdmVudFRhcmdldCkge1xuICAgIHJldHVybiAodGFyZ2V0ID09PSB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50IHx8XG4gICAgICB0YXJnZXQgPT09IHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5lbGVtZW50IHx8XG4gICAgICB0YXJnZXQgPT09IHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQuZWxlbWVudCB8fFxuICAgICAgdGFyZ2V0ID09PSB0aGlzLl90aHVtYkVsZW1lbnQuZWxlbWVudClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNEcm9wZG93blRhcmdldCh0YXJnZXQ6IEV2ZW50VGFyZ2V0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQgJiYgY3VycmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQgPT09IHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgVUkgaWYgdGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZCBhbmQgbWFrZXMgc3VyZSB0aGVcbiAgICogc2VsZWN0IGNvbnRyb2wgYW5kIHRoZSBnZW5lcmF0ZWQgbWFya3VwIGFyZSBzeW5jaHJvbml6ZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NlbGVjdGVkSXRlbUNoYW5nZWQoXG4gICAgbmV3SXRlbTogRWxlbWVudCxcbiAgICBhdXRvQ2xvc2UgPSB0cnVlLFxuICAgIG11bHRpc2VsZWN0ID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3Qgb2xkSXRlbXMgPSB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNX1NFTEVDVEVEfWApXG5cbiAgICBpZiAoIW5ld0l0ZW0pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jbG9zZSgpLCBUSU1FT1VUX0NMT1NFKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKERvbS5oYXNDbGFzcyhuZXdJdGVtLCBDTEFTU19JVEVNX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChvbGRJdGVtcy5sZW5ndGggPT09IDApICYmICFuZXdJdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNlbGVjdCB1bmRlZmluZWQgZWxlbWVudHNcIilcbiAgICB9XG5cbiAgICBsZXQgb2xkSXRlbSA9IG9sZEl0ZW1zWzBdXG5cbiAgICBpZiAobXVsdGlzZWxlY3QgPT09IHRydWUpIHtcbiAgICAgIG9sZEl0ZW0gPSBmaW5kKG9sZEl0ZW1zLCAoeCkgPT4geC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpID09PSBuZXdJdGVtLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikpIVxuICAgIH1cblxuICAgIGxldCBpc0Rlc2VsZWN0ID0gZmFsc2VcblxuICAgIGlmIChuZXdJdGVtICYmIG9sZEl0ZW0gJiYgb2xkSXRlbSA9PT0gbmV3SXRlbSkge1xuICAgICAgLy8gQ2xpY2sgb24gYSBwcmV2aW91c2x5IHNlbGVjdGVkIGVsZW1lbnQgLT4gZGVzZWxlY3RcbiAgICAgIGlzRGVzZWxlY3QgPSB0cnVlXG5cbiAgICAgIGlmICghdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24gJiYgIW11bHRpc2VsZWN0KSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHBsYWNlaG9sZGVyIG9wdGlvbiwgbm9uIG11bHRpc2VsZWN0IG9wdGlvbnMgY2Fubm90IGJlIGRlc2VsZWN0ZWRcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb25cbiAgICB9XG5cbiAgICBpZiAob2xkSXRlbSkge1xuICAgICAgLy8gUmVtb3ZlIHNlbGVjdGlvbiBvbiB0aGUgZWxlbWVudFxuICAgICAgbGV0IG9sZFZhbHVlID0gb2xkSXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgICBsZXQgb3B0RWxlbWVudCA9IGZpbmQodGhpcy5lbGVtZW50Lm9wdGlvbnMsICh4KSA9PiAheC5kaXNhYmxlZCAmJiB4LnZhbHVlID09PSBvbGRWYWx1ZSlcblxuICAgICAgaWYgKCFvcHRFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG9wdGlvbiB3aXRoIHZhbHVlICR7b2xkVmFsdWV9IGRvZXMgbm90IGV4aXN0YClcbiAgICAgIH1cblxuICAgICAgLy8gVW5zZXQgU2VsZWN0IHZhbHVlXG4gICAgICBvcHRFbGVtZW50LnNlbGVjdGVkID0gZmFsc2VcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhvbGRJdGVtLCBDTEFTU19JVEVNX1NFTEVDVEVEKVxuICAgIH1cblxuICAgIGlmICghaXNEZXNlbGVjdCkgeyAvLyBTZWxlY3QgYW4gb3B0aW9uXG4gICAgICAvLyBTZWxlY3QgYSBuZXcgaXRlbVxuICAgICAgbGV0IG5ld1ZhbHVlID0gbmV3SXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgICBsZXQgb3B0RWxlbWVudCA9IGZpbmQodGhpcy5lbGVtZW50Lm9wdGlvbnMsICh4KSA9PiAheC5kaXNhYmxlZCAmJiB4LnZhbHVlID09PSBuZXdWYWx1ZSlcblxuICAgICAgaWYgKCFvcHRFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG9wdGlvbiB3aXRoIHZhbHVlICR7bmV3VmFsdWV9IGRvZXMgbm90IGV4aXN0YClcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IFNlbGVjdCB2YWx1ZVxuICAgICAgb3B0RWxlbWVudC5zZWxlY3RlZCA9IHRydWVcbiAgICAgIERvbS5hZGRDbGFzcyhuZXdJdGVtLCBDTEFTU19JVEVNX1NFTEVDVEVEKVxuXG4gICAgICAvLyBQcmVzZXJ2ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiA9IG9wdEVsZW1lbnRcblxuICAgIH0gZWxzZSB7IC8vIERlc2VsZWN0IGFuIG9wdGlvblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiBmYWxsaW5nIGJhY2sgdG8gdGhlIHBsYWNlaG9sZGVyIChpZiBhbnkpXG4gICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJPcHRpb24pIHtcbiAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGVkT3B0aW9uID0gdGhpcy5fcGxhY2Vob2xkZXJPcHRpb25cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaGFzU2VsZWN0ZWRJdGVtcyA9IHRydWVcblxuICAgIGlmICh0aGlzLl9tdWx0aXNlbGVjdGlvbiA9PT0gZmFsc2UgJiYgaXNEZXNlbGVjdCkge1xuICAgICAgLy8gSGFuZGxlIG5vIHNlbGVjdGlvbiBmb3Igbm9uLW11bHRpc2VsZWN0IHN0YXRlc1xuICAgICAgdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24hLnNlbGVjdGVkID0gdHJ1ZVxuICAgICAgaGFzU2VsZWN0ZWRJdGVtcyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX211bHRpc2VsZWN0aW9uID09PSB0cnVlICYmIHRoaXMuX2dldFNlbGVjdGVkT3B0aW9ucygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaGFzU2VsZWN0ZWRJdGVtcyA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gUmVzZXQgdGhlIGZpbHRlciBpZiBmaWx0ZXJhYmxlXG4gICAgaWYgKHRoaXMuX2FjdGl2ZUZpbHRlcikge1xuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXIoKVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVBsYWNlaG9sZGVyKGhhc1NlbGVjdGVkSXRlbXMpXG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgY2hhbmdlZCBldmVudFxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKVxuXG4gICAgaWYgKGF1dG9DbG9zZSAmJiAhbXVsdGlzZWxlY3QpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgIH0sIFRJTUVPVVRfQ0xPU0UpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGVQbGFjZWhvbGRlcihoYXNTZWxlY3RlZEl0ZW1zOiBib29sZWFuKSB7XG4gICAgbGV0IHRleHQgPSB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbiA/IERvbS50ZXh0KHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uKSA6IFwiIFwiXG5cbiAgICBpZiAoaGFzU2VsZWN0ZWRJdGVtcyA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9nZXRTZWxlY3RlZE9wdGlvbnMoKVxuXG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRleHQgPSBcIlwiXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2Ygc2VsZWN0ZWRJdGVtcykge1xuICAgICAgICAgIHRleHQgKz0gYCR7RG9tLnRleHQoaXRlbSl9LCBgXG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHRleHQubGVuZ3RoIC0gMilcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zZXRQbGFjZWhvbGRlcih0ZXh0KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRTZWxlY3RlZE9wdGlvbnMoKSB7XG4gICAgbGV0IHNlbGVjdGVkT3B0aW9uczogSFRNTE9wdGlvbkVsZW1lbnRbXSA9IFtdXG4gICAgaWYgKHRoaXMuZWxlbWVudC5vcHRpb25zKSB7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwodGhpcy5lbGVtZW50Lm9wdGlvbnMsICgob3B0aW9uOiBIVE1MT3B0aW9uRWxlbWVudCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICYmICFvcHRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZE9wdGlvbnMucHVzaChvcHRpb24pXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRPcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgYWxsIG9mIHRoZSBpbml0aWFsbHkgc2V0IG9wdGlvbnMgKGFuZCBvcHRncm91cHMpIGFuZCByZXR1cm5zIHRoZW0gaW4gYSBuZXcgYXJyYXkuXG4gICAqIFRoaXMgc2VydmVzIGFzIHRoZSBiYXNpcyBmb3IgZmlsdGVyaW5nLiBJZiBhIGZpbHRlciBpcyBwcmVzZW50LCBpdCB3aWxsIGJlIHJlc3BlY3RlZC5cbiAgICovXG4gIHByaXZhdGUgZ2V0SW5pdGlhbE9wdGlvbnMoKTogRWxlbWVudFtdIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9hY3RpdmVGaWx0ZXIgfHwgXCJcIlxuICAgIGNvbnN0IGZpbHRlcmVkOiBFbGVtZW50W10gPSBbXVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gdGhpcy5faW5pdGlhbE9wdGlvbnNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdGlhbE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkOiBFbGVtZW50ID0gaW5pdGlhbE9wdGlvbnNbaV0gYXMgRWxlbWVudFxuXG4gICAgICBpZiAodGhpcy5faXNPcHRHcm91cChjaGlsZCkpIHsgLy8gaGFuZGxlIDxvcHRncm91cD5cbiAgICAgICAgY29uc3Qgb3B0R3JvdXBDbG9uZTogRWxlbWVudCA9IGNoaWxkLmNsb25lTm9kZShmYWxzZSkgYXMgRWxlbWVudFxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBvcHRpb25DbG9uZTogRWxlbWVudCA9IGNoaWxkLmNoaWxkcmVuW2pdLmNsb25lTm9kZSh0cnVlKSBhcyBFbGVtZW50XG5cbiAgICAgICAgICAvLyBBcHBlbmQgb24gbWF0Y2hcbiAgICAgICAgICBpZiAodGhpcy5fY29udGFpbnNXb3JkKG9wdGlvbkNsb25lLmlubmVySFRNTCwgZmlsdGVyKSkge1xuICAgICAgICAgICAgb3B0R3JvdXBDbG9uZS5hcHBlbmRDaGlsZChvcHRpb25DbG9uZSlcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1c2ggaWYgYW55IG1hdGNoZXMgZm91bmRcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgZmlsdGVyZWQucHVzaChvcHRHcm91cENsb25lKVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNPcHRpb24oY2hpbGQpKSB7IC8vIGhhbmRsZSA8b3B0aW9uPlxuICAgICAgICBjb25zdCBvcHRpb25DbG9uZTogRWxlbWVudCA9IGNoaWxkLmNsb25lTm9kZSh0cnVlKSBhcyBFbGVtZW50XG5cbiAgICAgICAgLy8gUHVzaCBvbiBtYXRjaFxuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNXb3JkKG9wdGlvbkNsb25lLmlubmVySFRNTCwgZmlsdGVyKSkge1xuICAgICAgICAgIGZpbHRlcmVkLnB1c2gob3B0aW9uQ2xvbmUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVyZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSB0ZXh0IGNvbnRhaW5zIGEgZ2l2ZW4ga2V5d29yZCwgZS5nLiBpbiBcImNhXCIgaW4gXCJDYXJcIlxuICAgKi9cbiAgcHJpdmF0ZSBfY29udGFpbnNXb3JkKHRleHQ6IHN0cmluZywga2V5d29yZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKGtleXdvcmQudG9Mb3dlckNhc2UoKSkgPiAtMVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLm9wZW4oKVxuICAgIHRoaXMuX29wZW5CeUZvY3VzID0gdHJ1ZVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9vcGVuQnlGb2N1cyA9IGZhbHNlXG4gICAgfSwgVElNRU9VVF9CTFVSKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVCbHVyKCkge1xuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5fbGFzdEhhbmRsZWRFdmVudCA9PT0gZXZlbnQpIHtcbiAgICAgIHRoaXMuX2xhc3RIYW5kbGVkRXZlbnQgPSB1bmRlZmluZWRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0J1dHRvblRhcmdldChldmVudC50YXJnZXQhKSAmJiB0aGlzLl9vcGVuQnlGb2N1cyA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGhhbmRsZSBoZWFkZXIgaXRlbSBjbGlja3MgYW5kIHRvZ2dsZSBkcm9wZG93blxuICAgICAgdGhpcy50b2dnbGUoKVxuICAgICAgaGFuZGxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBsZXQgbmV3SXRlbSA9IGV2ZW50LnRhcmdldCBhcyBFbGVtZW50XG5cbiAgICBpZiAoIWhhbmRsZWQgJiYgRG9tLmhhc0NsYXNzKG5ld0l0ZW0sIENMQVNTX0lURU0pKSB7XG4gICAgICAvLyBoYW5kbGUgY2xpY2tzIG9uIGRyb3Bkb3duIGl0ZW1zXG4gICAgICB0aGlzLl9zZWxlY3RlZEl0ZW1DaGFuZ2VkKG5ld0l0ZW0sIHRydWUsIHRoaXMuX211bHRpc2VsZWN0aW9uKVxuICAgICAgaGFuZGxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgdGhpcy5fbGFzdEhhbmRsZWRFdmVudCA9IGV2ZW50XG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzRHJvcGRvd25UYXJnZXQoZXZlbnQudGFyZ2V0ISkgfHwgdGhpcy5faXNCdXR0b25UYXJnZXQoZXZlbnQudGFyZ2V0ISkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9mb2N1c09wdGlvblN0YXJ0aW5nV2l0aChrZXljb2RlOiBudW1iZXIsIHN0YXJ0SW5kZXg6IG51bWJlciwgb3B0aW9uczogTm9kZUxpc3RPZjxIVE1MRWxlbWVudD4pIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tpbmRleF0pXG4gICAgICBsZXQgdmFsdWUgPSBpdGVtLmlubmVyVGV4dC50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmIChpbmRleCA+IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gMFxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChJbnB1dHMuZ2V0S2V5VmFsdWUoa2V5Y29kZSkpKSB7XG4gICAgICAgIGxldCBuZXdPcHRpb24gPSBuZXcgRG9tRWxlbWVudChvcHRpb25zW2luZGV4XSlcblxuICAgICAgICBpZiAoIW5ld09wdGlvbi5oYXNDbGFzcyhDTEFTU19JVEVNX0RJU0FCTEVEKSkge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3KG9wdGlvbnNbaW5kZXhdKVxuICAgICAgICAgIG5ld09wdGlvbi5hZGRDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG4gICAgICAgICAgcmV0dXJuIG5ld09wdGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogRXZlbnQpIHtcbiAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gZXZlbnQgYXMgS2V5Ym9hcmRFdmVudFxuICAgIGxldCBldnQgPSBrZXlib2FyZEV2ZW50IHx8IHdpbmRvdy5ldmVudFxuICAgIGxldCBrZXljb2RlID0ga2V5Ym9hcmRFdmVudC53aGljaCB8fCBrZXlib2FyZEV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfVxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTikge1xuICAgICAgLy8gVXAgYW5kIGRvd24gYXJyb3dzXG5cbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+XG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgbGV0IG5ld0luZGV4ID0gMFxuICAgICAgICBsZXQgb2xkT3B0aW9uXG5cbiAgICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZmluZChgLiR7Q0xBU1NfSVRFTV9GT0NVU0VEfWApXG4gICAgICAgIGxldCBzZWFyY2hGb3IgPSBmb2N1c2VkRWxlbWVudCA/IENMQVNTX0lURU1fRk9DVVNFRCA6IENMQVNTX0lURU1fU0VMRUNURURcblxuICAgICAgICBsZXQgbmV3RWxlbWVudFxuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX0RPV04gPyAxIDogLTFcblxuICAgICAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tpbmRleF0pXG5cbiAgICAgICAgICAvLyBzZWFyY2ggZm9yIHNlbGVjdGVkIG9yIGZvY3VzZWRFbGVtZW50IGVsZW1lbnRzXG4gICAgICAgICAgaWYgKGl0ZW0uaGFzQ2xhc3Moc2VhcmNoRm9yKSkge1xuICAgICAgICAgICAgb2xkT3B0aW9uID0gaXRlbVxuICAgICAgICAgICAgbmV3SW5kZXggPSBpbmRleFxuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG5leHQgbm90IGRpc2FibGVkIGVsZW1lbnQgaW4gdGhlIGFwcHJvcHJpYXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgY291bnQgPSAwOyBjb3VudCA8IG9wdGlvbnMubGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ICs9IGRpcmVjdGlvblxuICAgICAgICAgICAgICBuZXdJbmRleCAlPSBvcHRpb25zLmxlbmd0aFxuXG4gICAgICAgICAgICAgIGlmIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG9wdGlvbnMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KG9wdGlvbnNbbmV3SW5kZXhdKVxuICAgICAgICAgICAgICBpZiAoIW5ld0VsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfSVRFTV9ESVNBQkxFRCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBuZXcgZWxlbWVudCBmb2N1c2VkXG4gICAgICAgIHNjcm9sbEludG9WaWV3KG9wdGlvbnNbbmV3SW5kZXhdKVxuICAgICAgICBsZXQgbmV3T3B0aW9uID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tuZXdJbmRleF0pXG4gICAgICAgIG5ld09wdGlvbi5hZGRDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG5cbiAgICAgICAgaWYgKG9sZE9wdGlvbikge1xuICAgICAgICAgIG9sZE9wdGlvbi5yZW1vdmVDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChJbnB1dHMuZ2V0S2V5VmFsdWUoa2V5Y29kZSkgJiYgIXRoaXMuX2lzRmlsdGVyYWJsZSgpKSB7XG4gICAgICAvLyBLZXlib2FyZCBrZXlzXG5cbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+XG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgbGV0IG9sZEZvY3VzSW5kZXggPSAwXG4gICAgICAgIGxldCBoYXNGb2N1c2VkT3B0aW9uID0gZmFsc2VcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBEb21FbGVtZW50KG9wdGlvbnNbaW5kZXhdKVxuXG4gICAgICAgICAgaWYgKGl0ZW0uaGFzQ2xhc3MoQ0xBU1NfSVRFTV9GT0NVU0VEKSkge1xuICAgICAgICAgICAgaXRlbS5yZW1vdmVDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGl0ZW0uaW5uZXJUZXh0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKElucHV0cy5nZXRLZXlWYWx1ZShrZXljb2RlKSkpIHtcbiAgICAgICAgICAgICAgaGFzRm9jdXNlZE9wdGlvbiA9IHRydWVcbiAgICAgICAgICAgICAgb2xkRm9jdXNJbmRleCA9IGluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld09wdGlvbiA9IHRoaXMuX2ZvY3VzT3B0aW9uU3RhcnRpbmdXaXRoKGtleWNvZGUsIGhhc0ZvY3VzZWRPcHRpb24gPyBvbGRGb2N1c0luZGV4ICsgMSA6IDAsIG9wdGlvbnMpXG4gICAgICAgIGlmIChuZXdPcHRpb24gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgdGhpcy5fZm9jdXNPcHRpb25TdGFydGluZ1dpdGgoa2V5Y29kZSwgMCwgb3B0aW9ucylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRU5URVIgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9UQUIpIHtcbiAgICAgIC8vIEhhbmRsZSBlbnRlciBhbmQgdGFiIGtleSBieSBzZWxlY3RpbmcgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgIGxldCBuZXdJdGVtID0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfSVRFTV9GT0NVU0VEfWApIVxuICAgICAgdGhpcy5fc2VsZWN0ZWRJdGVtQ2hhbmdlZChuZXdJdGVtLCB0cnVlLCB0aGlzLl9tdWx0aXNlbGVjdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGluIHRoZSBmaWx0ZXIgZmllbGRcbiAgICovXG4gIHByaXZhdGUgX2hhbmRsZUZpbHRlcktleWRvd24oZTogRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gZSBhcyBLZXlib2FyZEV2ZW50XG4gICAgY29uc3Qga2V5Y29kZSA9IGtleWJvYXJkRXZlbnQud2hpY2ggfHwga2V5Ym9hcmRFdmVudC5rZXlDb2RlXG5cbiAgICAvLyBJZiB0aGUgdXNlciBoaXRzIHRoZSBlbnRlciBrZXkgd2hpbGUgZmlsdGVyaW5nIGFuZCB0aGVyZSdzIGEgc2luZ2xlIG1hdGNoLCBzZWxlY3QgaXRcbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FTlRFUikge1xuICAgICAgY29uc3QgZHJvcGRvd25FbGVtZW50cyA9IHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX0lURU19YClcblxuICAgICAgaWYgKGRyb3Bkb3duRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSXRlbUNoYW5nZWQoZHJvcGRvd25FbGVtZW50c1swXSwgdHJ1ZSwgdGhpcy5fbXVsdGlzZWxlY3Rpb24pXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIGtleSBpbiB0aGUgZmlsdGVyIGZpZWxkXG4gICAqL1xuICBwcml2YXRlIF9oYW5kbGVGaWx0ZXJLZXl1cChlOiBFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnRcblxuICAgIC8vIEZpbHRlciBoYXMgY2hhbmdlZFxuICAgIGlmICh0YXJnZXQudmFsdWUgIT09IHRoaXMuX2FjdGl2ZUZpbHRlciAmJiB0YXJnZXQudmFsdWUgIT09IHRoaXMuX3BsYWNlaG9sZGVyVGV4dCAmJiB0YXJnZXQudmFsdWUgIT09IHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEuaW5uZXJIVE1MKSB7XG4gICAgICB0aGlzLl9zZXRGaWx0ZXIodGFyZ2V0LnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGZvY3Vzc2VzIHRoZSBmaWx0ZXIgaW5wdXQgZmllbGRcbiAgICovXG4gIHByaXZhdGUgX2hhbmRsZUZpbHRlckZvY3VzKGU6IEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudFxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0YXJnZXQuc2VsZWN0KClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIFNlbGVjdCBieSBhIGdpdmVuIGZpbHRlciBrZXl3b3JkXG4gICAqIEBwYXJhbSBmaWx0ZXIgS2V5d29yZCB0byBmaWx0ZXIgYnlcbiAgICovXG4gIHByaXZhdGUgX3NldEZpbHRlcihmaWx0ZXI6IHN0cmluZyA9IFwiXCIpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3RpdmVGaWx0ZXIgPSAoZmlsdGVyLmxlbmd0aCA+PSB0aGlzLl9taW5GaWx0ZXJMZW5ndGgpID8gZmlsdGVyIDogXCJcIlxuICAgIHRoaXMuc2V0T3B0aW9ucyh0aGlzLmdldEluaXRpYWxPcHRpb25zKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBmaWx0ZXJcbiAgICovXG4gIHByaXZhdGUgX2NsZWFyRmlsdGVyKCk6IHZvaWQge1xuICAgIGRlbGV0ZSB0aGlzLl9hY3RpdmVGaWx0ZXJcbiAgICB0aGlzLnNldE9wdGlvbnModGhpcy5nZXRJbml0aWFsT3B0aW9ucygpKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBuZXcgY29udGVudCBhbmQgcmVsb2FkIHRoZSBTZWxlY3RcbiAgICogQHBhcmFtIGVsZW1lbnRzIEFycmF5IG9mIG5ldyBvcHRpb24gKG9yIG9wdGdyb3VwKSBlbGVtZW50cyB0byBkaXNwbGF5XG4gICAqL1xuICBwcml2YXRlIHNldE9wdGlvbnMob3B0aW9uczogRWxlbWVudFtdKTogdm9pZCB7XG4gICAgdGhpcy5fZW1wdHlOb2RlKHRoaXMuZWxlbWVudClcblxuICAgIG9wdGlvbnMuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQob3B0aW9uKVxuICAgIH0pXG5cbiAgICAvLyBQcmVzZXJ2ZSBzZWxlY3RlZCB2YWx1ZSBpZiB0aGUgc2VsZWN0ZWRcbiAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb24hLnZhbHVlXG5cbiAgICB0aGlzLnJlbG9hZCgpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGNoaWxkcmVuIG9mIGEgZ2l2ZW4gbm9kZVxuICAgKiBAcGFyYW0gbm9kZSBOb2RlXG4gICAqL1xuICBwcml2YXRlIF9lbXB0eU5vZGUobm9kZTogTm9kZSk6IHZvaWQge1xuICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYW4gb3B0aW9uIGlzIGEgcGxhY2Vob2xkZXIgb3B0aW9uXG4gICAqL1xuICBwcml2YXRlIF9pc1BsYWNlaG9sZGVyKG9wdGlvbjogSFRNTE9wdGlvbkVsZW1lbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gb3B0aW9uLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmIG9wdGlvbi5oYXNBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwbGFjZWhvbGRlciB2YWx1ZVxuICAgKiBAcGFyYW0gdGV4dCBDb250ZW50IG9mIHRoZSBwbGFjZWhvbGRlclxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZXRQbGFjZWhvbGRlcih0ZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50ICYmIHRleHQpIHtcbiAgICAgIGlmICh0aGlzLl9pc0ZpbHRlcmFibGUoKSkge1xuICAgICAgICAodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50IGFzIERvbUVsZW1lbnQ8SFRNTElucHV0RWxlbWVudD4pLmVsZW1lbnQudmFsdWUgPSB0ZXh0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuc2V0SHRtbCh0ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbi5cbiAgICogSWYgbXVsdGlwbGUgc2VsZWN0aW9uIGlzIGVuYWJsZWQgdGhpcyBwcm9wZXJ0eSByZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5fbXVsdGlzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZE9wdGlvbnMoKS5tYXAoKHgpID0+IHgudmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2VsZWN0IGNvbXBvbmVudCBkZXBlbmRpbmcgb24gdGhlXG4gICAqICd2YWx1ZScgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSBJZiB0cnVlIGRpc2FibGVzIHRoZSBjb250cm9sOyBmYWxzZSBlbmFibGVzIGl0LlxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbG9hZHMgdGhlIGRyb3Bkb3duJ3Mgb3B0aW9uIGRhdGEgZGVmaW5pdGlvbnMgZnJvbSB0aGUgRE9NIGFuZCB1cGRhdGVzXG4gICAqIHRoZSBnZW5lcmF0ZWQgZHJvcGRvd24gZGlzcGxheSBpdGVtcy5cbiAgICovXG4gIHB1YmxpYyByZWxvYWQoKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBleGlzdGluZyBjaGlsZCBlbGVtZW50c1xuICAgIHRoaXMuX2VtcHR5Tm9kZSh0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudClcblxuICAgIGlmICh0aGlzLl9hY3RpdmVGaWx0ZXIgPT09IHVuZGVmaW5lZCkgeyAvLyBJZiB0aGUgdXNlciBpcyBmaWx0ZXJpbmcsIGxldCB0aGUgcGxhY2Vob2xkZXIgXCJpbnB1dFwiIGFsaXZlXG4gICAgICB0aGlzLl9zZXR1cFBsYWNlaG9sZGVyKClcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVPcHRpb25zKHRoaXMuZWxlbWVudClcblxuICAgIHRoaXMuX3VwZGF0ZVNpemUoKVxuICAgIHRoaXMuX3VwZGF0ZU1lc3NhZ2UoKVxuXG4gICAgaWYgKCF0aGlzLl9pc0ZpbHRlcmFibGUoKSkge1xuICAgICAgdGhpcy5fdXBkYXRlUGxhY2Vob2xkZXIoISF0aGlzLnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QgY29udHJvbCB0byB0aGUgZW5hYmxlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBlbmFibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBkaXNhYmxlKCkge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFkZENsYXNzKENMQVNTX0RJU0FCTEVEKVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QgZHJvcGRvd24uXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBpZiB0aGUgc2VsZWN0IGRyb3Bkb3duIGlzIG9wZW4gb3IgY2xvc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9wZW47IG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIHB1YmxpYyBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZXJFbGVtZW50Lmhhc0NsYXNzKENMQVNTX09QRU4pXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIHNlbGVjdCBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyBvcGVuKCkge1xuICAgIGlmICghdGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSBmYWxzZVxuXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19DTE9TRUQpXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hZGRDbGFzcyhDTEFTU19PUEVOKVxuXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlRHJvcGRvd25DbGljaylcbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgdGhpcy5faGFuZGxlRHJvcGRvd25DbGljaylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzZWxlY3QgZHJvcGRvd24uXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuX29wZW5CeUZvY3VzID0gZmFsc2VcblxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFkZENsYXNzKENMQVNTX0NMT1NFRClcblxuICAgICAgLy8gSWYgdGhlIFNlbGVjdCBpcyBmaWx0ZXJhYmxlIGFuZCB0aGVyZWZvcmUgaGFzIGFuIGlucHV0IGZpZWxkLFxuICAgICAgLy8gcmVzZXQgdGhlIHZhbHVlIG9mIGl0IHRvIHRoZSBjaG9zZW4gb3B0aW9uXG4gICAgICBpZiAodGhpcy5faXNGaWx0ZXJhYmxlKCkpIHtcbiAgICAgICAgLy8gVW5mb2N1cyBpbnB1dCBmaWVsZFxuICAgICAgICAodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkuYmx1cigpXG5cbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVGaWx0ZXIgfHwgdGhpcy5fYWN0aXZlRmlsdGVyID09PSB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb24hLmlubmVySFRNTCkge1xuICAgICAgICAgIHRoaXMuX3NldFBsYWNlaG9sZGVyKHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEuaW5uZXJIVE1MKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRhcFwiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuXG4gICAgICBsZXQgZm9jdXNlZEl0ZW0gPSB0aGlzLl93cmFwcGVyRWxlbWVudC5maW5kKGAuJHtDTEFTU19JVEVNX0ZPQ1VTRUR9YClcblxuICAgICAgaWYgKGZvY3VzZWRJdGVtKSB7XG4gICAgICAgIGZvY3VzZWRJdGVtLnJlbW92ZUNsYXNzKENMQVNTX0lURU1fRk9DVVNFRClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVsZW1lbnQgaGFzIHRoZSBmaWx0ZXIgbW9kaWZpZXIgY2xhc3NcbiAgICovXG4gIHByaXZhdGUgX2lzRmlsdGVyYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlckVsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfRklMVEVSQUJMRSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBjbGVhcnMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIGlmICh0aGlzLl9kcm9wZG93bkVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRhcFwiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuXG4gICAgICByZW1vdmUodGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQpO1xuICAgICAgKHRoaXMgYXMgYW55KS5fZHJvcGRvd25FbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2ZpbHRlcktleWRvd25IYW5kbGVyKVxuICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9maWx0ZXJLZXl1cEhhbmRsZXIpXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZpbHRlckZvY3VzSGFuZGxlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fd3JhcHBlckVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKTtcblxuICAgICAgKHRoaXMgYXMgYW55KS5fd3JhcHBlckVsZW1lbnQgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudCkge1xuICAgICAgcmVtb3ZlKHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAodGhpcyBhcyBhbnkpLl9zZWxlY3RCdXR0b25FbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19DTE9TRUQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTFNlbGVjdEVsZW1lbnQ+KFwic2VsZWN0XCIsIChlKSA9PiB7XG4gICAgbmV3IFNlbGVjdChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9URVhUQVJFQSA9IFwidGV4dGFyZWFcIlxuY29uc3QgQ0xBU1NfSEFTX1ZBTFVFID0gXCJpcy1maXhlZFwiXG5cbi8qKlxuICogVGV4dGFyZWEgY29tcG9uZW50XG4gKi9cbmNsYXNzIFRleHRhcmVhIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2FyZWE6IEhUTUxUZXh0QXJlYUVsZW1lbnRcblxuICBwcml2YXRlIF9mb2N1c0NoYW5nZWRIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfdmFsdWVDaGFuZ2VkSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3Jlc2l6ZUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX21pblJvd3MhOiBudW1iZXJcbiAgcHJpdmF0ZSBfbWF4Um93cyE6IG51bWJlclxuICBwcml2YXRlIF9saW5lSGVpZ2h0ITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfdXBkYXRlQmFzZUhlaWdodCE6IGJvb2xlYW5cblxuICBwcml2YXRlIF9iYXNlSGVpZ2h0ITogbnVtYmVyXG4gIHByaXZhdGUgX2Jhc2VTY3JvbGxIZWlnaHQhOiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2FyZWEgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9URVhUQVJFQSkhXG5cbiAgICB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyID0gdGhpcy5fZm9jdXNDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kbGVyID0gdGhpcy5fb25WYWx1ZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgPSB0aGlzLl91cGRhdGVIZWlnaHQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHRleHRhcmVhIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9taW5Sb3dzID0gcGFyc2VJbnQodGhpcy5fYXJlYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1pbi1yb3dzXCIpIHx8IFwiM1wiLCAxMClcbiAgICB0aGlzLl9tYXhSb3dzID0gcGFyc2VJbnQodGhpcy5fYXJlYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1heC1yb3dzXCIpISwgMTApIHx8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5cbiAgICAvLyBNYWtlIHN1cmUgbWluIGFuIG1heCBhcmUgcHJvcGVydHkgc3BlY2lmaWVkXG4gICAgdGhpcy5fbWluUm93cyA9IE1hdGgubWluKHRoaXMuX21pblJvd3MsIHRoaXMuX21heFJvd3MpXG4gICAgdGhpcy5fbWF4Um93cyA9IE1hdGgubWF4KHRoaXMuX21pblJvd3MsIHRoaXMuX21heFJvd3MpXG5cbiAgICB0aGlzLl9saW5lSGVpZ2h0ID0gcGFyc2VJbnQoRG9tLmNzcyh0aGlzLl9hcmVhLCBcImxpbmUtaGVpZ2h0XCIpLCAxMClcblxuICAgIHRoaXMuX3VwZGF0ZUJhc2VIZWlnaHQgPSBEb20uaXNIaWRkZW4odGhpcy5fYXJlYSwgdHJ1ZSlcbiAgICB0aGlzLl9jYWxjdWxhdGVCYXNlSGVpZ2h0KClcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9hcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fZm9jdXNDaGFuZ2VkSGFuZGxlcilcbiAgICB0aGlzLl9hcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kbGVyKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9vblZhbHVlQ2hhbmdlZCgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZUJhc2VIZWlnaHQoKSB7XG4gICAgLy8gdGVtcG9yYXJ5IGNsZWFyIHRoZSBjb250ZW50IHRvIHRha2UgbWVhc3VyZW1lbnRzXG4gICAgbGV0IHZhbHVlID0gdGhpcy5fYXJlYS52YWx1ZVxuICAgIHRoaXMuX2FyZWEudmFsdWUgPSBcIlwiXG5cbiAgICB0aGlzLl9iYXNlSGVpZ2h0ID0gdGhpcy5fYXJlYS5vZmZzZXRIZWlnaHQgLSB0aGlzLl9saW5lSGVpZ2h0XG4gICAgdGhpcy5fYmFzZVNjcm9sbEhlaWdodCA9IHRoaXMuX2FyZWEuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fbGluZUhlaWdodFxuXG4gICAgLy8gcmVzdG9yZSBpbml0aWFsIGNvbnRlbnRcbiAgICB0aGlzLl9hcmVhLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfZm9jdXNDaGFuZ2VkKCkge1xuICAgIHRoaXMuX3VwZGF0ZUhlaWdodCgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZUhlaWdodCgpIHtcbiAgICBsZXQgaGFzRm9jdXMgPSB0aGlzLl9hcmVhID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgbGV0IG1heFJvd3MsIHJvd3MgPSAwXG5cbiAgICBpZiAodGhpcy5fdXBkYXRlQmFzZUhlaWdodCA9PT0gdHJ1ZSAmJiBEb20uaXNIaWRkZW4odGhpcy5fYXJlYSwgdHJ1ZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9jYWxjdWxhdGVCYXNlSGVpZ2h0KClcbiAgICAgIHRoaXMuX3VwZGF0ZUJhc2VIZWlnaHQgPSBmYWxzZVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYXByb3ByaWF0ZSBzaXplIGZvciB0aGUgY29udHJvbFxuICAgIGlmICghdGhpcy5faGFzVmFsdWUoKSkge1xuICAgICAgLy8gSGFuZGxlIGVtcHR5IHN0YXRlc1xuICAgICAgcm93cyA9IGhhc0ZvY3VzID09PSB0cnVlID8gdGhpcy5fbWluUm93cyA6IDFcbiAgICAgIG1heFJvd3MgPSByb3dzXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBoZWlnaHQgZm9yIGNhbGN1bGF0aW9uIG9mIHRoZSByb3cgY291bnRcbiAgICAgIHRoaXMuX2FyZWEuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCJcblxuICAgICAgLy8gR2V0IHRoZSBuZXcgaGVpZ2h0XG4gICAgICByb3dzID0gTWF0aC5jZWlsKCh0aGlzLl9hcmVhLnNjcm9sbEhlaWdodCAtIHRoaXMuX2Jhc2VTY3JvbGxIZWlnaHQpIC8gdGhpcy5fbGluZUhlaWdodCkgKyAxXG4gICAgICBtYXhSb3dzID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5fbWF4Um93cywgcm93cyksIHRoaXMuX21pblJvd3MpXG4gICAgfVxuXG4gICAgaWYgKHJvd3MgPiB0aGlzLl9tYXhSb3dzKSB7XG4gICAgICB0aGlzLl9hcmVhLnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXJlYS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCJcbiAgICB9XG5cbiAgICBjb25zdCBoZWlnaHQgPSAoKG1heFJvd3MgLSAxKSAqIHRoaXMuX2xpbmVIZWlnaHQpICsgdGhpcy5fYmFzZUhlaWdodFxuICAgIHRoaXMuX2FyZWEuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YFxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJlYS52YWx1ZSAmJiB0aGlzLl9hcmVhLnZhbHVlLmxlbmd0aCA+IDBcbiAgfVxuXG4gIHByb3RlY3RlZCBfb25WYWx1ZUNoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc1ZhbHVlKCkpIHtcbiAgICAgIERvbS5hZGRDbGFzcyh0aGlzLl9hcmVhLCBDTEFTU19IQVNfVkFMVUUpXG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLl9hcmVhLCBDTEFTU19IQVNfVkFMVUUpXG4gICAgICB0aGlzLl9hcmVhLnZhbHVlID0gXCJcIlxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUhlaWdodCgpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgY2xlYXJzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9hcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fZm9jdXNDaGFuZ2VkSGFuZGxlcilcbiAgICB0aGlzLl9hcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kbGVyKTtcblxuICAgICh0aGlzIGFzIGFueSkuX2ZvY3VzQ2hhbmdlZEhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3ZhbHVlQ2hhbmdlZEhhbmRlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYXJlYSA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbWluUm93cyA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbWF4Um93cyA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbGluZUhlaWdodCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYmFzZUhlaWdodCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYmFzZVNjcm9sbEhlaWdodCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5lbGVtZW50ID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmlucHV0LW11bHRpbGluZSwgLmlucHV0LWZpZWxkLS1tdWx0aWxpbmVcIiwgKGUpID0+IHtcbiAgICBuZXcgVGV4dGFyZWEoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dGFyZWFcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG4vKipcbiAqIExvYWRlciBiYXIgY29tcG9uZW50XG4gKi9cbmNsYXNzIExvYWRlckJhciBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIHByb2dyZXNzRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSBmaWxlTmFtZUVsZW1lbnQhOiBEb21FbGVtZW50XG4gIHByaXZhdGUgcHJvZ3Jlc3NMYWJlbEVsZW1lbnQhOiBEb21FbGVtZW50XG4gIHByaXZhdGUgdG90YWxQcm9ncmVzc0VsZW1lbnQhOiBEb21FbGVtZW50XG5cbiAgcHJpdmF0ZSB2YWx1ZSE6IG51bWJlclxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgTG9hZGVyQmFyIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIExvYWRlckJhciBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbG9hZGVyIGJhciBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5wcm9ncmVzc0VsZW1lbnQgPSB0aGlzLmZpbmQoXCIuaW5kaWNhdG9yXCIpIHx8IHRoaXNcbiAgICB0aGlzLmZpbGVOYW1lRWxlbWVudCA9IHRoaXMuZmluZChcIi5kZXRhaWwgPiAubmFtZVwiKSFcbiAgICB0aGlzLnByb2dyZXNzTGFiZWxFbGVtZW50ID0gdGhpcy5maW5kKFwiLnByb2dyZXNzXCIpIVxuICAgIHRoaXMudG90YWxQcm9ncmVzc0VsZW1lbnQgPSB0aGlzLmZpbmQoXCIucHJvZ3Jlc3MgPiAuZmlsZS1zaXplXCIpIVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgdmFsdWUgaW4gdGhlIHJhbmdlIG9mIDAuLjEuXG4gICAqL1xuICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgcHJvZ3Jlc3MgaW4gdGhlIHJhbmdlIG9mIDAuLjEuXG4gICAqL1xuICBzZXQgcHJvZ3Jlc3ModmFsKSB7XG4gICAgLy8gdmFsID0gY2xhbXAodmFsLCAwLCAxKVxuXG4gICAgbGV0IHBlcmNlbnRhZ2UgPSAodmFsICogMTAwKS50b0ZpeGVkKDApXG5cbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICh0aGlzLmVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSBTdHJpbmcodmFsKVxuXG4gICAgdGhpcy5wcm9ncmVzc0VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHdpZHRoOiAke3ZhbCAqIDEwMH0lYClcblxuICAgIGlmICh0aGlzLnByb2dyZXNzTGFiZWxFbGVtZW50KSB7XG4gICAgICB0aGlzLnByb2dyZXNzTGFiZWxFbGVtZW50LmVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHtwZXJjZW50YWdlfSVgXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpbGVuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBmaWxlbmFtZS5cbiAgICovXG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICBpZiAoIXRoaXMuZmlsZU5hbWVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmlsZU5hbWVFbGVtZW50LmVsZW1lbnQuaW5uZXJIVE1MXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsZW5hbWUuXG4gICAqL1xuICBzZXQgZmlsZW5hbWUodmFsOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoIXRoaXMuZmlsZU5hbWVFbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBmaWxlbmFtZSwgbWlzc2luZyBkZXRhaWwgZWxlbWVudFwiKVxuICAgIH1cblxuICAgIHRoaXMuZmlsZU5hbWVFbGVtZW50LnNldEh0bWwodmFsIHx8IFwiXCIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsZSBzaXplIGxhYmVsLlxuICAgKi9cbiAgc2V0IGZpbGVTaXplKHZhbDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLnRvdGFsUHJvZ3Jlc3NFbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBmaWxlU2l6ZSwgbWlzc2luZyBkZXRhaWwgZWxlbWVudFwiKVxuICAgIH1cblxuICAgIHRoaXMudG90YWxQcm9ncmVzc0VsZW1lbnQuc2V0SHRtbCh2YWwpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIubG9hZGVyLWJhclwiLCAoZSkgPT4ge1xuICAgIG5ldyBMb2FkZXJCYXIoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9hZGVyQmFyXG4iLCJpbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IFBvcHBlciBmcm9tIFwicG9wcGVyLmpzXCJcblxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgYWRkQ2xhc3MsIGhhc0NsYXNzLCByZW1vdmVDbGFzcywgaXNIaWRkZW4sIHBhcmVudFdpdGhDbGFzcyB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcbmNvbnN0IENMQVNTX01FTlUgPSBcImpzLWZseW91dFwiXG5jb25zdCBDTEFTU19UQUJTID0gXCJ0YWJzXCJcblxuY29uc3QgQU5JTUFUSU9OX09QRU4gPSAzMDBcblxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3IgdGhlIGZseW91dCBtZW51LlxuICovXG5jbGFzcyBNZW51Rmx5b3V0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGU6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfYW5pbWF0aW9uRHVyYXRpb24gPSBBTklNQVRJT05fT1BFTlxuXG4gIHByaXZhdGUgX2R5bmFtaWNQbGFjZW1lbnQgPSBmYWxzZVxuXG4gIHByaXZhdGUgX2hpZGRlbkluZGljYXRvcj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2ZseW91dEVsZW1lbnQhOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3BvcHBlckluc3RhbmNlPzogUG9wcGVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBmbHlvdXQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIGZseW91dCBtZW51IGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBmbHlvdXQgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGxldCBkYXRhVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpXG4gICAgaWYgKGRhdGFUYXJnZXQgPT09IG51bGwgfHwgZGF0YVRhcmdldCA9PT0gXCJcIikge1xuXG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmVycm9yKFwiQSBmbHlvdXQgbWVudSBlbGVtZW50IHJlcXVpcmVzIGEgJ2RhdGEtdGFyZ2V0JyB0aGF0IHNwZWNpZmllcyB0aGUgZWxlbWVudCB0byBjb2xsYXBzZVwiKVxuICAgICAgY29uc29sZS5pbmZvKHRoaXMuZWxlbWVudClcbiAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdXNlRHluYW1pY1BsYWNlbWVudCgpKSB7XG4gICAgICB0aGlzLl9keW5hbWljUGxhY2VtZW50ID0gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBoaWRkZW5UYXJnZXQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1oaWRkZW5cIilcbiAgICBpZiAoaGlkZGVuVGFyZ2V0ICE9PSBudWxsICYmIGhpZGRlblRhcmdldCAhPT0gXCJcIikge1xuICAgICAgdGhpcy5faGlkZGVuSW5kaWNhdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihoaWRkZW5UYXJnZXQpIGFzIEhUTUxFbGVtZW50IHx8IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHRoaXMuX2luaXRGbHlvdXRFbGVtZW50KGRhdGFUYXJnZXQpXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gIH1cblxuICBwcml2YXRlIF9pbml0Rmx5b3V0RWxlbWVudChkYXRhVGFyZ2V0OiBzdHJpbmcpIHtcbiAgICB0aGlzLl9mbHlvdXRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihkYXRhVGFyZ2V0KSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9mbHlvdXRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgIHRoaXMuX2ZseW91dEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKC0yMHB4KVwiXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMudG9nZ2xlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKHBhcmVudFdpdGhDbGFzcyh0YXJnZXQsIENMQVNTX01FTlUpID09PSB0aGlzLl9mbHlvdXRFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB3aGlsZSAodGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VzZUR5bmFtaWNQbGFjZW1lbnQoKSB7XG4gICAgcmV0dXJuIHBhcmVudFdpdGhDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX1RBQlMpXG4gIH1cblxuICBwcm90ZWN0ZWQgX29wZW5NZW51KGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGFuaW1lLnJlbW92ZShlbClcblxuICAgIGlmICh0aGlzLl9keW5hbWljUGxhY2VtZW50ID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBwb3BwZXJPcHRpb25zOiBQb3BwZXIuUG9wcGVyT3B0aW9ucyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRzRW5hYmxlZDogZmFsc2VcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSBuZXcgUG9wcGVyKHRoaXMuZWxlbWVudCwgdGhpcy5fZmx5b3V0RWxlbWVudCwgcG9wcGVyT3B0aW9ucylcbiAgICB9XG5cbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBlbCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9hbmltYXRpb25EdXJhdGlvbixcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRyYW5zbGF0ZVk6IFwiMHB4XCIsXG4gICAgICBiZWdpbjogKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG4gICAgICB9LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgYWRkQ2xhc3MoZWwsIENMQVNTX09QRU4pXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIilcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcIm9wZW5lZFwiKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9zZU1lbnUoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgYW5pbWUucmVtb3ZlKGVsKVxuXG4gICAgaWYgKHRoaXMuX3BvcHBlckluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5kZXN0cm95KClcbiAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogZWwsXG4gICAgICBkdXJhdGlvbjogdGhpcy5fYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB0cmFuc2xhdGVZOiBcIi0yMHB4XCIsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcbiAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIENMQVNTX09QRU4pXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjbG9zZWRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGVuaW5nIGFuaW1hdGlvbiBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtkdXJhdGlvbkluU2Vjb25kc30gLSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIHNlY29uZHMuXG4gICAqL1xuICBzZXQgYW5pbWF0aW9uRHVyYXRpb24oZHVyYXRpb25JblNlY29uZHM6IG51bWJlcikge1xuICAgIHRoaXMuX2FuaW1hdGlvbkR1cmF0aW9uID0gZHVyYXRpb25JblNlY29uZHNcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgZmx5b3V0IG1lbnUuXG4gICAqIEBmaXJlcyBNb2RhbCNvcGVuZWRcbiAgICovXG4gIHB1YmxpYyBvcGVuKCkge1xuICAgIGlmICh0aGlzLl9oaWRkZW5JbmRpY2F0b3IgJiYgaXNIaWRkZW4odGhpcy5faGlkZGVuSW5kaWNhdG9yLCBmYWxzZSkgPT09IHRydWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChoYXNDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pID09PSB0cnVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG4gICAgdGhpcy5fb3Blbk1lbnUodGhpcy5fZmx5b3V0RWxlbWVudClcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB9LCA1MClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGZseW91dCBtZW51LlxuICAgKiBAZmlyZXMgTW9kYWwjY2xvc2VkXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHRoaXMuX2Nsb3NlTWVudSh0aGlzLl9mbHlvdXRFbGVtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGZseW91dCBtZW51LlxuICAgKiBAZmlyZXMgTW9kYWwjb3BlbmVkXG4gICAqIEBmaXJlcyBNb2RhbCNjbG9zZWRcbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIGNsZWFycyByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fZmx5b3V0RWxlbWVudCA9IG51bGxcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuX2NsaWNrSGFuZGxlcikge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BvcHBlckluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5kZXN0cm95KClcbiAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5fY2xpY2tIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl93aW5kb3dDbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBmbHlvdXQgbWVudSBpcyBvcGVuZWQgYnkgdGhlIGFuY2hvciBsaW5rIG9yIHVzaW5nIHRoZVxuICAgKiB7QGxpbmsgTWVudUZseW91dCNvcGVufSBtZXRob2QuXG4gICAqIEBldmVudCBNZW51Rmx5b3V0I29wZW5lZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZmx5b3V0IG1lbnUgaXMgY2xvc2VkIGJ5IHRoZSB1c2VyIG9yIHVzaW5nIHRoZVxuICAgKiB7QGxpbmsgTWVudUZseW91dCNjbG9zZX0gbWV0aG9kLlxuICAgKiBAZXZlbnQgTWVudUZseW91dCNjbG9zZWRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtdG9nZ2xlPSdmbHlvdXQnXVwiKVxuICBmb3IgKGxldCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbml0XCIpID09PSBcImF1dG9cIikge1xuICAgICAgbmV3IE1lbnVGbHlvdXQoZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVudUZseW91dFxuIiwiaW1wb3J0IHsgZGlzYWJsZUJvZHlTY3JvbGwsIGVuYWJsZUJvZHlTY3JvbGwgfSBmcm9tIFwiYm9keS1zY3JvbGwtbG9ja1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBnZXRSb290RWxlbWVudCB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBDTEFTU19CQUNLRFJPUCA9IFwiYmFja2Ryb3BcIlxuY29uc3QgQ0xBU1NfQkFDS0RST1BfT1BFTiA9IFwiYmFja2Ryb3AtLW9wZW5cIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJtb2RhbC0tb3BlblwiXG5jb25zdCBDTEFTU19UUklHR0VSID0gXCJtb2RhbC10cmlnZ2VyXCJcblxuY29uc3QgQ0xBU1NfQk9EWSA9IFwibW9kYWxfX2JvZHlcIlxuXG5jb25zdCBDTEFTU19CVVRUT05TX09LQVkgPSBcIi5tb2RhbC1jbG9zZVwiXG5jb25zdCBDTEFTU19CVVRUT05TX0NMT1NFID0gXCIubW9kYWwtY2FuY2VsXCJcblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0byBvcGVuIGFuZCBjbG9zZSBtb2RhbCBkaWFsb2dzLiBJdCBhbHNvIGhhbmRsZXMgY2FuY2VsbGF0aW9uIGFuZCBtYWtlc1xuICogc3VyZSB0aGF0IHRoZSBtb2RhbCBiYWNrZ3JvdW5kIGlzIHByZXNlbnQgaW4gdGhlIERPTS5cbiAqL1xuY2xhc3MgTW9kYWwgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX29rYXlIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfY2FuY2VsSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleWRvd25IYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyPzogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3RyaWdnZXJDbGlja0hhbmRsZXI/OiAoZTogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9iYWNrZHJvcCE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX2JhY2tkcm9wUGFyZW50ITogRWxlbWVudFxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX29rYXlIYW5kbGVyID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fY2FuY2VsSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHJhbmdlIG1vZGFsIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcblxuICAgIC8vIENyZWF0ZSB0aGUgYmFja2Ryb3BcbiAgICB0aGlzLl9iYWNrZHJvcCA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0JBQ0tEUk9QKVxuXG4gICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQgPSBnZXRSb290RWxlbWVudCgpXG4gICAgdGhpcy5fc3Vic2NyaWJlVG9UcmlnZ2VyKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlVG9UcmlnZ2VyKCkge1xuICAgIGNvbnN0IHRyaWdnZXJJZCA9IHRoaXMuZWxlbWVudC5pZFxuICAgIGlmICghdHJpZ2dlcklkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl90cmlnZ2VyQ2xpY2tIYW5kbGVyID0gdGhpcy5vcGVuLmJpbmQodGhpcylcblxuICAgIGxldCB0cmlnZ2VyRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19UUklHR0VSfVtocmVmPSR7dHJpZ2dlcklkfV1gKVxuICAgIGZvciAobGV0IHRyaWdnZXJFbGVtZW50IG9mIHRyaWdnZXJFbGVtZW50cykge1xuICAgICAgdHJpZ2dlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3RyaWdnZXJDbGlja0hhbmRsZXIhKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5zdWJzY3JpYmVGcm9tVHJpZ2dlcigpIHtcbiAgICBjb25zdCB0cmlnZ2VySWQgPSB0aGlzLmVsZW1lbnQuaWRcbiAgICBpZiAoIXRyaWdnZXJJZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRyaWdnZXJFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1RSSUdHRVJ9W2hyZWY9JHt0cmlnZ2VySWR9XWApXG4gICAgZm9yIChsZXQgdHJpZ2dlckVsZW1lbnQgb2YgdHJpZ2dlckVsZW1lbnRzKSB7XG4gICAgICB0cmlnZ2VyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyISlcbiAgICB9XG5cbiAgICB0aGlzLl90cmlnZ2VyQ2xpY2tIYW5kbGVyID0gdW5kZWZpbmVkXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEV2ZW50KSB7XG4gICAgY29uc3Qga2V5Ym9hcmRFdmVudCA9IGV2ZW50IGFzIEtleWJvYXJkRXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGtleWJvYXJkRXZlbnQud2hpY2ggfHwga2V5Ym9hcmRFdmVudC5rZXlDb2RlXG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FU0NBUEUpIHtcbiAgICAgIC8vIGhhbmRsZSBFc2NhcGUga2V5IChFU0MpXG4gICAgICB0aGlzLmNhbmNlbCgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIHRoaXMuY2FuY2VsKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2UoKSB7XG4gICAgZW5hYmxlQm9keVNjcm9sbCh0aGlzLmVsZW1lbnQpXG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9iYWNrZHJvcC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuXG4gICAgdGhpcy5fYmFja2Ryb3AucmVtb3ZlQ2xhc3MoQ0xBU1NfQkFDS0RST1BfT1BFTilcbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG5cbiAgICBmb3IgKGxldCBjbG9zZUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX0NMT1NFKSkge1xuICAgICAgY2xvc2VCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NhbmNlbEhhbmRsZXIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2theUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX09LQVkpKSB7XG4gICAgICBva2F5QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9va2F5SGFuZGxlcilcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgYmFja2Ryb3AgZnJvbSB0aGUgYm9keVxuICAgICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fYmFja2Ryb3AuZWxlbWVudClcbiAgICB9LCAzMDApXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsIGRpYWxvZy5cbiAgICogQGZpcmVzIE1vZGFsI29wZW5lZFxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgZGlzYWJsZUJvZHlTY3JvbGwodGhpcy5lbGVtZW50LCB7XG4gICAgICBhbGxvd1RvdWNoTW92ZTogKGVsKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50RWwgPSBlbFxuXG4gICAgICAgIHdoaWxlIChjdXJyZW50RWwgJiYgY3VycmVudEVsICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHVzZXIgaXMgc2Nyb2xsaW5nIHRoZSBtb2RhbCBib2R5XG4gICAgICAgICAgaWYgKGN1cnJlbnRFbC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfQk9EWSkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IG92ZXJmbG93c1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5zY3JvbGxIZWlnaHQgPiBjdXJyZW50RWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudEVsID0gY3VycmVudEVsLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBhZGQgdGhlIGJhY2tkcm9wIHRvIHRoZSBib2R5XG4gICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2Ryb3AuZWxlbWVudClcblxuICAgIC8vIHNldCB0aGUgZWxlbWVudCB0byBmbGV4IGFzIGl0IGlzIGluaXRpYWxseSBoaWRkZW5cbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiXG5cbiAgICAvLyByZW1vdmUgdGhlIHN0eWxlIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCJcbiAgICB9LCA4MDApXG5cbiAgICAvLyB3YWl0IGEgYml0IHRvIGFsbG93IHRoZSBicm93c2VyIHRvIGNhdGNoIHVwIGFuZCBzaG93IHRoZSBhbmltYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmFkZENsYXNzKENMQVNTX0JBQ0tEUk9QX09QRU4pXG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuXG4gICAgICB0aGlzLl9iYWNrZHJvcC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuXG4gICAgICBmb3IgKGxldCBjbG9zZUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX0NMT1NFKSkge1xuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2FuY2VsSGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgb2theUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX09LQVkpKSB7XG4gICAgICAgIG9rYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29rYXlIYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlOiBFdmVudCkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSlcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwib3BlbmVkXCIpXG4gICAgfSwgNTApXG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyAoYW5kIGNsb3NlcykgdGhlIG1vZGFsIGRpYWxvZy5cbiAgICogQGZpcmVzIE1vZGFsI2NhbmNlbGxlZFxuICAgKiBAZmlyZXMgTW9kYWwjY2xvc2VkXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNhbmNlbGxlZFwiKVxuICAgIHRoaXMuX2Nsb3NlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1vZGFsIGRpYWxvZy5cbiAgICogQGZpcmVzIE1vZGFsI2Nsb3NlZFxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMuX2Nsb3NlKClcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjbG9zZWRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBmcmVlcyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FuY2VsKClcbiAgICB0aGlzLl91bnN1YnNjcmliZUZyb21UcmlnZ2VyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBtb2RhbCBkaWFsb2cgaXMgb3BlbmVkIGJ5IHRoZSBhbmNob3IgbGluayBvciB1c2luZyB0aGVcbiAgICoge0BsaW5rIE1vZGFsI29wZW59IG1ldGhvZC5cbiAgICogQGV2ZW50IE1vZGFsI29wZW5lZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgbW9kYWwgZGlhbG9nIGlzIGNsb3NlZCBieSB0aGUgdXNlciBvciB1c2luZyB0aGVcbiAgICoge0BsaW5rIE1vZGFsI2Nsb3NlfSBtZXRob2QuXG4gICAqIEBldmVudCBNb2RhbCNjbG9zZWRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIG1vZGFsIGRpYWxvZyBpcyBjYW5jZWxsZWQgYnkgdGhlIHVzZXIgb3IgdXNpbmcgdGhlXG4gICAqIHtAbGluayBNb2RhbCNjYW5jZWx9IG1ldGhvZC5cbiAgICogQGV2ZW50IE1vZGFsI2NhbmNlbGxlZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTEVsZW1lbnQ+KFwiLm1vZGFsXCIsIChlKSA9PiB7XG4gICAgbmV3IE1vZGFsKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsXG4iLCJpbXBvcnQgYW5pbWUsIHsgQW5pbWVUaW1lbGluZUluc3RhbmNlIH0gZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgU2VhcmNoSW5wdXQgZnJvbSBcIi4uL3NlYXJjaC9TZWFyY2hJbnB1dFwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9OQVZfSEFNQlVSR0VSID0gXCIubmF2LWhhbWJ1cmdlclwiXG5jb25zdCBRVUVSWV9OQVZfSEJfQk9EWSA9IFwiLm5hdl9fcHJpbWFyeVwiXG5cbmNvbnN0IENMQVNTX05BVl9MSU5LID0gXCJuYXYtbGluay0taGVhZGVyXCJcbmNvbnN0IFFVRVJZX05BVl9MSU5LX0FDVElWRSA9IFwiLm5hdi1saW5rLS1oZWFkZXIuaXMtYWN0aXZlXCJcblxuY29uc3QgUVVFUllfTkFWX01PQklMRSA9IFwiLm5hdl9fbGV2ZWwxIC5uYXZfX21haW5uYXYgLm5hdl9fcHJpbWFyeVwiXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwwID0gXCIubmF2X19sZXZlbDBcIlxuY29uc3QgUVVFUllfTkFWX0xFVkVMMF9DT05UQUlORVIgPSBcIi5uYXZfX2xldmVsMCAubmF2X19zdWJuYXZcIlxuY29uc3QgUVVFUllfU0VDVElPTl9PUEVOID0gXCIubmF2LXNlY3Rpb24uaXMtb3BlblwiXG5cbmNvbnN0IFFVRVJZX05BVl9MRVZFTDEgPSBcIi5uYXZfX2xldmVsMSAubmF2X19tYWlubmF2XCJcblxuY29uc3QgUVVFUllfTkFWX0xFVkVMMF9MSU5LID0gXCIubmF2LWxpbmsubmF2LWxpbmstLWhlYWRlclwiXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwxX0xJTksgPSBcIi5uYXYtbGluay0taGVhZGVyXCJcblxuY29uc3QgUVVFUllfTkFWX0NPTFVNTiA9IFwiLm5hdi1jb2xcIlxuY29uc3QgUVVFUllfTkFWX0NPTFVNTl9BQ1RJVkUgPSBcIi5uYXYtY29sLmlzLWFjdGl2ZVwiXG5cbmNvbnN0IFFVRVJZX05BVl9CT0RZID0gXCIubmF2LWJvZHlcIlxuY29uc3QgUVVFUllfTkFWX0ZPT1RFUiA9IFwiLm5hdi1mb290ZXJcIlxuXG5jb25zdCBRVUVSWV9TRUFSQ0hfSUNPTiA9IFwiLm5hdi1zZWFyY2hcIlxuY29uc3QgUVVFUllfU0VBUkNIX0ZJRUxEID0gXCIuc2VhcmNoX19pbnB1dFwiXG5jb25zdCBDTEFTU19TRUFSQ0hfREVTS1RPUCA9IFwic2VhcmNoLS1kZXNrdG9wXCJcblxuY29uc3QgQU5JTUFUSU9OX1NUQVJUX0RFTEFZID0gMjAwXG5jb25zdCBBTklNQVRJT05fT0ZGU0VUID0gNTBcblxuY29uc3QgQU5JTUFUSU9OX0JPRFlfRFVSQVRJT04gPSAzMDBcbmNvbnN0IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04gPSAxMDBcblxuLyoqXG4gKiBUaGUgbmF2aWdhdGlvbiBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvbiBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwdWJsaWMgX25hdkxldmVsMDogSFRNTEVsZW1lbnRcbiAgcHVibGljIF9uYXZMZXZlbDBCb2R5OiBIVE1MRWxlbWVudFxuICBwdWJsaWMgX25hdkxldmVsMTogSFRNTEVsZW1lbnRcblxuICBwdWJsaWMgX2hhbWJ1cmdlckVsZW1lbnQ6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfbmF2TW9iaWxlOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3NlYXJjaENvbXBvbmVudHM6IFNlYXJjaElucHV0W11cblxuICBwcml2YXRlIF9sZXZlbDBDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9sZXZlbDFDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF93aW5kb3dDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9zZWFyY2hDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgYW5pbWF0aW9uOiBBbmltZVRpbWVsaW5lSW5zdGFuY2UgPSBhbmltZS50aW1lbGluZSgpXG4gIHByaXZhdGUgX3NlYXJjaERlc2t0b3A/OiBTZWFyY2hJbnB1dFxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fbmF2TGV2ZWwwID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xFVkVMMCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIHRoaXMuX25hdkxldmVsMEJvZHkgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfTEVWRUwwX0NPTlRBSU5FUikgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIHRoaXMuX25hdkxldmVsMSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MRVZFTDEpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcblxuICAgIHRoaXMuX25hdk1vYmlsZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9NT0JJTEUpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICBpZiAoIXRoaXMuX25hdk1vYmlsZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBsZXQgZHVtbXlQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgICBkdW1teVBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLl9uYXZNb2JpbGUpXG4gICAgfVxuXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9IQU1CVVJHRVIpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICB0aGlzLl9zZWFyY2hDb21wb25lbnRzID0gW11cblxuICAgIHRoaXMuX2xldmVsMENsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUxldmVsMENsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9sZXZlbDFDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVMZXZlbDFDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3NlYXJjaENsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVNlYXJjaENsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9yZXNldE1haW5UaW1lbGluZSguLi5lbGVtZW50czogSFRNTEVsZW1lbnRbXSkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnBhdXNlKClcbiAgICBmb3IgKGxldCBlbCBvZiBlbGVtZW50cykge1xuICAgICAgYW5pbWUucmVtb3ZlKGVsISlcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltZS50aW1lbGluZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzTW9iaWxlKCkge1xuICAgIHJldHVybiBEb20uaXNIaWRkZW4odGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgdHJ1ZSkgPT09IGZhbHNlXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUxldmVsMENsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIGNvbnN0IGlzRGVza3RvcCA9ICF0aGlzLl9pc01vYmlsZSgpXG5cbiAgICBpZiAoaXNEZXNrdG9wKSB7XG4gICAgICBsZXQgbmF2SXRlbXMgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMpXG4gICAgICAgIC5mcm9tTGV2ZWwwKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudClcblxuICAgICAgaWYgKCFuYXZJdGVtcy5zZWN0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgcHJldmlvdXNOYXZMaW5rID0gdGhpcy5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKSEgYXMgSFRNTEVsZW1lbnRcbiAgICAgIGxldCBwcmV2aW91c05hdlNlY3Rpb24gPSB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvcihRVUVSWV9TRUNUSU9OX09QRU4pISBhcyBIVE1MRWxlbWVudFxuXG4gICAgICB0aGlzLl90b2dnbGVDb250YWluZXIoXG4gICAgICAgIG5hdkl0ZW1zLmxpbmssXG4gICAgICAgIHRoaXMuX25hdkxldmVsMEJvZHksXG4gICAgICAgIG5hdkl0ZW1zLnNlY3Rpb24sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgcHJldmlvdXNOYXZMaW5rLFxuICAgICAgICB0aGlzLl9uYXZMZXZlbDBCb2R5LFxuICAgICAgICBwcmV2aW91c05hdlNlY3Rpb24sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlTGV2ZWwxQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgbGV0IG5hdkl0ZW1zID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzKVxuICAgICAgLmZyb21MZXZlbDEoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxuXG4gICAgbGV0IHByZXZJdGVtcyA9IG5hdkl0ZW1zLnByZXZpb3VzTGV2ZWwxKClcblxuICAgIHRoaXMuX3RvZ2dsZUNvbnRhaW5lcihcbiAgICAgIG5hdkl0ZW1zLmxpbmssXG4gICAgICBuYXZJdGVtcy5jb250YWluZXIsXG4gICAgICBuYXZJdGVtcy5zZWN0aW9uLFxuICAgICAgbmF2SXRlbXMuZm9vdGVyLFxuICAgICAgcHJldkl0ZW1zLmxpbmssXG4gICAgICBwcmV2SXRlbXMuY29udGFpbmVyLFxuICAgICAgcHJldkl0ZW1zLnNlY3Rpb24sXG4gICAgICBwcmV2SXRlbXMuZm9vdGVyLFxuICAgICAgZmFsc2VcbiAgICApXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHByb3RlY3RlZCBfdG9nZ2xlQ29udGFpbmVyKFxuICAgIG5hdkxpbms6IEhUTUxFbGVtZW50LFxuICAgIG5hdkNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICAgIG5hdlNlY3Rpb24/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZGb290ZXI/OiBIVE1MRWxlbWVudCxcbiAgICBwcmV2aW91c05hdkxpbms/OiBIVE1MRWxlbWVudCxcbiAgICBwcmV2aW91c05hdkNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICAgIHByZXZpb3VzTmF2U2VjdGlvbj86IEhUTUxFbGVtZW50LFxuICAgIHByZXZpb3VzTmF2Rm9vdGVyPzogSFRNTEVsZW1lbnQsXG4gICAgYW5pbWF0ZUNvbnRhaW5lciA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IGlzRGVza3RvcCA9ICF0aGlzLl9pc01vYmlsZSgpXG5cbiAgICBpZiAocHJldmlvdXNOYXZMaW5rICYmIHByZXZpb3VzTmF2TGluayAhPT0gbmF2TGluayAmJiBuYXZMaW5rICE9PSB0aGlzLl9oYW1idXJnZXJFbGVtZW50KSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3MocHJldmlvdXNOYXZMaW5rLCBDTEFTU19BQ1RJVkUpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVzZXRNYWluVGltZWxpbmUobmF2Q29udGFpbmVyISwgbmF2U2VjdGlvbiEsIG5hdkZvb3RlciEsIHByZXZpb3VzTmF2Q29udGFpbmVyISwgcHJldmlvdXNOYXZTZWN0aW9uISwgcHJldmlvdXNOYXZGb290ZXIhKVxuXG4gICAgaWYgKERvbS5oYXNDbGFzcyhuYXZMaW5rLCBDTEFTU19BQ1RJVkUpKSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2TGluaywgQ0xBU1NfQUNUSVZFKVxuXG4gICAgICBpZiAoaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMuX29uTmF2aWdhdGlvbkNsb3NlZCgpXG5cbiAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfSBlbHNlIGlmIChuYXZMaW5rID09PSB0aGlzLl9oYW1idXJnZXJFbGVtZW50KSB7XG4gICAgICAgIC8vIENsb3NlIG1vYmlsZSBuYXZpZ2F0aW9uXG4gICAgICAgIHRoaXMuX29uTmF2aWdhdGlvbkNsb3NlZCgpXG5cbiAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgdW5kZWZpbmVkLCBmYWxzZSwgZmFsc2UpXG4gICAgICB9IGVsc2UgaWYgKCFpc0Rlc2t0b3ApIHtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNlY3Rpb25cbiAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBEb20uYWRkQ2xhc3MobmF2TGluaywgQ0xBU1NfQUNUSVZFKVxuXG4gICAgICBpZiAoaXNEZXNrdG9wKSB7XG4gICAgICAgIERvbS5hZGRDbGFzcyh0aGlzLl9uYXZNb2JpbGUsIENMQVNTX09QRU4pXG4gICAgICAgIHRoaXMuX29uTmF2aWdhdGlvbk9wZW5lZCgpXG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmF2Q29udGFpbmVyICYmIHByZXZpb3VzTmF2U2VjdGlvbikge1xuICAgICAgICAgIHRoaXMuX2Nsb3NlU2VjdGlvbihwcmV2aW91c05hdkNvbnRhaW5lciwgcHJldmlvdXNOYXZTZWN0aW9uLCBwcmV2aW91c05hdkZvb3RlciwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuU2VjdGlvbihuYXZDb250YWluZXIsIG5hdlNlY3Rpb24sIG5hdkZvb3RlciwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgIH0gZWxzZSBpZiAobmF2TGluayA9PT0gdGhpcy5faGFtYnVyZ2VyRWxlbWVudCkge1xuICAgICAgICAvLyBPcGVuIG1vYmlsZSBuYXZpZ2F0aW9uXG4gICAgICAgIHRoaXMuX29uTmF2aWdhdGlvbk9wZW5lZCgpXG5cbiAgICAgICAgdGhpcy5fb3BlblNlY3Rpb24obmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCB1bmRlZmluZWQsIGZhbHNlLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzRGVza3RvcCkge1xuICAgICAgICAvLyBPcGVuIHNlY3Rpb25cbiAgICAgICAgaWYgKHByZXZpb3VzTmF2Q29udGFpbmVyICYmIHByZXZpb3VzTmF2U2VjdGlvbikge1xuICAgICAgICAgIHRoaXMuX2Nsb3NlU2VjdGlvbihwcmV2aW91c05hdkNvbnRhaW5lciwgcHJldmlvdXNOYXZTZWN0aW9uLCBwcmV2aW91c05hdkZvb3RlciwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuU2VjdGlvbihuYXZDb250YWluZXIsIG5hdlNlY3Rpb24sIG5hdkZvb3RlciwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX29uTmF2aWdhdGlvbk9wZW5lZCgpIHtcbiAgICBEb20uYWRkQ2xhc3ModGhpcy5fbmF2TW9iaWxlLCBDTEFTU19PUEVOKVxuICAgIERvbS5hZGRDbGFzcyh0aGlzLl9uYXZNb2JpbGUucGFyZW50RWxlbWVudCEsIENMQVNTX09QRU4pXG4gICAgRG9tLmFkZENsYXNzKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIENMQVNTX0FDVElWRSlcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vbk5hdmlnYXRpb25DbG9zZWQoKSB7XG4gICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuX25hdk1vYmlsZSwgQ0xBU1NfT1BFTilcbiAgICBEb20ucmVtb3ZlQ2xhc3ModGhpcy5fbmF2TW9iaWxlLnBhcmVudEVsZW1lbnQhLCBDTEFTU19PUEVOKVxuICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLl9oYW1idXJnZXJFbGVtZW50LCBDTEFTU19BQ1RJVkUpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgd2hpbGUgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICYmIHRhcmdldC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIGlmICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vcGVuU2VjdGlvbihcbiAgICBuYXZDb250YWluZXI/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZTZWN0aW9uPzogSFRNTEVsZW1lbnQsXG4gICAgbmF2Rm9vdGVyPzogSFRNTEVsZW1lbnQsXG4gICAgYW5pbWF0ZUNvbHVtbnMgPSB0cnVlLFxuICAgIGFuaW1hdGVDb250YWluZXIgPSBmYWxzZVxuICApIHtcbiAgICBpZiAoIW5hdlNlY3Rpb24gfHwgIW5hdkNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZUl0ZW1zID0gbmF2U2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9DT0xVTU4pXG5cbiAgICBpZiAoYW5pbWF0ZUNvbnRhaW5lciA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IG5hdkNvbnRhaW5lclxuICAgICAgbmF2Q29udGFpbmVyID0gbmF2U2VjdGlvblxuICAgICAgbmF2U2VjdGlvbiA9IGNvbnRhaW5lclxuICAgIH1cblxuICAgIERvbS5hZGRDbGFzcyhuYXZDb250YWluZXIhLCBDTEFTU19PUEVOKVxuXG4gICAgbmF2U2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG5cbiAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgdGFyZ2V0czogbmF2U2VjdGlvbixcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fQk9EWV9EVVJBVElPTixcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgaGVpZ2h0OiBhbmltYXRlQ29udGFpbmVyID8gbmF2Q29udGFpbmVyLnNjcm9sbEhlaWdodCA6IG5hdlNlY3Rpb24uc2Nyb2xsSGVpZ2h0LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgRG9tLmFkZENsYXNzKG5hdlNlY3Rpb24hLCBDTEFTU19PUEVOKVxuICAgICAgICBuZXcgRG9tRWxlbWVudChuYXZTZWN0aW9uISkuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKG5hdkZvb3Rlcikge1xuICAgICAgY29uc3QgbmF2SXRlbXMgPSBuYXZGb290ZXIucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfQ09MVU1OKVxuICAgICAgZm9yIChsZXQgaXRlbSBvZiBuYXZJdGVtcykge1xuICAgICAgICBEb20uYWRkQ2xhc3MoaXRlbSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgfVxuXG4gICAgICBuYXZGb290ZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBuYXZGb290ZXIsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OLFxuICAgICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgICAgaGVpZ2h0OiBuYXZGb290ZXIuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBvZmZzZXQ6IGAtPSR7QU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTn1gLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIERvbS5hZGRDbGFzcyhuYXZGb290ZXIhLCBDTEFTU19PUEVOKVxuICAgICAgICAgIG5ldyBEb21FbGVtZW50KG5hdkZvb3RlciEpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGVDb2x1bW5zID09PSB0cnVlKSB7XG4gICAgICBsZXQgZGVsYXkgPSBBTklNQVRJT05fU1RBUlRfREVMQVlcblxuICAgICAgZm9yIChsZXQgaXRlbSBvZiBhY3RpdmVJdGVtcykge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICAgIHRhcmdldHM6IGl0ZW0sXG4gICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgb2Zmc2V0OiBkZWxheSxcbiAgICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgRG9tLmFkZENsYXNzKGl0ZW0sIENMQVNTX0FDVElWRSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGRlbGF5ICs9IEFOSU1BVElPTl9PRkZTRVRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Nsb3NlU2VjdGlvbihcbiAgICBuYXZDb250YWluZXI/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZTZWN0aW9uPzogSFRNTEVsZW1lbnQsXG4gICAgbmF2Rm9vdGVyPzogSFRNTEVsZW1lbnQsXG4gICAgYW5pbWF0ZUNvbHVtbnMgPSB0cnVlLFxuICAgIGFuaW1hdGVDb250YWluZXIgPSBmYWxzZVxuICApIHtcbiAgICBpZiAoIW5hdlNlY3Rpb24gfHwgIW5hdkNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZUl0ZW1zID0gbmF2U2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9DT0xVTU5fQUNUSVZFKVxuXG4gICAgaWYgKGFuaW1hdGVDb250YWluZXIgPT09IHRydWUpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSBuYXZDb250YWluZXJcbiAgICAgIG5hdkNvbnRhaW5lciA9IG5hdlNlY3Rpb25cbiAgICAgIG5hdlNlY3Rpb24gPSBjb250YWluZXJcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZUNvbHVtbnMgPT09IHRydWUpIHtcbiAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBhY3RpdmVJdGVtcykge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoYWN0aXZlLCBDTEFTU19BQ1RJVkUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgIHRhcmdldHM6IG5hdlNlY3Rpb24sXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0JPRFlfRFVSQVRJT04sXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZDb250YWluZXIhLCBDTEFTU19PUEVOKVxuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2U2VjdGlvbiEsIENMQVNTX09QRU4pXG4gICAgICAgIG5hdlNlY3Rpb24hLnN0eWxlLmhlaWdodCA9IFwiXCJcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKG5hdkZvb3Rlcikge1xuICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIG5hdkZvb3Rlci5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9DT0xVTU5fQUNUSVZFKSkge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoYWN0aXZlLCBDTEFTU19BQ1RJVkUpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IG5hdkZvb3RlcixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04sXG4gICAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2Rm9vdGVyISwgQ0xBU1NfT1BFTilcbiAgICAgICAgICBuYXZGb290ZXIhLnN0eWxlLmhlaWdodCA9IFwiXCJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVNlYXJjaENsaWNrKCkge1xuICAgIGlmICh0aGlzLl9zZWFyY2hEZXNrdG9wKSB7XG4gICAgICB0aGlzLl9zZWFyY2hEZXNrdG9wLm9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbmF2aWdhdGlvbiBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgZm9yIChsZXQgbmF2TGluayBvZiB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfTEVWRUwwX0xJTkspKSB7XG4gICAgICBuYXZMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9sZXZlbDBDbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgbmF2TGluayBvZiB0aGlzLl9uYXZMZXZlbDEucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfTEVWRUwxX0xJTkspKSB7XG4gICAgICBuYXZMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9sZXZlbDFDbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbGV2ZWwxQ2xpY2tIYW5kbGVyKVxuXG4gICAgLy8gRGVza3RvcCBzZWFyY2ggaWNvblxuICAgIGxldCBzZWFyY2hJY29uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0VBUkNIX0lDT04pXG4gICAgaWYgKHNlYXJjaEljb24pIHtcbiAgICAgIHNlYXJjaEljb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3NlYXJjaENsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBzZWFyY2ggb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfU0VBUkNIX0ZJRUxEKSkge1xuICAgICAgbGV0IHNlYXJjaENvbXBvbmVudCA9IG5ldyBTZWFyY2hJbnB1dChzZWFyY2ggYXMgSFRNTEVsZW1lbnQpXG5cbiAgICAgIGlmIChEb20uaGFzQ2xhc3Moc2VhcmNoLCBDTEFTU19TRUFSQ0hfREVTS1RPUCkgfHwgRG9tLmhhc0NsYXNzKHNlYXJjaC5wYXJlbnRFbGVtZW50ISwgQ0xBU1NfU0VBUkNIX0RFU0tUT1ApKSB7XG4gICAgICAgIHRoaXMuX3NlYXJjaERlc2t0b3AgPSBzZWFyY2hDb21wb25lbnRcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VhcmNoQ29tcG9uZW50cy5wdXNoKHNlYXJjaENvbXBvbmVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIGxldCBpc01vYmxlID0gdGhpcy5faXNNb2JpbGUoKVxuXG4gICAgbGV0IGxldmVsMSA9IHRoaXMuX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSkgYXMgSFRNTEVsZW1lbnRcbiAgICBsZXQgbGV2ZWwwID0gdGhpcy5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKSBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKCFsZXZlbDEgJiYgaXNNb2JsZSAmJiBEb20uaGFzQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKSkge1xuICAgICAgbGV2ZWwxID0gdGhpcy5faGFtYnVyZ2VyRWxlbWVudFxuICAgIH1cblxuICAgIGxldCBuYXZJdGVtc1xuXG4gICAgaWYgKGxldmVsMSkge1xuICAgICAgbmF2SXRlbXMgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMpLmZyb21MZXZlbDEobGV2ZWwxKVxuICAgIH0gZWxzZSBpZiAobGV2ZWwwKSB7XG4gICAgICBuYXZJdGVtcyA9IG5ldyBOYXZpZ2F0aW9uSXRlbXModGhpcykuZnJvbUxldmVsMChsZXZlbDApXG4gICAgfVxuXG4gICAgaWYgKG5hdkl0ZW1zKSB7XG4gICAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZShuYXZJdGVtcy5jb250YWluZXIhLCBuYXZJdGVtcy5zZWN0aW9uISwgbmF2SXRlbXMuZm9vdGVyISlcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZJdGVtcy5saW5rLCBDTEFTU19BQ1RJVkUpXG4gICAgICB0aGlzLl9vbk5hdmlnYXRpb25DbG9zZWQoKVxuICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkl0ZW1zLmNvbnRhaW5lciEsIG5hdkl0ZW1zLnNlY3Rpb24hLCBuYXZJdGVtcy5mb290ZXIsICFpc01vYmxlLCBmYWxzZSlcbiAgICB9XG5cbiAgfVxufVxuXG5jbGFzcyBOYXZpZ2F0aW9uSXRlbXMge1xuICBwcml2YXRlIF9uYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uXG4gIHByaXZhdGUgX2xpbmshOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9jb250YWluZXI/OiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9zZWN0aW9uPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfZm9vdGVyPzogSFRNTEVsZW1lbnRcbiAgY29uc3RydWN0b3IobmF2OiBOYXZpZ2F0aW9uKSB7XG4gICAgdGhpcy5fbmF2aWdhdGlvbiA9IG5hdlxuICB9XG5cbiAgZ2V0IGxpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmtcbiAgfVxuXG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICB9XG5cbiAgZ2V0IHNlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25cbiAgfVxuXG4gIGdldCBmb290ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvb3RlclxuICB9XG5cbiAgcHVibGljIGZyb21MZXZlbDAobmF2TGluazogSFRNTEVsZW1lbnQpIHtcbiAgICB3aGlsZSAoIURvbS5oYXNDbGFzcyhuYXZMaW5rLCBDTEFTU19OQVZfTElOSykgJiYgbmF2TGluay5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBuYXZMaW5rID0gbmF2TGluay5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgdGhpcy5fbGluayA9IG5hdkxpbmtcblxuICAgIGxldCB0b2dnbGVJZCA9IG5hdkxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS10b2dnbGVcIilcbiAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9uYXZpZ2F0aW9uLl9uYXZMZXZlbDBCb2R5XG4gICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMC5xdWVyeVNlbGVjdG9yKGAjJHt0b2dnbGVJZH1gKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgZnJvbUxldmVsMShuYXZMaW5rOiBIVE1MRWxlbWVudCkge1xuICAgIHdoaWxlIChuYXZMaW5rLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlmICgobmF2TGluayA9PT0gdGhpcy5fbmF2aWdhdGlvbi5faGFtYnVyZ2VyRWxlbWVudCkgfHwgRG9tLmhhc0NsYXNzKG5hdkxpbmssIENMQVNTX05BVl9MSU5LKSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBuYXZMaW5rID0gbmF2TGluay5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgdGhpcy5fbGluayA9IG5hdkxpbmtcbiAgICB0aGlzLl9jb250YWluZXIgPSBuYXZMaW5rLnBhcmVudEVsZW1lbnQhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX2NvbnRhaW5lciEucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfQk9EWSkhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fZm9vdGVyID0gdGhpcy5fY29udGFpbmVyIS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9GT09URVIpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKG5hdkxpbmsgPT09IHRoaXMuX25hdmlnYXRpb24uX2hhbWJ1cmdlckVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMVxuICAgICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9IQl9CT0RZKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIHByZXZpb3VzTGV2ZWwxKCkge1xuICAgIGxldCBwcmV2ID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzLl9uYXZpZ2F0aW9uKVxuXG4gICAgcHJldi5fbGluayA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSkhIGFzIEhUTUxFbGVtZW50XG4gICAgcHJldi5fY29udGFpbmVyID0gcHJldi5fbGluayA/IHByZXYuX2xpbmsucGFyZW50RWxlbWVudCEgOiB1bmRlZmluZWRcbiAgICBwcmV2Ll9zZWN0aW9uID0gcHJldi5fY29udGFpbmVyID8gcHJldi5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0JPRFkpISBhcyBIVE1MRWxlbWVudCA6IHVuZGVmaW5lZFxuICAgIHByZXYuX2Zvb3RlciA9IHByZXYuX2NvbnRhaW5lciA/IHByZXYuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9GT09URVIpISBhcyBIVE1MRWxlbWVudCA6IHVuZGVmaW5lZFxuXG4gICAgcmV0dXJuIHByZXZcbiAgfVxuXG4gIHB1YmxpYyBpc0hhbWJ1cmdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluayA9PT0gdGhpcy5fbmF2aWdhdGlvbi5faGFtYnVyZ2VyRWxlbWVudFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLm5hdlwiLCAoZSkgPT4ge1xuICAgIG5ldyBOYXZpZ2F0aW9uKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRpb25cbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9TSVRFX1dSQVBQRVIgPSBcIi5qcy1zaXRlLXdyYXBwZXJcIlxuY29uc3QgUVVFUllfTkFWX0hBTUJVUkdFUiA9IFwiLmpzLXNpdGUtd3JhcHBlciAuanMtaGFtYnVyZ2VyXCJcblxuY29uc3QgUVVFUllfTkFWX0lURU0gPSBcIi5qcy1uYXYtaXRlbVwiXG5cbmNvbnN0IE5BVl9MSU5LX0lOSVRJQUxfU0NBTEUgPSAwLjlcbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTl9MSU5LUyA9IDEwMFxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OX05BViA9IDMwMFxuXG5jb25zdCBBTklNQVRJT05fU1RBR0dFUl9ERUxBWSA9IDUwXG5cbi8qKlxuICogVGhlIG5hdmlnYXRpb24gc2lkZSBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvblNpZGUgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfY2xpY2tIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX3NpdGVXcmFwcGVyOiBFbGVtZW50XG4gIHByaXZhdGUgX2hhbWJ1cmdlckVsZW1lbnQ6IEVsZW1lbnRcbiAgcHJpdmF0ZSBfbmF2SXRlbXM6IE5vZGVMaXN0T2Y8RWxlbWVudD5cblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9zaXRlV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0lURV9XUkFQUEVSKSFcbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfSEFNQlVSR0VSKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fbmF2SXRlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfSVRFTSkhXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgRWxlbWVudFxuXG4gICAgd2hpbGUgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICYmIHRhcmdldC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIGlmICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNpZGUgbmF2aWdhdGlvbi5cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIHNsaWRlIG5hdmlnYXRpb24uXG4gICAqL1xuICBwdWJsaWMgb3BlbigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgfSwgNTApXG5cbiAgICBhZGRDbGFzcyh0aGlzLl9oYW1idXJnZXJFbGVtZW50LCBDTEFTU19BQ1RJVkUpXG4gICAgYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuICAgIGFkZENsYXNzKHRoaXMuX3NpdGVXcmFwcGVyLCBDTEFTU19PUEVOKVxuXG4gICAgY29uc3QgeCA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICBsZXQgb2ZmID0gQU5JTUFUSU9OX0RVUkFUSU9OX05BVlxuICAgIHRoaXMuX25hdkl0ZW1zLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IFwiMFwiXG4gICAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtOQVZfTElOS19JTklUSUFMX1NDQUxFfSlgXG4gICAgICB4LmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OX0xJTktTLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgZWFzaW5nOiBcImxpbmVhclwiLFxuICAgICAgICBvZmZzZXQ6IG9mZlxuICAgICAgfSlcbiAgICAgIG9mZiArPSBBTklNQVRJT05fU1RBR0dFUl9ERUxBWVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzaWRlIG5hdmlnYXRpb24uXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICByZW1vdmVDbGFzcyh0aGlzLl9oYW1idXJnZXJFbGVtZW50LCBDTEFTU19BQ1RJVkUpXG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuICAgIHJlbW92ZUNsYXNzKHRoaXMuX3NpdGVXcmFwcGVyLCBDTEFTU19PUEVOKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIHJlbW92ZXMgYWxsIGV2ZW50XG4gICAqIHN1YnNjcmlwdGlvbnMgYW5kIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcik7XG5cbiAgICAodGhpcyBhcyBhbnkpLl93aW5kb3dDbGlja0hhbmRsZXIgPSBudWxsO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fY2xpY2tIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9zaXRlV3JhcHBlciA9IG51bGw7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9oYW1idXJnZXJFbGVtZW50ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9uYXZJdGVtcyA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5uYXYtc2lkZVwiLCAoZSkgPT4ge1xuICAgIG5ldyBOYXZpZ2F0aW9uU2lkZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0aW9uU2lkZVxuIiwiaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19OT1RJRklDQVRJT04gPSBcIm5vdGlmaWNhdGlvbi1oZWFkZXJcIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJub3RpZmljYXRpb24tLW9wZW5cIlxuY29uc3QgQ0xBU1NfQlVUVE9OX0NMT1NFID0gXCJub3RpZmljYXRpb25fX2Nsb3NlXCJcblxuLyoqXG4gKiBOb3RpZmljYXRpb24gY29tcG9uZW50LlxuICogQG5hbWVzcGFjZSBOb3RpZmljYXRpb25cbiAqL1xuXG4vKipcbiAqIFRoZSBtZXNzYWdlIGNsaWNrIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQG1lbWJlcm9mIE5vdGlmaWNhdGlvblxuICogQGNhbGxiYWNrIE5vdGlmaWNhdGlvbn5DbGlja1xuICogQHByb3BlcnR5IHtOb3RpZmljYXRpb25IZWFkZXJ9IGl0ZW0gLSBUaGUgY3VycmVudCBub3RpZmljYXRpb24gaGVhZGVyIGluc3RhbmNlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiB0cnVlIGlmIHRoZSBub3RpZmljYXRpb24gc2hvdWxkIGJlIGNsb3NlZDsgcmV0dXJuIGZhbHNlIGlmIHRoZVxuICogICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbiBzaG91bGQgcmVtYWluIG9wZW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUNsaWNrQ2FsbGJhY2sge1xuICAoaGVhZGVyOiBOb3RpZmljYXRpb25IZWFkZXIpOiBib29sZWFuIHwgdW5kZWZpbmVkXG59XG5cbi8qKlxuICogVGhlIGNhbmNlbCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBtZW1iZXJvZiBOb3RpZmljYXRpb25cbiAqIEBjYWxsYmFjayBOb3RpZmljYXRpb25+Q2FuY2VsXG4gKiBAcHJvcGVydHkge05vdGlmaWNhdGlvbkhlYWRlcn0gaXRlbSAtIFRoZSBjdXJyZW50IG5vdGlmaWNhdGlvbiBoZWFkZXIgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsQ2FsbGJhY2sge1xuICAoaGVhZGVyOiBOb3RpZmljYXRpb25IZWFkZXIpOiB2b2lkXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgc2hvd3MgYSBub3RpZmljYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UuXG4gKiBAbWVtYmVyb2YgTm90aWZpY2F0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGFpbmVySWQgLSBUaGUgaWQgb2YgdGhlIGNvbnRhaW5lciBvbiB3aGVyZSB0byBzaG93IHRoZSBub3RpZmljYXRpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHNob3cuXG4gKiBAcGFyYW0ge05vdGlmaWNhdGlvbn5DbGlja30gbWVzc2FnZUNsaWNrQ2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbm90aWZpY2F0aW9uIG1lc3NhZ2UgdGV4dC5cbiAqIEBwYXJhbSB7Tm90aWZpY2F0aW9ufkNhbmNlbH0gY2FuY2VsQ2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIG5vdGlmaWNhdGlvbiBieSBjbG9zaW5nIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyQ2xhc3MgLSBUaGUgY3NzIG1vZGlmaWVyIGNsYXNzIGZvciB0aGUgbm90aWZpY2F0aW9uOyB0aGlzIGlzIGFuIG9wdGlvbmFsIHBhcmFtZXRlclxuICogQHJldHVybnMge05vdGlmaWNhdGlvbkhlYWRlcn0gVGhlIG5vdGlmaWNhdGlvbiBoZWFkZXIgaXRlbSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3dPbkhlYWRlcihcbiAgY29udGFpbmVySWQ6IHN0cmluZyxcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBtZXNzYWdlQ2xpY2tDYWxsYmFjaz86IE1lc3NhZ2VDbGlja0NhbGxiYWNrLFxuICBjYW5jZWxDYWxsYmFjaz86IENhbmNlbENhbGxiYWNrLFxuICBtb2RpZmllckNsYXNzPzogc3RyaW5nXG4pIHtcblxuICBjb25zdCBjb250YWluZXJFID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7Y29udGFpbmVySWR9YClcbiAgaWYgKCFjb250YWluZXJFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCB0aGUgY29udGFpbmVyIHdpdGggaWQgJHtjb250YWluZXJJZH1gKVxuICB9XG5cbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KGNvbnRhaW5lckUpXG4gIGNvbnN0IG5vdGlmaWNhdGlvbkVsZW1lbnQgPSBuZXcgTm90aWZpY2F0aW9uSGVhZGVyKClcblxuICBpZiAobW9kaWZpZXJDbGFzcykge1xuICAgIG5vdGlmaWNhdGlvbkVsZW1lbnQuYWRkQ2xhc3MobW9kaWZpZXJDbGFzcylcbiAgfVxuXG4gIG5vdGlmaWNhdGlvbkVsZW1lbnQubWVzc2FnZSA9IG1lc3NhZ2VcbiAgbm90aWZpY2F0aW9uRWxlbWVudC5tZXNzYWdlQ2xpY2tDYWxsYmFjayA9IG1lc3NhZ2VDbGlja0NhbGxiYWNrXG4gIG5vdGlmaWNhdGlvbkVsZW1lbnQuY2FuY2VsQ2FsbGJhY2sgPSBjYW5jZWxDYWxsYmFja1xuXG4gIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQobm90aWZpY2F0aW9uRWxlbWVudClcbiAgbm90aWZpY2F0aW9uRWxlbWVudC5fb3BlbigpXG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbkVsZW1lbnRcbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBub3RpZmljYXRpb25zIG9uIHRoZSBwYWdlLWhlYWRlci5cbiAqIEBpbm5lclxuICogQG1lbWJlcm9mIE5vdGlmaWNhdGlvblxuICovXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uSGVhZGVyIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2Nsb3NlSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9jYWxsYmFjaz86IE1lc3NhZ2VDbGlja0NhbGxiYWNrXG4gIHByaXZhdGUgX2NhbmNlbENhbGxiYWNrPzogQ2FuY2VsQ2FsbGJhY2tcblxuICBwcml2YXRlIF9jbG9zZUJ1dHRvbiE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uQm9keSE6IERvbUVsZW1lbnQ8RWxlbWVudD5cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImRpdlwiKVxuXG4gICAgdGhpcy5fY2xvc2VIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xvc2UuYmluZCh0aGlzKVxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSByYW5nZSBtb2RhbCBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19OT1RJRklDQVRJT04pXG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuXG4gICAgY29uc3Qgbm90aWZpY2F0aW9uQ29udGVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoXCJub3RpZmljYXRpb25fX2NvbnRlbnRcIilcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQobm90aWZpY2F0aW9uQ29udGVudClcblxuICAgIHRoaXMuX25vdGlmaWNhdGlvbkJvZHkgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwibm90aWZpY2F0aW9uX19ib2R5XCIpXG5cbiAgICBub3RpZmljYXRpb25Db250ZW50LmFwcGVuZENoaWxkKHRoaXMuX25vdGlmaWNhdGlvbkJvZHkpXG5cbiAgICB0aGlzLl9jbG9zZUJ1dHRvbiA9IG5ldyBEb21FbGVtZW50KFwiYnV0dG9uXCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQlVUVE9OX0NMT1NFKVxuICAgICAgLmFkZENsYXNzKFwibm90aWZpY2F0aW9uLWNhbmNlbFwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJDbG9zZVwiKVxuXG4gICAgY29uc3QgY2xvc2VJY29uID0gbmV3IERvbUVsZW1lbnQoXCJpXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uLTAyMi1jbG9zZVwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKVxuXG4gICAgdGhpcy5fY2xvc2VCdXR0b24uYXBwZW5kQ2hpbGQoY2xvc2VJY29uKVxuICAgIG5vdGlmaWNhdGlvbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5fY2xvc2VCdXR0b24pXG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG5cbiAgICBsZXQgY2xvc2VOb3RpZmljYXRpb24gPSB0cnVlXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5fY2FsbGJhY2sodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNsb3NlTm90aWZpY2F0aW9uID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xvc2VOb3RpZmljYXRpb24gPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xvc2UoZXZlbnQ6IEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICh0aGlzLl9jYW5jZWxDYWxsYmFjaykge1xuICAgICAgdGhpcy5fY2FuY2VsQ2FsbGJhY2sodGhpcylcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2UoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2Nsb3NlSGFuZGxlcilcblxuICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICBpZiAoZWwgJiYgZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKVxuICAgICAgfVxuICAgIH0sIDMwMClcbiAgfVxuXG4gIC8vIGNhbGxlZCBieSBzaG93T25IZWFkZXJcbiAgcHVibGljIF9vcGVuKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcblxuICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2Nsb3NlSGFuZGxlcilcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJvcGVuZWRcIilcbiAgfVxuXG4gIHNldCBtZXNzYWdlQ2xpY2tDYWxsYmFjayhjYWxsYmFjazogTWVzc2FnZUNsaWNrQ2FsbGJhY2sgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FuY2VsIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgc2V0IGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrOiBDYW5jZWxDYWxsYmFjayB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2NhbmNlbENhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIG1lc3NhZ2UgdG8gc2V0LlxuICAgKi9cbiAgc2V0IG1lc3NhZ2UodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX25vdGlmaWNhdGlvbkJvZHkuc2V0SHRtbCh2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICB0aGlzLl9jbG9zZSgpXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2xvc2VkXCIpXG4gIH1cbn1cbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBjbGFtcCwgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19IRUFERVIgPSBcIi5wcm9ncmVzcy1mdWxsX19iYXJcIlxuY29uc3QgQ0xBU1NfU0VDVElPTlMgPSBcIi5wcm9ncmVzcy1mdWxsX19zZWN0aW9ucyA+IHNwYW5cIlxuY29uc3QgQ0xBU1NfU0VDVElPTl9BQ1RJVkUgPSBcInNlY3Rpb24tLWFjdGl2ZVwiXG5cbmNvbnN0IENMQVNTX0lORElDQVRPUiA9IFwiaW5kaWNhdG9yXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9DVVJSRU5UID0gXCJpbmRpY2F0b3ItLWN1cnJlbnRcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRCA9IFwiaW5kaWNhdG9yLS1jb21wbGV0ZWRcIlxuXG4vKipcbiAqIEZ1bGwgcHJvZ3Jlc3MgYmFyIGNvbXBvbmVudFxuICovXG5jbGFzcyBQcm9ncmVzc0Z1bGwgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfYnV0dG9uQ2xpY2tIYW5kbGVyITogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleWRvd25IYW5kbGVyITogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfaGVhZGVyRWxlbWVudCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfcGFnZXMhOiBOb2RlTGlzdE9mPEVsZW1lbnQ+XG5cbiAgcHJpdmF0ZSBfbWluVmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdG90YWwhOiBudW1iZXJcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIFByb2dyZXNzRnVsbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBQcm9ncmVzc0Z1bGwgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGxvYWRlciBiYXIgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUJ1dHRvbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19IRUFERVIpIVxuXG4gICAgdGhpcy5fcGFnZXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19TRUNUSU9OUylcblxuICAgIHRoaXMuX21pblZhbHVlID0gMVxuICAgIHRoaXMuX3ZhbHVlID0gMVxuICAgIHRoaXMuX3RvdGFsID0gdGhpcy5fcGFnZXMubGVuZ3RoXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fcGFnZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAodGhpcy5fcGFnZXNbaW5kZXhdLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19TRUNUSU9OX0FDVElWRSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBpbmRleCArIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9hZGRJbmNpY2F0b3JzKClcbiAgICB0aGlzLl91cGRhdGUoLTEsIHRoaXMuX3ZhbHVlLCBmYWxzZSlcblxuICAgIC8vIEFwcGx5IHRoZSB0YWIgaW5kZXhcbiAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIilcbiAgICBpZiAodGFiSW5kZXgpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCJcIilcbiAgICAgIHRoaXMuX2hlYWRlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgdGFiSW5kZXgpXG4gICAgfVxuXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRJbmNpY2F0b3JzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9wYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGluZGljYXRvckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImJ1dHRvblwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SKVxuICAgICAgICAuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCBgJHtpICsgMX1gKVxuICAgICAgICAuc2V0SHRtbCgoaSArIDEpLnRvU3RyaW5nKCkpXG5cbiAgICAgIHRoaXMuX2hlYWRlckVsZW1lbnQucHJlcGVuZENoaWxkKGluZGljYXRvckVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGUob2xkVmFsdWU6IG51bWJlciwgbmV3VmFsdWU6IG51bWJlciwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICBsZXQgaW5kaWNhdG9ycyA9IHRoaXMuX2hlYWRlckVsZW1lbnQuZWxlbWVudC5jaGlsZE5vZGVzXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaW5kaWNhdG9ycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBpbmRpY2F0b3JFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoaW5kaWNhdG9yc1tpbmRleF0gYXMgRWxlbWVudClcblxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIGluZGljYXRvckVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQpXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9DT01QTEVURUQpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCArIDEgPT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIGluZGljYXRvckVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRClcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCArIDEgPiB0aGlzLl92YWx1ZSkge1xuICAgICAgICBpbmRpY2F0b3JFbGVtZW50XG4gICAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX0lORElDQVRPUl9DT01QTEVURUQpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX0lORElDQVRPUl9DVVJSRU5UKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGxldCBkaXJlY3Rpb24gPSBNYXRoLnNpZ24ob2xkVmFsdWUgLSBuZXdWYWx1ZSlcblxuICAgICAgaWYgKG9sZFZhbHVlID4gMCAmJiBvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZFNlY3Rpb24gPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9wYWdlc1tvbGRWYWx1ZSAtIDFdKVxuXG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgYW5pbWUoe1xuICAgICAgICAgICAgdGFyZ2V0czogb2xkU2VjdGlvbi5lbGVtZW50LFxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGxlZnQ6IDEwMCAqIGRpcmVjdGlvbixcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIG9sZFNlY3Rpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgICAgIG9sZFNlY3Rpb24uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZFNlY3Rpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgb2xkU2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdTZWN0aW9uID0gbmV3IERvbUVsZW1lbnQodGhpcy5fcGFnZXNbbmV3VmFsdWUgLSAxXSlcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgY29uc3QgZWwgPSBuZXdTZWN0aW9uLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IGAkey0xMDAgKiBkaXJlY3Rpb259cHhgXG4gICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgICAgICBuZXdTZWN0aW9uLmFkZENsYXNzKENMQVNTX1NFQ1RJT05fQUNUSVZFKVxuICAgICAgICBhbmltZSh7XG4gICAgICAgICAgdGFyZ2V0czogbmV3U2VjdGlvbi5lbGVtZW50LFxuICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBuZXdTZWN0aW9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U2VjdGlvbi5hZGRDbGFzcyhDTEFTU19TRUNUSU9OX0FDVElWRSlcbiAgICAgICAgbmV3U2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQnV0dG9uQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgbGV0IGVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChldmVudC50YXJnZXQgYXMgRWxlbWVudClcbiAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUhKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBFdmVudCkge1xuICAgIGNvbnN0IGtleWJvYXJkRXZlbnQgPSBldmVudCBhcyBLZXlib2FyZEV2ZW50XG4gICAgbGV0IGtleWNvZGUgPSBrZXlib2FyZEV2ZW50LndoaWNoIHx8IGtleWJvYXJkRXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfUklHSFQpIHtcbiAgICAgIHRoaXMudmFsdWUrK1xuXG4gICAgICBwcmV2ZW50RGVmYXVsdChrZXlib2FyZEV2ZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfTEVGVCkge1xuICAgICAgdGhpcy52YWx1ZS0tXG5cbiAgICAgIHByZXZlbnREZWZhdWx0KGtleWJvYXJkRXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA+PSBJbnB1dHMuS0VZX05SXzAgJiYga2V5Y29kZSA8PSBJbnB1dHMuS0VZX05SXzkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBrZXljb2RlIC0gSW5wdXRzLktFWV9OUl8wXG4gICAgICBwcmV2ZW50RGVmYXVsdChrZXlib2FyZEV2ZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgdmFsdWUgaW4gdGhlIHJhbmdlIG9mIDEuLnRvdGFsLlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAtIFRoZSBwcm9ncmVzcyBpbiB0aGUgcmFuZ2Ugb2YgMS4udG90YWwuXG4gICAqL1xuICBzZXQgdmFsdWUodmFsOiBudW1iZXIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3ZhbHVlXG5cbiAgICB0aGlzLl92YWx1ZSA9IGNsYW1wKHZhbCwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX3RvdGFsKVxuICAgIHRoaXMuX3VwZGF0ZShvbGRWYWx1ZSwgdGhpcy5fdmFsdWUsIHRydWUpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqL1xuICBnZXQgdG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIucHJvZ3Jlc3MtZnVsbFwiLCAoZSkgPT4ge1xuICAgIG5ldyBQcm9ncmVzc0Z1bGwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvZ3Jlc3NGdWxsXG4iLCJpbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgY2xhbXAgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19CQVIgPSBcIi5wcm9ncmVzcy1saWdodF9fYmFyXCJcbmNvbnN0IENMQVNTX1BST0dSRVNTID0gXCIuYmFyX19wcm9ncmVzc1wiXG5jb25zdCBDTEFTU19QUk9HUkVTU19DT01QTEVURUQgPSBcImJhcl9fcHJvZ3Jlc3MtLWNvbXBsZXRlXCJcbmNvbnN0IENMQVNTX1RJQ0sgPSBcImJhcl9fdGlja1wiXG5jb25zdCBDTEFTU19QQUdFX0NVUlJFTlQgPSBcIi5kZXRhaWxfX2N1cnJlbnRwYWdlXCJcbmNvbnN0IENMQVNTX1BBR0VfVE9UQUwgPSBcIi5kZXRhaWxfX3RvdGFscGFnZVwiXG5cbmNvbnN0IENMQVNTX0RJU0FCTEVEID0gXCJhcnJvdy0tZGlzYWJsZWRcIlxuY29uc3QgQ0xBU1NfQlVUVE9OX0xFRlQgPSBcIi5hcnJvdy0tbGVmdFwiXG5jb25zdCBDTEFTU19CVVRUT05fUklHSFQgPSBcIi5hcnJvdy0tcmlnaHRcIlxuXG4vKipcbiAqIExpZ2h0IHByb2dyZXNzIGJhciBjb21wb25lbnRcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NMaWdodCBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9idXR0b25DbGlja0hhbmRsZXIhOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2FuaW1hdGlvbkNvbXBsZXRlZEhhbmRsZXIhOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfYmFyRWxlbWVudCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfcHJvZ3Jlc3NFbGVtZW50ITogRG9tRWxlbWVudDxFbGVtZW50PlxuICBwcml2YXRlIF9wYWdlQ3VycmVudEVsZW1lbnQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX3BhZ2VUb3RhbEVsZW1lbnQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX2J1dHRvbkxlZnQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX2J1dHRvblJpZ2h0ITogRG9tRWxlbWVudDxFbGVtZW50PlxuXG4gIHByaXZhdGUgX21pblZhbHVlITogbnVtYmVyXG4gIHByaXZhdGUgX3RvdGFsITogbnVtYmVyXG4gIHByaXZhdGUgX3ZhbHVlITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfaXRlbVdpZHRoPzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBQcm9ncmVzc0xpZ2h0IGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIFByb2dyZXNzTGlnaHQgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGxvYWRlciBiYXIgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuXG4gICAgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQnV0dG9uQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2FuaW1hdGlvbkNvbXBsZXRlZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVBbmltYXRpb25Db21wbGV0ZWQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fYmFyRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19CQVIpIVxuICAgIHRoaXMuX3Byb2dyZXNzRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19QUk9HUkVTUykhXG4gICAgdGhpcy5fcGFnZUN1cnJlbnRFbGVtZW50ID0gdGhpcy5maW5kKENMQVNTX1BBR0VfQ1VSUkVOVCkhXG4gICAgdGhpcy5fcGFnZVRvdGFsRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19QQUdFX1RPVEFMKSFcbiAgICB0aGlzLl9idXR0b25MZWZ0ID0gdGhpcy5maW5kKENMQVNTX0JVVFRPTl9MRUZUKSFcbiAgICB0aGlzLl9idXR0b25SaWdodCA9IHRoaXMuZmluZChDTEFTU19CVVRUT05fUklHSFQpIVxuXG4gICAgdGhpcy5fbWluVmFsdWUgPSAxXG4gICAgdGhpcy5fdG90YWwgPSBNYXRoLm1heChwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZShcInRvdGFsXCIpIHx8IFwiMTAwXCIsIDEwKSwgdGhpcy5fbWluVmFsdWUpXG4gICAgdGhpcy5fdmFsdWUgPSBjbGFtcChwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiMVwiLCAxMCksIHRoaXMuX21pblZhbHVlLCB0aGlzLl90b3RhbClcblxuICAgIHRoaXMuX2xheW91dCgpXG5cbiAgICB0aGlzLl9hZGRUaWNrcygpXG4gICAgdGhpcy5fdXBkYXRlKGZhbHNlKVxuXG4gICAgdGhpcy5lbmFibGUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRUaWNrcygpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX3RvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5faXRlbVdpZHRoISAqIGlcblxuICAgICAgbGV0IHRpY2tFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RJQ0spXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgbGVmdDogJHtwb3NpdGlvbn0lYClcblxuICAgICAgdGhpcy5fYmFyRWxlbWVudC5wcmVwZW5kQ2hpbGQodGlja0VsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGUoYW5pbWF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLl9wYWdlQ3VycmVudEVsZW1lbnQuc2V0SHRtbCh0aGlzLl92YWx1ZS50b1N0cmluZygpKVxuICAgIHRoaXMuX3BhZ2VUb3RhbEVsZW1lbnQuc2V0SHRtbCh0aGlzLl90b3RhbC50b1N0cmluZygpKVxuXG4gICAgbGV0IHBvc2l0aW9uID0gdGhpcy5fdmFsdWUgKiB0aGlzLl9pdGVtV2lkdGghXG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCB3aWR0aCB0byB0aGUgbGFzdCBlbGVtZW50IHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZSByb3VuZGVkIGJvcmRlciBvbiB0aGUgbGVmdCBpcyBmaWxsZWQgYXMgd2VsbFxuICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gdGhpcy5fdG90YWwpIHtcbiAgICAgIHBvc2l0aW9uICs9IDVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdmFsdWUgPj0gdGhpcy5fdG90YWwpIHtcbiAgICAgIHRoaXMuX2J1dHRvblJpZ2h0LmFkZENsYXNzKENMQVNTX0RJU0FCTEVEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idXR0b25SaWdodC5yZW1vdmVDbGFzcyhDTEFTU19ESVNBQkxFRClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdmFsdWUgPD0gdGhpcy5fbWluVmFsdWUpIHtcbiAgICAgIHRoaXMuX2J1dHRvbkxlZnQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1dHRvbkxlZnQucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG4gICAgfVxuXG4gICAgY29uc3QgZWwgPSB0aGlzLl9wcm9ncmVzc0VsZW1lbnQuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgIGlmIChhbmltYXRlKSB7XG4gICAgICBhbmltZSh7XG4gICAgICAgIHRhcmdldHM6IHRoaXMuX3Byb2dyZXNzRWxlbWVudC5lbGVtZW50LFxuICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgICAgd2lkdGg6IHRoaXMuX2JhckVsZW1lbnQuZWxlbWVudC5jbGllbnRXaWR0aCAqIHBvc2l0aW9uIC8gMTAwLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gYCR7cG9zaXRpb259JWBcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25Db21wbGV0ZWRIYW5kbGVyKDxFdmVudD57fSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUud2lkdGggPSBgJHtwb3NpdGlvbn0lYFxuICAgICAgdGhpcy5fYW5pbWF0aW9uQ29tcGxldGVkSGFuZGxlcig8RXZlbnQ+e30pXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9sYXlvdXQoKSB7XG4gICAgdGhpcy5faXRlbVdpZHRoID0gTWF0aC5mbG9vcigxMDAgLyB0aGlzLl90b3RhbClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQnV0dG9uQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fYnV0dG9uTGVmdC5lbGVtZW50KSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5fdmFsdWUgLSAxXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuX2J1dHRvblJpZ2h0LmVsZW1lbnQpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl92YWx1ZSArIDFcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUFuaW1hdGlvbkNvbXBsZXRlZCgpIHtcbiAgICBpZiAodGhpcy5fdmFsdWUgPT09IHRoaXMuX3RvdGFsKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgcHJvZ3Jlc3MgaW4gdGhlIHJhbmdlIG9mIDEuLnRvdGFsLlxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbCkge1xuICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAodmFsLCB0aGlzLl9taW5WYWx1ZSwgdGhpcy5fdG90YWwpXG4gICAgdGhpcy5fdXBkYXRlKHRydWUpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqL1xuICBnZXQgdG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUgYW5kIHVwZGF0ZXMgdGhlIFVJIGFjY29yZGluZ2x5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgdG90YWwgcHJvZ3Jlc3MgcG9zaXRpdmUgaW50ZWdlciB2YWx1ZS5cbiAgICovXG4gIHNldCB0b3RhbCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl90b3RhbCA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3RvdGFsID0gTWF0aC5tYXgodmFsdWUsIHRoaXMuX21pblZhbHVlKVxuICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAodGhpcy5fdmFsdWUsIHRoaXMuX21pblZhbHVlLCB0aGlzLl90b3RhbClcblxuICAgIC8vIENsZWFyIHRoZSB0aWNrc1xuICAgIGZvciAobGV0IHRpY2sgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1RJQ0t9YCkpIHtcbiAgICAgIHRoaXMuX2JhckVsZW1lbnQuZWxlbWVudC5yZW1vdmVDaGlsZCh0aWNrKVxuICAgIH1cblxuICAgIHRoaXMuX2xheW91dCgpXG4gICAgdGhpcy5fYWRkVGlja3MoKVxuXG4gICAgdGhpcy5fdXBkYXRlKGZhbHNlKVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwidG90YWxjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgcHVibGljIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9idXR0b25MZWZ0LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgICB0aGlzLl9idXR0b25SaWdodC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHB1YmxpYyBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2J1dHRvbkxlZnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyKVxuICAgIHRoaXMuX2J1dHRvblJpZ2h0LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5wcm9ncmVzcy1saWdodFwiLCAoZSkgPT4ge1xuICAgIG5ldyBQcm9ncmVzc0xpZ2h0KGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzTGlnaHRcbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL1V0aWxzXCJcblxuaW1wb3J0IExvYWRlckJhciwgeyBpbml0IGFzIGluaXRMb2FkZXJCYXIgfSBmcm9tIFwiLi9sb2FkZXIvTG9hZGVyQmFyXCJcblxuLyogRm9ybSBDb21wb25lbnRzICovXG5pbXBvcnQgSW5wdXRGaWVsZCwgeyBpbml0IGFzIGluaXRJbnB1dEZpZWxkIH0gZnJvbSBcIi4vZm9ybS9JbnB1dEZpZWxkXCJcbmltcG9ydCBUZXh0YXJlYSwgeyBpbml0IGFzIGluaXRUZXh0YXJlYSB9IGZyb20gXCIuL2Zvcm0vVGV4dGFyZWFcIlxuaW1wb3J0IFNlbGVjdCwgeyBpbml0IGFzIGluaXRTZWxlY3QgfSBmcm9tIFwiLi9mb3JtL1NlbGVjdFwiXG5pbXBvcnQgUmFuZ2UsIHsgaW5pdCBhcyBpbml0UmFuZ2UgfSBmcm9tIFwiLi9mb3JtL1JhbmdlXCJcbmltcG9ydCBBdXRvY29tcGxldGUsIHsgaW5pdCBhcyBpbml0QXV0b2NvbXBsZXRlIH0gZnJvbSBcIi4vZm9ybS9BdXRvY29tcGxldGVcIlxuXG5pbXBvcnQgUHJvZ3Jlc3NMaWdodCwgeyBpbml0IGFzIGluaXRQcm9ncmVzc0xpZ2h0IH0gZnJvbSBcIi4vcHJvZ3Jlc3MvUHJvZ3Jlc3NMaWdodFwiXG5pbXBvcnQgUHJvZ3Jlc3NGdWxsLCB7IGluaXQgYXMgaW5pdFByb2dyZXNzRnVsbCB9IGZyb20gXCIuL3Byb2dyZXNzL1Byb2dyZXNzRnVsbFwiXG5cbmltcG9ydCBNb2RhbCwgeyBpbml0IGFzIGluaXRNb2RhbCB9IGZyb20gXCIuL21vZGFsL01vZGFsXCJcbmltcG9ydCBUb29sYmFyIGZyb20gXCIuL3Rvb2xiYXIvVG9vbGJhclwiXG5cbmltcG9ydCAqIGFzIE5vdGlmaWNhdGlvbiBmcm9tIFwiLi9ub3RpZmljYXRpb24vTm90aWZpY2F0aW9uXCJcblxuaW1wb3J0IENvbGxhcHNlLCB7IGluaXQgYXMgaW5pdENvbGxhcHNlIH0gZnJvbSBcIi4vY29sbGFwc2UvQ29sbGFwc2VcIlxuaW1wb3J0IEFjY29yZGlvbiwgeyBpbml0IGFzIGluaXRBY2NvcmRpb24gfSBmcm9tIFwiLi9hY2NvcmRpb24vQWNjb3JkaW9uXCJcbmltcG9ydCBNZW51Rmx5b3V0LCB7IGluaXQgYXMgaW5pdE1lbnVGbHlvdXQgfSBmcm9tIFwiLi9tZW51L01lbnVGbHlvdXRcIlxuXG5pbXBvcnQgTmF2aWdhdGlvbiwgeyBpbml0IGFzIGluaXROYXZpZ2F0aW9uIH0gZnJvbSBcIi4vbmF2aWdhdGlvbi9OYXZpZ2F0aW9uXCJcbmltcG9ydCBOYXZpZ2F0aW9uU2lkZSwgeyBpbml0IGFzIGluaXROYXZpZ2F0aW9uU2lkZSB9IGZyb20gXCIuL25hdmlnYXRpb24vTmF2aWdhdGlvblNpZGVcIlxuaW1wb3J0IFNlYXJjaElucHV0LCB7IGluaXQgYXMgaW5pdFNlYXJjaElucHV0IH0gZnJvbSBcIi4vc2VhcmNoL1NlYXJjaElucHV0XCJcbmltcG9ydCBFbXB0eVN0YXRlLCB7IGluaXQgYXMgaW5pdEVtcHR5U3RhdGUgfSBmcm9tIFwiLi9lbXB0eS1zdGF0ZXMvRW1wdHlTdGF0ZVwiXG5pbXBvcnQgQ2Fyb3VzZWwsIHsgaW5pdCBhcyBpbml0Q2Fyb3VzZWwgfSBmcm9tIFwiLi9jYXJvdXNlbC9DYXJvdXNlbFwiXG5cbmltcG9ydCBUYWJsZSwgeyBpbml0IGFzIGluaXRUYWJsZSB9IGZyb20gXCIuL3RhYmxlL1RhYmxlXCJcblxuaW1wb3J0IFBpZUNoYXJ0LCB7IGluaXQgYXMgaW5pdFBpZUNoYXJ0IH0gZnJvbSBcIi4vY2hhcnRzL1BpZUNoYXJ0XCJcbmltcG9ydCBCYXJDaGFydEhvcml6b250YWwsIHsgaW5pdCBhcyBpbml0QmFyQ2hhcnRIb3Jpem9udGFsIH0gZnJvbSBcIi4vY2hhcnRzL0JhckNoYXJ0SG9yaXpvbnRhbFwiXG5pbXBvcnQgQmFyQ2hhcnRWZXJ0aWNhbCwgeyBpbml0IGFzIGluaXRCYXJDaGFydFZlcnRpY2FsIH0gZnJvbSBcIi4vY2hhcnRzL0JhckNoYXJ0VmVydGljYWxcIlxuXG5leHBvcnQge1xuICB1dGlscyxcbiAgTG9hZGVyQmFyLCBpbml0TG9hZGVyQmFyLFxuICBJbnB1dEZpZWxkLCBpbml0SW5wdXRGaWVsZCxcbiAgVGV4dGFyZWEsIGluaXRUZXh0YXJlYSxcbiAgU2VsZWN0LCBpbml0U2VsZWN0LFxuICBSYW5nZSwgaW5pdFJhbmdlLFxuICBBdXRvY29tcGxldGUsIGluaXRBdXRvY29tcGxldGUsXG4gIFByb2dyZXNzTGlnaHQsIGluaXRQcm9ncmVzc0xpZ2h0LFxuICBQcm9ncmVzc0Z1bGwsIGluaXRQcm9ncmVzc0Z1bGwsXG4gIE1vZGFsLCBpbml0TW9kYWwsXG4gIFRvb2xiYXIsXG4gIE5vdGlmaWNhdGlvbixcbiAgQ29sbGFwc2UsIGluaXRDb2xsYXBzZSxcbiAgQWNjb3JkaW9uLCBpbml0QWNjb3JkaW9uLFxuICBNZW51Rmx5b3V0LCBpbml0TWVudUZseW91dCxcbiAgTmF2aWdhdGlvbiwgaW5pdE5hdmlnYXRpb24sXG4gIE5hdmlnYXRpb25TaWRlLCBpbml0TmF2aWdhdGlvblNpZGUsXG4gIFNlYXJjaElucHV0LCBpbml0U2VhcmNoSW5wdXQsXG4gIEVtcHR5U3RhdGUsIGluaXRFbXB0eVN0YXRlLFxuICBDYXJvdXNlbCwgaW5pdENhcm91c2VsLFxuICBUYWJsZSwgaW5pdFRhYmxlLFxuICBQaWVDaGFydCwgaW5pdFBpZUNoYXJ0LFxuICBCYXJDaGFydEhvcml6b250YWwsIGluaXRCYXJDaGFydEhvcml6b250YWwsXG4gIEJhckNoYXJ0VmVydGljYWwsIGluaXRCYXJDaGFydFZlcnRpY2FsXG59XG4iLCJpbXBvcnQgYW5pbWUsIHsgQW5pbWVUaW1lbGluZUluc3RhbmNlIH0gZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQsIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IGFkZENsYXNzLCByZW1vdmVDbGFzcywgZ2V0QXR0cmlidXRlUmVmZXJlbmNlLCBwYXJlbnRXaXRoQ2xhc3MgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgUVVFUllfU0VBUkNIX0lOUFVUID0gXCJpbnB1dC5zZWFyY2hfX2ZpZWxkXCJcbmNvbnN0IFFVRVJZX0JUTl9DTE9TRSA9IFwiLnNlYXJjaF9faWNvbi1jbG9zZVwiXG5cbmNvbnN0IFFVRVJZX0xJVkVfU1VHRVNUSU9OUyA9IFwiLmpzLXN1Z2dlc3Rpb25zXCJcbmNvbnN0IFFVRVJZX0xJVkVfRk9PVEVSID0gXCIuanMtZm9vdGVyXCJcblxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5cbmNvbnN0IENMQVNTX1NFQVJDSCA9IFwic2VhcmNoXCJcblxuY29uc3QgQU5JTUFUSU9OX1NVR0dFU1RJT05TX0RVUkFUSU9OID0gMzAwXG5jb25zdCBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OID0gMTAwXG5jb25zdCBBTklNQVRJT05fRk9PVEVSX0RFTEFZID0gQU5JTUFUSU9OX1NVR0dFU1RJT05TX0RVUkFUSU9OIC0gQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTlxuXG4vKipcbiAqIFRoZSBzZWFyY2ggaW5wdXQgY29tcG9uZW50IGRlZmluaXRpb24uXG4gKi9cbmNsYXNzIFNlYXJjaElucHV0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2lucHV0OiBIVE1MSW5wdXRFbGVtZW50XG4gIHByaXZhdGUgX2Zvcm06IEhUTUxGb3JtRWxlbWVudFxuICBwcml2YXRlIF9idG5DbG9zZTogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGl2ZVN1Z2dlc3Rpb25zPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGl2ZUZvb3Rlcj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2xpdmVDb250YWluZXI/OiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX2ZvY3VzSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2JsdXJIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfY2xvc2VIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyOiAoZTogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3Jlc2l6ZUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2lzT3BlbjogYm9vbGVhbiA9IGZhbHNlXG4gIHByaXZhdGUgYW5pbWF0aW9uITogQW5pbWVUaW1lbGluZUluc3RhbmNlXG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5faW5wdXQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TRUFSQ0hfSU5QVVQpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICB0aGlzLl9mb3JtID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJmb3JtXCIpIVxuICAgIHRoaXMuX2J0bkNsb3NlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQlROX0NMT1NFKSBhcyBIVE1MRWxlbWVudFxuXG4gICAgbGV0IGxpdmVTZWFyY2ggPSBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UodGhpcy5lbGVtZW50LCBcImRhdGEtbGl2ZVwiKVxuICAgIGlmIChsaXZlU2VhcmNoKSB7XG4gICAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMgPSBsaXZlU2VhcmNoLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTElWRV9TVUdFU1RJT05TKSBhcyBIVE1MRWxlbWVudCB8fCB1bmRlZmluZWRcbiAgICAgIHRoaXMuX2xpdmVGb290ZXIgPSBsaXZlU2VhcmNoLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTElWRV9GT09URVIpIGFzIEhUTUxFbGVtZW50IHx8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAodGhpcy5fbGl2ZVN1Z2dlc3Rpb25zKSB7XG4gICAgICAgIHRoaXMuX2xpdmVDb250YWluZXIgPSB0aGlzLl9saXZlU3VnZ2VzdGlvbnMucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fCB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVJbnB1dEZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUlucHV0Qmx1ci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fY2xvc2VIYW5kbGVyID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IHRoaXMuX2hhbmRsZVJlc2l6ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgaWYgKGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uKCkgPiAwKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgSUUgYnJvd3NlcnMgd2hlcmUgYSBmb2N1c2VkXG4gICAgICAvLyBpbnB1dCdzIGN1cnNvciBibGVlZHMgdHJvdWdoIGV2ZW4gaWYgaGlkZGVuXG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2J0bkNsb3NlKSB7XG4gICAgICB0aGlzLl9idG5DbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xvc2VIYW5kbGVyKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlSW5wdXRGb2N1cygpIHtcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlSW5wdXRCbHVyKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVXaW5kb3dDbGljayhldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAoIXBhcmVudFdpdGhDbGFzcyh0YXJnZXQsIENMQVNTX1NFQVJDSCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRVNDQVBFKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlUmVzaXplKCkge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudClcbiAgICBpZiAoc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHRoaXMuX2lucHV0LmJsdXIoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVzZXRNYWluVGltZWxpbmUoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbi5wYXVzZSgpXG4gICAgfVxuICAgIGFuaW1lLnJlbW92ZSh0aGlzLl9saXZlU3VnZ2VzdGlvbnMhKVxuICAgIGFuaW1lLnJlbW92ZSh0aGlzLl9saXZlRm9vdGVyISlcblxuICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWUudGltZWxpbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlYXJjaCBpbnB1dCB0ZXh0IGNvbnRlbnQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBpbnB1dCB0ZXh0LlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zL2FjdGl2YXRlcyB0aGUgc2VhcmNoIGlucHV0LlxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICAgIHRoaXMuX2lucHV0LmZvY3VzKClcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB9LCA1MClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMvZGVhY3RpdmF0ZXMgdGhlIHNlYXJjaCBpbnB1dC5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICB0aGlzLl9mb3JtLnJlc2V0KClcbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG5cbiAgICB0aGlzLmNsb3NlTGl2ZVNlYXJjaCgpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGxpdmUgc2VhcmNoIHN1Z2dlc3Rpb25zLlxuICAgKi9cbiAgcHVibGljIG9wZW5MaXZlU2VhcmNoKCkge1xuICAgIGlmICghdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zIHx8IHRoaXMuX2lzT3Blbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNPcGVuID0gdHJ1ZVxuICAgIGFkZENsYXNzKHRoaXMuX2xpdmVDb250YWluZXIhLCBDTEFTU19PUEVOKVxuXG4gICAgdGhpcy5fcmVzZXRNYWluVGltZWxpbmUoKVxuXG4gICAgdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICB0YXJnZXRzOiB0aGlzLl9saXZlU3VnZ2VzdGlvbnMsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX1NVR0dFU1RJT05TX0RVUkFUSU9OLFxuICAgICAgaGVpZ2h0OiB0aGlzLl9saXZlU3VnZ2VzdGlvbnMuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiLFxuICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBkb21FbCA9IG5ldyBEb21FbGVtZW50KHRoaXMuX2xpdmVTdWdnZXN0aW9ucyEpXG4gICAgICAgIGRvbUVsLmFkZENsYXNzKENMQVNTX09QRU4pXG4gICAgICAgIGRvbUVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmICh0aGlzLl9saXZlRm9vdGVyKSB7XG4gICAgICB0aGlzLl9saXZlRm9vdGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgICAgdGFyZ2V0czogdGhpcy5fbGl2ZUZvb3RlcixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04sXG4gICAgICAgIGhlaWdodDogdGhpcy5fbGl2ZUZvb3Rlci5zY3JvbGxIZWlnaHQgKyBcInB4XCIsXG4gICAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgICBvZmZzZXQ6IEFOSU1BVElPTl9GT09URVJfREVMQVksXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9saXZlRm9vdGVyISlcbiAgICAgICAgICBkb21FbC5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICAgIGRvbUVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbGl2ZSBzZWFyY2ggc3VnZ2VzdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgY2xvc2VMaXZlU2VhcmNoKCkge1xuICAgIGlmICghdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zIHx8ICF0aGlzLmlzT3Blbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNPcGVuID0gZmFsc2VcbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG5cbiAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgIHRhcmdldHM6IHRoaXMuX2xpdmVTdWdnZXN0aW9ucyxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04sXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbUVsID0gbmV3IERvbUVsZW1lbnQodGhpcy5fbGl2ZVN1Z2dlc3Rpb25zISlcbiAgICAgICAgZG9tRWwucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5fbGl2ZUNvbnRhaW5lciEsIENMQVNTX09QRU4pXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmICh0aGlzLl9saXZlRm9vdGVyKSB7XG4gICAgICB0aGlzLl9saXZlRm9vdGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgICAgdGFyZ2V0czogdGhpcy5fbGl2ZUZvb3RlcixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04sXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkb21FbCA9IG5ldyBEb21FbGVtZW50KHRoaXMuX2xpdmVGb290ZXIhKVxuICAgICAgICAgIGRvbUVsLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG4gICAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgY2xlYXJzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuX2J0bkNsb3NlKSB7XG4gICAgICB0aGlzLl9idG5DbG9zZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xvc2VIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX2lucHV0ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9mb3JtID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9idG5DbG9zZSA9IG51bGw7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9mb2N1c0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2JsdXJIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9jbG9zZUhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3dpbmRvd0NsaWNrSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fa2V5ZG93bkhhbmRsZXIgPSBudWxsO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fbGl2ZVN1Z2dlc3Rpb25zID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9saXZlRm9vdGVyID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIFNlYXJjaElucHV0IGlzIG9wZW4vdmlzaWJsZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBUcnVlIGlmIG9wZW47IG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIHB1YmxpYyBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIuc2VhcmNoLnNlYXJjaF9faW5wdXRcIiwgKGUpID0+IHtcbiAgICBuZXcgU2VhcmNoSW5wdXQoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VhcmNoSW5wdXRcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9IRUFERVIgPSBcInRoZWFkIHRoXCJcblxuY29uc3QgQ0xBU1NfU09SVEVEX0FTQ0VORElORyA9IFwianMtYXNjZW5kaW5nXCJcbmNvbnN0IENMQVNTX1NPUlRFRF9ERVNDRU5ESU5HID0gXCJqcy1kZXNjZW5kaW5nXCJcbmNvbnN0IENMQVNTX0FSUk9XID0gXCJhcnJvdy1pY29uXCJcblxuZXhwb3J0IGludGVyZmFjZSBDb21wYXJlcjxUID0gYW55PiB7XG4gIChpdGVtMTogVCwgaXRlbTI6IFQpOiBudW1iZXJcbn1cblxuLyoqXG4gKiBUaGUgVGFibGUgY29tcG9uZW50LiBBZGRzIGFkZGl0aW9uYWwgY2FwYWJpbGl0aWVzIHRvIHN0YW5kYXJkIEhUTUwgNSB0YWJsZXMuXG4gKi9cbmNsYXNzIFRhYmxlIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2hlYWRlckNsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2JvZHk6IEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50XG4gIHByaXZhdGUgX3Jvd3M6IEhUTUxDb2xsZWN0aW9uT2Y8SFRNTFRhYmxlUm93RWxlbWVudD5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgdGFibGUgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTFRhYmxlRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9oZWFkZXJDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVIZWFkZXJDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9ib2R5ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0Ym9keVwiKSBhcyBIVE1MVGFibGVTZWN0aW9uRWxlbWVudFxuICAgIHRoaXMuX3Jvd3MgPSB0aGlzLl9ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHJcIilcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGZvciAobGV0IGhlYWRlciBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpKSB7XG4gICAgICBpZiAoaGVhZGVyLmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKSkge1xuICAgICAgICBoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlcilcblxuICAgICAgICBsZXQgYXJyb3dFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQVJST1cpXG4gICAgICAgICAgLmVsZW1lbnRcblxuICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoYXJyb3dFbGVtZW50KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlSGVhZGVyQ2xpY2soZTogRXZlbnQpIHtcbiAgICBjb25zdCB0aCA9IGUudGFyZ2V0IGFzIEhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50XG4gICAgdGhpcy5zb3J0KHRoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIHRoZSB0YWJsZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0YWJsZSBoZWFkZXIgZWxlbWVudC5cbiAgICogVGhlIGNvbHVtbiBpcyBzb3J0ZWQgYXNjZW5kaW5nIGJ5IGRlZmF1bHQgaWYgbm8gZGlyZWN0aW9uIGlzIHNwZWNpZmllZCBhbmQgbm9cbiAgICogZXhpc3Rpbmcgc29ydCBvcmRlciBjbGFzcyBpcyBmb3VuZCBpbiB0aGUgbWFya3VwLlxuICAgKlxuICAgKiBJZiB0aGUgZGlzcGxheWVkIGRhdGEgaXMgbm90IHN1aXRhYmxlIGZvciBzb3J0aW5nIGA8dGQvPmAgZWxlbWVudHMgY2FuIGRlZmluZSBhIGBkYXRhLXZhbHVlYCBhdHRyaWJ1dGVcbiAgICogd2hpY2ggaXMgdGhlbiB1c2VkIGZvciB0aGUgZGF0YS1zb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGFibGVIZWFkZXJ9IHRhYmxlSGVhZGVyIFRoZSBoZWFkZXIgZWxlbWVudCBvZiB0aGUgcm93IHRvIHNvcnQgYnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0byBzb3J0LCBgMWAgZm9yIGFzY2VuZGluZywgYC0xYCBmb3IgZGVzY2VuZGluZyBvcmRlci4gVGhpcyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVxdWFsaXR5Q29tcGFyZXIgVGhlIGVxdWlhbGl0eSBjb21wYXJlciBmdW5jdGlvbiB0byBjb21wYXJlIGluZGl2aWR1YWwgY2VsbCB2YWx1ZXMuXG4gICAqL1xuICBwdWJsaWMgc29ydChcbiAgICB0YWJsZUhlYWRlcjogSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQsXG4gICAgZGlyZWN0aW9uPzogLTEgfCAxLFxuICAgIGVxdWFsaXR5Q29tcGFyZXI/OiBDb21wYXJlclxuICApIHtcbiAgICBpZiAoIXRhYmxlSGVhZGVyIHx8IHRhYmxlSGVhZGVyLnRhZ05hbWUgIT09IFwiVEhcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhcmFtZXRlciAndGFibGVIZWFkZXInIG11c3QgYmUgYSB2YWxpZCBjb2x1bW4gaGVhZGVyIG5vZGVcIilcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uICE9PSAxICYmIGRpcmVjdGlvbiAhPT0gLTEgJiYgZGlyZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBvdXQgb2YgcmFuZ2UsIHBhcmFtZXRlciAnZGlyZWN0aW9uJyB3aXRoIHZhbHVlICcke2RpcmVjdGlvbn0nIG11c3QgYmUgZWl0aGVyIC0xLCAxIG9yIHVuZGVmaW5lZGApXG4gICAgfVxuXG4gICAgY29uc3QgY29sdW1uSW5kZXggPSB0YWJsZUhlYWRlci5jZWxsSW5kZXhcblxuICAgIGlmICghZXF1YWxpdHlDb21wYXJlcikge1xuICAgICAgbGV0IGRhdGFUeXBlID0gdGFibGVIZWFkZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpXG4gICAgICBlcXVhbGl0eUNvbXBhcmVyID0gdGhpcy5fZ2V0Q29tcGFyZXIoZGF0YVR5cGUhKVxuICAgIH1cblxuICAgIGlmIChjb2x1bW5JbmRleCA+PSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIG91dCBvZiByYW5nZVwiKVxuICAgIH1cblxuICAgIGZvciAobGV0IGhlYWRlciBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpKSB7XG4gICAgICBpZiAoaGVhZGVyICE9PSB0YWJsZUhlYWRlcikge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoaGVhZGVyLCBDTEFTU19TT1JURURfQVNDRU5ESU5HKVxuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoaGVhZGVyLCBDTEFTU19TT1JURURfREVTQ0VORElORylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRG9tLmhhc0NsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfQVNDRU5ESU5HKSkge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfQVNDRU5ESU5HKVxuICAgICAgRG9tLmFkZENsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfREVTQ0VORElORylcblxuICAgICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyh0YWJsZUhlYWRlciwgQ0xBU1NfU09SVEVEX0RFU0NFTkRJTkcpXG4gICAgICBEb20uYWRkQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9BU0NFTkRJTkcpXG4gICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgMVxuICAgIH1cblxuICAgIHRoaXMuX3F1aWNrc29ydChjb2x1bW5JbmRleCwgMCwgdGhpcy5fcm93cy5sZW5ndGggLSAxLCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldENlbGwoY29sdW1uOiBudW1iZXIsIHJvdzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd3Nbcm93XS5jZWxsc1tjb2x1bW5dXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFJvdyhyb3c6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9yb3dzW3Jvd11cbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0Q29tcGFyZXIoZGF0YVR5cGU6IHN0cmluZyk6IENvbXBhcmVyPHN0cmluZz4ge1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjoge1xuICAgICAgICAvLyBwYXJzZSB0aGUgc3RyaW5nIGFzIGEgbnVtYmVyXG4gICAgICAgIHJldHVybiAoYSwgYikgPT4gcGFyc2VGbG9hdChhKSAtIHBhcnNlRmxvYXQoYilcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gY29tcGFyZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9xdWlja3NvcnQoXG4gICAgY29sdW1uOiBudW1iZXIsXG4gICAgbGVmdDogbnVtYmVyLFxuICAgIHJpZ2h0OiBudW1iZXIsXG4gICAgZGlyZWN0aW9uOiAtMSB8IDEgPSAxLFxuICAgIGVxdWFsaXR5Q29tcGFyZXI6IENvbXBhcmVyPHN0cmluZz5cbiAgKSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDApIHtcblxuICAgICAgbGV0IHBhcnRpdGlvbiA9IHRoaXMuX3BhcnRpdGlvbihjb2x1bW4sIGxlZnQsIHJpZ2h0LCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG5cbiAgICAgIGlmIChsZWZ0IDwgcGFydGl0aW9uIC0gMSkge1xuICAgICAgICB0aGlzLl9xdWlja3NvcnQoY29sdW1uLCBsZWZ0LCBwYXJ0aXRpb24gLSAxLCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJ0aXRpb24gPCByaWdodCkge1xuICAgICAgICB0aGlzLl9xdWlja3NvcnQoY29sdW1uLCBwYXJ0aXRpb24sIHJpZ2h0LCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9wYXJ0aXRpb24oXG4gICAgY29sdW1uOiBudW1iZXIsXG4gICAgbGVmdDogbnVtYmVyLFxuICAgIHJpZ2h0OiBudW1iZXIsXG4gICAgZGlyZWN0aW9uOiAtMSB8IDEgPSAxLFxuICAgIGVxdWFsaXR5Q29tcGFyZXI6IENvbXBhcmVyPHN0cmluZz5cbiAgKSB7XG4gICAgbGV0IHBpdm90ID0gdGhpcy5fZ2V0Q2VsbChjb2x1bW4sIE1hdGguZmxvb3IoKHJpZ2h0ICsgbGVmdCkgLyAyKSlcbiAgICBsZXQgaSA9IGxlZnRcbiAgICBsZXQgaiA9IHJpZ2h0XG5cbiAgICB3aGlsZSAoaSA8PSBqKSB7XG4gICAgICB3aGlsZSAodGhpcy5fZXF1YWxzKHRoaXMuX2dldENlbGwoY29sdW1uLCBpKSwgcGl2b3QsIGVxdWFsaXR5Q29tcGFyZXIpICogZGlyZWN0aW9uIDwgMCkge1xuICAgICAgICBpKytcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRoaXMuX2VxdWFscyh0aGlzLl9nZXRDZWxsKGNvbHVtbiwgaiksIHBpdm90LCBlcXVhbGl0eUNvbXBhcmVyKSAqIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgai0tXG4gICAgICB9XG5cbiAgICAgIGlmIChpIDw9IGopIHtcbiAgICAgICAgdGhpcy5fc3dhcChpLCBqKVxuICAgICAgICBpKytcbiAgICAgICAgai0tXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlcbiAgfVxuXG4gIHByb3RlY3RlZCBfZXF1YWxzKFxuICAgIGE6IEhUTUxFbGVtZW50LFxuICAgIGI6IEhUTUxFbGVtZW50LFxuICAgIGVxdWFsaXR5Q29tcGFyZXI6IENvbXBhcmVyPHN0cmluZz5cbiAgKSB7XG4gICAgbGV0IGRhdGFBID0gYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgbGV0IGRhdGFCID0gYi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG5cbiAgICBkYXRhQSA9IGRhdGFBIHx8IGEudGV4dENvbnRlbnQgfHwgYS5pbm5lclRleHRcbiAgICBkYXRhQiA9IGRhdGFCIHx8IGIudGV4dENvbnRlbnQgfHwgYi5pbm5lclRleHRcblxuICAgIHJldHVybiBlcXVhbGl0eUNvbXBhcmVyKGRhdGFBLCBkYXRhQilcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3dhcChpOiBudW1iZXIsIGo6IG51bWJlcikge1xuICAgIGxldCB0bXBOb2RlID0gdGhpcy5fYm9keS5yZXBsYWNlQ2hpbGQodGhpcy5fZ2V0Um93KGkpLCB0aGlzLl9nZXRSb3coaikpXG4gICAgY29uc3QgcmVmZXJlbmNlUm93ID0gdGhpcy5fZ2V0Um93KGkpXG5cbiAgICBpZiAoIXJlZmVyZW5jZVJvdykge1xuICAgICAgdGhpcy5fYm9keS5hcHBlbmRDaGlsZCh0bXBOb2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ib2R5Lmluc2VydEJlZm9yZSh0bXBOb2RlLCByZWZlcmVuY2VSb3cpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGNsZWFycyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGhlYWRlciBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpKSB7XG4gICAgICBoZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9oZWFkZXJDbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2JvZHkgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3Jvd3MgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCJ0YWJsZVwiLCAoZSkgPT4ge1xuICAgIG5ldyBUYWJsZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBUYWJsZVxuIiwiaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuY29uc3QgQ0xBU1NfSVRFTVMgPSBcIi50b29sYmFyX19pdGVtXCJcbmNvbnN0IENMQVNTX1NIT1cgPSBcIml0ZW0tLXNob3dcIlxuXG5jb25zdCBBTklNQVRJT05fU1RBUlRfREVMQVkgPSAxMDBcbmNvbnN0IEFOSU1BVElPTl9PRkZTRVQgPSA1MFxuXG4vKipcbiAqIFRvb2xiYXIgY29tcG9uZW50LiBVc2UgdGhpcyBjb21wb25lbnQgdG8gc2hvdyBhbmQgaGlkZSB0aGVcbiAqIGluZGl2aWR1YWwgdG9vbGJhciBpdGVtcy5cbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIERvbUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBNYWtlcyB0aGUgdG9vbGJhciBpdGVtcyB2aXNpYmxlLlxuICAgKi9cbiAgcHVibGljIHNob3coKSB7XG4gICAgbGV0IGRlbGF5ID0gQU5JTUFUSU9OX1NUQVJUX0RFTEFZXG4gICAgbGV0IGl0ZW1zID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoQ0xBU1NfSVRFTVMpXG5cbiAgICBsZXQgdGltZWxpbmUgPSBhbmltZS50aW1lbGluZSgpXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdGltZWxpbmUuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogaXRlbXNbaW5kZXhdLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgb2Zmc2V0OiBkZWxheSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBpdGVtc1tpbmRleF0uY2xhc3NMaXN0LmFkZChDTEFTU19TSE9XKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgZGVsYXkgKz0gQU5JTUFUSU9OX09GRlNFVFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgdG9vbGJhciBpdGVtcy5cbiAgICovXG4gIHB1YmxpYyBoaWRlKCkge1xuICAgIGxldCBkZWxheSA9IEFOSU1BVElPTl9TVEFSVF9ERUxBWVxuICAgIGxldCBpdGVtcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0lURU1TKVxuXG4gICAgbGV0IHRpbWVsaW5lID0gYW5pbWUudGltZWxpbmUoKVxuICAgIGZvciAobGV0IGluZGV4ID0gaXRlbXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgdGltZWxpbmUuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogaXRlbXNbaW5kZXhdLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgb2Zmc2V0OiBkZWxheSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBpdGVtc1tpbmRleF0uY2xhc3NMaXN0LnJlbW92ZShDTEFTU19TSE9XKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgZGVsYXkgKz0gQU5JTUFUSU9OX09GRlNFVFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSB0b29sYmFyIGl0ZW1zIHZpc2liaWxpdHkuXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfU0hPV31gKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2hvdygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2xiYXJcbiIsIi8qXG4gKiBhbmltZS5qcyB2My4xLjBcbiAqIChjKSAyMDE5IEp1bGlhbiBHYXJuaWVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGFuaW1lanMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBEZWZhdWx0c1xuXG52YXIgZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MgPSB7XG4gIHVwZGF0ZTogbnVsbCxcbiAgYmVnaW46IG51bGwsXG4gIGxvb3BCZWdpbjogbnVsbCxcbiAgY2hhbmdlQmVnaW46IG51bGwsXG4gIGNoYW5nZTogbnVsbCxcbiAgY2hhbmdlQ29tcGxldGU6IG51bGwsXG4gIGxvb3BDb21wbGV0ZTogbnVsbCxcbiAgY29tcGxldGU6IG51bGwsXG4gIGxvb3A6IDEsXG4gIGRpcmVjdGlvbjogJ25vcm1hbCcsXG4gIGF1dG9wbGF5OiB0cnVlLFxuICB0aW1lbGluZU9mZnNldDogMFxufTtcblxudmFyIGRlZmF1bHRUd2VlblNldHRpbmdzID0ge1xuICBkdXJhdGlvbjogMTAwMCxcbiAgZGVsYXk6IDAsXG4gIGVuZERlbGF5OiAwLFxuICBlYXNpbmc6ICdlYXNlT3V0RWxhc3RpYygxLCAuNSknLFxuICByb3VuZDogMFxufTtcblxudmFyIHZhbGlkVHJhbnNmb3JtcyA9IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3RyYW5zbGF0ZVonLCAncm90YXRlJywgJ3JvdGF0ZVgnLCAncm90YXRlWScsICdyb3RhdGVaJywgJ3NjYWxlJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnc2NhbGVaJywgJ3NrZXcnLCAnc2tld1gnLCAnc2tld1knLCAncGVyc3BlY3RpdmUnXTtcblxuLy8gQ2FjaGluZ1xuXG52YXIgY2FjaGUgPSB7XG4gIENTUzoge30sXG4gIHNwcmluZ3M6IHt9XG59O1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBtaW5NYXgodmFsLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdDb250YWlucyhzdHIsIHRleHQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKHRleHQpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QXJndW1lbnRzKGZ1bmMsIGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbnZhciBpcyA9IHtcbiAgYXJyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gQXJyYXkuaXNBcnJheShhKTsgfSxcbiAgb2JqOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gc3RyaW5nQ29udGFpbnMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpLCAnT2JqZWN0Jyk7IH0sXG4gIHB0aDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGlzLm9iaihhKSAmJiBhLmhhc093blByb3BlcnR5KCd0b3RhbExlbmd0aCcpOyB9LFxuICBzdmc6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgU1ZHRWxlbWVudDsgfSxcbiAgaW5wOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQ7IH0sXG4gIGRvbTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubm9kZVR5cGUgfHwgaXMuc3ZnKGEpOyB9LFxuICBzdHI6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ3N0cmluZyc7IH0sXG4gIGZuYzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnZnVuY3Rpb24nOyB9LFxuICB1bmQ6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCc7IH0sXG4gIGhleDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGEpOyB9LFxuICByZ2I6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvXnJnYi8udGVzdChhKTsgfSxcbiAgaHNsOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15oc2wvLnRlc3QoYSk7IH0sXG4gIGNvbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChpcy5oZXgoYSkgfHwgaXMucmdiKGEpIHx8IGlzLmhzbChhKSk7IH0sXG4gIGtleTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShhKSAmJiAhZGVmYXVsdFR3ZWVuU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgYSAhPT0gJ3RhcmdldHMnICYmIGEgIT09ICdrZXlmcmFtZXMnOyB9XG59O1xuXG4vLyBFYXNpbmdzXG5cbmZ1bmN0aW9uIHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gL1xcKChbXildKylcXCkvLmV4ZWMoc3RyaW5nKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBhcnNlRmxvYXQocCk7IH0pIDogW107XG59XG5cbi8vIFNwcmluZyBzb2x2ZXIgaW5zcGlyZWQgYnkgV2Via2l0IENvcHlyaWdodCDCqSAyMDE2IEFwcGxlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gaHR0cHM6Ly93ZWJraXQub3JnL2RlbW9zL3NwcmluZy9zcHJpbmcuanNcblxuZnVuY3Rpb24gc3ByaW5nKHN0cmluZywgZHVyYXRpb24pIHtcblxuICB2YXIgcGFyYW1zID0gcGFyc2VFYXNpbmdQYXJhbWV0ZXJzKHN0cmluZyk7XG4gIHZhciBtYXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMF0pID8gMSA6IHBhcmFtc1swXSwgLjEsIDEwMCk7XG4gIHZhciBzdGlmZm5lc3MgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1sxXSkgPyAxMDAgOiBwYXJhbXNbMV0sIC4xLCAxMDApO1xuICB2YXIgZGFtcGluZyA9IG1pbk1heChpcy51bmQocGFyYW1zWzJdKSA/IDEwIDogcGFyYW1zWzJdLCAuMSwgMTAwKTtcbiAgdmFyIHZlbG9jaXR5ID0gIG1pbk1heChpcy51bmQocGFyYW1zWzNdKSA/IDAgOiBwYXJhbXNbM10sIC4xLCAxMDApO1xuICB2YXIgdzAgPSBNYXRoLnNxcnQoc3RpZmZuZXNzIC8gbWFzcyk7XG4gIHZhciB6ZXRhID0gZGFtcGluZyAvICgyICogTWF0aC5zcXJ0KHN0aWZmbmVzcyAqIG1hc3MpKTtcbiAgdmFyIHdkID0gemV0YSA8IDEgPyB3MCAqIE1hdGguc3FydCgxIC0gemV0YSAqIHpldGEpIDogMDtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IHpldGEgPCAxID8gKHpldGEgKiB3MCArIC12ZWxvY2l0eSkgLyB3ZCA6IC12ZWxvY2l0eSArIHcwO1xuXG4gIGZ1bmN0aW9uIHNvbHZlcih0KSB7XG4gICAgdmFyIHByb2dyZXNzID0gZHVyYXRpb24gPyAoZHVyYXRpb24gKiB0KSAvIDEwMDAgOiB0O1xuICAgIGlmICh6ZXRhIDwgMSkge1xuICAgICAgcHJvZ3Jlc3MgPSBNYXRoLmV4cCgtcHJvZ3Jlc3MgKiB6ZXRhICogdzApICogKGEgKiBNYXRoLmNvcyh3ZCAqIHByb2dyZXNzKSArIGIgKiBNYXRoLnNpbih3ZCAqIHByb2dyZXNzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dyZXNzID0gKGEgKyBiICogcHJvZ3Jlc3MpICogTWF0aC5leHAoLXByb2dyZXNzICogdzApO1xuICAgIH1cbiAgICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7IHJldHVybiB0OyB9XG4gICAgcmV0dXJuIDEgLSBwcm9ncmVzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xuICAgIHZhciBjYWNoZWQgPSBjYWNoZS5zcHJpbmdzW3N0cmluZ107XG4gICAgaWYgKGNhY2hlZCkgeyByZXR1cm4gY2FjaGVkOyB9XG4gICAgdmFyIGZyYW1lID0gMS82O1xuICAgIHZhciBlbGFwc2VkID0gMDtcbiAgICB2YXIgcmVzdCA9IDA7XG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgZWxhcHNlZCArPSBmcmFtZTtcbiAgICAgIGlmIChzb2x2ZXIoZWxhcHNlZCkgPT09IDEpIHtcbiAgICAgICAgcmVzdCsrO1xuICAgICAgICBpZiAocmVzdCA+PSAxNikgeyBicmVhazsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkdXJhdGlvbiA9IGVsYXBzZWQgKiBmcmFtZSAqIDEwMDA7XG4gICAgY2FjaGUuc3ByaW5nc1tzdHJpbmddID0gZHVyYXRpb247XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGR1cmF0aW9uID8gc29sdmVyIDogZ2V0RHVyYXRpb247XG5cbn1cblxuLy8gQmFzaWMgc3RlcHMgZWFzaW5nIGltcGxlbWVudGF0aW9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2ZyL2RvY3MvV2ViL0NTUy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuXG5mdW5jdGlvbiBzdGVwcyhzdGVwcykge1xuICBpZiAoIHN0ZXBzID09PSB2b2lkIDAgKSBzdGVwcyA9IDEwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gTWF0aC5yb3VuZCh0ICogc3RlcHMpICogKDEgLyBzdGVwcyk7IH07XG59XG5cbi8vIEJlemllckVhc2luZyBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcblxudmFyIGJlemllciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbiAgdmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcblxuICBmdW5jdGlvbiBBKGFBMSwgYUEyKSB7IHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTEgfVxuICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTEgfVxuICBmdW5jdGlvbiBDKGFBMSkgICAgICB7IHJldHVybiAzLjAgKiBhQTEgfVxuXG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVCB9XG4gIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikgeyByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKSB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gICAgdmFyIGN1cnJlbnRYLCBjdXJyZW50VCwgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBpZiAoY3VycmVudFggPiAwLjApIHsgYUIgPSBjdXJyZW50VDsgfSBlbHNlIHsgYUEgPSBjdXJyZW50VDsgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IDAuMDAwMDAwMSAmJiArK2kgPCAxMCk7XG4gICAgcmV0dXJuIGN1cnJlbnRUO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHsgcmV0dXJuIGFHdWVzc1Q7IH1cbiAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcblxuICAgIGlmICghKDAgPD0gbVgxICYmIG1YMSA8PSAxICYmIDAgPD0gbVgyICYmIG1YMiA8PSAxKSkgeyByZXR1cm47IH1cbiAgICB2YXIgc2FtcGxlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblxuICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcblxuICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwO1xuICAgICAgdmFyIGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICB9XG5cbiAgICAgIC0tY3VycmVudFNhbXBsZTtcblxuICAgICAgdmFyIGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgdmFyIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgdmFyIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXG4gICAgICBpZiAoaW5pdGlhbFNsb3BlID49IDAuMDAxKSB7XG4gICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgeyByZXR1cm4geDsgfVxuICAgICAgaWYgKHggPT09IDAgfHwgeCA9PT0gMSkgeyByZXR1cm4geDsgfVxuICAgICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBiZXppZXI7XG5cbn0pKCk7XG5cbnZhciBwZW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIC8vIEJhc2VkIG9uIGpRdWVyeSBVSSdzIGltcGxlbWVuYXRpb24gb2YgZWFzaW5nIGVxdWF0aW9ucyBmcm9tIFJvYmVydCBQZW5uZXIgKGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcpXG5cbiAgdmFyIGVhc2VzID0geyBsaW5lYXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9OyB9IH07XG5cbiAgdmFyIGZ1bmN0aW9uRWFzaW5ncyA9IHtcbiAgICBTaW5lOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7IH07IH0sXG4gICAgQ2lyYzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTsgfTsgfSxcbiAgICBCYWNrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgKiAoMyAqIHQgLSAyKTsgfTsgfSxcbiAgICBCb3VuY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgcG93MiwgYiA9IDQ7XG4gICAgICB3aGlsZSAodCA8ICgoIHBvdzIgPSBNYXRoLnBvdygyLCAtLWIpKSAtIDEpIC8gMTEpIHt9XG4gICAgICByZXR1cm4gMSAvIE1hdGgucG93KDQsIDMgLSBiKSAtIDcuNTYyNSAqIE1hdGgucG93KCggcG93MiAqIDMgLSAyICkgLyAyMiAtIHQsIDIpXG4gICAgfTsgfSxcbiAgICBFbGFzdGljOiBmdW5jdGlvbiAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICAgIGlmICggYW1wbGl0dWRlID09PSB2b2lkIDAgKSBhbXBsaXR1ZGUgPSAxO1xuICAgICAgaWYgKCBwZXJpb2QgPT09IHZvaWQgMCApIHBlcmlvZCA9IC41O1xuXG4gICAgICB2YXIgYSA9IG1pbk1heChhbXBsaXR1ZGUsIDEsIDEwKTtcbiAgICAgIHZhciBwID0gbWluTWF4KHBlcmlvZCwgLjEsIDIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAodCA9PT0gMCB8fCB0ID09PSAxKSA/IHQgOiBcbiAgICAgICAgICAtYSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKiBNYXRoLnNpbigoKCh0IC0gMSkgLSAocCAvIChNYXRoLlBJICogMikgKiBNYXRoLmFzaW4oMSAvIGEpKSkgKiAoTWF0aC5QSSAqIDIpKSAvIHApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYmFzZUVhc2luZ3MgPSBbJ1F1YWQnLCAnQ3ViaWMnLCAnUXVhcnQnLCAnUXVpbnQnLCAnRXhwbyddO1xuXG4gIGJhc2VFYXNpbmdzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgICBmdW5jdGlvbkVhc2luZ3NbbmFtZV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gTWF0aC5wb3codCwgaSArIDIpOyB9OyB9O1xuICB9KTtcblxuICBPYmplY3Qua2V5cyhmdW5jdGlvbkVhc2luZ3MpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZWFzZUluID0gZnVuY3Rpb25FYXNpbmdzW25hbWVdO1xuICAgIGVhc2VzWydlYXNlSW4nICsgbmFtZV0gPSBlYXNlSW47XG4gICAgZWFzZXNbJ2Vhc2VPdXQnICsgbmFtZV0gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBlYXNlSW4oYSwgYikoMSAtIHQpOyB9OyB9O1xuICAgIGVhc2VzWydlYXNlSW5PdXQnICsgbmFtZV0gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAwLjUgPyBlYXNlSW4oYSwgYikodCAqIDIpIC8gMiA6IFxuICAgICAgMSAtIGVhc2VJbihhLCBiKSh0ICogLTIgKyAyKSAvIDI7IH07IH07XG4gIH0pO1xuXG4gIHJldHVybiBlYXNlcztcblxufSkoKTtcblxuZnVuY3Rpb24gcGFyc2VFYXNpbmdzKGVhc2luZywgZHVyYXRpb24pIHtcbiAgaWYgKGlzLmZuYyhlYXNpbmcpKSB7IHJldHVybiBlYXNpbmc7IH1cbiAgdmFyIG5hbWUgPSBlYXNpbmcuc3BsaXQoJygnKVswXTtcbiAgdmFyIGVhc2UgPSBwZW5uZXJbbmFtZV07XG4gIHZhciBhcmdzID0gcGFyc2VFYXNpbmdQYXJhbWV0ZXJzKGVhc2luZyk7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NwcmluZycgOiByZXR1cm4gc3ByaW5nKGVhc2luZywgZHVyYXRpb24pO1xuICAgIGNhc2UgJ2N1YmljQmV6aWVyJyA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhiZXppZXIsIGFyZ3MpO1xuICAgIGNhc2UgJ3N0ZXBzJyA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhzdGVwcywgYXJncyk7XG4gICAgZGVmYXVsdCA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhlYXNlLCBhcmdzKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdzXG5cbmZ1bmN0aW9uIHNlbGVjdFN0cmluZyhzdHIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHN0cik7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLy8gQXJyYXlzXG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaSBpbiBhcnIpIHtcbiAgICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWwsIGksIGFycikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkFycmF5KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoaXMuYXJyKGIpID8gZmxhdHRlbkFycmF5KGIpIDogYik7IH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShvKSB7XG4gIGlmIChpcy5hcnIobykpIHsgcmV0dXJuIG87IH1cbiAgaWYgKGlzLnN0cihvKSkgeyBvID0gc2VsZWN0U3RyaW5nKG8pIHx8IG87IH1cbiAgaWYgKG8gaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBvIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24pIHsgcmV0dXJuIFtdLnNsaWNlLmNhbGwobyk7IH1cbiAgcmV0dXJuIFtvXTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPT09IHZhbDsgfSk7XG59XG5cbi8vIE9iamVjdHNcblxuZnVuY3Rpb24gY2xvbmVPYmplY3Qobykge1xuICB2YXIgY2xvbmUgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBvKSB7IGNsb25lW3BdID0gb1twXTsgfVxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPYmplY3RQcm9wcyhvMSwgbzIpIHtcbiAgdmFyIG8gPSBjbG9uZU9iamVjdChvMSk7XG4gIGZvciAodmFyIHAgaW4gbzEpIHsgb1twXSA9IG8yLmhhc093blByb3BlcnR5KHApID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMikgeyBvW3BdID0gaXMudW5kKG8xW3BdKSA/IG8yW3BdIDogbzFbcF07IH1cbiAgcmV0dXJuIG87XG59XG5cbi8vIENvbG9yc1xuXG5mdW5jdGlvbiByZ2JUb1JnYmEocmdiVmFsdWUpIHtcbiAgdmFyIHJnYiA9IC9yZ2JcXCgoXFxkKyxcXHMqW1xcZF0rLFxccypbXFxkXSspXFwpL2cuZXhlYyhyZ2JWYWx1ZSk7XG4gIHJldHVybiByZ2IgPyAoXCJyZ2JhKFwiICsgKHJnYlsxXSkgKyBcIiwxKVwiKSA6IHJnYlZhbHVlO1xufVxuXG5mdW5jdGlvbiBoZXhUb1JnYmEoaGV4VmFsdWUpIHtcbiAgdmFyIHJneCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIHZhciBoZXggPSBoZXhWYWx1ZS5yZXBsYWNlKHJneCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHsgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjsgfSApO1xuICB2YXIgcmdiID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHZhciByID0gcGFyc2VJbnQocmdiWzFdLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQocmdiWzJdLCAxNik7XG4gIHZhciBiID0gcGFyc2VJbnQocmdiWzNdLCAxNik7XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLDEpXCIpO1xufVxuXG5mdW5jdGlvbiBoc2xUb1JnYmEoaHNsVmFsdWUpIHtcbiAgdmFyIGhzbCA9IC9oc2xcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSVcXCkvZy5leGVjKGhzbFZhbHVlKSB8fCAvaHNsYVxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspXFwpL2cuZXhlYyhoc2xWYWx1ZSk7XG4gIHZhciBoID0gcGFyc2VJbnQoaHNsWzFdLCAxMCkgLyAzNjA7XG4gIHZhciBzID0gcGFyc2VJbnQoaHNsWzJdLCAxMCkgLyAxMDA7XG4gIHZhciBsID0gcGFyc2VJbnQoaHNsWzNdLCAxMCkgLyAxMDA7XG4gIHZhciBhID0gaHNsWzRdIHx8IDE7XG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkgeyB0ICs9IDE7IH1cbiAgICBpZiAodCA+IDEpIHsgdCAtPSAxOyB9XG4gICAgaWYgKHQgPCAxLzYpIHsgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7IH1cbiAgICBpZiAodCA8IDEvMikgeyByZXR1cm4gcTsgfVxuICAgIGlmICh0IDwgMi8zKSB7IHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7IH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICB2YXIgciwgZywgYjtcbiAgaWYgKHMgPT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuICB9XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgKHIgKiAyNTUpICsgXCIsXCIgKyAoZyAqIDI1NSkgKyBcIixcIiArIChiICogMjU1KSArIFwiLFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gY29sb3JUb1JnYih2YWwpIHtcbiAgaWYgKGlzLnJnYih2YWwpKSB7IHJldHVybiByZ2JUb1JnYmEodmFsKTsgfVxuICBpZiAoaXMuaGV4KHZhbCkpIHsgcmV0dXJuIGhleFRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oc2wodmFsKSkgeyByZXR1cm4gaHNsVG9SZ2JhKHZhbCk7IH1cbn1cblxuLy8gVW5pdHNcblxuZnVuY3Rpb24gZ2V0VW5pdCh2YWwpIHtcbiAgdmFyIHNwbGl0ID0gL1srLV0/XFxkKlxcLj9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/KCV8cHh8cHR8ZW18cmVtfGlufGNtfG1tfGV4fGNofHBjfHZ3fHZofHZtaW58dm1heHxkZWd8cmFkfHR1cm4pPyQvLmV4ZWModmFsKTtcbiAgaWYgKHNwbGl0KSB7IHJldHVybiBzcGxpdFsxXTsgfVxufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1Vbml0KHByb3BOYW1lKSB7XG4gIGlmIChzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3RyYW5zbGF0ZScpIHx8IHByb3BOYW1lID09PSAncGVyc3BlY3RpdmUnKSB7IHJldHVybiAncHgnOyB9XG4gIGlmIChzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3JvdGF0ZScpIHx8IHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAnc2tldycpKSB7IHJldHVybiAnZGVnJzsgfVxufVxuXG4vLyBWYWx1ZXNcblxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25WYWx1ZSh2YWwsIGFuaW1hdGFibGUpIHtcbiAgaWYgKCFpcy5mbmModmFsKSkgeyByZXR1cm4gdmFsOyB9XG4gIHJldHVybiB2YWwoYW5pbWF0YWJsZS50YXJnZXQsIGFuaW1hdGFibGUuaWQsIGFuaW1hdGFibGUudG90YWwpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWwsIHByb3ApIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShwcm9wKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkge1xuICB2YXIgdmFsdWVVbml0ID0gZ2V0VW5pdCh2YWx1ZSk7XG4gIGlmIChhcnJheUNvbnRhaW5zKFt1bml0LCAnZGVnJywgJ3JhZCcsICd0dXJuJ10sIHZhbHVlVW5pdCkpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIHZhciBjYWNoZWQgPSBjYWNoZS5DU1NbdmFsdWUgKyB1bml0XTtcbiAgaWYgKCFpcy51bmQoY2FjaGVkKSkgeyByZXR1cm4gY2FjaGVkOyB9XG4gIHZhciBiYXNlbGluZSA9IDEwMDtcbiAgdmFyIHRlbXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwudGFnTmFtZSk7XG4gIHZhciBwYXJlbnRFbCA9IChlbC5wYXJlbnROb2RlICYmIChlbC5wYXJlbnROb2RlICE9PSBkb2N1bWVudCkpID8gZWwucGFyZW50Tm9kZSA6IGRvY3VtZW50LmJvZHk7XG4gIHBhcmVudEVsLmFwcGVuZENoaWxkKHRlbXBFbCk7XG4gIHRlbXBFbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHRlbXBFbC5zdHlsZS53aWR0aCA9IGJhc2VsaW5lICsgdW5pdDtcbiAgdmFyIGZhY3RvciA9IGJhc2VsaW5lIC8gdGVtcEVsLm9mZnNldFdpZHRoO1xuICBwYXJlbnRFbC5yZW1vdmVDaGlsZCh0ZW1wRWwpO1xuICB2YXIgY29udmVydGVkVW5pdCA9IGZhY3RvciAqIHBhcnNlRmxvYXQodmFsdWUpO1xuICBjYWNoZS5DU1NbdmFsdWUgKyB1bml0XSA9IGNvbnZlcnRlZFVuaXQ7XG4gIHJldHVybiBjb252ZXJ0ZWRVbml0O1xufVxuXG5mdW5jdGlvbiBnZXRDU1NWYWx1ZShlbCwgcHJvcCwgdW5pdCkge1xuICBpZiAocHJvcCBpbiBlbC5zdHlsZSkge1xuICAgIHZhciB1cHBlcmNhc2VQcm9wTmFtZSA9IHByb3AucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdmFsdWUgPSBlbC5zdHlsZVtwcm9wXSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHVwcGVyY2FzZVByb3BOYW1lKSB8fCAnMCc7XG4gICAgcmV0dXJuIHVuaXQgPyBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSA6IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGlvblR5cGUoZWwsIHByb3ApIHtcbiAgaWYgKGlzLmRvbShlbCkgJiYgIWlzLmlucChlbCkgJiYgKGdldEF0dHJpYnV0ZShlbCwgcHJvcCkgfHwgKGlzLnN2ZyhlbCkgJiYgZWxbcHJvcF0pKSkgeyByZXR1cm4gJ2F0dHJpYnV0ZSc7IH1cbiAgaWYgKGlzLmRvbShlbCkgJiYgYXJyYXlDb250YWlucyh2YWxpZFRyYW5zZm9ybXMsIHByb3ApKSB7IHJldHVybiAndHJhbnNmb3JtJzsgfVxuICBpZiAoaXMuZG9tKGVsKSAmJiAocHJvcCAhPT0gJ3RyYW5zZm9ybScgJiYgZ2V0Q1NTVmFsdWUoZWwsIHByb3ApKSkgeyByZXR1cm4gJ2Nzcyc7IH1cbiAgaWYgKGVsW3Byb3BdICE9IG51bGwpIHsgcmV0dXJuICdvYmplY3QnOyB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUcmFuc2Zvcm1zKGVsKSB7XG4gIGlmICghaXMuZG9tKGVsKSkgeyByZXR1cm47IH1cbiAgdmFyIHN0ciA9IGVsLnN0eWxlLnRyYW5zZm9ybSB8fCAnJztcbiAgdmFyIHJlZyAgPSAvKFxcdyspXFwoKFteKV0qKVxcKS9nO1xuICB2YXIgdHJhbnNmb3JtcyA9IG5ldyBNYXAoKTtcbiAgdmFyIG07IHdoaWxlIChtID0gcmVnLmV4ZWMoc3RyKSkgeyB0cmFuc2Zvcm1zLnNldChtWzFdLCBtWzJdKTsgfVxuICByZXR1cm4gdHJhbnNmb3Jtcztcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVmFsdWUoZWwsIHByb3BOYW1lLCBhbmltYXRhYmxlLCB1bml0KSB7XG4gIHZhciBkZWZhdWx0VmFsID0gc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdzY2FsZScpID8gMSA6IDAgKyBnZXRUcmFuc2Zvcm1Vbml0KHByb3BOYW1lKTtcbiAgdmFyIHZhbHVlID0gZ2V0RWxlbWVudFRyYW5zZm9ybXMoZWwpLmdldChwcm9wTmFtZSkgfHwgZGVmYXVsdFZhbDtcbiAgaWYgKGFuaW1hdGFibGUpIHtcbiAgICBhbmltYXRhYmxlLnRyYW5zZm9ybXMubGlzdC5zZXQocHJvcE5hbWUsIHZhbHVlKTtcbiAgICBhbmltYXRhYmxlLnRyYW5zZm9ybXNbJ2xhc3QnXSA9IHByb3BOYW1lO1xuICB9XG4gIHJldHVybiB1bml0ID8gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB1bml0LCBhbmltYXRhYmxlKSB7XG4gIHN3aXRjaCAoZ2V0QW5pbWF0aW9uVHlwZSh0YXJnZXQsIHByb3BOYW1lKSkge1xuICAgIGNhc2UgJ3RyYW5zZm9ybSc6IHJldHVybiBnZXRUcmFuc2Zvcm1WYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCBhbmltYXRhYmxlLCB1bml0KTtcbiAgICBjYXNlICdjc3MnOiByZXR1cm4gZ2V0Q1NTVmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCk7XG4gICAgY2FzZSAnYXR0cmlidXRlJzogcmV0dXJuIGdldEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdGFyZ2V0W3Byb3BOYW1lXSB8fCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlVmFsdWUodG8sIGZyb20pIHtcbiAgdmFyIG9wZXJhdG9yID0gL14oXFwqPXxcXCs9fC09KS8uZXhlYyh0byk7XG4gIGlmICghb3BlcmF0b3IpIHsgcmV0dXJuIHRvOyB9XG4gIHZhciB1ID0gZ2V0VW5pdCh0bykgfHwgMDtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KGZyb20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQodG8ucmVwbGFjZShvcGVyYXRvclswXSwgJycpKTtcbiAgc3dpdGNoIChvcGVyYXRvclswXVswXSkge1xuICAgIGNhc2UgJysnOiByZXR1cm4geCArIHkgKyB1O1xuICAgIGNhc2UgJy0nOiByZXR1cm4geCAtIHkgKyB1O1xuICAgIGNhc2UgJyonOiByZXR1cm4geCAqIHkgKyB1O1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVmFsdWUodmFsLCB1bml0KSB7XG4gIGlmIChpcy5jb2wodmFsKSkgeyByZXR1cm4gY29sb3JUb1JnYih2YWwpOyB9XG4gIGlmICgvXFxzL2cudGVzdCh2YWwpKSB7IHJldHVybiB2YWw7IH1cbiAgdmFyIG9yaWdpbmFsVW5pdCA9IGdldFVuaXQodmFsKTtcbiAgdmFyIHVuaXRMZXNzID0gb3JpZ2luYWxVbml0ID8gdmFsLnN1YnN0cigwLCB2YWwubGVuZ3RoIC0gb3JpZ2luYWxVbml0Lmxlbmd0aCkgOiB2YWw7XG4gIGlmICh1bml0KSB7IHJldHVybiB1bml0TGVzcyArIHVuaXQ7IH1cbiAgcmV0dXJuIHVuaXRMZXNzO1xufVxuXG4vLyBnZXRUb3RhbExlbmd0aCgpIGVxdWl2YWxlbnQgZm9yIGNpcmNsZSwgcmVjdCwgcG9seWxpbmUsIHBvbHlnb24gYW5kIGxpbmUgc2hhcGVzXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vU2ViTGFtYmxhLzNlMDU1MGM0OTZjMjM2NzA5NzQ0XG5cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAyLnggLSBwMS54LCAyKSArIE1hdGgucG93KHAyLnkgLSBwMS55LCAyKSk7XG59XG5cbmZ1bmN0aW9uIGdldENpcmNsZUxlbmd0aChlbCkge1xuICByZXR1cm4gTWF0aC5QSSAqIDIgKiBnZXRBdHRyaWJ1dGUoZWwsICdyJyk7XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIChnZXRBdHRyaWJ1dGUoZWwsICd3aWR0aCcpICogMikgKyAoZ2V0QXR0cmlidXRlKGVsLCAnaGVpZ2h0JykgKiAyKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChlbCkge1xuICByZXR1cm4gZ2V0RGlzdGFuY2UoXG4gICAge3g6IGdldEF0dHJpYnV0ZShlbCwgJ3gxJyksIHk6IGdldEF0dHJpYnV0ZShlbCwgJ3kxJyl9LCBcbiAgICB7eDogZ2V0QXR0cmlidXRlKGVsLCAneDInKSwgeTogZ2V0QXR0cmlidXRlKGVsLCAneTInKX1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9seWxpbmVMZW5ndGgoZWwpIHtcbiAgdmFyIHBvaW50cyA9IGVsLnBvaW50cztcbiAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcbiAgdmFyIHByZXZpb3VzUG9zO1xuICBmb3IgKHZhciBpID0gMCA7IGkgPCBwb2ludHMubnVtYmVyT2ZJdGVtczsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSBwb2ludHMuZ2V0SXRlbShpKTtcbiAgICBpZiAoaSA+IDApIHsgdG90YWxMZW5ndGggKz0gZ2V0RGlzdGFuY2UocHJldmlvdXNQb3MsIGN1cnJlbnRQb3MpOyB9XG4gICAgcHJldmlvdXNQb3MgPSBjdXJyZW50UG9zO1xuICB9XG4gIHJldHVybiB0b3RhbExlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2V0UG9seWdvbkxlbmd0aChlbCkge1xuICB2YXIgcG9pbnRzID0gZWwucG9pbnRzO1xuICByZXR1cm4gZ2V0UG9seWxpbmVMZW5ndGgoZWwpICsgZ2V0RGlzdGFuY2UocG9pbnRzLmdldEl0ZW0ocG9pbnRzLm51bWJlck9mSXRlbXMgLSAxKSwgcG9pbnRzLmdldEl0ZW0oMCkpO1xufVxuXG4vLyBQYXRoIGFuaW1hdGlvblxuXG5mdW5jdGlvbiBnZXRUb3RhbExlbmd0aChlbCkge1xuICBpZiAoZWwuZ2V0VG90YWxMZW5ndGgpIHsgcmV0dXJuIGVsLmdldFRvdGFsTGVuZ3RoKCk7IH1cbiAgc3dpdGNoKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2NpcmNsZSc6IHJldHVybiBnZXRDaXJjbGVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3JlY3QnOiByZXR1cm4gZ2V0UmVjdExlbmd0aChlbCk7XG4gICAgY2FzZSAnbGluZSc6IHJldHVybiBnZXRMaW5lTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdwb2x5bGluZSc6IHJldHVybiBnZXRQb2x5bGluZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncG9seWdvbic6IHJldHVybiBnZXRQb2x5Z29uTGVuZ3RoKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXREYXNob2Zmc2V0KGVsKSB7XG4gIHZhciBwYXRoTGVuZ3RoID0gZ2V0VG90YWxMZW5ndGgoZWwpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBwYXRoTGVuZ3RoKTtcbiAgcmV0dXJuIHBhdGhMZW5ndGg7XG59XG5cbi8vIE1vdGlvbiBwYXRoXG5cbmZ1bmN0aW9uIGdldFBhcmVudFN2Z0VsKGVsKSB7XG4gIHZhciBwYXJlbnRFbCA9IGVsLnBhcmVudE5vZGU7XG4gIHdoaWxlIChpcy5zdmcocGFyZW50RWwpKSB7XG4gICAgaWYgKCFpcy5zdmcocGFyZW50RWwucGFyZW50Tm9kZSkpIHsgYnJlYWs7IH1cbiAgICBwYXJlbnRFbCA9IHBhcmVudEVsLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhcmVudEVsO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdmcocGF0aEVsLCBzdmdEYXRhKSB7XG4gIHZhciBzdmcgPSBzdmdEYXRhIHx8IHt9O1xuICB2YXIgcGFyZW50U3ZnRWwgPSBzdmcuZWwgfHwgZ2V0UGFyZW50U3ZnRWwocGF0aEVsKTtcbiAgdmFyIHJlY3QgPSBwYXJlbnRTdmdFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHZpZXdCb3hBdHRyID0gZ2V0QXR0cmlidXRlKHBhcmVudFN2Z0VsLCAndmlld0JveCcpO1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciB2aWV3Qm94ID0gc3ZnLnZpZXdCb3ggfHwgKHZpZXdCb3hBdHRyID8gdmlld0JveEF0dHIuc3BsaXQoJyAnKSA6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gIHJldHVybiB7XG4gICAgZWw6IHBhcmVudFN2Z0VsLFxuICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgeDogdmlld0JveFswXSAvIDEsXG4gICAgeTogdmlld0JveFsxXSAvIDEsXG4gICAgdzogd2lkdGggLyB2aWV3Qm94WzJdLFxuICAgIGg6IGhlaWdodCAvIHZpZXdCb3hbM11cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoKHBhdGgsIHBlcmNlbnQpIHtcbiAgdmFyIHBhdGhFbCA9IGlzLnN0cihwYXRoKSA/IHNlbGVjdFN0cmluZyhwYXRoKVswXSA6IHBhdGg7XG4gIHZhciBwID0gcGVyY2VudCB8fCAxMDA7XG4gIHJldHVybiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICBlbDogcGF0aEVsLFxuICAgICAgc3ZnOiBnZXRQYXJlbnRTdmcocGF0aEVsKSxcbiAgICAgIHRvdGFsTGVuZ3RoOiBnZXRUb3RhbExlbmd0aChwYXRoRWwpICogKHAgLyAxMDApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhQcm9ncmVzcyhwYXRoLCBwcm9ncmVzcykge1xuICBmdW5jdGlvbiBwb2ludChvZmZzZXQpIHtcbiAgICBpZiAoIG9mZnNldCA9PT0gdm9pZCAwICkgb2Zmc2V0ID0gMDtcblxuICAgIHZhciBsID0gcHJvZ3Jlc3MgKyBvZmZzZXQgPj0gMSA/IHByb2dyZXNzICsgb2Zmc2V0IDogMDtcbiAgICByZXR1cm4gcGF0aC5lbC5nZXRQb2ludEF0TGVuZ3RoKGwpO1xuICB9XG4gIHZhciBzdmcgPSBnZXRQYXJlbnRTdmcocGF0aC5lbCwgcGF0aC5zdmcpO1xuICB2YXIgcCA9IHBvaW50KCk7XG4gIHZhciBwMCA9IHBvaW50KC0xKTtcbiAgdmFyIHAxID0gcG9pbnQoKzEpO1xuICBzd2l0Y2ggKHBhdGgucHJvcGVydHkpIHtcbiAgICBjYXNlICd4JzogcmV0dXJuIChwLnggLSBzdmcueCkgKiBzdmcudztcbiAgICBjYXNlICd5JzogcmV0dXJuIChwLnkgLSBzdmcueSkgKiBzdmcuaDtcbiAgICBjYXNlICdhbmdsZSc6IHJldHVybiBNYXRoLmF0YW4yKHAxLnkgLSBwMC55LCBwMS54IC0gcDAueCkgKiAxODAgLyBNYXRoLlBJO1xuICB9XG59XG5cbi8vIERlY29tcG9zZSB2YWx1ZVxuXG5mdW5jdGlvbiBkZWNvbXBvc2VWYWx1ZSh2YWwsIHVuaXQpIHtcbiAgLy8gY29uc3Qgcmd4ID0gLy0/XFxkKlxcLj9cXGQrL2c7IC8vIGhhbmRsZXMgYmFzaWMgbnVtYmVyc1xuICAvLyBjb25zdCByZ3ggPSAvWystXT9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/L2c7IC8vIGhhbmRsZXMgZXhwb25lbnRzIG5vdGF0aW9uXG4gIHZhciByZ3ggPSAvWystXT9cXGQqXFwuP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8vZzsgLy8gaGFuZGxlcyBleHBvbmVudHMgbm90YXRpb25cbiAgdmFyIHZhbHVlID0gdmFsaWRhdGVWYWx1ZSgoaXMucHRoKHZhbCkgPyB2YWwudG90YWxMZW5ndGggOiB2YWwpLCB1bml0KSArICcnO1xuICByZXR1cm4ge1xuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBudW1iZXJzOiB2YWx1ZS5tYXRjaChyZ3gpID8gdmFsdWUubWF0Y2gocmd4KS5tYXAoTnVtYmVyKSA6IFswXSxcbiAgICBzdHJpbmdzOiAoaXMuc3RyKHZhbCkgfHwgdW5pdCkgPyB2YWx1ZS5zcGxpdChyZ3gpIDogW11cbiAgfVxufVxuXG4vLyBBbmltYXRhYmxlc1xuXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gdGFyZ2V0cyA/IChmbGF0dGVuQXJyYXkoaXMuYXJyKHRhcmdldHMpID8gdGFyZ2V0cy5tYXAodG9BcnJheSkgOiB0b0FycmF5KHRhcmdldHMpKSkgOiBbXTtcbiAgcmV0dXJuIGZpbHRlckFycmF5KHRhcmdldHNBcnJheSwgZnVuY3Rpb24gKGl0ZW0sIHBvcywgc2VsZikgeyByZXR1cm4gc2VsZi5pbmRleE9mKGl0ZW0pID09PSBwb3M7IH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlcyh0YXJnZXRzKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIHJldHVybiBwYXJzZWQubWFwKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgcmV0dXJuIHt0YXJnZXQ6IHQsIGlkOiBpLCB0b3RhbDogcGFyc2VkLmxlbmd0aCwgdHJhbnNmb3JtczogeyBsaXN0OiBnZXRFbGVtZW50VHJhbnNmb3Jtcyh0KSB9IH07XG4gIH0pO1xufVxuXG4vLyBQcm9wZXJ0aWVzXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHByb3AsIHR3ZWVuU2V0dGluZ3MpIHtcbiAgdmFyIHNldHRpbmdzID0gY2xvbmVPYmplY3QodHdlZW5TZXR0aW5ncyk7XG4gIC8vIE92ZXJyaWRlIGR1cmF0aW9uIGlmIGVhc2luZyBpcyBhIHNwcmluZ1xuICBpZiAoL15zcHJpbmcvLnRlc3Qoc2V0dGluZ3MuZWFzaW5nKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHNwcmluZyhzZXR0aW5ncy5lYXNpbmcpOyB9XG4gIGlmIChpcy5hcnIocHJvcCkpIHtcbiAgICB2YXIgbCA9IHByb3AubGVuZ3RoO1xuICAgIHZhciBpc0Zyb21UbyA9IChsID09PSAyICYmICFpcy5vYmoocHJvcFswXSkpO1xuICAgIGlmICghaXNGcm9tVG8pIHtcbiAgICAgIC8vIER1cmF0aW9uIGRpdmlkZWQgYnkgdGhlIG51bWJlciBvZiB0d2VlbnNcbiAgICAgIGlmICghaXMuZm5jKHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24pKSB7IHNldHRpbmdzLmR1cmF0aW9uID0gdHdlZW5TZXR0aW5ncy5kdXJhdGlvbiAvIGw7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhbnNmb3JtIFtmcm9tLCB0b10gdmFsdWVzIHNob3J0aGFuZCB0byBhIHZhbGlkIHR3ZWVuIHZhbHVlXG4gICAgICBwcm9wID0ge3ZhbHVlOiBwcm9wfTtcbiAgICB9XG4gIH1cbiAgdmFyIHByb3BBcnJheSA9IGlzLmFycihwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gIHJldHVybiBwcm9wQXJyYXkubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgdmFyIG9iaiA9IChpcy5vYmoodikgJiYgIWlzLnB0aCh2KSkgPyB2IDoge3ZhbHVlOiB2fTtcbiAgICAvLyBEZWZhdWx0IGRlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGZpcnN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZGVsYXkpKSB7IG9iai5kZWxheSA9ICFpID8gdHdlZW5TZXR0aW5ncy5kZWxheSA6IDA7IH1cbiAgICAvLyBEZWZhdWx0IGVuZERlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGxhc3QgdHdlZW5cbiAgICBpZiAoaXMudW5kKG9iai5lbmREZWxheSkpIHsgb2JqLmVuZERlbGF5ID0gaSA9PT0gcHJvcEFycmF5Lmxlbmd0aCAtIDEgPyB0d2VlblNldHRpbmdzLmVuZERlbGF5IDogMDsgfVxuICAgIHJldHVybiBvYmo7XG4gIH0pLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gbWVyZ2VPYmplY3RzKGssIHNldHRpbmdzKTsgfSk7XG59XG5cblxuZnVuY3Rpb24gZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpIHtcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoa2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBPYmplY3Qua2V5cyhrZXkpOyB9KSksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBpcy5rZXkocCk7IH0pXG4gIC5yZWR1Y2UoZnVuY3Rpb24gKGEsYikgeyBpZiAoYS5pbmRleE9mKGIpIDwgMCkgeyBhLnB1c2goYik7IH0gcmV0dXJuIGE7IH0sIFtdKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgICBwcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG5ld0tleSA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBrZXkpIHtcbiAgICAgICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgICAgIGlmIChwID09IHByb3BOYW1lKSB7IG5ld0tleS52YWx1ZSA9IGtleVtwXTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0tleVtwXSA9IGtleVtwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXModHdlZW5TZXR0aW5ncywgcGFyYW1zKSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gW107XG4gIHZhciBrZXlmcmFtZXMgPSBwYXJhbXMua2V5ZnJhbWVzO1xuICBpZiAoa2V5ZnJhbWVzKSB7IHBhcmFtcyA9IG1lcmdlT2JqZWN0cyhmbGF0dGVuS2V5ZnJhbWVzKGtleWZyYW1lcyksIHBhcmFtcyk7IH1cbiAgZm9yICh2YXIgcCBpbiBwYXJhbXMpIHtcbiAgICBpZiAoaXMua2V5KHApKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBwLFxuICAgICAgICB0d2VlbnM6IG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHBhcmFtc1twXSwgdHdlZW5TZXR0aW5ncylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuLy8gVHdlZW5zXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHR3ZWVuLCBhbmltYXRhYmxlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gdHdlZW4pIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuW3BdLCBhbmltYXRhYmxlKTtcbiAgICBpZiAoaXMuYXJyKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGdldEZ1bmN0aW9uVmFsdWUodiwgYW5pbWF0YWJsZSk7IH0pO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkgeyB2YWx1ZSA9IHZhbHVlWzBdOyB9XG4gICAgfVxuICAgIHRbcF0gPSB2YWx1ZTtcbiAgfVxuICB0LmR1cmF0aW9uID0gcGFyc2VGbG9hdCh0LmR1cmF0aW9uKTtcbiAgdC5kZWxheSA9IHBhcnNlRmxvYXQodC5kZWxheSk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSkge1xuICB2YXIgcHJldmlvdXNUd2VlbjtcbiAgcmV0dXJuIHByb3AudHdlZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHZhciB0d2VlbiA9IG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHQsIGFuaW1hdGFibGUpO1xuICAgIHZhciB0d2VlblZhbHVlID0gdHdlZW4udmFsdWU7XG4gICAgdmFyIHRvID0gaXMuYXJyKHR3ZWVuVmFsdWUpID8gdHdlZW5WYWx1ZVsxXSA6IHR3ZWVuVmFsdWU7XG4gICAgdmFyIHRvVW5pdCA9IGdldFVuaXQodG8pO1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZShhbmltYXRhYmxlLnRhcmdldCwgcHJvcC5uYW1lLCB0b1VuaXQsIGFuaW1hdGFibGUpO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJldmlvdXNUd2VlbiA/IHByZXZpb3VzVHdlZW4udG8ub3JpZ2luYWwgOiBvcmlnaW5hbFZhbHVlO1xuICAgIHZhciBmcm9tID0gaXMuYXJyKHR3ZWVuVmFsdWUpID8gdHdlZW5WYWx1ZVswXSA6IHByZXZpb3VzVmFsdWU7XG4gICAgdmFyIGZyb21Vbml0ID0gZ2V0VW5pdChmcm9tKSB8fCBnZXRVbml0KG9yaWdpbmFsVmFsdWUpO1xuICAgIHZhciB1bml0ID0gdG9Vbml0IHx8IGZyb21Vbml0O1xuICAgIGlmIChpcy51bmQodG8pKSB7IHRvID0gcHJldmlvdXNWYWx1ZTsgfVxuICAgIHR3ZWVuLmZyb20gPSBkZWNvbXBvc2VWYWx1ZShmcm9tLCB1bml0KTtcbiAgICB0d2Vlbi50byA9IGRlY29tcG9zZVZhbHVlKGdldFJlbGF0aXZlVmFsdWUodG8sIGZyb20pLCB1bml0KTtcbiAgICB0d2Vlbi5zdGFydCA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLmVuZCA6IDA7XG4gICAgdHdlZW4uZW5kID0gdHdlZW4uc3RhcnQgKyB0d2Vlbi5kZWxheSArIHR3ZWVuLmR1cmF0aW9uICsgdHdlZW4uZW5kRGVsYXk7XG4gICAgdHdlZW4uZWFzaW5nID0gcGFyc2VFYXNpbmdzKHR3ZWVuLmVhc2luZywgdHdlZW4uZHVyYXRpb24pO1xuICAgIHR3ZWVuLmlzUGF0aCA9IGlzLnB0aCh0d2VlblZhbHVlKTtcbiAgICB0d2Vlbi5pc0NvbG9yID0gaXMuY29sKHR3ZWVuLmZyb20ub3JpZ2luYWwpO1xuICAgIGlmICh0d2Vlbi5pc0NvbG9yKSB7IHR3ZWVuLnJvdW5kID0gMTsgfVxuICAgIHByZXZpb3VzVHdlZW4gPSB0d2VlbjtcbiAgICByZXR1cm4gdHdlZW47XG4gIH0pO1xufVxuXG4vLyBUd2VlbiBwcm9ncmVzc1xuXG52YXIgc2V0UHJvZ3Jlc3NWYWx1ZSA9IHtcbiAgY3NzOiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdC5zdHlsZVtwXSA9IHY7IH0sXG4gIGF0dHJpYnV0ZTogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc2V0QXR0cmlidXRlKHAsIHYpOyB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0W3BdID0gdjsgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiAodCwgcCwgdiwgdHJhbnNmb3JtcywgbWFudWFsKSB7XG4gICAgdHJhbnNmb3Jtcy5saXN0LnNldChwLCB2KTtcbiAgICBpZiAocCA9PT0gdHJhbnNmb3Jtcy5sYXN0IHx8IG1hbnVhbCkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgdHJhbnNmb3Jtcy5saXN0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBwcm9wKSB7IHN0ciArPSBwcm9wICsgXCIoXCIgKyB2YWx1ZSArIFwiKSBcIjsgfSk7XG4gICAgICB0LnN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFNldCBWYWx1ZSBoZWxwZXJcblxuZnVuY3Rpb24gc2V0VGFyZ2V0c1ZhbHVlKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGFuaW1hdGFibGVzID0gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cyk7XG4gIGFuaW1hdGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGFibGUpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHByb3BlcnRpZXNbcHJvcGVydHldLCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB0YXJnZXQgPSBhbmltYXRhYmxlLnRhcmdldDtcbiAgICAgIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZVVuaXQsIGFuaW1hdGFibGUpO1xuICAgICAgdmFyIHVuaXQgPSB2YWx1ZVVuaXQgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciB0byA9IGdldFJlbGF0aXZlVmFsdWUodmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdW5pdCksIG9yaWdpbmFsVmFsdWUpO1xuICAgICAgdmFyIGFuaW1UeXBlID0gZ2V0QW5pbWF0aW9uVHlwZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIHNldFByb2dyZXNzVmFsdWVbYW5pbVR5cGVdKHRhcmdldCwgcHJvcGVydHksIHRvLCBhbmltYXRhYmxlLnRyYW5zZm9ybXMsIHRydWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIEFuaW1hdGlvbnNcblxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApIHtcbiAgdmFyIGFuaW1UeXBlID0gZ2V0QW5pbWF0aW9uVHlwZShhbmltYXRhYmxlLnRhcmdldCwgcHJvcC5uYW1lKTtcbiAgaWYgKGFuaW1UeXBlKSB7XG4gICAgdmFyIHR3ZWVucyA9IG5vcm1hbGl6ZVR3ZWVucyhwcm9wLCBhbmltYXRhYmxlKTtcbiAgICB2YXIgbGFzdFR3ZWVuID0gdHdlZW5zW3R3ZWVucy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYW5pbVR5cGUsXG4gICAgICBwcm9wZXJ0eTogcHJvcC5uYW1lLFxuICAgICAgYW5pbWF0YWJsZTogYW5pbWF0YWJsZSxcbiAgICAgIHR3ZWVuczogdHdlZW5zLFxuICAgICAgZHVyYXRpb246IGxhc3RUd2Vlbi5lbmQsXG4gICAgICBkZWxheTogdHdlZW5zWzBdLmRlbGF5LFxuICAgICAgZW5kRGVsYXk6IGxhc3RUd2Vlbi5lbmREZWxheVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoYW5pbWF0YWJsZXMubWFwKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgcmV0dXJuIHByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApO1xuICAgIH0pO1xuICB9KSksIGZ1bmN0aW9uIChhKSB7IHJldHVybiAhaXMudW5kKGEpOyB9KTtcbn1cblxuLy8gQ3JlYXRlIEluc3RhbmNlXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlVGltaW5ncyhhbmltYXRpb25zLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBhbmltTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gIHZhciBnZXRUbE9mZnNldCA9IGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBhbmltLnRpbWVsaW5lT2Zmc2V0ID8gYW5pbS50aW1lbGluZU9mZnNldCA6IDA7IH07XG4gIHZhciB0aW1pbmdzID0ge307XG4gIHRpbWluZ3MuZHVyYXRpb24gPSBhbmltTGVuZ3RoID8gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbjsgfSkpIDogdHdlZW5TZXR0aW5ncy5kdXJhdGlvbjtcbiAgdGltaW5ncy5kZWxheSA9IGFuaW1MZW5ndGggPyBNYXRoLm1pbi5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmRlbGF5OyB9KSkgOiB0d2VlblNldHRpbmdzLmRlbGF5O1xuICB0aW1pbmdzLmVuZERlbGF5ID0gYW5pbUxlbmd0aCA/IHRpbWluZ3MuZHVyYXRpb24gLSBNYXRoLm1heC5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmR1cmF0aW9uIC0gYW5pbS5lbmREZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5lbmREZWxheTtcbiAgcmV0dXJuIHRpbWluZ3M7XG59XG5cbnZhciBpbnN0YW5jZUlEID0gMDtcblxuZnVuY3Rpb24gY3JlYXRlTmV3SW5zdGFuY2UocGFyYW1zKSB7XG4gIHZhciBpbnN0YW5jZVNldHRpbmdzID0gcmVwbGFjZU9iamVjdFByb3BzKGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgdHdlZW5TZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHByb3BlcnRpZXMgPSBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHBhcmFtcy50YXJnZXRzKTtcbiAgdmFyIGFuaW1hdGlvbnMgPSBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKTtcbiAgdmFyIHRpbWluZ3MgPSBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncyk7XG4gIHZhciBpZCA9IGluc3RhbmNlSUQ7XG4gIGluc3RhbmNlSUQrKztcbiAgcmV0dXJuIG1lcmdlT2JqZWN0cyhpbnN0YW5jZVNldHRpbmdzLCB7XG4gICAgaWQ6IGlkLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBhbmltYXRhYmxlczogYW5pbWF0YWJsZXMsXG4gICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICBkdXJhdGlvbjogdGltaW5ncy5kdXJhdGlvbixcbiAgICBkZWxheTogdGltaW5ncy5kZWxheSxcbiAgICBlbmREZWxheTogdGltaW5ncy5lbmREZWxheVxuICB9KTtcbn1cblxuLy8gQ29yZVxuXG52YXIgYWN0aXZlSW5zdGFuY2VzID0gW107XG52YXIgcGF1c2VkSW5zdGFuY2VzID0gW107XG52YXIgcmFmO1xuXG52YXIgZW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gcGxheSgpIHsgXG4gICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICB9XG4gIGZ1bmN0aW9uIHN0ZXAodCkge1xuICAgIHZhciBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgIGlmIChhY3RpdmVJbnN0YW5jZXNMZW5ndGgpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICAgICAgaWYgKCFhY3RpdmVJbnN0YW5jZS5wYXVzZWQpIHtcbiAgICAgICAgICBhY3RpdmVJbnN0YW5jZS50aWNrKHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnN0YW5jZUluZGV4ID0gYWN0aXZlSW5zdGFuY2VzLmluZGV4T2YoYWN0aXZlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VJbmRleCwgMSk7XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBwbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZiA9IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgfVxuICB9XG4gIHJldHVybiBwbGF5O1xufSkoKTtcblxuZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgIGFjdGl2ZUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnMpIHsgcmV0dXJuIGlucy5wYXVzZSgpOyB9KTtcbiAgICBwYXVzZWRJbnN0YW5jZXMgPSBhY3RpdmVJbnN0YW5jZXMuc2xpY2UoMCk7XG4gICAgYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIHBhdXNlZEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnMpIHsgcmV0dXJuIGlucy5wbGF5KCk7IH0pO1xuICB9XG59XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbn1cblxuLy8gUHVibGljIEluc3RhbmNlXG5cbmZ1bmN0aW9uIGFuaW1lKHBhcmFtcykge1xuICBpZiAoIHBhcmFtcyA9PT0gdm9pZCAwICkgcGFyYW1zID0ge307XG5cblxuICB2YXIgc3RhcnRUaW1lID0gMCwgbGFzdFRpbWUgPSAwLCBub3cgPSAwO1xuICB2YXIgY2hpbGRyZW4sIGNoaWxkcmVuTGVuZ3RoID0gMDtcbiAgdmFyIHJlc29sdmUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIG1ha2VQcm9taXNlKGluc3RhbmNlKSB7XG4gICAgdmFyIHByb21pc2UgPSB3aW5kb3cuUHJvbWlzZSAmJiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoX3Jlc29sdmUpIHsgcmV0dXJuIHJlc29sdmUgPSBfcmVzb2x2ZTsgfSk7XG4gICAgaW5zdGFuY2UuZmluaXNoZWQgPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gY3JlYXRlTmV3SW5zdGFuY2UocGFyYW1zKTtcbiAgdmFyIHByb21pc2UgPSBtYWtlUHJvbWlzZShpbnN0YW5jZSk7XG5cbiAgZnVuY3Rpb24gdG9nZ2xlSW5zdGFuY2VEaXJlY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGluc3RhbmNlLmRpcmVjdGlvbjtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnYWx0ZXJuYXRlJykge1xuICAgICAgaW5zdGFuY2UuZGlyZWN0aW9uID0gZGlyZWN0aW9uICE9PSAnbm9ybWFsJyA/ICdub3JtYWwnIDogJ3JldmVyc2UnO1xuICAgIH1cbiAgICBpbnN0YW5jZS5yZXZlcnNlZCA9ICFpbnN0YW5jZS5yZXZlcnNlZDtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQucmV2ZXJzZWQgPSBpbnN0YW5jZS5yZXZlcnNlZDsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGp1c3RUaW1lKHRpbWUpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UucmV2ZXJzZWQgPyBpbnN0YW5jZS5kdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUaW1lKCkge1xuICAgIHN0YXJ0VGltZSA9IDA7XG4gICAgbGFzdFRpbWUgPSBhZGp1c3RUaW1lKGluc3RhbmNlLmN1cnJlbnRUaW1lKSAqICgxIC8gYW5pbWUuc3BlZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2Vla0NoaWxkKHRpbWUsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7IGNoaWxkLnNlZWsodGltZSAtIGNoaWxkLnRpbWVsaW5lT2Zmc2V0KTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY0luc3RhbmNlQ2hpbGRyZW4odGltZSkge1xuICAgIGlmICghaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHsgc2Vla0NoaWxkKHRpbWUsIGNoaWxkcmVuW2ldKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSBjaGlsZHJlbkxlbmd0aDsgaSQxLS07KSB7IHNlZWtDaGlsZCh0aW1lLCBjaGlsZHJlbltpJDFdKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNUaW1lKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhbmltYXRpb25zID0gaW5zdGFuY2UuYW5pbWF0aW9ucztcbiAgICB2YXIgYW5pbWF0aW9uc0xlbmd0aCA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgYW5pbWF0aW9uc0xlbmd0aCkge1xuICAgICAgdmFyIGFuaW0gPSBhbmltYXRpb25zW2ldO1xuICAgICAgdmFyIGFuaW1hdGFibGUgPSBhbmltLmFuaW1hdGFibGU7XG4gICAgICB2YXIgdHdlZW5zID0gYW5pbS50d2VlbnM7XG4gICAgICB2YXIgdHdlZW5MZW5ndGggPSB0d2VlbnMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciB0d2VlbiA9IHR3ZWVuc1t0d2Vlbkxlbmd0aF07XG4gICAgICAvLyBPbmx5IGNoZWNrIGZvciBrZXlmcmFtZXMgaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSB0d2VlblxuICAgICAgaWYgKHR3ZWVuTGVuZ3RoKSB7IHR3ZWVuID0gZmlsdGVyQXJyYXkodHdlZW5zLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gKGluc1RpbWUgPCB0LmVuZCk7IH0pWzBdIHx8IHR3ZWVuOyB9XG4gICAgICB2YXIgZWxhcHNlZCA9IG1pbk1heChpbnNUaW1lIC0gdHdlZW4uc3RhcnQgLSB0d2Vlbi5kZWxheSwgMCwgdHdlZW4uZHVyYXRpb24pIC8gdHdlZW4uZHVyYXRpb247XG4gICAgICB2YXIgZWFzZWQgPSBpc05hTihlbGFwc2VkKSA/IDEgOiB0d2Vlbi5lYXNpbmcoZWxhcHNlZCk7XG4gICAgICB2YXIgc3RyaW5ncyA9IHR3ZWVuLnRvLnN0cmluZ3M7XG4gICAgICB2YXIgcm91bmQgPSB0d2Vlbi5yb3VuZDtcbiAgICAgIHZhciBudW1iZXJzID0gW107XG4gICAgICB2YXIgdG9OdW1iZXJzTGVuZ3RoID0gdHdlZW4udG8ubnVtYmVycy5sZW5ndGg7XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSAodm9pZCAwKTtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdG9OdW1iZXJzTGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gKHZvaWQgMCk7XG4gICAgICAgIHZhciB0b051bWJlciA9IHR3ZWVuLnRvLm51bWJlcnNbbl07XG4gICAgICAgIHZhciBmcm9tTnVtYmVyID0gdHdlZW4uZnJvbS5udW1iZXJzW25dIHx8IDA7XG4gICAgICAgIGlmICghdHdlZW4uaXNQYXRoKSB7XG4gICAgICAgICAgdmFsdWUgPSBmcm9tTnVtYmVyICsgKGVhc2VkICogKHRvTnVtYmVyIC0gZnJvbU51bWJlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gZ2V0UGF0aFByb2dyZXNzKHR3ZWVuLnZhbHVlLCBlYXNlZCAqIHRvTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICBpZiAoISh0d2Vlbi5pc0NvbG9yICYmIG4gPiAyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogcm91bmQpIC8gcm91bmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBNYW51YWwgQXJyYXkucmVkdWNlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VzXG4gICAgICB2YXIgc3RyaW5nc0xlbmd0aCA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgaWYgKCFzdHJpbmdzTGVuZ3RoKSB7XG4gICAgICAgIHByb2dyZXNzID0gbnVtYmVyc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyZXNzID0gc3RyaW5nc1swXTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdHJpbmdzTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgYSA9IHN0cmluZ3Nbc107XG4gICAgICAgICAgdmFyIGIgPSBzdHJpbmdzW3MgKyAxXTtcbiAgICAgICAgICB2YXIgbiQxID0gbnVtYmVyc1tzXTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG4kMSkpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyAnICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UHJvZ3Jlc3NWYWx1ZVthbmltLnR5cGVdKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltLnByb3BlcnR5LCBwcm9ncmVzcywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zKTtcbiAgICAgIGFuaW0uY3VycmVudFZhbHVlID0gcHJvZ3Jlc3M7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FsbGJhY2soY2IpIHtcbiAgICBpZiAoaW5zdGFuY2VbY2JdICYmICFpbnN0YW5jZS5wYXNzVGhyb3VnaCkgeyBpbnN0YW5jZVtjYl0oaW5zdGFuY2UpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudEl0ZXJhdGlvbigpIHtcbiAgICBpZiAoaW5zdGFuY2UucmVtYWluaW5nICYmIGluc3RhbmNlLnJlbWFpbmluZyAhPT0gdHJ1ZSkge1xuICAgICAgaW5zdGFuY2UucmVtYWluaW5nLS07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW5zdGFuY2VQcm9ncmVzcyhlbmdpbmVUaW1lKSB7XG4gICAgdmFyIGluc0R1cmF0aW9uID0gaW5zdGFuY2UuZHVyYXRpb247XG4gICAgdmFyIGluc0RlbGF5ID0gaW5zdGFuY2UuZGVsYXk7XG4gICAgdmFyIGluc0VuZERlbGF5ID0gaW5zRHVyYXRpb24gLSBpbnN0YW5jZS5lbmREZWxheTtcbiAgICB2YXIgaW5zVGltZSA9IGFkanVzdFRpbWUoZW5naW5lVGltZSk7XG4gICAgaW5zdGFuY2UucHJvZ3Jlc3MgPSBtaW5NYXgoKGluc1RpbWUgLyBpbnNEdXJhdGlvbikgKiAxMDAsIDAsIDEwMCk7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gaW5zVGltZSA8IGluc3RhbmNlLmN1cnJlbnRUaW1lO1xuICAgIGlmIChjaGlsZHJlbikgeyBzeW5jSW5zdGFuY2VDaGlsZHJlbihpbnNUaW1lKTsgfVxuICAgIGlmICghaW5zdGFuY2UuYmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5iZWdhbiA9IHRydWU7XG4gICAgICBzZXRDYWxsYmFjaygnYmVnaW4nKTtcbiAgICB9XG4gICAgaWYgKCFpbnN0YW5jZS5sb29wQmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSB0cnVlO1xuICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BCZWdpbicpO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA8PSBpbnNEZWxheSAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSAhPT0gMCkge1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKDApO1xuICAgIH1cbiAgICBpZiAoKGluc1RpbWUgPj0gaW5zRW5kRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IGluc0R1cmF0aW9uKSB8fCAhaW5zRHVyYXRpb24pIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNEdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChpbnNUaW1lID4gaW5zRGVsYXkgJiYgaW5zVGltZSA8IGluc0VuZERlbGF5KSB7XG4gICAgICBpZiAoIWluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VCZWdpbicpO1xuICAgICAgfVxuICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZScpO1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zdGFuY2UuY2hhbmdlQmVnYW4pIHtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZUNvbXBsZXRlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gbWluTWF4KGluc1RpbWUsIDAsIGluc0R1cmF0aW9uKTtcbiAgICBpZiAoaW5zdGFuY2UuYmVnYW4pIHsgc2V0Q2FsbGJhY2soJ3VwZGF0ZScpOyB9XG4gICAgaWYgKGVuZ2luZVRpbWUgPj0gaW5zRHVyYXRpb24pIHtcbiAgICAgIGxhc3RUaW1lID0gMDtcbiAgICAgIGNvdW50SXRlcmF0aW9uKCk7XG4gICAgICBpZiAoIWluc3RhbmNlLnJlbWFpbmluZykge1xuICAgICAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWluc3RhbmNlLmNvbXBsZXRlZCkge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICAgIHNldENhbGxiYWNrKCdjb21wbGV0ZScpO1xuICAgICAgICAgIGlmICghaW5zdGFuY2UucGFzc1Rocm91Z2ggJiYgJ1Byb21pc2UnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmRpcmVjdGlvbiA9PT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgICAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zdGFuY2UucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGluc3RhbmNlLnBhc3NUaHJvdWdoID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIGluc3RhbmNlLnByb2dyZXNzID0gMDtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIGluc3RhbmNlLmJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jaGFuZ2VDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlZCA9IGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnO1xuICAgIGluc3RhbmNlLnJlbWFpbmluZyA9IGluc3RhbmNlLmxvb3A7XG4gICAgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gY2hpbGRyZW5MZW5ndGg7IGktLTspIHsgaW5zdGFuY2UuY2hpbGRyZW5baV0ucmVzZXQoKTsgfVxuICAgIGlmIChpbnN0YW5jZS5yZXZlcnNlZCAmJiBpbnN0YW5jZS5sb29wICE9PSB0cnVlIHx8IChkaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnICYmIGluc3RhbmNlLmxvb3AgPT09IDEpKSB7IGluc3RhbmNlLnJlbWFpbmluZysrOyB9XG4gICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gOiAwKTtcbiAgfTtcblxuICAvLyBTZXQgVmFsdWUgaGVscGVyXG5cbiAgaW5zdGFuY2Uuc2V0ID0gZnVuY3Rpb24odGFyZ2V0cywgcHJvcGVydGllcykge1xuICAgIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgaW5zdGFuY2UudGljayA9IGZ1bmN0aW9uKHQpIHtcbiAgICBub3cgPSB0O1xuICAgIGlmICghc3RhcnRUaW1lKSB7IHN0YXJ0VGltZSA9IG5vdzsgfVxuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoKG5vdyArIChsYXN0VGltZSAtIHN0YXJ0VGltZSkpICogYW5pbWUuc3BlZWQpO1xuICB9O1xuXG4gIGluc3RhbmNlLnNlZWsgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgc2V0SW5zdGFuY2VQcm9ncmVzcyhhZGp1c3RUaW1lKHRpbWUpKTtcbiAgfTtcblxuICBpbnN0YW5jZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgcmVzZXRUaW1lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGxheSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghaW5zdGFuY2UucGF1c2VkKSB7IHJldHVybjsgfVxuICAgIGlmIChpbnN0YW5jZS5jb21wbGV0ZWQpIHsgaW5zdGFuY2UucmVzZXQoKTsgfVxuICAgIGluc3RhbmNlLnBhdXNlZCA9IGZhbHNlO1xuICAgIGFjdGl2ZUluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICByZXNldFRpbWUoKTtcbiAgICBpZiAoIXJhZikgeyBlbmdpbmUoKTsgfVxuICB9O1xuXG4gIGluc3RhbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5yZXNldCgpO1xuICAgIGluc3RhbmNlLnBsYXkoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5yZXNldCgpO1xuXG4gIGlmIChpbnN0YW5jZS5hdXRvcGxheSkgeyBpbnN0YW5jZS5wbGF5KCk7IH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG5cbn1cblxuLy8gUmVtb3ZlIHRhcmdldHMgZnJvbSBhbmltYXRpb25cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9ucykge1xuICBmb3IgKHZhciBhID0gYW5pbWF0aW9ucy5sZW5ndGg7IGEtLTspIHtcbiAgICBpZiAoYXJyYXlDb250YWlucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnNbYV0uYW5pbWF0YWJsZS50YXJnZXQpKSB7XG4gICAgICBhbmltYXRpb25zLnNwbGljZShhLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXRzQXJyYXkgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIGZvciAodmFyIGkgPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIGluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzW2ldO1xuICAgIHZhciBhbmltYXRpb25zID0gaW5zdGFuY2UuYW5pbWF0aW9ucztcbiAgICB2YXIgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKTtcbiAgICBmb3IgKHZhciBjID0gY2hpbGRyZW4ubGVuZ3RoOyBjLS07KSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltjXTtcbiAgICAgIHZhciBjaGlsZEFuaW1hdGlvbnMgPSBjaGlsZC5hbmltYXRpb25zO1xuICAgICAgcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgY2hpbGRBbmltYXRpb25zKTtcbiAgICAgIGlmICghY2hpbGRBbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7IGNoaWxkcmVuLnNwbGljZShjLCAxKTsgfVxuICAgIH1cbiAgICBpZiAoIWFuaW1hdGlvbnMubGVuZ3RoICYmICFjaGlsZHJlbi5sZW5ndGgpIHsgaW5zdGFuY2UucGF1c2UoKTsgfVxuICB9XG59XG5cbi8vIFN0YWdnZXIgaGVscGVyc1xuXG5mdW5jdGlvbiBzdGFnZ2VyKHZhbCwgcGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgZGlyZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbiB8fCAnbm9ybWFsJztcbiAgdmFyIGVhc2luZyA9IHBhcmFtcy5lYXNpbmcgPyBwYXJzZUVhc2luZ3MocGFyYW1zLmVhc2luZykgOiBudWxsO1xuICB2YXIgZ3JpZCA9IHBhcmFtcy5ncmlkO1xuICB2YXIgYXhpcyA9IHBhcmFtcy5heGlzO1xuICB2YXIgZnJvbUluZGV4ID0gcGFyYW1zLmZyb20gfHwgMDtcbiAgdmFyIGZyb21GaXJzdCA9IGZyb21JbmRleCA9PT0gJ2ZpcnN0JztcbiAgdmFyIGZyb21DZW50ZXIgPSBmcm9tSW5kZXggPT09ICdjZW50ZXInO1xuICB2YXIgZnJvbUxhc3QgPSBmcm9tSW5kZXggPT09ICdsYXN0JztcbiAgdmFyIGlzUmFuZ2UgPSBpcy5hcnIodmFsKTtcbiAgdmFyIHZhbDEgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMF0pIDogcGFyc2VGbG9hdCh2YWwpO1xuICB2YXIgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZUZsb2F0KHZhbFsxXSkgOiAwO1xuICB2YXIgdW5pdCA9IGdldFVuaXQoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgfHwgMDtcbiAgdmFyIHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgbWF4VmFsdWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCB0KSB7XG4gICAgaWYgKGZyb21GaXJzdCkgeyBmcm9tSW5kZXggPSAwOyB9XG4gICAgaWYgKGZyb21DZW50ZXIpIHsgZnJvbUluZGV4ID0gKHQgLSAxKSAvIDI7IH1cbiAgICBpZiAoZnJvbUxhc3QpIHsgZnJvbUluZGV4ID0gdCAtIDE7IH1cbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0OyBpbmRleCsrKSB7XG4gICAgICAgIGlmICghZ3JpZCkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKE1hdGguYWJzKGZyb21JbmRleCAtIGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb21YID0gIWZyb21DZW50ZXIgPyBmcm9tSW5kZXglZ3JpZFswXSA6IChncmlkWzBdLTEpLzI7XG4gICAgICAgICAgdmFyIGZyb21ZID0gIWZyb21DZW50ZXIgPyBNYXRoLmZsb29yKGZyb21JbmRleC9ncmlkWzBdKSA6IChncmlkWzFdLTEpLzI7XG4gICAgICAgICAgdmFyIHRvWCA9IGluZGV4JWdyaWRbMF07XG4gICAgICAgICAgdmFyIHRvWSA9IE1hdGguZmxvb3IoaW5kZXgvZ3JpZFswXSk7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBmcm9tWSAtIHRvWTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7IHZhbHVlID0gLWRpc3RhbmNlWDsgfVxuICAgICAgICAgIGlmIChheGlzID09PSAneScpIHsgdmFsdWUgPSAtZGlzdGFuY2VZOyB9XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlYXNpbmcpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBlYXNpbmcodmFsIC8gbWF4VmFsdWUpICogbWF4VmFsdWU7IH0pOyB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncmV2ZXJzZScpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBheGlzID8gKHZhbCA8IDApID8gdmFsICogLTEgOiAtdmFsIDogTWF0aC5hYnMobWF4VmFsdWUgLSB2YWwpOyB9KTsgfVxuICAgIH1cbiAgICB2YXIgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIHJldHVybiBzdGFydCArIChzcGFjaW5nICogKE1hdGgucm91bmQodmFsdWVzW2ldICogMTAwKSAvIDEwMCkpICsgdW5pdDtcbiAgfVxufVxuXG4vLyBUaW1lbGluZVxuXG5mdW5jdGlvbiB0aW1lbGluZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciB0bCA9IGFuaW1lKHBhcmFtcyk7XG4gIHRsLmR1cmF0aW9uID0gMDtcbiAgdGwuYWRkID0gZnVuY3Rpb24oaW5zdGFuY2VQYXJhbXMsIHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgdmFyIHRsSW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZih0bCk7XG4gICAgdmFyIGNoaWxkcmVuID0gdGwuY2hpbGRyZW47XG4gICAgaWYgKHRsSW5kZXggPiAtMSkgeyBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKHRsSW5kZXgsIDEpOyB9XG4gICAgZnVuY3Rpb24gcGFzc1Rocm91Z2goaW5zKSB7IGlucy5wYXNzVGhyb3VnaCA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHBhc3NUaHJvdWdoKGNoaWxkcmVuW2ldKTsgfVxuICAgIHZhciBpbnNQYXJhbXMgPSBtZXJnZU9iamVjdHMoaW5zdGFuY2VQYXJhbXMsIHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKSk7XG4gICAgaW5zUGFyYW1zLnRhcmdldHMgPSBpbnNQYXJhbXMudGFyZ2V0cyB8fCBwYXJhbXMudGFyZ2V0cztcbiAgICB2YXIgdGxEdXJhdGlvbiA9IHRsLmR1cmF0aW9uO1xuICAgIGluc1BhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGluc1BhcmFtcy5kaXJlY3Rpb24gPSB0bC5kaXJlY3Rpb247XG4gICAgaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0ID0gaXMudW5kKHRpbWVsaW5lT2Zmc2V0KSA/IHRsRHVyYXRpb24gOiBnZXRSZWxhdGl2ZVZhbHVlKHRpbWVsaW5lT2Zmc2V0LCB0bER1cmF0aW9uKTtcbiAgICBwYXNzVGhyb3VnaCh0bCk7XG4gICAgdGwuc2VlayhpbnNQYXJhbXMudGltZWxpbmVPZmZzZXQpO1xuICAgIHZhciBpbnMgPSBhbmltZShpbnNQYXJhbXMpO1xuICAgIHBhc3NUaHJvdWdoKGlucyk7XG4gICAgY2hpbGRyZW4ucHVzaChpbnMpO1xuICAgIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGNoaWxkcmVuLCBwYXJhbXMpO1xuICAgIHRsLmRlbGF5ID0gdGltaW5ncy5kZWxheTtcbiAgICB0bC5lbmREZWxheSA9IHRpbWluZ3MuZW5kRGVsYXk7XG4gICAgdGwuZHVyYXRpb24gPSB0aW1pbmdzLmR1cmF0aW9uO1xuICAgIHRsLnNlZWsoMCk7XG4gICAgdGwucmVzZXQoKTtcbiAgICBpZiAodGwuYXV0b3BsYXkpIHsgdGwucGxheSgpOyB9XG4gICAgcmV0dXJuIHRsO1xuICB9O1xuICByZXR1cm4gdGw7XG59XG5cbmFuaW1lLnZlcnNpb24gPSAnMy4xLjAnO1xuYW5pbWUuc3BlZWQgPSAxO1xuYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcztcbmFuaW1lLnJlbW92ZSA9IHJlbW92ZVRhcmdldHM7XG5hbmltZS5nZXQgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlO1xuYW5pbWUuc2V0ID0gc2V0VGFyZ2V0c1ZhbHVlO1xuYW5pbWUuY29udmVydFB4ID0gY29udmVydFB4VG9Vbml0O1xuYW5pbWUucGF0aCA9IGdldFBhdGg7XG5hbmltZS5zZXREYXNob2Zmc2V0ID0gc2V0RGFzaG9mZnNldDtcbmFuaW1lLnN0YWdnZXIgPSBzdGFnZ2VyO1xuYW5pbWUudGltZWxpbmUgPSB0aW1lbGluZTtcbmFuaW1lLmVhc2luZyA9IHBhcnNlRWFzaW5ncztcbmFuaW1lLnBlbm5lciA9IHBlbm5lcjtcbmFuaW1lLnJhbmRvbSA9IGZ1bmN0aW9uIChtaW4sIG1heCkgeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBhbmltZTtcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXRoL3RydW5jXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1uYW5cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL21heC1zYWZlLWludGVnZXJcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIiFmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW1wiZXhwb3J0c1wiXSx0KTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzKXQoZXhwb3J0cyk7ZWxzZXt2YXIgbz17fTt0KG8pLGUuYm9keVNjcm9sbExvY2s9b319KHRoaXMsZnVuY3Rpb24oZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxvPUFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylvW3RdPWVbdF07cmV0dXJuIG99cmV0dXJuIEFycmF5LmZyb20oZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9ITE7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl7dmFyIGU9e2dldCBwYXNzaXZlKCl7bD0hMH19O3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIixudWxsLGUpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIixudWxsLGUpfXZhciBkPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5uYXZpZ2F0b3ImJndpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0mJi9pUChhZHxob25lfG9kKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSxjPVtdLHU9ITEsYT0tMSxzPXZvaWQgMCx2PXZvaWQgMCxmPWZ1bmN0aW9uKHQpe3JldHVybiBjLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuISghZS5vcHRpb25zLmFsbG93VG91Y2hNb3ZlfHwhZS5vcHRpb25zLmFsbG93VG91Y2hNb3ZlKHQpKX0pfSxtPWZ1bmN0aW9uKGUpe3ZhciB0PWV8fHdpbmRvdy5ldmVudDtyZXR1cm4hIWYodC50YXJnZXQpfHwoMTx0LnRvdWNoZXMubGVuZ3RofHwodC5wcmV2ZW50RGVmYXVsdCYmdC5wcmV2ZW50RGVmYXVsdCgpLCExKSl9LG89ZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dm9pZCAwIT09diYmKGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0PXYsdj12b2lkIDApLHZvaWQgMCE9PXMmJihkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93PXMscz12b2lkIDApfSl9O2V4cG9ydHMuZGlzYWJsZUJvZHlTY3JvbGw9ZnVuY3Rpb24oaSxlKXtpZihkKXtpZighaSlyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiZGlzYWJsZUJvZHlTY3JvbGwgdW5zdWNjZXNzZnVsIC0gdGFyZ2V0RWxlbWVudCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY2FsbGluZyBkaXNhYmxlQm9keVNjcm9sbCBvbiBJT1MgZGV2aWNlcy5cIik7aWYoaSYmIWMuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZS50YXJnZXRFbGVtZW50PT09aX0pKXt2YXIgdD17dGFyZ2V0RWxlbWVudDppLG9wdGlvbnM6ZXx8e319O2M9W10uY29uY2F0KHIoYyksW3RdKSxpLm9udG91Y2hzdGFydD1mdW5jdGlvbihlKXsxPT09ZS50YXJnZXRUb3VjaGVzLmxlbmd0aCYmKGE9ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkpfSxpLm9udG91Y2htb3ZlPWZ1bmN0aW9uKGUpe3ZhciB0LG8sbixyOzE9PT1lLnRhcmdldFRvdWNoZXMubGVuZ3RoJiYobz1pLHI9KHQ9ZSkudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLWEsIWYodC50YXJnZXQpJiYobyYmMD09PW8uc2Nyb2xsVG9wJiYwPHI/bSh0KToobj1vKSYmbi5zY3JvbGxIZWlnaHQtbi5zY3JvbGxUb3A8PW4uY2xpZW50SGVpZ2h0JiZyPDA/bSh0KTp0LnN0b3BQcm9wYWdhdGlvbigpKSl9LHV8fChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsbSxsP3twYXNzaXZlOiExfTp2b2lkIDApLHU9ITApfX1lbHNle249ZSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYodm9pZCAwPT09dil7dmFyIGU9ISFuJiYhMD09PW4ucmVzZXJ2ZVNjcm9sbEJhckdhcCx0PXdpbmRvdy5pbm5lcldpZHRoLWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtlJiYwPHQmJih2PWRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0LGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0PXQrXCJweFwiKX12b2lkIDA9PT1zJiYocz1kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93LGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIil9KTt2YXIgbz17dGFyZ2V0RWxlbWVudDppLG9wdGlvbnM6ZXx8e319O2M9W10uY29uY2F0KHIoYyksW29dKX12YXIgbn0sZXhwb3J0cy5jbGVhckFsbEJvZHlTY3JvbGxMb2Nrcz1mdW5jdGlvbigpe2Q/KGMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnRhcmdldEVsZW1lbnQub250b3VjaHN0YXJ0PW51bGwsZS50YXJnZXRFbGVtZW50Lm9udG91Y2htb3ZlPW51bGx9KSx1JiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLG0sbD97cGFzc2l2ZTohMX06dm9pZCAwKSx1PSExKSxjPVtdLGE9LTEpOihvKCksYz1bXSl9LGV4cG9ydHMuZW5hYmxlQm9keVNjcm9sbD1mdW5jdGlvbih0KXtpZihkKXtpZighdClyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiZW5hYmxlQm9keVNjcm9sbCB1bnN1Y2Nlc3NmdWwgLSB0YXJnZXRFbGVtZW50IG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjYWxsaW5nIGVuYWJsZUJvZHlTY3JvbGwgb24gSU9TIGRldmljZXMuXCIpO3Qub250b3VjaHN0YXJ0PW51bGwsdC5vbnRvdWNobW92ZT1udWxsLGM9Yy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUudGFyZ2V0RWxlbWVudCE9PXR9KSx1JiYwPT09Yy5sZW5ndGgmJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsbSxsP3twYXNzaXZlOiExfTp2b2lkIDApLHU9ITEpfWVsc2UgMT09PWMubGVuZ3RoJiZjWzBdLnRhcmdldEVsZW1lbnQ9PT10PyhvKCksYz1bXSk6Yz1jLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50YXJnZXRFbGVtZW50IT09dH0pfX0pO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5NYXRoLnNpZ247XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5NYXRoLnRydW5jO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTnVtYmVyLmlzTmFOO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbm1vZHVsZS5leHBvcnRzID0gMHgxZmZmZmZmZmZmZmZmZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMTEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgaXNFbnVtLmNhbGwoUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKSB9KTtcbiIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCkge1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIvKiBmbGF0cGlja3IgdjQuNS43LCBAbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuZmxhdHBpY2tyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbiAgICB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG4gICAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiAgICBUSElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAgICBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbiAgICBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG4gICAgTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcbiAgICBTZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuICAgIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcblxuICAgIHZhciBIT09LUyA9IFtcbiAgICAgICAgXCJvbkNoYW5nZVwiLFxuICAgICAgICBcIm9uQ2xvc2VcIixcbiAgICAgICAgXCJvbkRheUNyZWF0ZVwiLFxuICAgICAgICBcIm9uRGVzdHJveVwiLFxuICAgICAgICBcIm9uS2V5RG93blwiLFxuICAgICAgICBcIm9uTW9udGhDaGFuZ2VcIixcbiAgICAgICAgXCJvbk9wZW5cIixcbiAgICAgICAgXCJvblBhcnNlQ29uZmlnXCIsXG4gICAgICAgIFwib25SZWFkeVwiLFxuICAgICAgICBcIm9uVmFsdWVVcGRhdGVcIixcbiAgICAgICAgXCJvblllYXJDaGFuZ2VcIixcbiAgICAgICAgXCJvblByZUNhbGVuZGFyUG9zaXRpb25cIixcbiAgICBdO1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgX2Rpc2FibGU6IFtdLFxuICAgICAgICBfZW5hYmxlOiBbXSxcbiAgICAgICAgYWxsb3dJbnB1dDogZmFsc2UsXG4gICAgICAgIGFsdEZvcm1hdDogXCJGIGosIFlcIixcbiAgICAgICAgYWx0SW5wdXQ6IGZhbHNlLFxuICAgICAgICBhbHRJbnB1dENsYXNzOiBcImZvcm0tY29udHJvbCBpbnB1dFwiLFxuICAgICAgICBhbmltYXRlOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSA9PT0gLTEsXG4gICAgICAgIGFyaWFEYXRlRm9ybWF0OiBcIkYgaiwgWVwiLFxuICAgICAgICBjbGlja09wZW5zOiB0cnVlLFxuICAgICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgICBjb25qdW5jdGlvbjogXCIsIFwiLFxuICAgICAgICBkYXRlRm9ybWF0OiBcIlktbS1kXCIsXG4gICAgICAgIGRlZmF1bHRIb3VyOiAxMixcbiAgICAgICAgZGVmYXVsdE1pbnV0ZTogMCxcbiAgICAgICAgZGVmYXVsdFNlY29uZHM6IDAsXG4gICAgICAgIGRpc2FibGU6IFtdLFxuICAgICAgICBkaXNhYmxlTW9iaWxlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlOiBbXSxcbiAgICAgICAgZW5hYmxlU2Vjb25kczogZmFsc2UsXG4gICAgICAgIGVuYWJsZVRpbWU6IGZhbHNlLFxuICAgICAgICBlcnJvckhhbmRsZXI6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2VlazogZnVuY3Rpb24gKGdpdmVuRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShnaXZlbkRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAvLyBUaHVyc2RheSBpbiBjdXJyZW50IHdlZWsgZGVjaWRlcyB0aGUgeWVhci5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDMgLSAoKGRhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpKTtcbiAgICAgICAgICAgIC8vIEphbnVhcnkgNCBpcyBhbHdheXMgaW4gd2VlayAxLlxuICAgICAgICAgICAgdmFyIHdlZWsxID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCA0KTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0byBUaHVyc2RheSBpbiB3ZWVrIDEgYW5kIGNvdW50IG51bWJlciBvZiB3ZWVrcyBmcm9tIGRhdGUgdG8gd2VlazEuXG4gICAgICAgICAgICByZXR1cm4gKDEgK1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKChkYXRlLmdldFRpbWUoKSAtIHdlZWsxLmdldFRpbWUoKSkgLyA4NjQwMDAwMCAtXG4gICAgICAgICAgICAgICAgICAgIDMgK1xuICAgICAgICAgICAgICAgICAgICAoKHdlZWsxLmdldERheSgpICsgNikgJSA3KSkgL1xuICAgICAgICAgICAgICAgICAgICA3KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhvdXJJbmNyZW1lbnQ6IDEsXG4gICAgICAgIGlnbm9yZWRGb2N1c0VsZW1lbnRzOiBbXSxcbiAgICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgICAgbG9jYWxlOiBcImRlZmF1bHRcIixcbiAgICAgICAgbWludXRlSW5jcmVtZW50OiA1LFxuICAgICAgICBtb2RlOiBcInNpbmdsZVwiLFxuICAgICAgICBuZXh0QXJyb3c6IFwiPHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHZpZXdCb3g9JzAgMCAxNyAxNyc+PGc+PC9nPjxwYXRoIGQ9J00xMy4yMDcgOC40NzJsLTcuODU0IDcuODU0LTAuNzA3LTAuNzA3IDcuMTQ2LTcuMTQ2LTcuMTQ2LTcuMTQ4IDAuNzA3LTAuNzA3IDcuODU0IDcuODU0eicgLz48L3N2Zz5cIixcbiAgICAgICAgbm9DYWxlbmRhcjogZmFsc2UsXG4gICAgICAgIG5vdzogbmV3IERhdGUoKSxcbiAgICAgICAgb25DaGFuZ2U6IFtdLFxuICAgICAgICBvbkNsb3NlOiBbXSxcbiAgICAgICAgb25EYXlDcmVhdGU6IFtdLFxuICAgICAgICBvbkRlc3Ryb3k6IFtdLFxuICAgICAgICBvbktleURvd246IFtdLFxuICAgICAgICBvbk1vbnRoQ2hhbmdlOiBbXSxcbiAgICAgICAgb25PcGVuOiBbXSxcbiAgICAgICAgb25QYXJzZUNvbmZpZzogW10sXG4gICAgICAgIG9uUmVhZHk6IFtdLFxuICAgICAgICBvblZhbHVlVXBkYXRlOiBbXSxcbiAgICAgICAgb25ZZWFyQ2hhbmdlOiBbXSxcbiAgICAgICAgb25QcmVDYWxlbmRhclBvc2l0aW9uOiBbXSxcbiAgICAgICAgcGx1Z2luczogW10sXG4gICAgICAgIHBvc2l0aW9uOiBcImF1dG9cIixcbiAgICAgICAgcG9zaXRpb25FbGVtZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZBcnJvdzogXCI8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgdmlld0JveD0nMCAwIDE3IDE3Jz48Zz48L2c+PHBhdGggZD0nTTUuMjA3IDguNDcxbDcuMTQ2IDcuMTQ3LTAuNzA3IDAuNzA3LTcuODUzLTcuODU0IDcuODU0LTcuODUzIDAuNzA3IDAuNzA3LTcuMTQ3IDcuMTQ2eicgLz48L3N2Zz5cIixcbiAgICAgICAgc2hvcnRoYW5kQ3VycmVudE1vbnRoOiBmYWxzZSxcbiAgICAgICAgc2hvd01vbnRoczogMSxcbiAgICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgICAgdGltZV8yNGhyOiBmYWxzZSxcbiAgICAgICAgd2Vla051bWJlcnM6IGZhbHNlLFxuICAgICAgICB3cmFwOiBmYWxzZVxuICAgIH07XG5cbiAgICB2YXIgZW5nbGlzaCA9IHtcbiAgICAgICAgd2Vla2RheXM6IHtcbiAgICAgICAgICAgIHNob3J0aGFuZDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIlN1bmRheVwiLFxuICAgICAgICAgICAgICAgIFwiTW9uZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJUdWVzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJXZWRuZXNkYXlcIixcbiAgICAgICAgICAgICAgICBcIlRodXJzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJGcmlkYXlcIixcbiAgICAgICAgICAgICAgICBcIlNhdHVyZGF5XCIsXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIG1vbnRoczoge1xuICAgICAgICAgICAgc2hvcnRoYW5kOiBbXG4gICAgICAgICAgICAgICAgXCJKYW5cIixcbiAgICAgICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgICAgIFwiTWFyXCIsXG4gICAgICAgICAgICAgICAgXCJBcHJcIixcbiAgICAgICAgICAgICAgICBcIk1heVwiLFxuICAgICAgICAgICAgICAgIFwiSnVuXCIsXG4gICAgICAgICAgICAgICAgXCJKdWxcIixcbiAgICAgICAgICAgICAgICBcIkF1Z1wiLFxuICAgICAgICAgICAgICAgIFwiU2VwXCIsXG4gICAgICAgICAgICAgICAgXCJPY3RcIixcbiAgICAgICAgICAgICAgICBcIk5vdlwiLFxuICAgICAgICAgICAgICAgIFwiRGVjXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIkphbnVhcnlcIixcbiAgICAgICAgICAgICAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgICAgICAgICAgICAgXCJNYXJjaFwiLFxuICAgICAgICAgICAgICAgIFwiQXByaWxcIixcbiAgICAgICAgICAgICAgICBcIk1heVwiLFxuICAgICAgICAgICAgICAgIFwiSnVuZVwiLFxuICAgICAgICAgICAgICAgIFwiSnVseVwiLFxuICAgICAgICAgICAgICAgIFwiQXVndXN0XCIsXG4gICAgICAgICAgICAgICAgXCJTZXB0ZW1iZXJcIixcbiAgICAgICAgICAgICAgICBcIk9jdG9iZXJcIixcbiAgICAgICAgICAgICAgICBcIk5vdmVtYmVyXCIsXG4gICAgICAgICAgICAgICAgXCJEZWNlbWJlclwiLFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBkYXlzSW5Nb250aDogWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdLFxuICAgICAgICBmaXJzdERheU9mV2VlazogMCxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG50aCkge1xuICAgICAgICAgICAgdmFyIHMgPSBudGggJSAxMDA7XG4gICAgICAgICAgICBpZiAocyA+IDMgJiYgcyA8IDIxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInRoXCI7XG4gICAgICAgICAgICBzd2l0Y2ggKHMgJSAxMCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyZFwiO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJhbmdlU2VwYXJhdG9yOiBcIiB0byBcIixcbiAgICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJXa1wiLFxuICAgICAgICBzY3JvbGxUaXRsZTogXCJTY3JvbGwgdG8gaW5jcmVtZW50XCIsXG4gICAgICAgIHRvZ2dsZVRpdGxlOiBcIkNsaWNrIHRvIHRvZ2dsZVwiLFxuICAgICAgICBhbVBNOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgICAgICB5ZWFyQXJpYUxhYmVsOiBcIlllYXJcIlxuICAgIH07XG5cbiAgICB2YXIgcGFkID0gZnVuY3Rpb24gKG51bWJlcikgeyByZXR1cm4gKFwiMFwiICsgbnVtYmVyKS5zbGljZSgtMik7IH07XG4gICAgdmFyIGludCA9IGZ1bmN0aW9uIChib29sKSB7IHJldHVybiAoYm9vbCA9PT0gdHJ1ZSA/IDEgOiAwKTsgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgICAgICBpZiAoaW1tZWRpYXRlID09PSB2b2lkIDApIHsgaW1tZWRpYXRlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aW1lb3V0ICE9PSBudWxsICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9LCB3YWl0KTtcbiAgICAgICAgICAgIGlmIChpbW1lZGlhdGUgJiYgIXRpbWVvdXQpXG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGFycmF5aWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiBbb2JqXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lLCBib29sKSB7XG4gICAgICAgIGlmIChib29sID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzTmFtZSwgY29udGVudCkge1xuICAgICAgICB2YXIgZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCBcIlwiO1xuICAgICAgICBjb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xuICAgICAgICBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFBhcmVudChub2RlLCBjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmluZFBhcmVudChub2RlLnBhcmVudE5vZGUsIGNvbmRpdGlvbik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIG5vdGhpbmcgZm91bmRcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTnVtYmVySW5wdXQoaW5wdXRDbGFzc05hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwibnVtSW5wdXRXcmFwcGVyXCIpLCBudW1JbnB1dCA9IGNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBcIm51bUlucHV0IFwiICsgaW5wdXRDbGFzc05hbWUpLCBhcnJvd1VwID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJhcnJvd1VwXCIpLCBhcnJvd0Rvd24gPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImFycm93RG93blwiKTtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgOS4wXCIpID09PSAtMSkge1xuICAgICAgICAgICAgbnVtSW5wdXQudHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBudW1JbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBudW1JbnB1dC5wYXR0ZXJuID0gXCJcXFxcZCpcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpXG4gICAgICAgICAgICAgICAgbnVtSW5wdXQuc2V0QXR0cmlidXRlKGtleSwgb3B0c1trZXldKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChudW1JbnB1dCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dVcCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dEb3duKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQuY29tcG9zZWRQYXRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICByZXR1cm4gcGF0aFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb19ub3RoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9O1xuICAgIHZhciBtb250aFRvU3RyID0gZnVuY3Rpb24gKG1vbnRoTnVtYmVyLCBzaG9ydGhhbmQsIGxvY2FsZSkgeyByZXR1cm4gbG9jYWxlLm1vbnRoc1tzaG9ydGhhbmQgPyBcInNob3J0aGFuZFwiIDogXCJsb25naGFuZFwiXVttb250aE51bWJlcl07IH07XG4gICAgdmFyIHJldkZvcm1hdCA9IHtcbiAgICAgICAgRDogZG9fbm90aGluZyxcbiAgICAgICAgRjogZnVuY3Rpb24gKGRhdGVPYmosIG1vbnRoTmFtZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1vbnRoKGxvY2FsZS5tb250aHMubG9uZ2hhbmQuaW5kZXhPZihtb250aE5hbWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgRzogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIEg6IGZ1bmN0aW9uIChkYXRlT2JqLCBob3VyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKHBhcnNlRmxvYXQoaG91cikpO1xuICAgICAgICB9LFxuICAgICAgICBKOiBmdW5jdGlvbiAoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgSzogZnVuY3Rpb24gKGRhdGVPYmosIGFtUE0sIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycygoZGF0ZU9iai5nZXRIb3VycygpICUgMTIpICtcbiAgICAgICAgICAgICAgICAxMiAqIGludChuZXcgUmVnRXhwKGxvY2FsZS5hbVBNWzFdLCBcImlcIikudGVzdChhbVBNKSkpO1xuICAgICAgICB9LFxuICAgICAgICBNOiBmdW5jdGlvbiAoZGF0ZU9iaiwgc2hvcnRNb250aCwgbG9jYWxlKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1vbnRoKGxvY2FsZS5tb250aHMuc2hvcnRoYW5kLmluZGV4T2Yoc2hvcnRNb250aCkpO1xuICAgICAgICB9LFxuICAgICAgICBTOiBmdW5jdGlvbiAoZGF0ZU9iaiwgc2Vjb25kcykge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRTZWNvbmRzKHBhcnNlRmxvYXQoc2Vjb25kcykpO1xuICAgICAgICB9LFxuICAgICAgICBVOiBmdW5jdGlvbiAoXywgdW5peFNlY29uZHMpIHsgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peFNlY29uZHMpICogMTAwMCk7IH0sXG4gICAgICAgIFc6IGZ1bmN0aW9uIChkYXRlT2JqLCB3ZWVrTnVtKSB7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlciA9IHBhcnNlSW50KHdlZWtOdW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVPYmouZ2V0RnVsbFllYXIoKSwgMCwgMiArICh3ZWVrTnVtYmVyIC0gMSkgKiA3LCAwLCAwLCAwLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgWTogZnVuY3Rpb24gKGRhdGVPYmosIHllYXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RnVsbFllYXIocGFyc2VGbG9hdCh5ZWFyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFo6IGZ1bmN0aW9uIChfLCBJU09EYXRlKSB7IHJldHVybiBuZXcgRGF0ZShJU09EYXRlKTsgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKGRhdGVPYmosIGRheSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXREYXRlKHBhcnNlRmxvYXQoZGF5KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGg6IGZ1bmN0aW9uIChkYXRlT2JqLCBob3VyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKHBhcnNlRmxvYXQoaG91cikpO1xuICAgICAgICB9LFxuICAgICAgICBpOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbWludXRlcykge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNaW51dGVzKHBhcnNlRmxvYXQobWludXRlcykpO1xuICAgICAgICB9LFxuICAgICAgICBqOiBmdW5jdGlvbiAoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbDogZG9fbm90aGluZyxcbiAgICAgICAgbTogZnVuY3Rpb24gKGRhdGVPYmosIG1vbnRoKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1vbnRoKHBhcnNlRmxvYXQobW9udGgpIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIG46IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aCkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChwYXJzZUZsb2F0KG1vbnRoKSAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBzOiBmdW5jdGlvbiAoZGF0ZU9iaiwgc2Vjb25kcykge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRTZWNvbmRzKHBhcnNlRmxvYXQoc2Vjb25kcykpO1xuICAgICAgICB9LFxuICAgICAgICB1OiBmdW5jdGlvbiAoXywgdW5peE1pbGxTZWNvbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VGbG9hdCh1bml4TWlsbFNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdzogZG9fbm90aGluZyxcbiAgICAgICAgeTogZnVuY3Rpb24gKGRhdGVPYmosIHllYXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RnVsbFllYXIoMjAwMCArIHBhcnNlRmxvYXQoeWVhcikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdG9rZW5SZWdleCA9IHtcbiAgICAgICAgRDogXCIoXFxcXHcrKVwiLFxuICAgICAgICBGOiBcIihcXFxcdyspXCIsXG4gICAgICAgIEc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIEg6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIEo6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXFxcXHcrXCIsXG4gICAgICAgIEs6IFwiXCIsXG4gICAgICAgIE06IFwiKFxcXFx3KylcIixcbiAgICAgICAgUzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgVTogXCIoLispXCIsXG4gICAgICAgIFc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIFk6IFwiKFxcXFxkezR9KVwiLFxuICAgICAgICBaOiBcIiguKylcIixcbiAgICAgICAgZDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgaDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgaTogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgajogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgbDogXCIoXFxcXHcrKVwiLFxuICAgICAgICBtOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBuOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBzOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICB1OiBcIiguKylcIixcbiAgICAgICAgdzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgeTogXCIoXFxcXGR7Mn0pXCJcbiAgICB9O1xuICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgICAvLyBnZXQgdGhlIGRhdGUgaW4gVVRDXG4gICAgICAgIFo6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7IH0sXG4gICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgc2hvcnQsIGUuZy4gVGh1XG4gICAgICAgIEQ6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXMuc2hvcnRoYW5kW2Zvcm1hdHMudyhkYXRlLCBsb2NhbGUsIG9wdGlvbnMpXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZnVsbCBtb250aCBuYW1lIGUuZy4gSmFudWFyeVxuICAgICAgICBGOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhUb1N0cihmb3JtYXRzLm4oZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSAtIDEsIGZhbHNlLCBsb2NhbGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwYWRkZWQgaG91ciAxLTEyXG4gICAgICAgIEc6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWQoZm9ybWF0cy5oKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBob3VycyB3aXRoIGxlYWRpbmcgemVybyBlLmcuIDAzXG4gICAgICAgIEg6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRIb3VycygpKTsgfSxcbiAgICAgICAgLy8gZGF5ICgxLTMwKSB3aXRoIG9yZGluYWwgc3VmZml4IGUuZy4gMXN0LCAybmRcbiAgICAgICAgSjogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5vcmRpbmFsICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGRhdGUuZ2V0RGF0ZSgpICsgbG9jYWxlLm9yZGluYWwoZGF0ZS5nZXREYXRlKCkpXG4gICAgICAgICAgICAgICAgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQU0vUE1cbiAgICAgICAgSzogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkgeyByZXR1cm4gbG9jYWxlLmFtUE1baW50KGRhdGUuZ2V0SG91cnMoKSA+IDExKV07IH0sXG4gICAgICAgIC8vIHNob3J0aGFuZCBtb250aCBlLmcuIEphbiwgU2VwLCBPY3QsIGV0Y1xuICAgICAgICBNOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhUb1N0cihkYXRlLmdldE1vbnRoKCksIHRydWUsIGxvY2FsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHNlY29uZHMgMDAtNTlcbiAgICAgICAgUzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldFNlY29uZHMoKSk7IH0sXG4gICAgICAgIC8vIHVuaXggdGltZXN0YW1wXG4gICAgICAgIFU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7IH0sXG4gICAgICAgIFc6IGZ1bmN0aW9uIChkYXRlLCBfLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXRXZWVrKGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmdWxsIHllYXIgZS5nLiAyMDE2XG4gICAgICAgIFk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7IH0sXG4gICAgICAgIC8vIGRheSBpbiBtb250aCwgcGFkZGVkICgwMS0zMClcbiAgICAgICAgZDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldERhdGUoKSk7IH0sXG4gICAgICAgIC8vIGhvdXIgZnJvbSAxLTEyIChhbS9wbSlcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIChkYXRlLmdldEhvdXJzKCkgJSAxMiA/IGRhdGUuZ2V0SG91cnMoKSAlIDEyIDogMTIpOyB9LFxuICAgICAgICAvLyBtaW51dGVzLCBwYWRkZWQgd2l0aCBsZWFkaW5nIHplcm8gZS5nLiAwOVxuICAgICAgICBpOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0TWludXRlcygpKTsgfSxcbiAgICAgICAgLy8gZGF5IGluIG1vbnRoICgxLTMwKVxuICAgICAgICBqOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXREYXRlKCk7IH0sXG4gICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgZnVsbCwgZS5nLiBUaHVyc2RheVxuICAgICAgICBsOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzLmxvbmdoYW5kW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwYWRkZWQgbW9udGggbnVtYmVyICgwMS0xMilcbiAgICAgICAgbTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldE1vbnRoKCkgKyAxKTsgfSxcbiAgICAgICAgLy8gdGhlIG1vbnRoIG51bWJlciAoMS0xMilcbiAgICAgICAgbjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7IH0sXG4gICAgICAgIC8vIHNlY29uZHMgMC01OVxuICAgICAgICBzOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7IH0sXG4gICAgICAgIC8vIFVuaXggTWlsbGlzZWNvbmRzXG4gICAgICAgIHU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKTsgfSxcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICAgICAgdzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7IH0sXG4gICAgICAgIC8vIGxhc3QgdHdvIGRpZ2l0cyBvZiB5ZWFyIGUuZy4gMTYgZm9yIDIwMTZcbiAgICAgICAgeTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIFN0cmluZyhkYXRlLmdldEZ1bGxZZWFyKCkpLnN1YnN0cmluZygyKTsgfVxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGF0ZUZvcm1hdHRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5jb25maWcsIGNvbmZpZyA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyA6IF9iLCBfYyA9IF9hLmwxMG4sIGwxMG4gPSBfYyA9PT0gdm9pZCAwID8gZW5nbGlzaCA6IF9jO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGVPYmosIGZybXQsIG92ZXJyaWRlTG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gb3ZlcnJpZGVMb2NhbGUgfHwgbDEwbjtcbiAgICAgICAgICAgIGlmIChjb25maWcuZm9ybWF0RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5mb3JtYXREYXRlKGRhdGVPYmosIGZybXQsIGxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJtdFxuICAgICAgICAgICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRzW2NdICYmIGFycltpIC0gMV0gIT09IFwiXFxcXFwiXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0c1tjXShkYXRlT2JqLCBsb2NhbGUsIGNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgOiBjICE9PSBcIlxcXFxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZURhdGVQYXJzZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EuY29uZmlnLCBjb25maWcgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdHMgOiBfYiwgX2MgPSBfYS5sMTBuLCBsMTBuID0gX2MgPT09IHZvaWQgMCA/IGVuZ2xpc2ggOiBfYztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBnaXZlbkZvcm1hdCwgdGltZWxlc3MsIGN1c3RvbUxvY2FsZSkge1xuICAgICAgICAgICAgaWYgKGRhdGUgIT09IDAgJiYgIWRhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBjdXN0b21Mb2NhbGUgfHwgbDEwbjtcbiAgICAgICAgICAgIHZhciBwYXJzZWREYXRlO1xuICAgICAgICAgICAgdmFyIGRhdGVfb3JpZyA9IGRhdGU7XG4gICAgICAgICAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRlICE9PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZGF0ZS50b0ZpeGVkICE9PSB1bmRlZmluZWQgLy8gdGltZXN0YW1wXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29weVxuICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gZGF0ZSBzdHJpbmdcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0ID0gZ2l2ZW5Gb3JtYXQgfHwgKGNvbmZpZyB8fCBkZWZhdWx0cykuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZXN0ciA9IFN0cmluZyhkYXRlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVzdHIgPT09IFwidG9kYXlcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvWiQvLnRlc3QoZGF0ZXN0cikgfHxcbiAgICAgICAgICAgICAgICAgICAgL0dNVCQvLnRlc3QoZGF0ZXN0cikgLy8gZGF0ZXN0cmluZ3Mgdy8gdGltZXpvbmVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25maWcgJiYgY29uZmlnLnBhcnNlRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IGNvbmZpZy5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAhY29uZmlnIHx8ICFjb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IERhdGUobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCAwLCAxLCAwLCAwLCAwLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IERhdGUobmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkID0gdm9pZCAwLCBvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1hdGNoSW5kZXggPSAwLCByZWdleFN0ciA9IFwiXCI7IGkgPCBmb3JtYXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbl8xID0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzQmFja1NsYXNoID0gdG9rZW5fMSA9PT0gXCJcXFxcXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXNjYXBlZCA9IGZvcm1hdFtpIC0gMV0gPT09IFwiXFxcXFwiIHx8IGlzQmFja1NsYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuUmVnZXhbdG9rZW5fMV0gJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleFN0ciArPSB0b2tlblJlZ2V4W3Rva2VuXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG5ldyBSZWdFeHAocmVnZXhTdHIpLmV4ZWMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaGVkID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BzW3Rva2VuXzEgIT09IFwiWVwiID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm46IHJldkZvcm1hdFt0b2tlbl8xXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbDogbWF0Y2hbKyttYXRjaEluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNCYWNrU2xhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhTdHIgKz0gXCIuXCI7IC8vIGRvbid0IHJlYWxseSBjYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBfYS5mbiwgdmFsID0gX2EudmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFyc2VkRGF0ZSA9IGZuKHBhcnNlZERhdGUsIHZhbCwgbG9jYWxlKSB8fCBwYXJzZWREYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBtYXRjaGVkID8gcGFyc2VkRGF0ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCEocGFyc2VkRGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHBhcnNlZERhdGUuZ2V0VGltZSgpKSkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBwcm92aWRlZDogXCIgKyBkYXRlX29yaWcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVsZXNzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHBhcnNlZERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkRGF0ZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGRpZmZlcmVuY2UgaW4gZGF0ZXMsIG1lYXN1cmVkIGluIG1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZURhdGVzKGRhdGUxLCBkYXRlMiwgdGltZWxlc3MpIHtcbiAgICAgICAgaWYgKHRpbWVsZXNzID09PSB2b2lkIDApIHsgdGltZWxlc3MgPSB0cnVlOyB9XG4gICAgICAgIGlmICh0aW1lbGVzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IERhdGUoZGF0ZTEuZ2V0VGltZSgpKS5zZXRIb3VycygwLCAwLCAwLCAwKSAtXG4gICAgICAgICAgICAgICAgbmV3IERhdGUoZGF0ZTIuZ2V0VGltZSgpKS5zZXRIb3VycygwLCAwLCAwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUxLmdldFRpbWUoKSAtIGRhdGUyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgdmFyIGlzQmV0d2VlbiA9IGZ1bmN0aW9uICh0cywgdHMxLCB0czIpIHtcbiAgICAgICAgcmV0dXJuIHRzID4gTWF0aC5taW4odHMxLCB0czIpICYmIHRzIDwgTWF0aC5tYXgodHMxLCB0czIpO1xuICAgIH07XG4gICAgdmFyIGR1cmF0aW9uID0ge1xuICAgICAgICBEQVk6IDg2NDAwMDAwXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGFyZ3NfMSA9IGFyZ3M7IF9hIDwgYXJnc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmdzXzFbX2FdO1xuICAgICAgICAgICAgICAgIF9sb29wXzEoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIERFQk9VTkNFRF9DSEFOR0VfTVMgPSAzMDA7XG4gICAgZnVuY3Rpb24gRmxhdHBpY2tySW5zdGFuY2UoZWxlbWVudCwgaW5zdGFuY2VDb25maWcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB7XG4gICAgICAgICAgICBjb25maWc6IF9fYXNzaWduKHt9LCBmbGF0cGlja3IuZGVmYXVsdENvbmZpZyksXG4gICAgICAgICAgICBsMTBuOiBlbmdsaXNoXG4gICAgICAgIH07XG4gICAgICAgIHNlbGYucGFyc2VEYXRlID0gY3JlYXRlRGF0ZVBhcnNlcih7IGNvbmZpZzogc2VsZi5jb25maWcsIGwxMG46IHNlbGYubDEwbiB9KTtcbiAgICAgICAgc2VsZi5faGFuZGxlcnMgPSBbXTtcbiAgICAgICAgc2VsZi5fYmluZCA9IGJpbmQ7XG4gICAgICAgIHNlbGYuX3NldEhvdXJzRnJvbURhdGUgPSBzZXRIb3Vyc0Zyb21EYXRlO1xuICAgICAgICBzZWxmLl9wb3NpdGlvbkNhbGVuZGFyID0gcG9zaXRpb25DYWxlbmRhcjtcbiAgICAgICAgc2VsZi5jaGFuZ2VNb250aCA9IGNoYW5nZU1vbnRoO1xuICAgICAgICBzZWxmLmNoYW5nZVllYXIgPSBjaGFuZ2VZZWFyO1xuICAgICAgICBzZWxmLmNsZWFyID0gY2xlYXI7XG4gICAgICAgIHNlbGYuY2xvc2UgPSBjbG9zZTtcbiAgICAgICAgc2VsZi5fY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgIHNlbGYuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gaXNFbmFibGVkO1xuICAgICAgICBzZWxmLmp1bXBUb0RhdGUgPSBqdW1wVG9EYXRlO1xuICAgICAgICBzZWxmLm9wZW4gPSBvcGVuO1xuICAgICAgICBzZWxmLnJlZHJhdyA9IHJlZHJhdztcbiAgICAgICAgc2VsZi5zZXQgPSBzZXQ7XG4gICAgICAgIHNlbGYuc2V0RGF0ZSA9IHNldERhdGU7XG4gICAgICAgIHNlbGYudG9nZ2xlID0gdG9nZ2xlO1xuICAgICAgICBmdW5jdGlvbiBzZXR1cEhlbHBlckZ1bmN0aW9ucygpIHtcbiAgICAgICAgICAgIHNlbGYudXRpbHMgPSB7XG4gICAgICAgICAgICAgICAgZ2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uIChtb250aCwgeXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSB2b2lkIDApIHsgbW9udGggPSBzZWxmLmN1cnJlbnRNb250aDsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeXIgPT09IHZvaWQgMCkgeyB5ciA9IHNlbGYuY3VycmVudFllYXI7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSAxICYmICgoeXIgJSA0ID09PSAwICYmIHlyICUgMTAwICE9PSAwKSB8fCB5ciAlIDQwMCA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmwxMG4uZGF5c0luTW9udGhbbW9udGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudCA9IHNlbGYuaW5wdXQgPSBlbGVtZW50O1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHBhcnNlQ29uZmlnKCk7XG4gICAgICAgICAgICBzZXR1cExvY2FsZSgpO1xuICAgICAgICAgICAgc2V0dXBJbnB1dHMoKTtcbiAgICAgICAgICAgIHNldHVwRGF0ZXMoKTtcbiAgICAgICAgICAgIHNldHVwSGVscGVyRnVuY3Rpb25zKCk7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgYnVpbGQoKTtcbiAgICAgICAgICAgIGJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIHx8IHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21EYXRlKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogfHwgc2VsZi5jb25maWcubWluRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDYWxlbmRhcldpZHRoKCk7XG4gICAgICAgICAgICBzZWxmLnNob3dUaW1lSW5wdXQgPVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwIHx8IHNlbGYuY29uZmlnLm5vQ2FsZW5kYXI7XG4gICAgICAgICAgICB2YXIgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAgICAgLyogVE9ETzogaW52ZXN0aWdhdGUgdGhpcyBmdXJ0aGVyXG4gICAgICAgIFxuICAgICAgICAgICAgICBDdXJyZW50bHksIHRoZXJlIGlzIHdlaXJkIHBvc2l0aW9uaW5nIGJlaGF2aW9yIGluIHNhZmFyaSBjYXVzaW5nIHBhZ2VzXG4gICAgICAgICAgICAgIHRvIHNjcm9sbCB1cC4gaHR0cHM6Ly9naXRodWIuY29tL2NobWxuL2ZsYXRwaWNrci9pc3N1ZXMvNTYzXG4gICAgICAgIFxuICAgICAgICAgICAgICBIb3dldmVyLCBtb3N0IGJyb3dzZXJzIGFyZSBub3QgU2FmYXJpIGFuZCBwb3NpdGlvbmluZyBpcyBleHBlbnNpdmUgd2hlbiB1c2VkXG4gICAgICAgICAgICAgIGluIHNjYWxlLiBodHRwczovL2dpdGh1Yi5jb20vY2htbG4vZmxhdHBpY2tyL2lzc3Vlcy8xMDk2XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzTW9iaWxlICYmIGlzU2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25DYWxlbmRhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25SZWFkeVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiaW5kVG9JbnN0YW5jZShmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmJpbmQoc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0Q2FsZW5kYXJXaWR0aCgpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBzZWxmLmNvbmZpZztcbiAgICAgICAgICAgIGlmIChjb25maWcud2Vla051bWJlcnMgPT09IGZhbHNlICYmIGNvbmZpZy5zaG93TW9udGhzID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5ub0NhbGVuZGFyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF5c1dpZHRoID0gKHNlbGYuZGF5cy5vZmZzZXRXaWR0aCArIDEpICogY29uZmlnLnNob3dNb250aHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIuc3R5bGUud2lkdGggPSBkYXlzV2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLndpZHRoID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlzV2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VsZi53ZWVrV3JhcHBlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYud2Vla1dyYXBwZXIub2Zmc2V0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidmlzaWJpbGl0eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoYW5kbGVyIGZvciBhbGwgZXZlbnRzIHRhcmdldGluZyB0aGUgdGltZSBpbnB1dHNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRpbWUoZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZXREZWZhdWx0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgIT09IHVuZGVmaW5lZCAmJiBlLnR5cGUgIT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgICAgICAgdGltZVdyYXBwZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gc2VsZi5faW5wdXQudmFsdWU7XG4gICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5faW5wdXQudmFsdWUgIT09IHByZXZWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFtcG0ybWlsaXRhcnkoaG91ciwgYW1QTSkge1xuICAgICAgICAgICAgcmV0dXJuIChob3VyICUgMTIpICsgMTIgKiBpbnQoYW1QTSA9PT0gc2VsZi5sMTBuLmFtUE1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1pbGl0YXJ5MmFtcG0oaG91cikge1xuICAgICAgICAgICAgc3dpdGNoIChob3VyICUgMjQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBob3VyICUgMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN5bmNzIHRoZSBzZWxlY3RlZCBkYXRlIG9iamVjdCB0aW1lIHdpdGggdXNlcidzIHRpbWUgaW5wdXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEhvdXJzRnJvbUlucHV0cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmhvdXJFbGVtZW50ID09PSB1bmRlZmluZWQgfHwgc2VsZi5taW51dGVFbGVtZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGhvdXJzID0gKHBhcnNlSW50KHNlbGYuaG91ckVsZW1lbnQudmFsdWUuc2xpY2UoLTIpLCAxMCkgfHwgMCkgJSAyNCwgbWludXRlcyA9IChwYXJzZUludChzZWxmLm1pbnV0ZUVsZW1lbnQudmFsdWUsIDEwKSB8fCAwKSAlIDYwLCBzZWNvbmRzID0gc2VsZi5zZWNvbmRFbGVtZW50ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IChwYXJzZUludChzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUsIDEwKSB8fCAwKSAlIDYwXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaG91cnMgPSBhbXBtMm1pbGl0YXJ5KGhvdXJzLCBzZWxmLmFtUE0udGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbWl0TWluSG91cnMgPSBzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1pbkRhdGVIYXNUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5jb25maWcubWluRGF0ZSwgdHJ1ZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIHZhciBsaW1pdE1heEhvdXJzID0gc2VsZi5jb25maWcubWF4VGltZSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXhEYXRlSGFzVGltZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYuY29uZmlnLm1heERhdGUsIHRydWUpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgMCk7XG4gICAgICAgICAgICBpZiAobGltaXRNYXhIb3Vycykge1xuICAgICAgICAgICAgICAgIHZhciBtYXhUaW1lID0gc2VsZi5jb25maWcubWF4VGltZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubWF4VGltZVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1heERhdGU7XG4gICAgICAgICAgICAgICAgaG91cnMgPSBNYXRoLm1pbihob3VycywgbWF4VGltZS5nZXRIb3VycygpKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1heFRpbWUuZ2V0SG91cnMoKSlcbiAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGgubWluKG1pbnV0ZXMsIG1heFRpbWUuZ2V0TWludXRlcygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWludXRlcyA9PT0gbWF4VGltZS5nZXRNaW51dGVzKCkpXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLm1pbihzZWNvbmRzLCBtYXhUaW1lLmdldFNlY29uZHMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXRNaW5Ib3Vycykge1xuICAgICAgICAgICAgICAgIHZhciBtaW5UaW1lID0gc2VsZi5jb25maWcubWluVGltZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubWluVGltZVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1pbkRhdGU7XG4gICAgICAgICAgICAgICAgaG91cnMgPSBNYXRoLm1heChob3VycywgbWluVGltZS5nZXRIb3VycygpKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1pblRpbWUuZ2V0SG91cnMoKSlcbiAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGgubWF4KG1pbnV0ZXMsIG1pblRpbWUuZ2V0TWludXRlcygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWludXRlcyA9PT0gbWluVGltZS5nZXRNaW51dGVzKCkpXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLm1heChzZWNvbmRzLCBtaW5UaW1lLmdldFNlY29uZHMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRIb3Vycyhob3VycywgbWludXRlcywgc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN5bmNzIHRpbWUgaW5wdXQgdmFsdWVzIHdpdGggYSBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZXRIb3Vyc0Zyb21EYXRlKGRhdGVPYmopIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gZGF0ZU9iaiB8fCBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iajtcbiAgICAgICAgICAgIGlmIChkYXRlKVxuICAgICAgICAgICAgICAgIHNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCksIGRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXREZWZhdWx0SG91cnMoKSB7XG4gICAgICAgICAgICB2YXIgaG91cnMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0SG91cjtcbiAgICAgICAgICAgIHZhciBtaW51dGVzID0gc2VsZi5jb25maWcuZGVmYXVsdE1pbnV0ZTtcbiAgICAgICAgICAgIHZhciBzZWNvbmRzID0gc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHM7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbl9ociA9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWluX21pbnV0ZXMgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5faHIpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluX2hyKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5tYXgobWluX21pbnV0ZXMsIG1pbnV0ZXMpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluX2hyICYmIG1pbnV0ZXMgPT09IG1pbl9taW51dGVzKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heF9ociA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4X21pbnV0ZXMgPSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWluKGhvdXJzLCBtYXhfaHIpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4X2hyKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5taW4obWF4X21pbnV0ZXMsIG1pbnV0ZXMpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4X2hyICYmIG1pbnV0ZXMgPT09IG1heF9taW51dGVzKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRIb3Vycyhob3VycywgbWludXRlcywgc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhvdXJzLCBtaW51dGVzLCBhbmQgb3B0aW9uYWxseSBzZWNvbmRzXG4gICAgICAgICAqIG9mIHRoZSBsYXRlc3Qgc2VsZWN0ZWQgZGF0ZSBvYmplY3QgYW5kIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHRpbWUgaW5wdXRzXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3VycyB0aGUgaG91ci4gd2hldGhlciBpdHMgbWlsaXRhcnlcbiAgICAgICAgICogICAgICAgICAgICAgICAgIG9yIGFtLXBtIGdldHMgaW5mZXJyZWQgZnJvbSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgdGhlIG1pbnV0ZXNcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgdGhlIHNlY29uZHMgKG9wdGlvbmFsKVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouc2V0SG91cnMoaG91cnMgJSAyNCwgbWludXRlcywgc2Vjb25kcyB8fCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5ob3VyRWxlbWVudCB8fCAhc2VsZi5taW51dGVFbGVtZW50IHx8IHNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC52YWx1ZSA9IHBhZCghc2VsZi5jb25maWcudGltZV8yNGhyXG4gICAgICAgICAgICAgICAgPyAoKDEyICsgaG91cnMpICUgMTIpICsgMTIgKiBpbnQoaG91cnMgJSAxMiA9PT0gMClcbiAgICAgICAgICAgICAgICA6IGhvdXJzKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC52YWx1ZSA9IHBhZChtaW51dGVzKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVtpbnQoaG91cnMgPj0gMTIpXTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUgPSBwYWQoc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgdGhlIHllYXIgaW5wdXQgYW5kIGluY3JlbWVudGluZyBldmVudHNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIGtleXVwIG9yIGluY3JlbWVudCBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gb25ZZWFySW5wdXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LnZhbHVlKSArIChldmVudC5kZWx0YSB8fCAwKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIC8gMTAwMCA+IDEgfHxcbiAgICAgICAgICAgICAgICAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgIS9bXlxcZF0vLnRlc3QoeWVhci50b1N0cmluZygpKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VZZWFyKHllYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFc3NlbnRpYWxseSBhZGRFdmVudExpc3RlbmVyICsgdHJhY2tpbmdcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGFkZEV2ZW50TGlzdGVuZXIgdG9cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGJpbmQoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChldikgeyByZXR1cm4gYmluZChlbGVtZW50LCBldiwgaGFuZGxlciwgb3B0aW9ucyk7IH0pO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gYmluZChlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpOyB9KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1vdXNlZG93biBoYW5kbGVyIHdoaWNoIG1pbWljcyBjbGljay5cbiAgICAgICAgICogTWluaW1pemVzIGxhdGVuY3ksIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gd2FpdCBmb3IgbW91c2V1cCBpbiBtb3N0IGNhc2VzLlxuICAgICAgICAgKiBBbHNvLCBhdm9pZHMgaGFuZGxpbmcgcmlnaHQgY2xpY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBvbkNsaWNrKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgZXZ0LndoaWNoID09PSAxICYmIGhhbmRsZXIoZXZ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckNoYW5nZSgpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy53cmFwKSB7XG4gICAgICAgICAgICAgICAgW1wib3BlblwiLCBcImNsb3NlXCIsIFwidG9nZ2xlXCIsIFwiY2xlYXJcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoc2VsZi5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1cIiArIGV2dCArIFwiXVwiKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZChlbCwgXCJjbGlja1wiLCBzZWxmW2V2dF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgc2V0dXBNb2JpbGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVib3VuY2VkUmVzaXplID0gZGVib3VuY2Uob25SZXNpemUsIDUwKTtcbiAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSA9IGRlYm91bmNlKHRyaWdnZXJDaGFuZ2UsIERFQk9VTkNFRF9DSEFOR0VfTVMpO1xuICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAmJiAhL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5kYXlzQ29udGFpbmVyLCBcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQuYm9keSwgXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLnN0YXRpYylcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuX2lucHV0LCBcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuaW5saW5lICYmICFzZWxmLmNvbmZpZy5zdGF0aWMpXG4gICAgICAgICAgICAgICAgYmluZCh3aW5kb3csIFwicmVzaXplXCIsIGRlYm91bmNlZFJlc2l6ZSk7XG4gICAgICAgICAgICBpZiAod2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcImNsaWNrXCIsIGRvY3VtZW50Q2xpY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKGRvY3VtZW50Q2xpY2spKTtcbiAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcImZvY3VzXCIsIGRvY3VtZW50Q2xpY2ssIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbGlja09wZW5zID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJmb2N1c1wiLCBzZWxmLm9wZW4pO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soc2VsZi5vcGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYubW9udGhOYXYsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2sob25Nb250aE5hdkNsaWNrKSk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLm1vbnRoTmF2LCBbXCJrZXl1cFwiLCBcImluY3JlbWVudFwiXSwgb25ZZWFySW5wdXQpO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5kYXlzQ29udGFpbmVyLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHNlbGVjdERhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnRpbWVDb250YWluZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbFRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgW1wiaW5jcmVtZW50XCJdLCB1cGRhdGVUaW1lKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJibHVyXCIsIHVwZGF0ZVRpbWUsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJtb3VzZWRvd25cIiwgb25DbGljayh0aW1lSW5jcmVtZW50KSk7XG4gICAgICAgICAgICAgICAgYmluZChbc2VsZi5ob3VyRWxlbWVudCwgc2VsZi5taW51dGVFbGVtZW50XSwgW1wiZm9jdXNcIiwgXCJjbGlja1wiXSwgc2VsVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBiaW5kKHNlbGYuc2Vjb25kRWxlbWVudCwgXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLnNlY29uZEVsZW1lbnQgJiYgc2VsZi5zZWNvbmRFbGVtZW50LnNlbGVjdCgpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZChzZWxmLmFtUE0sIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY2FsZW5kYXIgdmlldyB0byBhIHBhcnRpY3VsYXIgZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHtEYXRlfSBqdW1wRGF0ZSB0aGUgZGF0ZSB0byBzZXQgdGhlIHZpZXcgdG9cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGp1bXBUb0RhdGUoanVtcERhdGUpIHtcbiAgICAgICAgICAgIHZhciBqdW1wVG8gPSBqdW1wRGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBzZWxmLnBhcnNlRGF0ZShqdW1wRGF0ZSlcbiAgICAgICAgICAgICAgICA6IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqIHx8XG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmIHNlbGYuY29uZmlnLm1pbkRhdGUgPiBzZWxmLm5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1heERhdGUgJiYgc2VsZi5jb25maWcubWF4RGF0ZSA8IHNlbGYubm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhEYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLm5vdyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChqdW1wVG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0ganVtcFRvLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0ganVtcFRvLmdldE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IFwiSW52YWxpZCBkYXRlIHN1cHBsaWVkOiBcIiArIGp1bXBUbztcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXAvZG93biBhcnJvdyBoYW5kbGVyIGZvciB0aW1lIGlucHV0c1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIHRoZSBjbGljayBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdGltZUluY3JlbWVudChlKSB7XG4gICAgICAgICAgICBpZiAofmUudGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKFwiYXJyb3dcIikpXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50TnVtSW5wdXQoZSwgZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dVcFwiKSA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluY3JlbWVudHMvZGVjcmVtZW50cyB0aGUgdmFsdWUgb2YgaW5wdXQgYXNzb2NpLVxuICAgICAgICAgKiBhdGVkIHdpdGggdGhlIHVwL2Rvd24gYXJyb3cgYnkgZGlzcGF0Y2hpbmcgYW5cbiAgICAgICAgICogXCJpbmNyZW1lbnRcIiBldmVudCBvbiB0aGUgaW5wdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGNsaWNrIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSB0aGUgZGlmZiAodXN1YWxseSAxIG9yIC0xKVxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGlucHV0RWxlbSB0aGUgaW5wdXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaW5jcmVtZW50TnVtSW5wdXQoZSwgZGVsdGEsIGlucHV0RWxlbSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUgJiYgZS50YXJnZXQ7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dEVsZW0gfHxcbiAgICAgICAgICAgICAgICAodGFyZ2V0ICYmIHRhcmdldC5wYXJlbnROb2RlICYmIHRhcmdldC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlRXZlbnQoXCJpbmNyZW1lbnRcIik7XG4gICAgICAgICAgICBldmVudC5kZWx0YSA9IGRlbHRhO1xuICAgICAgICAgICAgaW5wdXQgJiYgaW5wdXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItY2FsZW5kYXJcIik7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLm5vQ2FsZW5kYXIpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChidWlsZE1vbnRoTmF2KCkpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5uZXJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWlubmVyQ29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy53ZWVrTnVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBidWlsZFdlZWtzKCksIHdlZWtXcmFwcGVyID0gX2Eud2Vla1dyYXBwZXIsIHdlZWtOdW1iZXJzID0gX2Eud2Vla051bWJlcnM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQod2Vla1dyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLndlZWtOdW1iZXJzID0gd2Vla051bWJlcnM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYud2Vla1dyYXBwZXIgPSB3ZWVrV3JhcHBlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5yQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1yQ29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuckNvbnRhaW5lci5hcHBlbmRDaGlsZChidWlsZFdlZWtkYXlzKCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5kYXlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItZGF5c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICAgICAgICAgIHNlbGYuckNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5yQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChzZWxmLmlubmVyQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyYW5nZU1vZGVcIiwgc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYW5pbWF0ZVwiLCBzZWxmLmNvbmZpZy5hbmltYXRlID09PSB0cnVlKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwibXVsdGlNb250aFwiLCBzZWxmLmNvbmZpZy5zaG93TW9udGhzID4gMSk7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgICAgIHZhciBjdXN0b21BcHBlbmQgPSBzZWxmLmNvbmZpZy5hcHBlbmRUbyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuYXBwZW5kVG8ubm9kZVR5cGUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUgfHwgc2VsZi5jb25maWcuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHNlbGYuY29uZmlnLmlubGluZSA/IFwiaW5saW5lXCIgOiBcInN0YXRpY1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VzdG9tQXBwZW5kICYmIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIHNlbGYuX2lucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcuYXBwZW5kVG8gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmFwcGVuZFRvLmFwcGVuZENoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13cmFwcGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlciwgc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5hbHRJbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgIXNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcuYXBwZW5kVG8gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmFwcGVuZFRvXG4gICAgICAgICAgICAgICAgICAgIDogd2luZG93LmRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURheShjbGFzc05hbWUsIGRhdGUsIGRheU51bWJlciwgaSkge1xuICAgICAgICAgICAgdmFyIGRhdGVJc0VuYWJsZWQgPSBpc0VuYWJsZWQoZGF0ZSwgdHJ1ZSksIGRheUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1kYXkgXCIgKyBjbGFzc05hbWUsIGRhdGUuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZGF5RWxlbWVudC5kYXRlT2JqID0gZGF0ZTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuJGkgPSBpO1xuICAgICAgICAgICAgZGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHNlbGYuZm9ybWF0RGF0ZShkYXRlLCBzZWxmLmNvbmZpZy5hcmlhRGF0ZUZvcm1hdCkpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLm5vdykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRvZGF5RGF0ZUVsZW0gPSBkYXlFbGVtZW50O1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInRvZGF5XCIpO1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIsIFwiZGF0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlSXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZGF5RWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpc0RhdGVTZWxlY3RlZChkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtID0gZGF5RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZGF5RWxlbWVudCwgXCJzdGFydFJhbmdlXCIsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHRydWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRheUVsZW1lbnQsIFwiZW5kUmFuZ2VcIiwgc2VsZi5zZWxlY3RlZERhdGVzWzFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSwgdHJ1ZSkgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gXCJuZXh0TW9udGhEYXlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJpblJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZUluUmFuZ2UoZGF0ZSkgJiYgIWlzRGF0ZVNlbGVjdGVkKGRhdGUpKVxuICAgICAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJpblJhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYud2Vla051bWJlcnMgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zaG93TW9udGhzID09PSAxICYmXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICE9PSBcInByZXZNb250aERheVwiICYmXG4gICAgICAgICAgICAgICAgZGF5TnVtYmVyICUgNyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNlbGYud2Vla051bWJlcnMuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIFwiPHNwYW4gY2xhc3M9J2ZsYXRwaWNrci1kYXknPlwiICsgc2VsZi5jb25maWcuZ2V0V2VlayhkYXRlKSArIFwiPC9zcGFuPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uRGF5Q3JlYXRlXCIsIGRheUVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGRheUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9jdXNPbkRheUVsZW0odGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIilcbiAgICAgICAgICAgICAgICBvbk1vdXNlT3Zlcih0YXJnZXROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRGaXJzdEF2YWlsYWJsZURheShkZWx0YSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0TW9udGggPSBkZWx0YSA+IDAgPyAwIDogc2VsZi5jb25maWcuc2hvd01vbnRocyAtIDE7XG4gICAgICAgICAgICB2YXIgZW5kTW9udGggPSBkZWx0YSA+IDAgPyBzZWxmLmNvbmZpZy5zaG93TW9udGhzIDogLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gc3RhcnRNb250aDsgbSAhPSBlbmRNb250aDsgbSArPSBkZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGRlbHRhID4gMCA/IDAgOiBtb250aC5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IGRlbHRhID4gMCA/IG1vbnRoLmNoaWxkcmVuLmxlbmd0aCA6IC0xO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpICs9IGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gbW9udGguY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJiBpc0VuYWJsZWQoYy5kYXRlT2JqKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dEF2YWlsYWJsZURheShjdXJyZW50LCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIGdpdmVuTW9udGggPSBjdXJyZW50LmNsYXNzTmFtZS5pbmRleE9mKFwiTW9udGhcIikgPT09IC0xXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50LmRhdGVPYmouZ2V0TW9udGgoKVxuICAgICAgICAgICAgICAgIDogc2VsZi5jdXJyZW50TW9udGg7XG4gICAgICAgICAgICB2YXIgZW5kTW9udGggPSBkZWx0YSA+IDAgPyBzZWxmLmNvbmZpZy5zaG93TW9udGhzIDogLTE7XG4gICAgICAgICAgICB2YXIgbG9vcERlbHRhID0gZGVsdGEgPiAwID8gMSA6IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IGdpdmVuTW9udGggLSBzZWxmLmN1cnJlbnRNb250aDsgbSAhPSBlbmRNb250aDsgbSArPSBsb29wRGVsdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBzZWxmLmRheXNDb250YWluZXIuY2hpbGRyZW5bbV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBnaXZlbk1vbnRoIC0gc2VsZi5jdXJyZW50TW9udGggPT09IG1cbiAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50LiRpICsgZGVsdGFcbiAgICAgICAgICAgICAgICAgICAgOiBkZWx0YSA8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbW9udGguY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgIHZhciBudW1Nb250aERheXMgPSBtb250aC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPj0gMCAmJiBpIDwgbnVtTW9udGhEYXlzICYmIGkgIT0gKGRlbHRhID4gMCA/IG51bU1vbnRoRGF5cyA6IC0xKTsgaSArPSBsb29wRGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtb250aC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuYWJsZWQoYy5kYXRlT2JqKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoY3VycmVudC4kaSAtIGkpID49IE1hdGguYWJzKGRlbHRhKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb2N1c09uRGF5RWxlbShjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmNoYW5nZU1vbnRoKGxvb3BEZWx0YSk7XG4gICAgICAgICAgICBmb2N1c09uRGF5KGdldEZpcnN0QXZhaWxhYmxlRGF5KGxvb3BEZWx0YSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb2N1c09uRGF5KGN1cnJlbnQsIG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIGRheUZvY3VzZWQgPSBpc0luVmlldyhkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RWxlbSA9IGN1cnJlbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gY3VycmVudFxuICAgICAgICAgICAgICAgIDogZGF5Rm9jdXNlZFxuICAgICAgICAgICAgICAgICAgICA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gIT09IHVuZGVmaW5lZCAmJiBpc0luVmlldyhzZWxmLnNlbGVjdGVkRGF0ZUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuc2VsZWN0ZWREYXRlRWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLnRvZGF5RGF0ZUVsZW0gIT09IHVuZGVmaW5lZCAmJiBpc0luVmlldyhzZWxmLnRvZGF5RGF0ZUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLnRvZGF5RGF0ZUVsZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGdldEZpcnN0QXZhaWxhYmxlRGF5KG9mZnNldCA+IDAgPyAxIDogLTEpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0RWxlbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKCFkYXlGb2N1c2VkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb2N1c09uRGF5RWxlbShzdGFydEVsZW0pO1xuICAgICAgICAgICAgZ2V0TmV4dEF2YWlsYWJsZURheShzdGFydEVsZW0sIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aERheXMoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdE9mTW9udGggPSAobmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpIC0gc2VsZi5sMTBuLmZpcnN0RGF5T2ZXZWVrICsgNykgJSA3O1xuICAgICAgICAgICAgdmFyIHByZXZNb250aERheXMgPSBzZWxmLnV0aWxzLmdldERheXNJbk1vbnRoKChtb250aCAtIDEgKyAxMikgJSAxMik7XG4gICAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBzZWxmLnV0aWxzLmdldERheXNJbk1vbnRoKG1vbnRoKSwgZGF5cyA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGlzTXVsdGlNb250aCA9IHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxLCBwcmV2TW9udGhEYXlDbGFzcyA9IGlzTXVsdGlNb250aCA/IFwicHJldk1vbnRoRGF5IGhpZGRlblwiIDogXCJwcmV2TW9udGhEYXlcIiwgbmV4dE1vbnRoRGF5Q2xhc3MgPSBpc011bHRpTW9udGggPyBcIm5leHRNb250aERheSBoaWRkZW5cIiA6IFwibmV4dE1vbnRoRGF5XCI7XG4gICAgICAgICAgICB2YXIgZGF5TnVtYmVyID0gcHJldk1vbnRoRGF5cyArIDEgLSBmaXJzdE9mTW9udGgsIGRheUluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIHByZXBlbmQgZGF5cyBmcm9tIHRoZSBlbmRpbmcgb2YgcHJldmlvdXMgbW9udGhcbiAgICAgICAgICAgIGZvciAoOyBkYXlOdW1iZXIgPD0gcHJldk1vbnRoRGF5czsgZGF5TnVtYmVyKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShwcmV2TW9udGhEYXlDbGFzcywgbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXlOdW1iZXIpLCBkYXlOdW1iZXIsIGRheUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBhdCAxIHNpbmNlIHRoZXJlIGlzIG5vIDB0aCBkYXlcbiAgICAgICAgICAgIGZvciAoZGF5TnVtYmVyID0gMTsgZGF5TnVtYmVyIDw9IGRheXNJbk1vbnRoOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KFwiXCIsIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXlOdW1iZXIpLCBkYXlOdW1iZXIsIGRheUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBlbmQgZGF5cyBmcm9tIHRoZSBuZXh0IG1vbnRoXG4gICAgICAgICAgICBmb3IgKHZhciBkYXlOdW0gPSBkYXlzSW5Nb250aCArIDE7IGRheU51bSA8PSA0MiAtIGZpcnN0T2ZNb250aCAmJlxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5zaG93TW9udGhzID09PSAxIHx8IGRheUluZGV4ICUgNyAhPT0gMCk7IGRheU51bSsrLCBkYXlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkobmV4dE1vbnRoRGF5Q2xhc3MsIG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgZGF5TnVtICUgZGF5c0luTW9udGgpLCBkYXlOdW0sIGRheUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3VwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIHZhciBkYXlDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZGF5Q29udGFpbmVyXCIpO1xuICAgICAgICAgICAgZGF5Q29udGFpbmVyLmFwcGVuZENoaWxkKGRheXMpO1xuICAgICAgICAgICAgcmV0dXJuIGRheUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZERheXMoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhck5vZGUoc2VsZi5kYXlzQ29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHdlZWsgbnVtYmVycyBmb3IgZWFjaCBtb250aFxuICAgICAgICAgICAgaWYgKHNlbGYud2Vla051bWJlcnMpXG4gICAgICAgICAgICAgICAgY2xlYXJOb2RlKHNlbGYud2Vla051bWJlcnMpO1xuICAgICAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuY29uZmlnLnNob3dNb250aHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGgsIDEpO1xuICAgICAgICAgICAgICAgIGQuc2V0TW9udGgoc2VsZi5jdXJyZW50TW9udGggKyBpKTtcbiAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGJ1aWxkTW9udGhEYXlzKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICAgICAgICBzZWxmLmRheXMgPSBzZWxmLmRheXNDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIgJiYgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aCgpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLW1vbnRoXCIpO1xuICAgICAgICAgICAgdmFyIG1vbnRoTmF2RnJhZ21lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgdmFyIG1vbnRoRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiY3VyLW1vbnRoXCIpO1xuICAgICAgICAgICAgdmFyIHllYXJJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiY3VyLXllYXJcIiwgeyB0YWJpbmRleDogXCItMVwiIH0pO1xuICAgICAgICAgICAgdmFyIHllYXJFbGVtZW50ID0geWVhcklucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHNlbGYubDEwbi55ZWFyQXJpYUxhYmVsKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlKSB7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlKSB7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC5kaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICEhc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudE1vbnRoID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1jdXJyZW50LW1vbnRoXCIpO1xuICAgICAgICAgICAgY3VycmVudE1vbnRoLmFwcGVuZENoaWxkKG1vbnRoRWxlbWVudCk7XG4gICAgICAgICAgICBjdXJyZW50TW9udGguYXBwZW5kQ2hpbGQoeWVhcklucHV0KTtcbiAgICAgICAgICAgIG1vbnRoTmF2RnJhZ21lbnQuYXBwZW5kQ2hpbGQoY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtb250aE5hdkZyYWdtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQ6IHllYXJFbGVtZW50LFxuICAgICAgICAgICAgICAgIG1vbnRoRWxlbWVudDogbW9udGhFbGVtZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhzKCkge1xuICAgICAgICAgICAgY2xlYXJOb2RlKHNlbGYubW9udGhOYXYpO1xuICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChzZWxmLnByZXZNb250aE5hdik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2hvd01vbnRocykge1xuICAgICAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gc2VsZi5jb25maWcuc2hvd01vbnRoczsgbS0tOykge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IGJ1aWxkTW9udGgoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cy5wdXNoKG1vbnRoLnllYXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMucHVzaChtb250aC5tb250aEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQobW9udGguY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQoc2VsZi5uZXh0TW9udGhOYXYpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhOYXYoKSB7XG4gICAgICAgICAgICBzZWxmLm1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1tb250aHNcIik7XG4gICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICBzZWxmLnByZXZNb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXByZXYtbW9udGhcIik7XG4gICAgICAgICAgICBzZWxmLnByZXZNb250aE5hdi5pbm5lckhUTUwgPSBzZWxmLmNvbmZpZy5wcmV2QXJyb3c7XG4gICAgICAgICAgICBzZWxmLm5leHRNb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLW5leHQtbW9udGhcIik7XG4gICAgICAgICAgICBzZWxmLm5leHRNb250aE5hdi5pbm5lckhUTUwgPSBzZWxmLmNvbmZpZy5uZXh0QXJyb3c7XG4gICAgICAgICAgICBidWlsZE1vbnRocygpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLl9faGlkZVByZXZNb250aEFycm93OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3cgIT09IGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYucHJldk1vbnRoTmF2LCBcImRpc2FibGVkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdyA9IGJvb2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcIl9oaWRlTmV4dE1vbnRoQXJyb3dcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdzsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9faGlkZU5leHRNb250aEFycm93ICE9PSBib29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLm5leHRNb250aE5hdiwgXCJkaXNhYmxlZFwiLCBib29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3cgPSBib29sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudCA9IHNlbGYueWVhckVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubW9udGhOYXY7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRUaW1lKCkge1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzVGltZVwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vQ2FsZW5kYXJcIik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXRpbWVcIik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci10aW1lLXNlcGFyYXRvclwiLCBcIjpcIik7XG4gICAgICAgICAgICB2YXIgaG91cklucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3ItaG91clwiKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgPSBob3VySW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHZhciBtaW51dGVJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiZmxhdHBpY2tyLW1pbnV0ZVwiKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCA9IG1pbnV0ZUlucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnRhYkluZGV4ID0gc2VsZi5taW51dGVFbGVtZW50LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRIb3VycygpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy50aW1lXzI0aHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5kZWZhdWx0SG91clxuICAgICAgICAgICAgICAgICAgICA6IG1pbGl0YXJ5MmFtcG0oc2VsZi5jb25maWcuZGVmYXVsdEhvdXIpKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC52YWx1ZSA9IHBhZChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9ialxuICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0TWludXRlcygpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5kZWZhdWx0TWludXRlKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3RlcFwiLCBzZWxmLmNvbmZpZy5ob3VySW5jcmVtZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnNldEF0dHJpYnV0ZShcInN0ZXBcIiwgc2VsZi5jb25maWcubWludXRlSW5jcmVtZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtaW5cIiwgc2VsZi5jb25maWcudGltZV8yNGhyID8gXCIwXCIgOiBcIjFcIik7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyBcIjIzXCIgOiBcIjEyXCIpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBcIjBcIik7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIFwiNTlcIik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoaG91cklucHV0KTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKG1pbnV0ZUlucHV0KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy50aW1lXzI0aHIpXG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0aW1lMjRoclwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVTZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNTZWNvbmRzXCIpO1xuICAgICAgICAgICAgICAgIHZhciBzZWNvbmRJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiZmxhdHBpY2tyLXNlY29uZFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQgPSBzZWNvbmRJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSA9IHBhZChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9ialxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldFNlY29uZHMoKVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRlZmF1bHRTZWNvbmRzKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3RlcFwiLCBzZWxmLm1pbnV0ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3RlcFwiKSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBcIjBcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCBcIjU5XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci10aW1lLXNlcGFyYXRvclwiLCBcIjpcIikpO1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWNvbmRJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLnRpbWVfMjRocikge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBzZWxmLmFtUE0gaWYgYXBwcm9wcmlhdGVcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0gPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1hbS1wbVwiLCBzZWxmLmwxMG4uYW1QTVtpbnQoKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5ob3VyRWxlbWVudC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyKSA+IDExKV0pO1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50aXRsZSA9IHNlbGYubDEwbi50b2dnbGVUaXRsZTtcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5hbVBNKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmLnRpbWVDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRXZWVrZGF5cygpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi53ZWVrZGF5Q29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHNlbGYud2Vla2RheUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla2RheXNcIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2xlYXJOb2RlKHNlbGYud2Vla2RheUNvbnRhaW5lcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5jb25maWcuc2hvd01vbnRoczsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtkYXljb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVXZWVrZGF5cygpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYud2Vla2RheUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVXZWVrZGF5cygpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdERheU9mV2VlayA9IHNlbGYubDEwbi5maXJzdERheU9mV2VlaztcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5cyA9IHNlbGYubDEwbi53ZWVrZGF5cy5zaG9ydGhhbmQuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChmaXJzdERheU9mV2VlayA+IDAgJiYgZmlyc3REYXlPZldlZWsgPCB3ZWVrZGF5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5cyA9IHdlZWtkYXlzLnNwbGljZShmaXJzdERheU9mV2Vlaywgd2Vla2RheXMubGVuZ3RoKS5jb25jYXQod2Vla2RheXMuc3BsaWNlKDAsIGZpcnN0RGF5T2ZXZWVrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5jb25maWcuc2hvd01vbnRoczsgaS0tOykge1xuICAgICAgICAgICAgICAgIHNlbGYud2Vla2RheUNvbnRhaW5lci5jaGlsZHJlbltpXS5pbm5lckhUTUwgPSBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPSdmbGF0cGlja3Itd2Vla2RheSc+XFxuICAgICAgICBcIiArIHdlZWtkYXlzLmpvaW4oXCI8L3NwYW4+PHNwYW4gY2xhc3M9J2ZsYXRwaWNrci13ZWVrZGF5Jz5cIikgKyBcIlxcbiAgICAgIDwvc3Bhbj5cXG4gICAgICBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBidWlsZFdlZWtzKCkge1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzV2Vla3NcIik7XG4gICAgICAgICAgICB2YXIgd2Vla1dyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWt3cmFwcGVyXCIpO1xuICAgICAgICAgICAgd2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3Itd2Vla2RheVwiLCBzZWxmLmwxMG4ud2Vla0FiYnJldmlhdGlvbikpO1xuICAgICAgICAgICAgdmFyIHdlZWtOdW1iZXJzID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrc1wiKTtcbiAgICAgICAgICAgIHdlZWtXcmFwcGVyLmFwcGVuZENoaWxkKHdlZWtOdW1iZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2Vla1dyYXBwZXI6IHdlZWtXcmFwcGVyLFxuICAgICAgICAgICAgICAgIHdlZWtOdW1iZXJzOiB3ZWVrTnVtYmVyc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VNb250aCh2YWx1ZSwgaXNfb2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAoaXNfb2Zmc2V0ID09PSB2b2lkIDApIHsgaXNfb2Zmc2V0ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGRlbHRhID0gaXNfb2Zmc2V0ID8gdmFsdWUgOiB2YWx1ZSAtIHNlbGYuY3VycmVudE1vbnRoO1xuICAgICAgICAgICAgaWYgKChkZWx0YSA8IDAgJiYgc2VsZi5faGlkZVByZXZNb250aEFycm93ID09PSB0cnVlKSB8fFxuICAgICAgICAgICAgICAgIChkZWx0YSA+IDAgJiYgc2VsZi5faGlkZU5leHRNb250aEFycm93ID09PSB0cnVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCArPSBkZWx0YTtcbiAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRNb250aCA8IDAgfHwgc2VsZi5jdXJyZW50TW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgKz0gc2VsZi5jdXJyZW50TW9udGggPiAxMSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IChzZWxmLmN1cnJlbnRNb250aCArIDEyKSAlIDEyO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25Nb250aENoYW5nZVwiKTtcbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGVhcih0cmlnZ2VyQ2hhbmdlRXZlbnQsIHRvSW5pdGlhbCkge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2VFdmVudCA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmICh0b0luaXRpYWwgPT09IHZvaWQgMCkgeyB0b0luaXRpYWwgPSB0cnVlOyB9XG4gICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gW107XG4gICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0b0luaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0gc2VsZi5faW5pdGlhbERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IHNlbGYuX2luaXRpYWxEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnNob3dUaW1lSW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2V0RGVmYXVsdEhvdXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudClcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyQ2hhbmdlRXZlbnQgaXMgdHJ1ZSAoZGVmYXVsdCkgb3IgYW4gRXZlbnRcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgIHNlbGYuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DbG9zZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25EZXN0cm95XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYuX2hhbmRsZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciBoID0gc2VsZi5faGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgICAgaC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoaC5ldmVudCwgaC5oYW5kbGVyLCBoLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5faGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYubW9iaWxlSW5wdXQpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICYmIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zdGF0aWMgJiYgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmxhc3RDaGlsZCAmJiB3cmFwcGVyLnJlbW92ZUNoaWxkKHdyYXBwZXIubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIuZmlyc3RDaGlsZCwgd3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLmFsdElucHV0KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5hbHRJbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gc2VsZi5pbnB1dC5fdHlwZTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmNsYXNzTGlzdC5yZW1vdmUoXCJmbGF0cGlja3ItaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJyZWFkb25seVwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIl9zaG93VGltZUlucHV0XCIsXG4gICAgICAgICAgICAgICAgXCJsYXRlc3RTZWxlY3RlZERhdGVPYmpcIixcbiAgICAgICAgICAgICAgICBcIl9oaWRlTmV4dE1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcIl9oaWRlUHJldk1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcIl9faGlkZU5leHRNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJfX2hpZGVQcmV2TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiaXNNb2JpbGVcIixcbiAgICAgICAgICAgICAgICBcImlzT3BlblwiLFxuICAgICAgICAgICAgICAgIFwic2VsZWN0ZWREYXRlRWxlbVwiLFxuICAgICAgICAgICAgICAgIFwibWluRGF0ZUhhc1RpbWVcIixcbiAgICAgICAgICAgICAgICBcIm1heERhdGVIYXNUaW1lXCIsXG4gICAgICAgICAgICAgICAgXCJkYXlzXCIsXG4gICAgICAgICAgICAgICAgXCJkYXlzQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJfaW5wdXRcIixcbiAgICAgICAgICAgICAgICBcIl9wb3NpdGlvbkVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcImlubmVyQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJyQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJtb250aE5hdlwiLFxuICAgICAgICAgICAgICAgIFwidG9kYXlEYXRlRWxlbVwiLFxuICAgICAgICAgICAgICAgIFwiY2FsZW5kYXJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIndlZWtkYXlDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcInByZXZNb250aE5hdlwiLFxuICAgICAgICAgICAgICAgIFwibmV4dE1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJjdXJyZW50TW9udGhFbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJjdXJyZW50WWVhckVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcIm5hdmlnYXRpb25DdXJyZW50TW9udGhcIixcbiAgICAgICAgICAgICAgICBcInNlbGVjdGVkRGF0ZUVsZW1cIixcbiAgICAgICAgICAgICAgICBcImNvbmZpZ1wiLFxuICAgICAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGZba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2FsZW5kYXJFbGVtKGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAmJiBzZWxmLmNvbmZpZy5hcHBlbmRUby5jb250YWlucyhlbGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNvbnRhaW5zKGVsZW0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXRfMSA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgICAgIHZhciBpc0NhbGVuZGFyRWxlbWVudCA9IGlzQ2FsZW5kYXJFbGVtKGV2ZW50VGFyZ2V0XzEpO1xuICAgICAgICAgICAgICAgIHZhciBpc0lucHV0ID0gZXZlbnRUYXJnZXRfMSA9PT0gc2VsZi5pbnB1dCB8fFxuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldF8xID09PSBzZWxmLmFsdElucHV0IHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5jb250YWlucyhldmVudFRhcmdldF8xKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZWIgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBlLnBhdGggaXMgbm90IHByZXNlbnQgaW4gYWxsIGJyb3dzZXJzLiBjaXJjdW12ZW50aW5nIHR5cGVjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgKGUucGF0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wYXRoLmluZGV4T2YgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh+ZS5wYXRoLmluZGV4T2Yoc2VsZi5pbnB1dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB+ZS5wYXRoLmluZGV4T2Yoc2VsZi5hbHRJbnB1dCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9zdEZvY3VzID0gZS50eXBlID09PSBcImJsdXJcIlxuICAgICAgICAgICAgICAgICAgICA/IGlzSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtKGUucmVsYXRlZFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJZ25vcmVkID0gIXNlbGYuY29uZmlnLmlnbm9yZWRGb2N1c0VsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGFpbnMoZXZlbnRUYXJnZXRfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvc3RGb2N1cyAmJiBpc0lnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VZZWFyKG5ld1llYXIpIHtcbiAgICAgICAgICAgIGlmICghbmV3WWVhciB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmIG5ld1llYXIgPCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUgJiYgbmV3WWVhciA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5ld1llYXJOdW0gPSBuZXdZZWFyLCBpc05ld1llYXIgPSBzZWxmLmN1cnJlbnRZZWFyICE9PSBuZXdZZWFyTnVtO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IG5ld1llYXJOdW0gfHwgc2VsZi5jdXJyZW50WWVhcjtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBNYXRoLm1pbihzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1vbnRoKCksIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IE1hdGgubWF4KHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TW9udGgoKSwgc2VsZi5jdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmV3WWVhcikge1xuICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChkYXRlLCB0aW1lbGVzcykge1xuICAgICAgICAgICAgaWYgKHRpbWVsZXNzID09PSB2b2lkIDApIHsgdGltZWxlc3MgPSB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgZGF0ZVRvQ2hlY2sgPSBzZWxmLnBhcnNlRGF0ZShkYXRlLCB1bmRlZmluZWQsIHRpbWVsZXNzKTsgLy8gdGltZWxlc3NcbiAgICAgICAgICAgIGlmICgoc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGVUb0NoZWNrLCBzZWxmLmNvbmZpZy5taW5EYXRlLCB0aW1lbGVzcyAhPT0gdW5kZWZpbmVkID8gdGltZWxlc3MgOiAhc2VsZi5taW5EYXRlSGFzVGltZSkgPCAwKSB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlVG9DaGVjaywgc2VsZi5jb25maWcubWF4RGF0ZSwgdGltZWxlc3MgIT09IHVuZGVmaW5lZCA/IHRpbWVsZXNzIDogIXNlbGYubWF4RGF0ZUhhc1RpbWUpID4gMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZS5sZW5ndGggPT09IDAgJiYgc2VsZi5jb25maWcuZGlzYWJsZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoZGF0ZVRvQ2hlY2sgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYm9vbCA9IHNlbGYuY29uZmlnLmVuYWJsZS5sZW5ndGggPiAwLCBhcnJheSA9IGJvb2wgPyBzZWxmLmNvbmZpZy5lbmFibGUgOiBzZWxmLmNvbmZpZy5kaXNhYmxlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGQgPSB2b2lkIDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGQgPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICBkKGRhdGVUb0NoZWNrKSAvLyBkaXNhYmxlZCBieSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZCBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2sgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBkLmdldFRpbWUoKSA9PT0gZGF0ZVRvQ2hlY2suZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCBieSBkYXRlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09PSBcInN0cmluZ1wiICYmIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnkgZGF0ZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHNlbGYucGFyc2VEYXRlKGQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQgJiYgcGFyc2VkLmdldFRpbWUoKSA9PT0gZGF0ZVRvQ2hlY2suZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJvb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIDogIWJvb2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIGJ5IHJhbmdlXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2sgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBkLmZyb20gJiZcbiAgICAgICAgICAgICAgICAgICAgZC50byAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjay5nZXRUaW1lKCkgPj0gZC5mcm9tLmdldFRpbWUoKSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjay5nZXRUaW1lKCkgPD0gZC50by5nZXRUaW1lKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFib29sO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzSW5WaWV3KGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW0uY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5jb250YWlucyhlbGVtKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgICAgICAgIC8vIGUua2V5ICAgICAgICAgICAgICAgICAgICAgIGUua2V5Q29kZVxuICAgICAgICAgICAgLy8gXCJCYWNrc3BhY2VcIiAgICAgICAgICAgICAgICAgICAgICAgIDhcbiAgICAgICAgICAgIC8vIFwiVGFiXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA5XG4gICAgICAgICAgICAvLyBcIkVudGVyXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAxM1xuICAgICAgICAgICAgLy8gXCJFc2NhcGVcIiAgICAgKElFIFwiRXNjXCIpICAgICAgICAgICAyN1xuICAgICAgICAgICAgLy8gXCJBcnJvd0xlZnRcIiAgKElFIFwiTGVmdFwiKSAgICAgICAgICAzN1xuICAgICAgICAgICAgLy8gXCJBcnJvd1VwXCIgICAgKElFIFwiVXBcIikgICAgICAgICAgICAzOFxuICAgICAgICAgICAgLy8gXCJBcnJvd1JpZ2h0XCIgKElFIFwiUmlnaHRcIikgICAgICAgICAzOVxuICAgICAgICAgICAgLy8gXCJBcnJvd0Rvd25cIiAgKElFIFwiRG93blwiKSAgICAgICAgICA0MFxuICAgICAgICAgICAgLy8gXCJEZWxldGVcIiAgICAgKElFIFwiRGVsXCIpICAgICAgICAgICA0NlxuICAgICAgICAgICAgdmFyIGlzSW5wdXQgPSBlLnRhcmdldCA9PT0gc2VsZi5faW5wdXQ7XG4gICAgICAgICAgICB2YXIgYWxsb3dJbnB1dCA9IHNlbGYuY29uZmlnLmFsbG93SW5wdXQ7XG4gICAgICAgICAgICB2YXIgYWxsb3dLZXlkb3duID0gc2VsZi5pc09wZW4gJiYgKCFhbGxvd0lucHV0IHx8ICFpc0lucHV0KTtcbiAgICAgICAgICAgIHZhciBhbGxvd0lubGluZUtleWRvd24gPSBzZWxmLmNvbmZpZy5pbmxpbmUgJiYgaXNJbnB1dCAmJiAhYWxsb3dJbnB1dDtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzICYmIGlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUoc2VsZi5faW5wdXQudmFsdWUsIHRydWUsIGUudGFyZ2V0ID09PSBzZWxmLmFsdElucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmFsdEZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ2FsZW5kYXJFbGVtKGUudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIGFsbG93S2V5ZG93biB8fFxuICAgICAgICAgICAgICAgIGFsbG93SW5saW5lS2V5ZG93bikge1xuICAgICAgICAgICAgICAgIHZhciBpc1RpbWVPYmogPSAhIXNlbGYudGltZUNvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3REYXRlKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0lucHV0ICYmICFzZWxmLmNvbmZpZy5hbGxvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RpbWVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhbGxvd0lucHV0ID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgaXNJblZpZXcoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFfMSA9IGUua2V5Q29kZSA9PT0gMzkgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZS5jdHJsS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheSh1bmRlZmluZWQsIGRlbHRhXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VNb250aChkZWx0YV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkoZ2V0Rmlyc3RBdmFpbGFibGVEYXkoMSksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5ob3VyRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IGUua2V5Q29kZSA9PT0gNDAgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHNlbGYuZGF5c0NvbnRhaW5lciAmJiBlLnRhcmdldC4kaSAhPT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0ID09PSBzZWxmLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgLSBkZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkoZ2V0Rmlyc3RBdmFpbGFibGVEYXkoMSksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNUaW1lT2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KHVuZGVmaW5lZCwgZGVsdGEgKiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZU9iaiAmJiBzZWxmLmhvdXJFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGltZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9kZWJvdW5jZWRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGVsZW1zLmluZGV4T2YoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWxlbXNbaSArIChlLnNoaWZ0S2V5ID8gLTEgOiAxKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkICYmIGUudGFyZ2V0ID09PSBzZWxmLmFtUE0pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMF0uY2hhckF0KDApOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzBdLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMV0uY2hhckF0KDApLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uS2V5RG93blwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlT3ZlcihlbGVtKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICAgICAgICAgIChlbGVtICYmXG4gICAgICAgICAgICAgICAgICAgICghZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGF5XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGhvdmVyRGF0ZSA9IGVsZW1cbiAgICAgICAgICAgICAgICA/IGVsZW0uZGF0ZU9iai5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuZGF5cy5maXJzdEVsZW1lbnRDaGlsZC5kYXRlT2JqLmdldFRpbWUoKSwgaW5pdGlhbERhdGUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHVuZGVmaW5lZCwgdHJ1ZSkuZ2V0VGltZSgpLCByYW5nZVN0YXJ0RGF0ZSA9IE1hdGgubWluKGhvdmVyRGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKSksIHJhbmdlRW5kRGF0ZSA9IE1hdGgubWF4KGhvdmVyRGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKSksIGxhc3REYXRlID0gc2VsZi5kYXlzQ29udGFpbmVyLmxhc3RDaGlsZFxuICAgICAgICAgICAgICAgIC5sYXN0Q2hpbGQuZGF0ZU9iai5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgY29udGFpbnNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG1pblJhbmdlID0gMCwgbWF4UmFuZ2UgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IHJhbmdlU3RhcnREYXRlOyB0IDwgbGFzdERhdGU7IHQgKz0gZHVyYXRpb24uREFZKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0VuYWJsZWQobmV3IERhdGUodCksIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zRGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEaXNhYmxlZCB8fCAodCA+IHJhbmdlU3RhcnREYXRlICYmIHQgPCByYW5nZUVuZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGluaXRpYWxEYXRlICYmICghbWluUmFuZ2UgfHwgdCA+IG1pblJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblJhbmdlID0gdDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA+IGluaXRpYWxEYXRlICYmICghbWF4UmFuZ2UgfHwgdCA8IG1heFJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFJhbmdlID0gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHNlbGYuY29uZmlnLnNob3dNb250aHM7IG0rKykge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldk1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW20gLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpLCBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXlFbGVtID0gbW9udGguY2hpbGRyZW5baV0sIGRhdGUgPSBkYXlFbGVtLmRhdGVPYmo7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dE9mUmFuZ2UgPSAobWluUmFuZ2UgPiAwICYmIHRpbWVzdGFtcCA8IG1pblJhbmdlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG1heFJhbmdlID4gMCAmJiB0aW1lc3RhbXAgPiBtYXhSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRPZlJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJub3RBbGxvd2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgW1wiaW5SYW5nZVwiLCBcInN0YXJ0UmFuZ2VcIiwgXCJlbmRSYW5nZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zRGlzYWJsZWQgJiYgIW91dE9mUmFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICBbXCJzdGFydFJhbmdlXCIsIFwiaW5SYW5nZVwiLCBcImVuZFJhbmdlXCIsIFwibm90QWxsb3dlZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoaG92ZXJEYXRlIDwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJzdGFydFJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZW5kUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9udGguY29udGFpbnMoZWxlbSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKG0gPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZNb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2TW9udGgubGFzdENoaWxkLmRhdGVPYmouZ2V0VGltZSgpID49IHRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbERhdGUgPCBob3ZlckRhdGUgJiYgdGltZXN0YW1wID09PSBpbml0aWFsRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwic3RhcnRSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbml0aWFsRGF0ZSA+IGhvdmVyRGF0ZSAmJiB0aW1lc3RhbXAgPT09IGluaXRpYWxEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJlbmRSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG1pblJhbmdlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXhSYW5nZSA9PT0gMCB8fCB0aW1lc3RhbXAgPD0gbWF4UmFuZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQmV0d2Vlbih0aW1lc3RhbXAsIGluaXRpYWxEYXRlLCBob3ZlckRhdGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJpblJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1vbnRoLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKGksIGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzT3BlbiAmJiAhc2VsZi5jb25maWcuc3RhdGljICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcG9zaXRpb25DYWxlbmRhcigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldERlZmF1bHRUaW1lKCkge1xuICAgICAgICAgICAgc2VsZi5zZXREYXRlKHNlbGYuY29uZmlnLm1pbkRhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbmV3IERhdGUoc2VsZi5jb25maWcubWluRGF0ZS5nZXRUaW1lKCkpXG4gICAgICAgICAgICAgICAgOiBuZXcgRGF0ZSgpLCBmYWxzZSk7XG4gICAgICAgICAgICBzZXREZWZhdWx0SG91cnMoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb3BlbihlLCBwb3NpdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkVsZW1lbnQgPT09IHZvaWQgMCkgeyBwb3NpdGlvbkVsZW1lbnQgPSBzZWxmLl9wb3NpdGlvbkVsZW1lbnQ7IH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlzTW9iaWxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldCAmJiBlLnRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uT3BlblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5faW5wdXQuZGlzYWJsZWQgfHwgc2VsZi5jb25maWcuaW5saW5lKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB3YXNPcGVuID0gc2VsZi5pc09wZW47XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXdhc09wZW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJvcGVuXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25PcGVuXCIpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2FsZW5kYXIocG9zaXRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lID09PSB0cnVlICYmIHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXREZWZhdWx0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYWxsb3dJbnB1dCA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXNlbGYudGltZUNvbnRhaW5lci5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuaG91ckVsZW1lbnQuc2VsZWN0KCk7IH0sIDUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWluTWF4RGF0ZVNldHRlcih0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZU9iaiA9IChzZWxmLmNvbmZpZ1tcIl9cIiArIHR5cGUgKyBcIkRhdGVcIl0gPSBzZWxmLnBhcnNlRGF0ZShkYXRlLCBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KSk7XG4gICAgICAgICAgICAgICAgdmFyIGludmVyc2VEYXRlT2JqID0gc2VsZi5jb25maWdbXCJfXCIgKyAodHlwZSA9PT0gXCJtaW5cIiA/IFwibWF4XCIgOiBcIm1pblwiKSArIFwiRGF0ZVwiXTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZbdHlwZSA9PT0gXCJtaW5cIiA/IFwibWluRGF0ZUhhc1RpbWVcIiA6IFwibWF4RGF0ZUhhc1RpbWVcIl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iai5nZXRIb3VycygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmouZ2V0TWludXRlcygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmouZ2V0U2Vjb25kcygpID4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBzZWxmLnNlbGVjdGVkRGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBpc0VuYWJsZWQoZCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggJiYgdHlwZSA9PT0gXCJtaW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoZGF0ZU9iaik7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRlT2JqICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudFt0eXBlXSA9IGRhdGVPYmouZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50LmRpc2FibGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICEhaW52ZXJzZURhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlRGF0ZU9iai5nZXRGdWxsWWVhcigpID09PSBkYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwYXJzZUNvbmZpZygpIHtcbiAgICAgICAgICAgIHZhciBib29sT3B0cyA9IFtcbiAgICAgICAgICAgICAgICBcIndyYXBcIixcbiAgICAgICAgICAgICAgICBcIndlZWtOdW1iZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJhbGxvd0lucHV0XCIsXG4gICAgICAgICAgICAgICAgXCJjbGlja09wZW5zXCIsXG4gICAgICAgICAgICAgICAgXCJ0aW1lXzI0aHJcIixcbiAgICAgICAgICAgICAgICBcImVuYWJsZVRpbWVcIixcbiAgICAgICAgICAgICAgICBcIm5vQ2FsZW5kYXJcIixcbiAgICAgICAgICAgICAgICBcImFsdElucHV0XCIsXG4gICAgICAgICAgICAgICAgXCJzaG9ydGhhbmRDdXJyZW50TW9udGhcIixcbiAgICAgICAgICAgICAgICBcImlubGluZVwiLFxuICAgICAgICAgICAgICAgIFwic3RhdGljXCIsXG4gICAgICAgICAgICAgICAgXCJlbmFibGVTZWNvbmRzXCIsXG4gICAgICAgICAgICAgICAgXCJkaXNhYmxlTW9iaWxlXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIHVzZXJDb25maWcgPSBfX2Fzc2lnbih7fSwgaW5zdGFuY2VDb25maWcsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZWxlbWVudC5kYXRhc2V0IHx8IHt9KSkpO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLnBhcnNlRGF0ZSA9IHVzZXJDb25maWcucGFyc2VEYXRlO1xuICAgICAgICAgICAgc2VsZi5jb25maWcuZm9ybWF0RGF0ZSA9IHVzZXJDb25maWcuZm9ybWF0RGF0ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJlbmFibGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX2VuYWJsZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5fZW5hYmxlID0gcGFyc2VEYXRlUnVsZXMoZGF0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcImRpc2FibGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX2Rpc2FibGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuX2Rpc2FibGUgPSBwYXJzZURhdGVSdWxlcyhkYXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdGltZU1vZGUgPSB1c2VyQ29uZmlnLm1vZGUgPT09IFwidGltZVwiO1xuICAgICAgICAgICAgaWYgKCF1c2VyQ29uZmlnLmRhdGVGb3JtYXQgJiYgKHVzZXJDb25maWcuZW5hYmxlVGltZSB8fCB0aW1lTW9kZSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzLmRhdGVGb3JtYXQgPVxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlnLm5vQ2FsZW5kYXIgfHwgdGltZU1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJIOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmbGF0cGlja3IuZGVmYXVsdENvbmZpZy5kYXRlRm9ybWF0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBIOmlcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcuYWx0SW5wdXQgJiZcbiAgICAgICAgICAgICAgICAodXNlckNvbmZpZy5lbmFibGVUaW1lIHx8IHRpbWVNb2RlKSAmJlxuICAgICAgICAgICAgICAgICF1c2VyQ29uZmlnLmFsdEZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMuYWx0Rm9ybWF0ID1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5ub0NhbGVuZGFyIHx8IHRpbWVNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiaDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6UyBLXCIgOiBcIiBLXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLmFsdEZvcm1hdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiIGg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpICsgXCIgS1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtaW5EYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9taW5EYXRlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4RGF0ZVNldHRlcihcIm1pblwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWF4RGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWF4RGF0ZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heERhdGVTZXR0ZXIoXCJtYXhcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1pbk1heFRpbWVTZXR0ZXIgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW3R5cGUgPT09IFwibWluXCIgPyBcIl9taW5UaW1lXCIgOiBcIl9tYXhUaW1lXCJdID0gc2VsZi5wYXJzZURhdGUodmFsLCBcIkg6aVwiKTtcbiAgICAgICAgICAgIH07IH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWluVGltZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWluVGltZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heFRpbWVTZXR0ZXIoXCJtaW5cIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heFRpbWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21heFRpbWU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhUaW1lU2V0dGVyKFwibWF4XCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLm1vZGUgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubm9DYWxlbmRhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZW5hYmxlVGltZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbGYuY29uZmlnLCBmb3JtYXRzLCB1c2VyQ29uZmlnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbE9wdHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tib29sT3B0c1tpXV0gPT09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgSE9PS1MuZmlsdGVyKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBzZWxmLmNvbmZpZ1tob29rXSAhPT0gdW5kZWZpbmVkOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWdbaG9va10gPSBhcnJheWlmeShzZWxmLmNvbmZpZ1tob29rXSB8fCBbXSkubWFwKGJpbmRUb0luc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5pc01vYmlsZSA9XG4gICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmRpc2FibGVNb2JpbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmlubGluZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlID09PSBcInNpbmdsZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5kaXNhYmxlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZW5hYmxlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcud2Vla051bWJlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpbkNvbmYgPSBzZWxmLmNvbmZpZy5wbHVnaW5zW2ldKHNlbGYpIHx8IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwbHVnaW5Db25mKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChIT09LUy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdba2V5XSA9IGFycmF5aWZ5KHBsdWdpbkNvbmZba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGJpbmRUb0luc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoc2VsZi5jb25maWdba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVzZXJDb25maWdba2V5XSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2tleV0gPSBwbHVnaW5Db25mW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25QYXJzZUNvbmZpZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cExvY2FsZSgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5jb25maWcubG9jYWxlICE9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGZsYXRwaWNrci5sMTBuc1tzZWxmLmNvbmZpZy5sb2NhbGVdID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJmbGF0cGlja3I6IGludmFsaWQgbG9jYWxlIFwiICsgc2VsZi5jb25maWcubG9jYWxlKSk7XG4gICAgICAgICAgICBzZWxmLmwxMG4gPSBfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmwxMG5zW1wiZGVmYXVsdFwiXSwgKHR5cGVvZiBzZWxmLmNvbmZpZy5sb2NhbGUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmxvY2FsZVxuICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubG9jYWxlICE9PSBcImRlZmF1bHRcIlxuICAgICAgICAgICAgICAgICAgICA/IGZsYXRwaWNrci5sMTBuc1tzZWxmLmNvbmZpZy5sb2NhbGVdXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB0b2tlblJlZ2V4LksgPSBcIihcIiArIHNlbGYubDEwbi5hbVBNWzBdICsgXCJ8XCIgKyBzZWxmLmwxMG4uYW1QTVsxXSArIFwifFwiICsgc2VsZi5sMTBuLmFtUE1bMF0udG9Mb3dlckNhc2UoKSArIFwifFwiICsgc2VsZi5sMTBuLmFtUE1bMV0udG9Mb3dlckNhc2UoKSArIFwiKVwiO1xuICAgICAgICAgICAgc2VsZi5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcihzZWxmKTtcbiAgICAgICAgICAgIHNlbGYucGFyc2VEYXRlID0gY3JlYXRlRGF0ZVBhcnNlcih7IGNvbmZpZzogc2VsZi5jb25maWcsIGwxMG46IHNlbGYubDEwbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwb3NpdGlvbkNhbGVuZGFyKGN1c3RvbVBvc2l0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblByZUNhbGVuZGFyUG9zaXRpb25cIik7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25FbGVtZW50ID0gY3VzdG9tUG9zaXRpb25FbGVtZW50IHx8IHNlbGYuX3Bvc2l0aW9uRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhckhlaWdodCA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNoaWxkcmVuLCAoZnVuY3Rpb24gKGFjYywgY2hpbGQpIHsgcmV0dXJuIGFjYyArIGNoaWxkLm9mZnNldEhlaWdodDsgfSksIDApLCBjYWxlbmRhcldpZHRoID0gc2VsZi5jYWxlbmRhckNvbnRhaW5lci5vZmZzZXRXaWR0aCwgY29uZmlnUG9zID0gc2VsZi5jb25maWcucG9zaXRpb24uc3BsaXQoXCIgXCIpLCBjb25maWdQb3NWZXJ0aWNhbCA9IGNvbmZpZ1Bvc1swXSwgY29uZmlnUG9zSG9yaXpvbnRhbCA9IGNvbmZpZ1Bvcy5sZW5ndGggPiAxID8gY29uZmlnUG9zWzFdIDogbnVsbCwgaW5wdXRCb3VuZHMgPSBwb3NpdGlvbkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRpc3RhbmNlRnJvbUJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGlucHV0Qm91bmRzLmJvdHRvbSwgc2hvd09uVG9wID0gY29uZmlnUG9zVmVydGljYWwgPT09IFwiYWJvdmVcIiB8fFxuICAgICAgICAgICAgICAgIChjb25maWdQb3NWZXJ0aWNhbCAhPT0gXCJiZWxvd1wiICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlRnJvbUJvdHRvbSA8IGNhbGVuZGFySGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLnRvcCA+IGNhbGVuZGFySGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgK1xuICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLnRvcCArXG4gICAgICAgICAgICAgICAgKCFzaG93T25Ub3AgPyBwb3NpdGlvbkVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgMiA6IC1jYWxlbmRhckhlaWdodCAtIDIpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd1RvcFwiLCAhc2hvd09uVG9wKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYXJyb3dCb3R0b21cIiwgc2hvd09uVG9wKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgK1xuICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLmxlZnQgLVxuICAgICAgICAgICAgICAgIChjb25maWdQb3NIb3Jpem9udGFsICE9IG51bGwgJiYgY29uZmlnUG9zSG9yaXpvbnRhbCA9PT0gXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICA/IChjYWxlbmRhcldpZHRoIC0gaW5wdXRCb3VuZHMud2lkdGgpIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLSBpbnB1dEJvdW5kcy5yaWdodDtcbiAgICAgICAgICAgIHZhciByaWdodE1vc3QgPSBsZWZ0ICsgY2FsZW5kYXJXaWR0aCA+IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdmFyIGNlbnRlck1vc3QgPSByaWdodCArIGNhbGVuZGFyV2lkdGggPiB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmlnaHRNb3N0XCIsIHJpZ2h0TW9zdCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc3RhdGljKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgaWYgKCFyaWdodE1vc3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjZW50ZXJNb3N0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IHJpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzWzBdO1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgdGVzdGluZyBlbnZpcm9ubWVudHMgZG9uJ3QgaGF2ZSBjc3Mgc3VwcG9ydFxuICAgICAgICAgICAgICAgIGlmIChkb2MgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBib2R5V2lkdGggPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyTGVmdCA9IE1hdGgubWF4KDAsIGJvZHlXaWR0aCAvIDIgLSBjYWxlbmRhcldpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckJlZm9yZSA9IFwiLmZsYXRwaWNrci1jYWxlbmRhci5jZW50ZXJNb3N0OmJlZm9yZVwiO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJBZnRlciA9IFwiLmZsYXRwaWNrci1jYWxlbmRhci5jZW50ZXJNb3N0OmFmdGVyXCI7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckluZGV4ID0gZG9jLmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyU3R5bGUgPSBcIntsZWZ0OlwiICsgaW5wdXRCb3VuZHMubGVmdCArIFwicHg7cmlnaHQ6YXV0bzt9XCI7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyaWdodE1vc3RcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiY2VudGVyTW9zdFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2MuaW5zZXJ0UnVsZShjZW50ZXJCZWZvcmUgKyBcIixcIiArIGNlbnRlckFmdGVyICsgY2VudGVyU3R5bGUsIGNlbnRlckluZGV4KTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBjZW50ZXJMZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhciB8fCBzZWxmLmlzTW9iaWxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzQW5kQ2xvc2UoKSB7XG4gICAgICAgICAgICBzZWxmLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBoYWNrIC0gYnVncyBpbiB0aGUgd2F5IElFIGhhbmRsZXMgZm9jdXMga2VlcHMgdGhlIGNhbGVuZGFyIG9wZW5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHNlbGYuY2xvc2UsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdERhdGUoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciBpc1NlbGVjdGFibGUgPSBmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheS5jbGFzc0xpc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF5LmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgIWRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZGF5LmNsYXNzTGlzdC5jb250YWlucyhcIm5vdEFsbG93ZWRcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHQgPSBmaW5kUGFyZW50KGUudGFyZ2V0LCBpc1NlbGVjdGFibGUpO1xuICAgICAgICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdDtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZERhdGUgPSAoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBuZXcgRGF0ZSh0YXJnZXQuZGF0ZU9iai5nZXRUaW1lKCkpKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRDaGFuZ2VNb250aCA9IChzZWxlY3RlZERhdGUuZ2V0TW9udGgoKSA8IHNlbGYuY3VycmVudE1vbnRoIHx8XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlLmdldE1vbnRoKCkgPlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCArIHNlbGYuY29uZmlnLnNob3dNb250aHMgLSAxKSAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIjtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInNpbmdsZVwiKVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtzZWxlY3RlZERhdGVdO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJtdWx0aXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSBpc0RhdGVTZWxlY3RlZChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4KVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMuc3BsaWNlKHBhcnNlSW50KHNlbGVjdGVkSW5kZXgpLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5wdXNoKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZWN0ZWREYXRlO1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5wdXNoKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIHNlbGVjdGluZyBzYW1lIGRhdGUgdHdpY2UsIHNvcnQgYXNjZW5kaW5nbHlcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZURhdGVzKHNlbGVjdGVkRGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB0cnVlKSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2hhbmdlTW9udGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNOZXdZZWFyID0gc2VsZi5jdXJyZW50WWVhciAhPT0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IHNlbGVjdGVkRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gc2VsZWN0ZWREYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3WWVhcilcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uTW9udGhDaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIChzZWxmLnNob3dUaW1lSW5wdXQgPSB0cnVlKTsgfSwgNTApO1xuICAgICAgICAgICAgLy8gbWFpbnRhaW4gZm9jdXNcbiAgICAgICAgICAgIGlmICghc2hvdWxkQ2hhbmdlTW9udGggJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zaG93TW9udGhzID09PSAxKVxuICAgICAgICAgICAgICAgIGZvY3VzT25EYXlFbGVtKHRhcmdldCk7XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAmJiBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbG9zZU9uU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZSA9IHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBDQUxMQkFDS1MgPSB7XG4gICAgICAgICAgICBsb2NhbGU6IFtzZXR1cExvY2FsZSwgdXBkYXRlV2Vla2RheXNdLFxuICAgICAgICAgICAgc2hvd01vbnRoczogW2J1aWxkTW9udGhzLCBzZXRDYWxlbmRhcldpZHRoLCBidWlsZFdlZWtkYXlzXVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBzZXQob3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbiAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIG9wdGlvbik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tvcHRpb25dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKENBTExCQUNLU1tvcHRpb25dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIENBTExCQUNLU1tvcHRpb25dLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgoKTsgfSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoSE9PS1MuaW5kZXhPZihvcHRpb24pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW29wdGlvbl0gPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGVkRGF0ZShpbnB1dERhdGUsIGZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgICAgICBpZiAoaW5wdXREYXRlIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGUubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBzZWxmLnBhcnNlRGF0ZShkLCBmb3JtYXQpOyB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0RGF0ZSBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGlucHV0RGF0ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0RGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5jb25maWcubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoc2VsZi5jb25maWcuY29uanVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJhbmdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChzZWxmLmwxMG4ucmFuZ2VTZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHN1cHBsaWVkOiBcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0RGF0ZSkpKTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IGRhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCBpbnN0YW5jZW9mIERhdGUgJiYgaXNFbmFibGVkKGQsIGZhbHNlKTsgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXREYXRlKGRhdGUsIHRyaWdnZXJDaGFuZ2UsIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgPT09IHZvaWQgMCkgeyB0cmlnZ2VyQ2hhbmdlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkgeyBmb3JtYXQgPSBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0OyB9XG4gICAgICAgICAgICBpZiAoKGRhdGUgIT09IDAgJiYgIWRhdGUpIHx8IChkYXRlIGluc3RhbmNlb2YgQXJyYXkgJiYgZGF0ZS5sZW5ndGggPT09IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsZWFyKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKGRhdGUsIGZvcm1hdCk7XG4gICAgICAgICAgICBzZWxmLnNob3dUaW1lSW5wdXQgPSBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZi5zZWxlY3RlZERhdGVzWzBdO1xuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgIGp1bXBUb0RhdGUoKTtcbiAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VEYXRlUnVsZXMoYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyXG4gICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBydWxlID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcnNlRGF0ZShydWxlLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBydWxlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuZnJvbSAmJlxuICAgICAgICAgICAgICAgICAgICBydWxlLnRvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogc2VsZi5wYXJzZURhdGUocnVsZS5mcm9tLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHNlbGYucGFyc2VEYXRlKHJ1bGUudG8sIHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7IC8vIHJlbW92ZSBmYWxzeSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cERhdGVzKCkge1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gW107XG4gICAgICAgICAgICBzZWxmLm5vdyA9IHNlbGYucGFyc2VEYXRlKHNlbGYuY29uZmlnLm5vdykgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgSUUxMSBzZXR0aW5nIHBsYWNlaG9sZGVyIGFzIHRoZSBpbnB1dCdzIHZhbHVlXG4gICAgICAgICAgICB2YXIgcHJlbG9hZGVkRGF0ZSA9IHNlbGYuY29uZmlnLmRlZmF1bHREYXRlIHx8XG4gICAgICAgICAgICAgICAgKChzZWxmLmlucHV0Lm5vZGVOYW1lID09PSBcIklOUFVUXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5ub2RlTmFtZSA9PT0gXCJURVhUQVJFQVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnBsYWNlaG9sZGVyICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPT09IHNlbGYuaW5wdXQucGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5pbnB1dC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJlbG9hZGVkRGF0ZSlcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZERhdGUocHJlbG9hZGVkRGF0ZSwgc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICBzZWxmLl9pbml0aWFsRGF0ZSA9XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLnNlbGVjdGVkRGF0ZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFRpbWUoKSA+IHNlbGYubm93LmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldFRpbWUoKSA8IHNlbGYubm93LmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubWF4RGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5ub3c7XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0gc2VsZi5faW5pdGlhbERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gc2VsZi5faW5pdGlhbERhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHNlbGYuc2VsZWN0ZWREYXRlc1swXTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluVGltZSA9IHNlbGYucGFyc2VEYXRlKHNlbGYuY29uZmlnLm1pblRpbWUsIFwiSDppXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heFRpbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhUaW1lID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubWF4VGltZSwgXCJIOmlcIik7XG4gICAgICAgICAgICBzZWxmLm1pbkRhdGVIYXNUaW1lID1cbiAgICAgICAgICAgICAgICAhIXNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0SG91cnMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TWludXRlcygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRTZWNvbmRzKCkgPiAwKTtcbiAgICAgICAgICAgIHNlbGYubWF4RGF0ZUhhc1RpbWUgPVxuICAgICAgICAgICAgICAgICEhc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZS5nZXRIb3VycygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNaW51dGVzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldFNlY29uZHMoKSA+IDApO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwic2hvd1RpbWVJbnB1dFwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLl9zaG93VGltZUlucHV0OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2hvd1RpbWVJbnB1dCA9IGJvb2w7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJzaG93VGltZUlucHV0XCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlzT3BlbiAmJiBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBJbnB1dHMoKSB7XG4gICAgICAgICAgICBzZWxmLmlucHV0ID0gc2VsZi5jb25maWcud3JhcFxuICAgICAgICAgICAgICAgID8gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtaW5wdXRdXCIpXG4gICAgICAgICAgICAgICAgOiBlbGVtZW50O1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghc2VsZi5pbnB1dCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IGVsZW1lbnQgc3BlY2lmaWVkXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYWNrOiBzdG9yZSBwcmV2aW91cyB0eXBlIHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZGVzdHJveSgpXG4gICAgICAgICAgICBzZWxmLmlucHV0Ll90eXBlID0gc2VsZi5pbnB1dC50eXBlO1xuICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBzZWxmLmlucHV0LmNsYXNzTGlzdC5hZGQoXCJmbGF0cGlja3ItaW5wdXRcIik7XG4gICAgICAgICAgICBzZWxmLl9pbnB1dCA9IHNlbGYuaW5wdXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYWx0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsaWNhdGUgc2VsZi5lbGVtZW50XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dCA9IGNyZWF0ZUVsZW1lbnQoc2VsZi5pbnB1dC5ub2RlTmFtZSwgc2VsZi5pbnB1dC5jbGFzc05hbWUgKyBcIiBcIiArIHNlbGYuY29uZmlnLmFsdElucHV0Q2xhc3MpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0ID0gc2VsZi5hbHRJbnB1dDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnBsYWNlaG9sZGVyID0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LmRpc2FibGVkID0gc2VsZi5pbnB1dC5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnJlcXVpcmVkID0gc2VsZi5pbnB1dC5yZXF1aXJlZDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnRhYkluZGV4ID0gc2VsZi5pbnB1dC50YWJJbmRleDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgc2VsZi5pbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuYWx0SW5wdXQsIHNlbGYuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5hbGxvd0lucHV0KVxuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICBzZWxmLl9wb3NpdGlvbkVsZW1lbnQgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5faW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBNb2JpbGUoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRUeXBlID0gc2VsZi5jb25maWcuZW5hYmxlVGltZVxuICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICA/IFwidGltZVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJkYXRldGltZS1sb2NhbFwiXG4gICAgICAgICAgICAgICAgOiBcImRhdGVcIjtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQgPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgc2VsZi5pbnB1dC5jbGFzc05hbWUgKyBcIiBmbGF0cGlja3ItbW9iaWxlXCIpO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5zdGVwID0gc2VsZi5pbnB1dC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpIHx8IFwiYW55XCI7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnRhYkluZGV4ID0gMTtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudHlwZSA9IGlucHV0VHlwZTtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZGlzYWJsZWQgPSBzZWxmLmlucHV0LmRpc2FibGVkO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5yZXF1aXJlZCA9IHNlbGYuaW5wdXQucmVxdWlyZWQ7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnBsYWNlaG9sZGVyID0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlRm9ybWF0U3RyID1cbiAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPT09IFwiZGF0ZXRpbWUtbG9jYWxcIlxuICAgICAgICAgICAgICAgICAgICA/IFwiWS1tLWRcXFxcVEg6aTpTXCJcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dFR5cGUgPT09IFwiZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiWS1tLWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIkg6aTpTXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmRlZmF1bHRWYWx1ZSA9IHNlbGYubW9iaWxlSW5wdXQudmFsdWUgPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5zZWxlY3RlZERhdGVzWzBdLCBzZWxmLm1vYmlsZUZvcm1hdFN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSlcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0Lm1pbiA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLmNvbmZpZy5taW5EYXRlLCBcIlktbS1kXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5tYXggPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5jb25maWcubWF4RGF0ZSwgXCJZLW0tZFwiKTtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmlucHV0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2VsZi5tb2JpbGVJbnB1dCwgc2VsZi5pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgYmluZChzZWxmLm1vYmlsZUlucHV0LCBcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShlLnRhcmdldC52YWx1ZSwgZmFsc2UsIHNlbGYubW9iaWxlRm9ybWF0U3RyKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNsb3NlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzT3BlbiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgc2VsZi5vcGVuKGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbHJlYWR5LCBhbGwgaG9va3MgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBob29rcyA9IHNlbGYuY29uZmlnW2V2ZW50XTtcbiAgICAgICAgICAgIGlmIChob29rcyAhPT0gdW5kZWZpbmVkICYmIGhvb2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaG9va3NbaV0gJiYgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBob29rc1tpXShzZWxmLnNlbGVjdGVkRGF0ZXMsIHNlbGYuaW5wdXQudmFsdWUsIHNlbGYsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBcIm9uQ2hhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJjaGFuZ2VcIikpO1xuICAgICAgICAgICAgICAgIC8vIG1hbnkgZnJvbnQtZW5kIGZyYW1ld29ya3MgYmluZCB0byB0aGUgaW5wdXQgZXZlbnRcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJpbnB1dFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgICAgICAgICAgZS5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3RlZChkYXRlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRGF0ZXMoc2VsZi5zZWxlY3RlZERhdGVzW2ldLCBkYXRlKSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRGF0ZUluUmFuZ2UoZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIiB8fCBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0pID49IDAgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzFdKSA8PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgfHwgc2VsZi5pc01vYmlsZSB8fCAhc2VsZi5tb250aE5hdilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh5ZWFyRWxlbWVudCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGgsIDEpO1xuICAgICAgICAgICAgICAgIGQuc2V0TW9udGgoc2VsZi5jdXJyZW50TW9udGggKyBpKTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHNbaV0udGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICBtb250aFRvU3RyKGQuZ2V0TW9udGgoKSwgc2VsZi5jb25maWcuc2hvcnRoYW5kQ3VycmVudE1vbnRoLCBzZWxmLmwxMG4pICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiO1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LnZhbHVlID0gZC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuX2hpZGVQcmV2TW9udGhBcnJvdyA9XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jdXJyZW50TW9udGggPD0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY3VycmVudFllYXIgPCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgICAgICAgc2VsZi5faGlkZU5leHRNb250aEFycm93ID1cbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhEYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmN1cnJlbnRNb250aCArIDEgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1vbnRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jdXJyZW50WWVhciA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGF0ZVN0cihmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNlbGVjdGVkRGF0ZXNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkT2JqKSB7IHJldHVybiBzZWxmLmZvcm1hdERhdGUoZE9iaiwgZm9ybWF0KTsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgYXJyLmluZGV4T2YoZCkgPT09IGk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIlxuICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuY29uanVuY3Rpb25cbiAgICAgICAgICAgICAgICA6IHNlbGYubDEwbi5yYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiBpbnB1dHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYWxlbmRhclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmFsdWUodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgPT09IHZvaWQgMCkgeyB0cmlnZ2VyQ2hhbmdlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2xlYXIodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkICYmIHNlbGYubW9iaWxlRm9ybWF0U3RyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5mb3JtYXREYXRlKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLm1vYmlsZUZvcm1hdFN0cilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBnZXREYXRlU3RyKHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudmFsdWUgPSBnZXREYXRlU3RyKHNlbGYuY29uZmlnLmFsdEZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25WYWx1ZVVwZGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk1vbnRoTmF2Q2xpY2soZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGlzUHJldk1vbnRoID0gc2VsZi5wcmV2TW9udGhOYXYuY29udGFpbnMoZS50YXJnZXQpO1xuICAgICAgICAgICAgdmFyIGlzTmV4dE1vbnRoID0gc2VsZi5uZXh0TW9udGhOYXYuY29udGFpbnMoZS50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGlzUHJldk1vbnRoIHx8IGlzTmV4dE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlTW9udGgoaXNQcmV2TW9udGggPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi55ZWFyRWxlbWVudHMuaW5kZXhPZihlLnRhcmdldCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0LnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dVcFwiKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcnJvd0Rvd25cIikpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRpbWVXcmFwcGVyKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBpc0tleURvd24gPSBlLnR5cGUgPT09IFwia2V5ZG93blwiLCBpbnB1dCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkICYmIGUudGFyZ2V0ID09PSBzZWxmLmFtUE0pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmwxMG4uYW1QTVtpbnQoc2VsZi5hbVBNLnRleHRDb250ZW50ID09PSBzZWxmLmwxMG4uYW1QTVswXSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbiA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwibWluXCIpKSwgbWF4ID0gcGFyc2VGbG9hdChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJtYXhcIikpLCBzdGVwID0gcGFyc2VGbG9hdChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKSwgY3VyVmFsdWUgPSBwYXJzZUludChpbnB1dC52YWx1ZSwgMTApLCBkZWx0YSA9IGUuZGVsdGEgfHxcbiAgICAgICAgICAgICAgICAoaXNLZXlEb3duID8gKGUud2hpY2ggPT09IDM4ID8gMSA6IC0xKSA6IDApO1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VyVmFsdWUgKyBzdGVwICogZGVsdGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0LnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIGlucHV0LnZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBpc0hvdXJFbGVtID0gaW5wdXQgPT09IHNlbGYuaG91ckVsZW1lbnQsIGlzTWludXRlRWxlbSA9IGlucHV0ID09PSBzZWxmLm1pbnV0ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCghaXNIb3VyRWxlbSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbnQoaXNIb3VyRWxlbSkgJiYgaW50KCFzZWxmLmFtUE0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWludXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KHVuZGVmaW5lZCwgLTEsIHNlbGYuaG91ckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9PT0gc2VsZi5ob3VyRWxlbWVudCA/IG5ld1ZhbHVlIC0gbWF4IC0gaW50KCFzZWxmLmFtUE0pIDogbWluO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaW51dGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50TnVtSW5wdXQodW5kZWZpbmVkLCAxLCBzZWxmLmhvdXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0hvdXJFbGVtICYmXG4gICAgICAgICAgICAgICAgICAgIChzdGVwID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ld1ZhbHVlICsgY3VyVmFsdWUgPT09IDIzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguYWJzKG5ld1ZhbHVlIC0gY3VyVmFsdWUpID4gc3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubDEwbi5hbVBNW2ludChzZWxmLmFtUE0udGV4dENvbnRlbnQgPT09IHNlbGYubDEwbi5hbVBNWzBdKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gcGFkKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbml0KCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIF9mbGF0cGlja3Iobm9kZUxpc3QsIGNvbmZpZykge1xuICAgICAgICAvLyBzdGF0aWMgbGlzdFxuICAgICAgICB2YXIgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICAgIC5jYWxsKG5vZGVMaXN0KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50OyB9KTtcbiAgICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWZwLW9taXRcIikgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLl9mbGF0cGlja3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9mbGF0cGlja3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9mbGF0cGlja3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrciA9IEZsYXRwaWNrckluc3RhbmNlKG5vZGUsIGNvbmZpZyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzLnB1c2gobm9kZS5fZmxhdHBpY2tyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2VzLmxlbmd0aCA9PT0gMSA/IGluc3RhbmNlc1swXSA6IGluc3RhbmNlcztcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGJyb3dzZXIgZW52XG4gICAgICAgIEhUTUxDb2xsZWN0aW9uLnByb3RvdHlwZS5mbGF0cGlja3IgPSBOb2RlTGlzdC5wcm90b3R5cGUuZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IodGhpcywgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKFt0aGlzXSwgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB2YXIgZmxhdHBpY2tyID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3Iod2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IoW3NlbGVjdG9yXSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHNlbGVjdG9yLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdHM7XG4gICAgZmxhdHBpY2tyLmwxMG5zID0ge1xuICAgICAgICBlbjogX19hc3NpZ24oe30sIGVuZ2xpc2gpLFxuICAgICAgICBcImRlZmF1bHRcIjogX19hc3NpZ24oe30sIGVuZ2xpc2gpXG4gICAgfTtcbiAgICBmbGF0cGlja3IubG9jYWxpemUgPSBmdW5jdGlvbiAobDEwbikge1xuICAgICAgICBmbGF0cGlja3IubDEwbnNbXCJkZWZhdWx0XCJdID0gX19hc3NpZ24oe30sIGZsYXRwaWNrci5sMTBuc1tcImRlZmF1bHRcIl0sIGwxMG4pO1xuICAgIH07XG4gICAgZmxhdHBpY2tyLnNldERlZmF1bHRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBmbGF0cGlja3IuZGVmYXVsdENvbmZpZyA9IF9fYXNzaWduKHt9LCBmbGF0cGlja3IuZGVmYXVsdENvbmZpZywgY29uZmlnKTtcbiAgICB9O1xuICAgIGZsYXRwaWNrci5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHt9KTtcbiAgICBmbGF0cGlja3IuZm9ybWF0RGF0ZSA9IGNyZWF0ZURhdGVGb3JtYXR0ZXIoe30pO1xuICAgIGZsYXRwaWNrci5jb21wYXJlRGF0ZXMgPSBjb21wYXJlRGF0ZXM7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBqUXVlcnkuZm4uZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IodGhpcywgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGF0ZS5wcm90b3R5cGUuZnBfaW5jciA9IGZ1bmN0aW9uIChkYXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksIHRoaXMuZ2V0TW9udGgoKSwgdGhpcy5nZXREYXRlKCkgKyAodHlwZW9mIGRheXMgPT09IFwic3RyaW5nXCIgPyBwYXJzZUludChkYXlzLCAxMCkgOiBkYXlzKSk7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB3aW5kb3cuZmxhdHBpY2tyID0gZmxhdHBpY2tyO1xuICAgIH1cblxuICAgIHJldHVybiBmbGF0cGlja3I7XG5cbn0pKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kZSA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZnAgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mbGF0cGlja3IgIT09IHVuZGVmaW5lZFxuICAgICAgPyB3aW5kb3cuZmxhdHBpY2tyXG4gICAgICA6IHtcbiAgICAgICAgICBsMTBuczoge31cbiAgICAgIH07XG4gIHZhciBHZXJtYW4gPSB7XG4gICAgICB3ZWVrZGF5czoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1wiU29cIiwgXCJNb1wiLCBcIkRpXCIsIFwiTWlcIiwgXCJEb1wiLCBcIkZyXCIsIFwiU2FcIl0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJTb25udGFnXCIsXG4gICAgICAgICAgICAgIFwiTW9udGFnXCIsXG4gICAgICAgICAgICAgIFwiRGllbnN0YWdcIixcbiAgICAgICAgICAgICAgXCJNaXR0d29jaFwiLFxuICAgICAgICAgICAgICBcIkRvbm5lcnN0YWdcIixcbiAgICAgICAgICAgICAgXCJGcmVpdGFnXCIsXG4gICAgICAgICAgICAgIFwiU2Ftc3RhZ1wiLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBtb250aHM6IHtcbiAgICAgICAgICBzaG9ydGhhbmQ6IFtcbiAgICAgICAgICAgICAgXCJKYW5cIixcbiAgICAgICAgICAgICAgXCJGZWJcIixcbiAgICAgICAgICAgICAgXCJNw6RyXCIsXG4gICAgICAgICAgICAgIFwiQXByXCIsXG4gICAgICAgICAgICAgIFwiTWFpXCIsXG4gICAgICAgICAgICAgIFwiSnVuXCIsXG4gICAgICAgICAgICAgIFwiSnVsXCIsXG4gICAgICAgICAgICAgIFwiQXVnXCIsXG4gICAgICAgICAgICAgIFwiU2VwXCIsXG4gICAgICAgICAgICAgIFwiT2t0XCIsXG4gICAgICAgICAgICAgIFwiTm92XCIsXG4gICAgICAgICAgICAgIFwiRGV6XCIsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICBcIkphbnVhclwiLFxuICAgICAgICAgICAgICBcIkZlYnJ1YXJcIixcbiAgICAgICAgICAgICAgXCJNw6RyelwiLFxuICAgICAgICAgICAgICBcIkFwcmlsXCIsXG4gICAgICAgICAgICAgIFwiTWFpXCIsXG4gICAgICAgICAgICAgIFwiSnVuaVwiLFxuICAgICAgICAgICAgICBcIkp1bGlcIixcbiAgICAgICAgICAgICAgXCJBdWd1c3RcIixcbiAgICAgICAgICAgICAgXCJTZXB0ZW1iZXJcIixcbiAgICAgICAgICAgICAgXCJPa3RvYmVyXCIsXG4gICAgICAgICAgICAgIFwiTm92ZW1iZXJcIixcbiAgICAgICAgICAgICAgXCJEZXplbWJlclwiLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBmaXJzdERheU9mV2VlazogMSxcbiAgICAgIHdlZWtBYmJyZXZpYXRpb246IFwiS1dcIixcbiAgICAgIHJhbmdlU2VwYXJhdG9yOiBcIiBiaXMgXCIsXG4gICAgICBzY3JvbGxUaXRsZTogXCJadW0gw4RuZGVybiBzY3JvbGxlblwiLFxuICAgICAgdG9nZ2xlVGl0bGU6IFwiWnVtIFVtc2NoYWx0ZW4ga2xpY2tlblwiXG4gIH07XG4gIGZwLmwxMG5zLmRlID0gR2VybWFuO1xuICB2YXIgZGUgPSBmcC5sMTBucztcblxuICBleHBvcnRzLkdlcm1hbiA9IEdlcm1hbjtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gZGU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmZyID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmcCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmZsYXRwaWNrciAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHdpbmRvdy5mbGF0cGlja3JcbiAgICAgIDoge1xuICAgICAgICAgIGwxMG5zOiB7fVxuICAgICAgfTtcbiAgdmFyIEZyZW5jaCA9IHtcbiAgICAgIGZpcnN0RGF5T2ZXZWVrOiAxLFxuICAgICAgd2Vla2RheXM6IHtcbiAgICAgICAgICBzaG9ydGhhbmQ6IFtcImRpbVwiLCBcImx1blwiLCBcIm1hclwiLCBcIm1lclwiLCBcImpldVwiLCBcInZlblwiLCBcInNhbVwiXSxcbiAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICBcImRpbWFuY2hlXCIsXG4gICAgICAgICAgICAgIFwibHVuZGlcIixcbiAgICAgICAgICAgICAgXCJtYXJkaVwiLFxuICAgICAgICAgICAgICBcIm1lcmNyZWRpXCIsXG4gICAgICAgICAgICAgIFwiamV1ZGlcIixcbiAgICAgICAgICAgICAgXCJ2ZW5kcmVkaVwiLFxuICAgICAgICAgICAgICBcInNhbWVkaVwiLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBtb250aHM6IHtcbiAgICAgICAgICBzaG9ydGhhbmQ6IFtcbiAgICAgICAgICAgICAgXCJqYW52XCIsXG4gICAgICAgICAgICAgIFwiZsOpdnJcIixcbiAgICAgICAgICAgICAgXCJtYXJzXCIsXG4gICAgICAgICAgICAgIFwiYXZyXCIsXG4gICAgICAgICAgICAgIFwibWFpXCIsXG4gICAgICAgICAgICAgIFwianVpblwiLFxuICAgICAgICAgICAgICBcImp1aWxcIixcbiAgICAgICAgICAgICAgXCJhb8O7dFwiLFxuICAgICAgICAgICAgICBcInNlcHRcIixcbiAgICAgICAgICAgICAgXCJvY3RcIixcbiAgICAgICAgICAgICAgXCJub3ZcIixcbiAgICAgICAgICAgICAgXCJkw6ljXCIsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICBcImphbnZpZXJcIixcbiAgICAgICAgICAgICAgXCJmw6l2cmllclwiLFxuICAgICAgICAgICAgICBcIm1hcnNcIixcbiAgICAgICAgICAgICAgXCJhdnJpbFwiLFxuICAgICAgICAgICAgICBcIm1haVwiLFxuICAgICAgICAgICAgICBcImp1aW5cIixcbiAgICAgICAgICAgICAgXCJqdWlsbGV0XCIsXG4gICAgICAgICAgICAgIFwiYW/Du3RcIixcbiAgICAgICAgICAgICAgXCJzZXB0ZW1icmVcIixcbiAgICAgICAgICAgICAgXCJvY3RvYnJlXCIsXG4gICAgICAgICAgICAgIFwibm92ZW1icmVcIixcbiAgICAgICAgICAgICAgXCJkw6ljZW1icmVcIixcbiAgICAgICAgICBdXG4gICAgICB9LFxuICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG50aCkge1xuICAgICAgICAgIGlmIChudGggPiAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICByZXR1cm4gXCJlclwiO1xuICAgICAgfSxcbiAgICAgIHJhbmdlU2VwYXJhdG9yOiBcIiBhdSBcIixcbiAgICAgIHdlZWtBYmJyZXZpYXRpb246IFwiU2VtXCIsXG4gICAgICBzY3JvbGxUaXRsZTogXCJEw6lmaWxlciBwb3VyIGF1Z21lbnRlciBsYSB2YWxldXJcIixcbiAgICAgIHRvZ2dsZVRpdGxlOiBcIkNsaXF1ZXIgcG91ciBiYXNjdWxlclwiXG4gIH07XG4gIGZwLmwxMG5zLmZyID0gRnJlbmNoO1xuICB2YXIgZnIgPSBmcC5sMTBucztcblxuICBleHBvcnRzLkZyZW5jaCA9IEZyZW5jaDtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gZnI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLml0ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmcCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmZsYXRwaWNrciAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHdpbmRvdy5mbGF0cGlja3JcbiAgICAgIDoge1xuICAgICAgICAgIGwxMG5zOiB7fVxuICAgICAgfTtcbiAgdmFyIEl0YWxpYW4gPSB7XG4gICAgICB3ZWVrZGF5czoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1wiRG9tXCIsIFwiTHVuXCIsIFwiTWFyXCIsIFwiTWVyXCIsIFwiR2lvXCIsIFwiVmVuXCIsIFwiU2FiXCJdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiRG9tZW5pY2FcIixcbiAgICAgICAgICAgICAgXCJMdW5lZMOsXCIsXG4gICAgICAgICAgICAgIFwiTWFydGVkw6xcIixcbiAgICAgICAgICAgICAgXCJNZXJjb2xlZMOsXCIsXG4gICAgICAgICAgICAgIFwiR2lvdmVkw6xcIixcbiAgICAgICAgICAgICAgXCJWZW5lcmTDrFwiLFxuICAgICAgICAgICAgICBcIlNhYmF0b1wiLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBtb250aHM6IHtcbiAgICAgICAgICBzaG9ydGhhbmQ6IFtcbiAgICAgICAgICAgICAgXCJHZW5cIixcbiAgICAgICAgICAgICAgXCJGZWJcIixcbiAgICAgICAgICAgICAgXCJNYXJcIixcbiAgICAgICAgICAgICAgXCJBcHJcIixcbiAgICAgICAgICAgICAgXCJNYWdcIixcbiAgICAgICAgICAgICAgXCJHaXVcIixcbiAgICAgICAgICAgICAgXCJMdWdcIixcbiAgICAgICAgICAgICAgXCJBZ29cIixcbiAgICAgICAgICAgICAgXCJTZXRcIixcbiAgICAgICAgICAgICAgXCJPdHRcIixcbiAgICAgICAgICAgICAgXCJOb3ZcIixcbiAgICAgICAgICAgICAgXCJEaWNcIixcbiAgICAgICAgICBdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiR2VubmFpb1wiLFxuICAgICAgICAgICAgICBcIkZlYmJyYWlvXCIsXG4gICAgICAgICAgICAgIFwiTWFyem9cIixcbiAgICAgICAgICAgICAgXCJBcHJpbGVcIixcbiAgICAgICAgICAgICAgXCJNYWdnaW9cIixcbiAgICAgICAgICAgICAgXCJHaXVnbm9cIixcbiAgICAgICAgICAgICAgXCJMdWdsaW9cIixcbiAgICAgICAgICAgICAgXCJBZ29zdG9cIixcbiAgICAgICAgICAgICAgXCJTZXR0ZW1icmVcIixcbiAgICAgICAgICAgICAgXCJPdHRvYnJlXCIsXG4gICAgICAgICAgICAgIFwiTm92ZW1icmVcIixcbiAgICAgICAgICAgICAgXCJEaWNlbWJyZVwiLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBmaXJzdERheU9mV2VlazogMSxcbiAgICAgIG9yZGluYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiwrBcIjsgfSxcbiAgICAgIHJhbmdlU2VwYXJhdG9yOiBcIiBhbCBcIixcbiAgICAgIHdlZWtBYmJyZXZpYXRpb246IFwiU2VcIixcbiAgICAgIHNjcm9sbFRpdGxlOiBcIlNjcm9sbGEgcGVyIGF1bWVudGFyZVwiLFxuICAgICAgdG9nZ2xlVGl0bGU6IFwiQ2xpY2NhIHBlciBjYW1iaWFyZVwiXG4gIH07XG4gIGZwLmwxMG5zLml0ID0gSXRhbGlhbjtcbiAgdmFyIGl0ID0gZnAubDEwbnM7XG5cbiAgZXhwb3J0cy5JdGFsaWFuID0gSXRhbGlhbjtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gaXQ7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xMi45XG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLlBvcHBlciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xudmFyIHRpbWVvdXREdXJhdGlvbiA9IDA7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICB0aW1lb3V0RHVyYXRpb24gPSAxO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbCkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQgJiYgZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSwgMTApICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddLCAxMCk7XG59XG5cbi8qKlxuICogVGVsbHMgaWYgeW91IGFyZSBydW5uaW5nIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRTEwXG4gKi9cbnZhciBpc0lFMTAgPSB1bmRlZmluZWQ7XG5cbnZhciBpc0lFMTAkMSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGlzSUUxMCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaXNJRTEwID0gbmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZignTVNJRSAxMCcpICE9PSAtMTtcbiAgfVxuICByZXR1cm4gaXNJRTEwO1xufTtcblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRTEwJDEoKSA/IGh0bWxbJ29mZnNldCcgKyBheGlzXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldICsgY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUxMCQxKCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSlcbiAgfTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZzZXRzLCB7XG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICBpZiAoaXNJRTEwJDEoKSkge1xuICAgIHRyeSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfSBlbHNlIHtcbiAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcygpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LnJpZ2h0IC0gcmVzdWx0LmxlZnQ7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmJvdHRvbSAtIHJlc3VsdC50b3A7XG5cbiAgdmFyIGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICB2YXIgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgIHZlcnRTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneScpO1xuXG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydFNjcm9sbGJhcjtcbiAgfVxuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50KSB7XG4gIHZhciBpc0lFMTAgPSBpc0lFMTAkMSgpO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoLCAxMCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgsIDEwKTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCwgMTApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCwgMTApO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoaHRtbCk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0Jyk7XG5cbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIGJvdW5kYXJpZXMgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50KTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcygpLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRXaW5kb3dTaXplcy5oZWlnaHQsXG4gICAgICAgICAgd2lkdGggPSBfZ2V0V2luZG93U2l6ZXMud2lkdGg7XG5cbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgYm91bmRhcmllcy5sZWZ0ICs9IHBhZGRpbmc7XG4gIGJvdW5kYXJpZXMudG9wICs9IHBhZGRpbmc7XG4gIGJvdW5kYXJpZXMucmlnaHQgLT0gcGFkZGluZztcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gcGFkZGluZztcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBkYXRhLnBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHModGhpcy5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveSB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0eSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBvblVwZGF0ZSBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICB9KS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgfVxuICB2YXIgZ3B1QWNjZWxlcmF0aW9uID0gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uXG4gIH07XG5cbiAgLy8gZmxvb3Igc2lkZXMgdG8gYXZvaWQgYmx1cnJ5IHRleHRcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgbGVmdDogTWF0aC5mbG9vcihwb3BwZXIubGVmdCksXG4gICAgdG9wOiBNYXRoLmZsb29yKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogTWF0aC5mbG9vcihwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogTWF0aC5mbG9vcihwb3BwZXIucmlnaHQpXG4gIH07XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1Y3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdLCAxMCk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSwgMTApO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1yaWdodGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICB2YXIgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NMZWZ0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKGJvdW5kYXJpZXMubGVmdCk7XG4gICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICB2YXIgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIHZhciBvdmVyZmxvd3NCb3R0b20gPSBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgLy8gZmxpcCB0aGUgdmFyaWF0aW9uIGlmIHJlcXVpcmVkXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgIC8vIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgZGF0YS5mbGlwcGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gZmxpcE9yZGVyW2luZGV4ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgIHZhcmlhdGlvbiA9IGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgLy8gdGhpcyBvYmplY3QgY29udGFpbnMgYHBvc2l0aW9uYCwgd2Ugd2FudCB0byBwcmVzZXJ2ZSBpdCBhbG9uZyB3aXRoXG4gICAgICAvLyBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0eSB3ZSBtYXkgYWRkIGluIHRoZSBmdXR1cmVcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcblxuICAgICAgZGF0YSA9IHJ1bk1vZGlmaWVycyhkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZGF0YSwgJ2ZsaXAnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGtlZXBUb2dldGhlcihkYXRhKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSAtIHBvcHBlclttZWFzdXJlbWVudF07XG4gIH1cbiAgaWYgKHBvcHBlcltvcFNpZGVdID4gZmxvb3IocmVmZXJlbmNlW3NpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtzaWRlXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5mdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIHZhciB2YWx1ZSA9ICtzcGxpdFsxXTtcbiAgdmFyIHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIHJldHVybiByZWN0W21lYXN1cmVtZW50XSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2UgaWYgKHVuaXQgPT09ICd2aCcgfHwgdW5pdCA9PT0gJ3Z3Jykge1xuICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgc2l6ZSA9IHZvaWQgMDtcbiAgICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzaXplIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAvLyBpZiBpcyBhbiBpbXBsaWNpdCB1bml0LCBpdCdzIHB4LCBhbmQgd2UgcmV0dXJuIGp1c3QgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBvZmZzZXRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IGJhc2VQbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gYSB0d28gY2VsbHMgYXJyYXkgd2l0aCB4IGFuZCB5IG9mZnNldHMgaW4gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMsIGJhc2VQbGFjZW1lbnQpIHtcbiAgdmFyIG9mZnNldHMgPSBbMCwgMF07XG5cbiAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gIC8vIGluIHRoaXMgd2F5IHRoZSBmaXJzdCBvZmZzZXQgd2lsbCB1c2UgYW4gYXhpcyBhbmQgdGhlIHNlY29uZCBvbmVcbiAgLy8gd2lsbCB1c2UgdGhlIG90aGVyIG9uZVxuICB2YXIgdXNlSGVpZ2h0ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgLy8gU3BsaXQgdGhlIG9mZnNldCBzdHJpbmcgdG8gb2J0YWluIGEgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzXG4gIC8vIFRoZSByZWdleCBhZGRyZXNzZXMgdmFsdWVzIHdpdGggdGhlIHBsdXMgb3IgbWludXMgc2lnbiBpbiBmcm9udCAoKzEwLCAtMjAsIGV0YylcbiAgdmFyIGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcudHJpbSgpO1xuICB9KTtcblxuICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgLy8gdGhleSBjb3VsZCBiZSBzZXBhcmF0ZWQgYnkgY29tbWEgb3Igc3BhY2VcbiAgdmFyIGRpdmlkZXIgPSBmcmFnbWVudHMuaW5kZXhPZihmaW5kKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICB9KSk7XG5cbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IHZvaWQgMDtcbiAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgIG9mZnNldHMgPSBbK29mZnNldCwgMF07XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICB9XG5cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cblxuICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyaWVzRWxlbWVudCA9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdGxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGhlaWdodC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IE1vcmUgb24gdGhpcyBbcmVhZGluZyB0aGlzIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKVxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBbiBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyIHRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGhhcyBhbHdheXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllciwgY2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaG90aGVyc1xuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEV4cGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGFzc3VyZSBpdCB0byBwb2ludCB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMsIHlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1Y3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKS5cbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbixcbiAgICAgKiB0aGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYga2VlcFRvZ2V0aGVyIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3Ugb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzZCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbnMgdXNlZCBieSBQb3BwZXIuanNcbiAqIHRoaXMgb2JqZWN0IGdldCBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsIGl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdywgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFzIDNyZCBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoaXMgb2JqZWN0LCBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudFxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogV2hldGhlciBldmVudHMgKHJlc2l6ZSwgc2Nyb2xsKSBhcmUgaW5pdGlhbGx5IGVuYWJsZWRcbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZCwgdGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYW4gdXBkYXRlLCBpdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAxLjcsIHRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHlvdVxuICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAqXG4gICAgICogKipERVBSRUNBVElPTioqOiBUaGlzIHdheSB0byBhY2Nlc3MgUG9wcGVyVXRpbHMgaXMgZGVwcmVjYXRlZFxuICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICAgKiBndWFyYW50ZWUgdGhlbSB0byBmb2xsb3cgc2VtdmVyLiBVc2UgdGhlbSBhdCB5b3VyIG93biByaXNrIVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgKiBAbWVtYmVyIFV0aWxzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIFBvcHBlcjtcbn0oKTtcblxuLyoqXG4gKiBUaGUgYHJlZmVyZW5jZU9iamVjdGAgaXMgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGNvbXBhdGlibGUgd2l0aCBQb3BwZXIuanNcbiAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gYSBwb3BwZXIgcmVsYXRpdmVseSB0byBhIHNldCBvZiBjb29yZGluYXRlc1xuICogaW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIERPTSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZmVyZW5jZU9iamVjdCwgcG9wcGVyTm9kZSk7XG4gKiBgYGBcbiAqXG4gKiBOQjogVGhpcyBmZWF0dXJlIGlzbid0IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMFxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5yZXR1cm4gUG9wcGVyO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIGdsb2JhbCwgZGVmaW5lLCBTeXN0ZW0sIFJlZmxlY3QsIFByb21pc2UgKi9cclxudmFyIF9fZXh0ZW5kcztcclxudmFyIF9fYXNzaWduO1xyXG52YXIgX19yZXN0O1xyXG52YXIgX19kZWNvcmF0ZTtcclxudmFyIF9fcGFyYW07XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ZXIgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24gKG0sIGV4cG9ydHMpIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChvW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9OyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIH07XHJcblxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgICAgIHJldHVybiBjb29rZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0KTtcclxufSk7XHJcbiJdfQ==
;