import * as wcHelpers from "../../core/helpers/webcomponent-helpers";
import flatpickr from "flatpickr";
import "flatpickr/dist/l10n/it.js";
import "flatpickr/dist/l10n/fr.js";
import "flatpickr/dist/l10n/de.js";
export class Input {
    constructor() {
        this.invokeHitEnterCallback = () => null;
        this.invokeChangeCallback = () => null;
        this.invokeInputCallback = () => null;
        this.invokeFocusCallback = () => null;
        this.invokeBlurCallback = () => null;
        this.inputElValue = "";
        this.hasInputElFocus = false;
        this.srHint = "";
        this.placeholder = "";
        this.type = "text";
        this.value = "";
        this.selectTextOnFocus = false;
        this.inputStyle = {};
        this.readonly = false;
        this.disabled = false;
        this.editable = true;
        this.label = "";
        this.required = false;
    }
    valueChanged() {
        this.inputElValue = this.value;
        this.updateHeight();
        this.updateHiddenFormInputEl();
        this.invokeChangeCallback(this.value);
    }
    nameChanged() {
        this.updateHiddenFormInputEl();
    }
    hitEnterCallbackChanged() {
        this.setInvokeHitEnterCallback();
    }
    changeCallbackChanged() {
        this.setInvokeChangeCallback();
    }
    inputCallbackChanged() {
        this.setInvokeInputCallback();
    }
    focusCallbackChanged() {
        this.setInvokeFocusCallback();
    }
    blurCallbackChanged() {
        this.setInvokeBlurCallback();
    }
    componentWillLoad() {
        this.inputElValue = this.value;
        this.setInvokeHitEnterCallback();
        this.setInvokeChangeCallback();
        this.setInvokeInputCallback();
        this.setInvokeFocusCallback();
        this.setInvokeBlurCallback();
        this.initHiddenFormInputEl();
    }
    componentDidLoad() {
        this.offsetHeight = this.inputEl.offsetHeight;
        if (this.type === "date") {
            this.flatpickrInstance = flatpickr(this.inputEl.parentElement, Object.assign({}, Input.flatpickrOptions, this.getParsedFlatpickrOptions(), { defaultDate: this.value }));
        }
        this.updateHeight();
    }
    componentDidUnload() {
        if (this.type === "date") {
            this.flatpickrInstance.destroy();
        }
    }
    onFocus() {
        this.hasInputElFocus = true;
        if (this.selectTextOnFocus) {
            this.selectText();
        }
    }
    onBlur() {
        this.hasInputElFocus = false;
    }
    onInputElKeyPress(e) {
        if (e.which === 13) {
            this.invokeHitEnterCallback();
        }
    }
    onInputElKeyDown(e) {
        if (e.key === "Enter" || e.keyCode === 13) {
            this.openDatePicker();
        }
    }
    openDatePicker() {
        if (this.type === "date") {
            this.flatpickrInstance.open();
            setTimeout(() => this.flatpickrInstance.set("allowInput", false));
        }
    }
    onInputElInput(e) {
        const value = e.target.value;
        this.inputElValue = value;
        this.invokeInputCallback(value);
    }
    defaultInputCallback(value) {
        this.value = value;
    }
    setInvokeHitEnterCallback() {
        this.invokeHitEnterCallback = wcHelpers.parseFunction(this.hitEnterCallback);
    }
    setInvokeChangeCallback() {
        this.invokeChangeCallback = wcHelpers.parseFunction(this.changeCallback);
    }
    setInvokeInputCallback() {
        if (this.inputCallback) {
            this.invokeInputCallback = wcHelpers.parseFunction(this.inputCallback);
        }
        else {
            this.invokeInputCallback = this.defaultInputCallback;
        }
    }
    setInvokeFocusCallback() {
        this.invokeFocusCallback = wcHelpers.parseFunction(this.focusCallback);
    }
    setInvokeBlurCallback() {
        this.invokeBlurCallback = wcHelpers.parseFunction(this.blurCallback);
    }
    onInputElFocus() {
        this.hasInputElFocus = true;
        if (!this.readonly) {
            this.updateHeight();
        }
        this.invokeFocusCallback();
    }
    onInputElBlur() {
        this.hasInputElFocus = false;
        this.updateHeight();
        this.invokeBlurCallback();
    }
    selectText() {
        setTimeout(() => {
            const inputEl = this.inputEl;
            inputEl.setSelectionRange(0, inputEl.value.length);
        });
    }
    updateHeight() {
        if (this.type !== "textarea") {
            return;
        }
        const inputEl = this.inputEl;
        const computedInputElStyle = getComputedStyle(inputEl);
        const lineHeight = parseInt(computedInputElStyle.lineHeight, 10);
        const offsetHeight = inputEl.offsetHeight;
        const clientHeight = inputEl.clientHeight;
        const border = offsetHeight - clientHeight;
        const minHeight = this.offsetHeight;
        const focussedHeight = minHeight + (lineHeight * 4);
        const maxHeight = minHeight + (lineHeight * 10);
        let newHeight = minHeight;
        inputEl.style.overflow = "hidden";
        if (this.value) {
            inputEl.style.height = "auto";
            const newHeightBasedOnContent = inputEl.scrollHeight + border + lineHeight;
            if (newHeightBasedOnContent > maxHeight) {
                inputEl.style.overflow = "auto";
            }
            newHeight = Math.min(Math.max(focussedHeight, newHeightBasedOnContent), maxHeight);
        }
        else {
            if (this.hasInputElFocus) {
                newHeight = focussedHeight;
            }
        }
        inputEl.style.height = `${newHeight}px`;
    }
    initHiddenFormInputEl() {
        this.lightDOMHiddenFormInputEl = document.createElement("input");
        this.lightDOMHiddenFormInputEl.type = "hidden";
        this.updateHiddenFormInputEl();
        this.el.appendChild(this.lightDOMHiddenFormInputEl);
    }
    updateHiddenFormInputEl() {
        delete this.lightDOMHiddenFormInputEl.name;
        this.lightDOMHiddenFormInputEl.removeAttribute("name");
        if (this.name && this.value) {
            this.lightDOMHiddenFormInputEl.name = this.name;
            this.lightDOMHiddenFormInputEl.value = this.value;
        }
    }
    getLabel() {
        const hiddenText = this.validationMessage ? `${this.srHint} ${this.validationMessage}` : this.srHint;
        if (this.label) {
            return (h("label", { class: "label", htmlFor: "id" },
                this.label,
                this.required && h("span", { "aria-hidden": "true" }, " *"),
                hiddenText && h("span", { class: "sr-only" },
                    " ",
                    hiddenText)));
        }
        else if (hiddenText) {
            return (h("label", { class: "sr-only", htmlFor: "id" }, hiddenText));
        }
        else {
            return null;
        }
    }
    getCommonInputFieldProps() {
        return {
            id: "id",
            placeholder: this.placeholder,
            onInput: (e) => this.onInputElInput(e),
            onKeyPress: (e) => this.onInputElKeyPress(e),
            onKeyDown: (e) => this.onInputElKeyDown(e),
            onFocus: () => this.onInputElFocus(),
            onBlur: () => this.onInputElBlur(),
            ref: (el) => this.inputEl = el,
            style: this.inputStyle,
            autoComplete: this.autocomplete,
            autoCorrect: "off",
            autoCapitalize: "off",
            maxLength: this.maxlength,
            required: this.required,
            disabled: this.disabled,
            readonly: this.readonly
        };
    }
    getComponentClassNames() {
        return {
            component: true,
            [this.type]: true,
            readonly: this.readonly,
            disabled: this.disabled,
            editable: this.editable,
            focus: this.hasInputElFocus,
            valid: this.valid === true,
            invalid: this.valid === false
        };
    }
    createInputField() {
        return (h("div", { class: "wrapper" },
            this.editable &&
                h("input", Object.assign({}, this.getCommonInputFieldProps(), { class: "input", type: this.type, value: this.inputElValue, spellCheck: "false" })),
            !this.editable &&
                h("div", { class: "input", style: this.inputStyle, tabIndex: this.disabled ? undefined : 0, ref: (el) => this.inputEl = el },
                    h("sdx-text-truncate", null, this.value)),
            this.valid &&
                h("sdx-icon", { class: "checkmark-icon", iconName: "icon-check-mark", size: 3 })));
    }
    createNumberInputField() {
        return (h("div", { class: "wrapper" },
            h("input", Object.assign({}, this.getCommonInputFieldProps(), { class: "input", type: this.type, value: this.value, step: this.step, min: this.min, max: this.max }))));
    }
    createDateInputField() {
        return (h("div", { class: "wrapper" },
            h("input", Object.assign({}, this.getCommonInputFieldProps(), { class: "input", type: "date", value: this.value, "data-input": true })),
            h("sdx-button", { tabindex: "-1", class: "calendar-button", theme: "transparent", srHint: "Calendar", iconName: "icon-calendar", iconSize: 3, "data-toggle": true, disabled: this.disabled || this.readonly, valid: !(this.valid === false && !this.hasInputElFocus) })));
    }
    createTextArea() {
        return (h("div", { class: "wrapper" },
            h("textarea", Object.assign({}, this.getCommonInputFieldProps(), { class: "input textarea" }), this.value)));
    }
    getParsedFlatpickrOptions() {
        let flatpickrOptions = {};
        if (this.flatpickrOptions) {
            if (typeof this.flatpickrOptions === "string") {
                flatpickrOptions = JSON.parse(this.flatpickrOptions);
            }
            else {
                flatpickrOptions = this.flatpickrOptions;
            }
        }
        return flatpickrOptions;
    }
    render() {
        return (h("div", { class: this.getComponentClassNames() },
            (() => this.getLabel())(),
            (() => {
                switch (this.type) {
                    case "textarea":
                        return this.createTextArea();
                    case "date":
                        return this.createDateInputField();
                    case "number":
                        return this.createNumberInputField();
                    default:
                        return this.createInputField();
                }
            })(),
            this.validationMessage &&
                h("sdx-validation-message", { validationMessage: this.validationMessage })));
    }
    static get is() { return "sdx-input"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "autocomplete": {
            "type": String,
            "attr": "autocomplete"
        },
        "blurCallback": {
            "type": String,
            "attr": "blur-callback",
            "watchCallbacks": ["blurCallbackChanged"]
        },
        "changeCallback": {
            "type": String,
            "attr": "change-callback",
            "watchCallbacks": ["changeCallbackChanged"]
        },
        "disabled": {
            "type": Boolean,
            "attr": "disabled"
        },
        "editable": {
            "type": Boolean,
            "attr": "editable"
        },
        "el": {
            "elementRef": true
        },
        "flatpickrOptions": {
            "type": "Any",
            "attr": "flatpickr-options"
        },
        "focusCallback": {
            "type": String,
            "attr": "focus-callback",
            "watchCallbacks": ["focusCallbackChanged"]
        },
        "hasInputElFocus": {
            "state": true
        },
        "hitEnterCallback": {
            "type": String,
            "attr": "hit-enter-callback",
            "watchCallbacks": ["hitEnterCallbackChanged"]
        },
        "inputCallback": {
            "type": String,
            "attr": "input-callback",
            "watchCallbacks": ["inputCallbackChanged"]
        },
        "inputElValue": {
            "state": true
        },
        "inputStyle": {
            "type": "Any",
            "attr": "input-style"
        },
        "label": {
            "type": String,
            "attr": "label"
        },
        "max": {
            "type": Number,
            "attr": "max"
        },
        "maxlength": {
            "type": Number,
            "attr": "maxlength"
        },
        "min": {
            "type": Number,
            "attr": "min"
        },
        "name": {
            "type": String,
            "attr": "name",
            "watchCallbacks": ["nameChanged"]
        },
        "placeholder": {
            "type": String,
            "attr": "placeholder"
        },
        "readonly": {
            "type": Boolean,
            "attr": "readonly"
        },
        "required": {
            "type": Boolean,
            "attr": "required"
        },
        "selectTextOnFocus": {
            "type": Boolean,
            "attr": "select-text-on-focus"
        },
        "srHint": {
            "type": String,
            "attr": "sr-hint"
        },
        "step": {
            "type": Number,
            "attr": "step"
        },
        "type": {
            "type": String,
            "attr": "type"
        },
        "valid": {
            "type": Boolean,
            "attr": "valid"
        },
        "validationMessage": {
            "type": String,
            "attr": "validation-message"
        },
        "value": {
            "type": String,
            "attr": "value",
            "mutable": true,
            "watchCallbacks": ["valueChanged"]
        }
    }; }
    static get listeners() { return [{
            "name": "focus",
            "method": "onFocus",
            "capture": true
        }, {
            "name": "blur",
            "method": "onBlur",
            "capture": true
        }]; }
    static get style() { return "/**style-placeholder:sdx-input:**/"; }
}
Input.flatpickrOptions = {
    wrap: true,
    allowInput: true,
    locale: "de",
    dateFormat: "d.m.Y",
    time_24hr: true,
    onClose: ({}, {}, instance) => instance.set("allowInput", true)
};
