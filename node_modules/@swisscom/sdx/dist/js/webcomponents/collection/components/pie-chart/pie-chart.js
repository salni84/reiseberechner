import anime from "animejs";
import { colors } from "../../core/variables/colors";
export class PieChart {
    constructor() {
        this.viewBox = 34;
        this.radius = 16;
        this.segmentPaddingForSizeSmall = 0;
        this.segmentPaddingForSizeMedium = 3;
        this.hundredPercent = this.radius * 2 * Math.PI;
        this.animationDuration = 300;
        this.data = [];
        this.value = "";
        this.legendPosition = "bottom";
        this.size = "medium";
        this.backgroundTheme = "light";
        this.dataState = [];
    }
    dataChanged() {
        this.parseData();
    }
    componentWillLoad() {
        this.parseData();
    }
    animateSegment(segment, timeline) {
        if (!segment.circle) {
            return;
        }
        timeline.add({
            targets: segment.circle,
            begin: () => {
                segment.circle.style.display = "";
            },
            "stroke-dasharray": `${segment.width} ${this.hundredPercent}`,
            duration: this.animationDuration,
            easing: "easeInQuint"
        });
    }
    animateLegendItem(legendItem, timeline) {
        if (!legendItem) {
            return;
        }
        timeline.add({
            targets: legendItem,
            opacity: 1,
            duration: this.animationDuration,
            easing: "easeInQuint"
        });
    }
    dataToSegments() {
        const segmentPadding = this.size === "medium"
            ? this.segmentPaddingForSizeMedium
            : this.segmentPaddingForSizeSmall;
        const totalValue = this.dataState.reduce((total, d) => total + d.value, 0);
        const segmentsSmallerThanPadding = this.dataState.filter((d) => {
            let width = d.value / totalValue * this.hundredPercent;
            return width < segmentPadding;
        });
        const totalValueOfSegmentsSmallerThanPadding = segmentsSmallerThanPadding.reduce((total, d) => {
            return total + d.value;
        }, 0);
        const segmentPaddingRotationDeg = (360 / this.hundredPercent * segmentPadding);
        let rotation = segmentPaddingRotationDeg;
        return this.dataState
            .filter(({}, i) => this.size === "small" ? i === 0 : true)
            .map((d) => {
            const availableWidth = this.hundredPercent - (segmentPadding * segmentsSmallerThanPadding.length);
            let width = d.value / (totalValue - totalValueOfSegmentsSmallerThanPadding) * availableWidth;
            if (width < segmentPadding) {
                width = 0;
            }
            else {
                width = width - segmentPadding;
            }
            const segment = { d, width, rotation };
            rotation += this.widthToDeg(segment.width) + segmentPaddingRotationDeg;
            return segment;
        });
    }
    widthToDeg(width) {
        return 360 / this.hundredPercent * width;
    }
    getComponentClassNames() {
        return {
            component: true,
            [this.legendPosition]: true,
            [this.size]: true,
            [this.backgroundTheme]: true
        };
    }
    parseData() {
        if (typeof this.data === "string") {
            try {
                this.dataState = JSON.parse(this.data);
            }
            catch (e) {
            }
        }
        else {
            this.dataState = this.data;
        }
    }
    hasLabelsOrSrHints() {
        return this.dataState.some(this.hasLabelOrSrHint);
    }
    hasLabelOrSrHint(d) {
        return !!d.label || !!d.srHint;
    }
    getSegmentColor(d) {
        if (d && d.color) {
            return colors[d.color];
        }
        return colors[this.backgroundTheme];
    }
    render() {
        const center = this.viewBox / 2;
        const segmentsTimeline = anime.timeline();
        const legendItemsTimeline = anime.timeline();
        return (h("div", { class: this.getComponentClassNames() },
            h("div", { class: "wrapper" },
                h("div", { class: "chart-container" },
                    h("div", { class: "chart" },
                        this.size === "small" &&
                            h("svg", { viewBox: `0 0 ${this.viewBox} ${this.viewBox}`, style: { transform: `rotate(${this.widthToDeg(this.hundredPercent)}deg)` } },
                                h("circle", { "stroke-dasharray": `${this.hundredPercent} ${this.hundredPercent}`, stroke: this.getSegmentColor(), cx: center, cy: center, r: this.radius })),
                        this.dataToSegments().map((segment) => {
                            return (h("svg", { key: Math.random(), viewBox: `0 0 ${this.viewBox} ${this.viewBox}`, style: { transform: `rotate(${segment.rotation}deg)` } },
                                h("circle", { ref: (el) => this.animateSegment(Object.assign({}, segment, { circle: el }), segmentsTimeline), style: { display: "none" }, "stroke-dasharray": `0 ${this.hundredPercent}`, stroke: this.getSegmentColor(segment.d), cx: center, cy: center, r: this.radius })));
                        })),
                    h("div", { class: "metadata", "aria-hidden": "true" },
                        h("div", { class: "value" }, this.value),
                        this.size !== "small" &&
                            h("div", { class: "description" }, this.description))),
                this.hasLabelsOrSrHints() &&
                    h("ul", { class: { legend: true, "sr-only": this.size === "small" } }, this.dataState.filter(this.hasLabelOrSrHint).map((d) => {
                        return (h("li", { key: Math.random(), ref: (el) => this.animateLegendItem(el, legendItemsTimeline), style: { opacity: "0" } },
                            h("span", { "aria-hidden": "true" },
                                h("sdx-icon", { "icon-name": "icon-record-filled", style: { color: this.getSegmentColor(d) } }),
                                " ",
                                d.label),
                            d.srHint && h("span", { class: "sr-only" }, d.srHint)));
                    })))));
    }
    static get is() { return "sdx-pie-chart"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "backgroundTheme": {
            "type": String,
            "attr": "background-theme"
        },
        "data": {
            "type": String,
            "attr": "data",
            "watchCallbacks": ["dataChanged"]
        },
        "dataState": {
            "state": true
        },
        "description": {
            "type": String,
            "attr": "description"
        },
        "legendPosition": {
            "type": String,
            "attr": "legend-position"
        },
        "size": {
            "type": String,
            "attr": "size"
        },
        "value": {
            "type": String,
            "attr": "value"
        }
    }; }
    static get style() { return "/**style-placeholder:sdx-pie-chart:**/"; }
}
