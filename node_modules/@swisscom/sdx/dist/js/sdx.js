(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

require("../modernizr");

require("./sdx-global");

},{"../modernizr":34,"./sdx-global":4}],2:[function(require,module,exports){
"use strict";
// Math.sign (used in ProgressFull)

if (!("sign" in Math)) {
    Math.sign = function (x) {
        return x > 0 ? 1 : x < 0 ? -1 : +x;
    };
}

},{}],3:[function(require,module,exports){
"use strict";

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

},{}],4:[function(require,module,exports){
"use strict";

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

require("./polyfills/Math.sign");

require("./polyfills/startsWith");

var _sdx = require("./src/sdx");

var sdxExports = _interopRequireWildcard(_sdx);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var sdx = tslib_1.__assign({}, sdxExports, window.sdx || {}, { VERSION: "1.32.0" });
/* Polyfills */

window.sdx = sdx;
sdxExports.utils.onDocumentReady(function () {
    sdxExports.initInputField();
    sdxExports.initTextarea();
    sdxExports.initSelect();
    sdxExports.initLoaderBar();
    sdxExports.initAutocomplete();
    sdxExports.initProgressLight();
    sdxExports.initProgressFull();
    sdxExports.initRange();
    sdxExports.initModal();
    sdxExports.initAccordion();
    sdxExports.initCollapse();
    sdxExports.initMenuFlyout();
    sdxExports.initNavigation();
    sdxExports.initNavigationSide();
    sdxExports.initSearchInput();
    sdxExports.initEmptyState();
    sdxExports.initCarousel();
    sdxExports.initTable();
    sdxExports.initPieChart();
    sdxExports.initBarChartHorizontal();
    sdxExports.initBarChartVertical();
});

},{"./polyfills/Math.sign":2,"./polyfills/startsWith":3,"./src/sdx":30,"tslib":135}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _DomFunctions = require("./DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var htmlEvents;
/**
 * A wrapper class for DOM Elements.
 */
var DomElement = /** @class */function () {
    /**
     * Creates a new instance.
     * @param {Element} - The element to wrap.
     * @param {String} - The DOM element to create.
     */
    function DomElement(element) {
        if (typeof element === "string") {
            this.element = document.createElement(element);
        } else {
            this.element = element;
        }
    }
    /**
     * Adds the specified CSS class to the element.
     * @param {String} - The class name to add.
     * @return {DomElement} Returns the current instance for fluent chaining of calls.
     */
    DomElement.prototype.addClass = function (name) {
        Dom.addClass(this.element, name);
        return this;
    };
    /**
     * Removes the specified CSS class from the element.
     * @param {String} - The class name to remove.
     * @return {DomElement} Returns the current instance for fluent chaining of calls.
     */
    DomElement.prototype.removeClass = function (name) {
        Dom.removeClass(this.element, name);
        return this;
    };
    DomElement.prototype.hasClass = function (name) {
        return Dom.hasClass(this.element, name);
    };
    DomElement.prototype.toggleClass = function (name) {
        Dom.toggleClass(this.element, name);
        return this;
    };
    Object.defineProperty(DomElement.prototype, "classes", {
        get: function get() {
            return this.element.classList;
        },
        enumerable: true,
        configurable: true
    });
    DomElement.prototype.setId = function (id) {
        this.element.setAttribute("id", id);
        return this;
    };
    Object.defineProperty(DomElement.prototype, "innerText", {
        get: function get() {
            return Dom.text(this.element);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomElement.prototype, "innerHtml", {
        get: function get() {
            return this.element.innerHTML;
        },
        enumerable: true,
        configurable: true
    });
    DomElement.prototype.setHtml = function (value) {
        if (typeof value !== "string") {
            throw new Error("Expected HTML string");
        }
        this.element.innerHTML = value;
        return this;
    };
    DomElement.prototype.getAttribute = function (name) {
        return this.element.getAttribute(name);
    };
    DomElement.prototype.setAttribute = function (name, value) {
        this.element.setAttribute(name, value);
        return this;
    };
    /**
     * Registers an event listener.
     */
    DomElement.prototype.addEventListener = function (type, listener) {
        this.element.addEventListener(type, listener);
    };
    /**
     * Unregisters an event listener on the component.
     */
    DomElement.prototype.removeEventListener = function (type, listener) {
        this.element.removeEventListener(type, listener);
    };
    DomElement.prototype.appendChild = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        this.element.appendChild(newChild.element);
        return this;
    };
    DomElement.prototype.prependChild = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        this.element.insertBefore(newChild.element, this.element.firstChild);
        return this;
    };
    DomElement.prototype.insertBefore = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.insertBefore(newChild.element, this.element);
        return this;
    };
    DomElement.prototype.insertAfter = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.insertBefore(newChild.element, this.element.nextSibling);
        return this;
    };
    DomElement.prototype.removeChild = function (oldChild) {
        if (!(oldChild instanceof DomElement)) {
            throw new Error("Only a DomElements child can be removed");
        }
        this.element.removeChild(oldChild.element);
    };
    DomElement.prototype.find = function (selectors) {
        var e = this.element.querySelector(selectors);
        if (e) {
            return new DomElement(e);
        }
        return undefined;
    };
    DomElement.prototype.wrapWithElement = function (wrapperElement) {
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.replaceChild(wrapperElement.element, this.element);
        wrapperElement.element.appendChild(this.element);
        return this;
    };
    DomElement.prototype.dispatchEvent = function (eventName) {
        var event;
        var el = this.element;
        if (document.createEvent) {
            event = document.createEvent("HTMLEvents");
            event.initEvent(eventName, true, true);
        } else if (document.createEventObject) {
            // IE < 9
            event = document.createEventObject();
            event.eventType = eventName;
        }
        event.eventName = eventName;
        if (el.dispatchEvent) {
            el.dispatchEvent(event);
        } else if (el.fireEvent && htmlEvents["on" + eventName]) {
            // IE < 9
            el.fireEvent("on" + event.eventType, event); // can trigger only real event (e.g. 'click')
        } else if (el[eventName]) {
            el[eventName]();
        } else if (el["on" + eventName]) {
            el["on" + eventName]();
        }
    };
    DomElement.prototype.css = function (property) {
        return Dom.css(this.element, property);
    };
    /**
     * Removes all child nodes of the current DomElement.
     */
    DomElement.prototype.empty = function () {
        Dom.empty(this.element);
    };
    return DomElement;
}();
exports.default = DomElement;

},{"./DomFunctions":6}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.hasClass = hasClass;
exports.toggleClass = toggleClass;
exports.isHidden = isHidden;
exports.text = text;
exports.parentWithClass = parentWithClass;
exports.textWidth = textWidth;
exports.css = css;
exports.getAttributeReference = getAttributeReference;
exports.getRootElement = getRootElement;
exports.empty = empty;
function addClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.add(name);
}
function removeClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.remove(name);
}
function hasClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    return element.classList.contains(name);
}
function toggleClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.toggle(name);
}
/**
 * Determines if the given element is hidden from view.
 * @param {Element} Element The dom element to check.
 * @param {boolean} includeParents If set to `true` searches up the DOM and checks parent visibility as well. Defaults to `false`.
 */
function isHidden(element, includeParents) {
    if (includeParents === void 0) {
        includeParents = false;
    }
    if (includeParents === false) {
        var style = window.getComputedStyle(element);
        return style.display === "none" || element.offsetLeft < 0;
    }
    var result;
    // tslint:disable-next-line:no-conditional-assignment
    while ((result = isHidden(element, false)) === false && element.parentElement) {
        element = element.parentElement;
    }
    return result;
}
/**
 * Gets the text of an element an makes sure this works on all browsers.
 */
function text(element) {
    return element.textContent || element.innerText;
}
function parentWithClass(element, className) {
    var current = element;
    while (!hasClass(current, className) && current.parentElement) {
        current = current.parentElement;
    }
    if (hasClass(current, className)) {
        return current;
    }
    return undefined;
}
function textWidth(text, font) {
    // NOTE: this width measuring algorithm is a lot faster
    // but does unfortunately not work on IE 10...
    // let canvas = document.createElement("canvas")
    // let context = canvas.getContext("2d")
    // context.font = font
    // let metrics = context.measureText(text)
    // return Math.round(metrics.width)
    var div = document.createElement("div");
    div.innerHTML = text;
    div.style.font = font;
    div.style.position = "absolute";
    div.style.visibility = "hidden";
    document.body.appendChild(div);
    var result = div.offsetWidth;
    document.body.removeChild(div);
    return result;
}
function css(element, property) {
    return window.getComputedStyle(element).getPropertyValue(property);
}
/**
 * Gets the single element referenced in an items data-* attribute.
 * @param {DomElement} element - The element containing the reference attribute.
 * @param {string} attribute - The name of the reference attribute.
 * @returns {DomElement} The referenced element; or `undefined` if the reference is invalid
 * or the attribute could not be found.
 */
function getAttributeReference(element, attribute) {
    var attrValue = element.getAttribute(attribute);
    if (!attrValue || attrValue === "") {
        return undefined;
    }
    return document.querySelector(attrValue);
}
/**
 * Gets the document root element (normally the body element)
 * If the document uses a sdx-container wrapper this is returned instead.
 * @returns {Element} The root dom element.
 */
function getRootElement() {
    var element = document.querySelector(".sdx-container");
    if (!element) {
        element = document.body;
    }
    return element;
}
/**
 * Removes all child nodes from the provided element.
 * @param {Element} element The Dom element
 */
function empty(element) {
    while (element.firstChild) {
        element.removeChild(element.firstChild);
    }
}

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/* Keyboard input keycode definitions */
var KEY_TAB = exports.KEY_TAB = 9;
var KEY_ENTER = exports.KEY_ENTER = 13;
var KEY_ESCAPE = exports.KEY_ESCAPE = 27;
// Arrow keys
var KEY_ARROW_UP = exports.KEY_ARROW_UP = 38;
var KEY_ARROW_DOWN = exports.KEY_ARROW_DOWN = 40;
var KEY_ARROW_LEFT = exports.KEY_ARROW_LEFT = 37;
var KEY_ARROW_RIGHT = exports.KEY_ARROW_RIGHT = 39;
// Page keys
var KEY_PAGE_UP = exports.KEY_PAGE_UP = 33;
var KEY_PAGE_DOWN = exports.KEY_PAGE_DOWN = 34;
// Numbers
var KEY_NR_0 = exports.KEY_NR_0 = 48;
var KEY_NR_1 = exports.KEY_NR_1 = 49;
var KEY_NR_9 = exports.KEY_NR_9 = 57;
// helper functions
var containsKey = exports.containsKey = function containsKey(keycode, inputsKeys) {
    var hasKey = false;
    if (inputsKeys && inputsKeys.length > 0) {
        [].forEach.call(inputsKeys, function (inputsKey) {
            if (keycode === inputsKey) {
                hasKey = true;
            }
        });
    }
    return hasKey;
};
var getKeyValue = exports.getKeyValue = function getKeyValue(keycode) {
    if (keycode < 48 || keycode > 105) {
        return "";
    }
    return String.fromCharCode(96 <= keycode && keycode <= 105 ? keycode - 48 : keycode).toLowerCase();
};

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onDocumentReady = onDocumentReady;
exports.searchAndInitialize = searchAndInitialize;
exports.clamp = clamp;
exports.preventDefault = preventDefault;
exports.remove = remove;
exports.find = find;
exports.internetExplorerOrEdgeVersion = internetExplorerOrEdgeVersion;
exports.scrollIntoView = scrollIntoView;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Calls the callback function when the document has been completely parsed.
 * @param {callback} value The callback function to execute.
 */
function onDocumentReady(callback) {
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        callback();
    }
    if (document.readyState === "complete") {
        setTimeout(callback);
    } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed, false);
    }
}
function searchAndInitialize(selector, callback, initSelector) {
    var e_1, _a;
    if (!callback) {
        throw new Error("The callback cannot be undefined");
    }
    var elements = document.querySelectorAll(selector);
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            var initElement = e;
            if (initSelector) {
                initElement = initSelector(e);
            }
            if (initElement.getAttribute("data-init") === "auto") {
                callback(e);
            }
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
}
/**
 * Returns a number whose value is limited to the given range.
 *
 * Example: limit the output of this computation to between 0 and 255
 * Utils.clamp(number, 0, 255)
 *
 * @param {Number} value The number to clamp
 * @param {Number} min The lower boundary of the output range
 * @param {Number} max The upper boundary of the output range
 * @returns A number in the range [min, max]
 * @type Number
 */
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
/**
 * A polyfill for Event.preventDefault().
 * @param {Event} event - The event to prevent the default action.
 */
function preventDefault(event) {
    if (event.preventDefault) {
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
}
/**
 * A polyfill for Node.remove().
 * @param {Node} node - The node to remove.
 */
function remove(node) {
    if (!node || !node.parentNode) {
        return;
    }
    node.parentNode.removeChild(node);
}
/**
 * A simple polyfill for the Array.find() method.
 * @param {Array} array - The array to search in.
 * @param {function} expression - The expression to evaluate. Must return true if the element matches.
 */
function find(array, expression) {
    for (var i = 0; i < array.length; i++) {
        var item = array[i];
        if (expression(item) === true) {
            return item;
        }
    }
    return undefined;
}
/**
 * Checks the useragent and returns the Microsoft Internet Explorer / Edge version.
 * If another browser is detected 0 is returned.
 */
function internetExplorerOrEdgeVersion(userAgent) {
    if (userAgent === void 0) {
        userAgent = navigator.userAgent;
    }
    // handle IE and Edge
    var ieOrEdge = userAgent.search(/MSIE |Edge[/]/);
    if (ieOrEdge > 0) {
        return parseInt(userAgent.substring(ieOrEdge + 5, userAgent.indexOf(".", ieOrEdge)), 10);
    }
    // handle IE11
    if (userAgent.indexOf("Trident/") > 0) {
        var rv = userAgent.indexOf("rv:");
        return parseInt(userAgent.substring(rv + 3, userAgent.indexOf(".", rv)), 10);
    }
    return 0;
}
/**
 * Tries to move a child element to the top by scrolling the parent element, if it is not already fully visible.
 */
function scrollIntoView(child) {
    var parent = child.parentNode;
    var parentRect = parent.getBoundingClientRect();
    var childRect = child.getBoundingClientRect();
    var isFullyVisible = childRect.top >= parentRect.top && childRect.bottom <= parentRect.top + parent.clientHeight;
    if (!isFullyVisible) {
        parent.scrollTop = childRect.top + parent.scrollTop - parentRect.top;
    }
}

},{"tslib":135}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_TOGGLE = ".accordion__toggle";
var QUERY_OPEN_SECTION = ".accordion__item.is-open";
var QUERY_COLLAPSE = ".accordion__collapse";
var CLASS_ITEM = "accordion__item";
var CLASS_OPEN = "is-open";
var CLASS_KEEP_OPEN = "accordion__keep-open";
var REGEX_HIDDEN = /accordion--hidden-.*/;
var ANIMATION_OPEN = 300;
var ANIMATION_DELAY_OPEN = 50;
var ANIMATION_VISIBLE = 150;
/**
 * The Accordion component
 */
var Accordion = /** @class */function (_super) {
    tslib_1.__extends(Accordion, _super);
    /**
     * Creates and initializes the Accordion component.
     * @param {DomElement} - The root element of the Accordion component.
     */
    function Accordion(element) {
        var _this = _super.call(this, element) || this;
        _this._sectionClickHandler = _this._handleSectionClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Accordion component.
     * @private
     */
    Accordion.prototype._initialize = function () {
        var e_1, _a;
        if (this.element.className.split(" ").some(function (c) {
            return REGEX_HIDDEN.test(c);
        })) {
            var indicator = new _DomElement2.default("input").setAttribute("type", "hidden").addClass("js-hidden");
            this.appendChild(indicator);
            this._hiddenIndicator = indicator.element;
        }
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_TOGGLE)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var toggle = _c.value;
                toggle.addEventListener("click", this._sectionClickHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Accordion.prototype._handleSectionClick = function (event) {
        if (this._hiddenIndicator) {
            var style = window.getComputedStyle(this._hiddenIndicator);
            if (style.visibility !== "visible") {
                return;
            }
        }
        var navSection = event.target.parentElement;
        while (!Dom.hasClass(navSection, CLASS_ITEM) && navSection.parentElement) {
            navSection = navSection.parentElement;
        }
        var prevSection = this.element.querySelector(QUERY_OPEN_SECTION);
        if (prevSection && prevSection !== navSection) {
            if (!Dom.hasClass(this.element, CLASS_KEEP_OPEN)) {
                this._toggleSection(prevSection);
            }
        }
        this._toggleSection(navSection);
    };
    Accordion.prototype._toggleSection = function (accSection) {
        var collapseElement = accSection.querySelector(QUERY_COLLAPSE);
        if (Dom.hasClass(accSection, CLASS_OPEN)) {
            Dom.removeClass(accSection, CLASS_OPEN);
            this._closeCollapseSection(collapseElement);
        } else {
            Dom.addClass(accSection, CLASS_OPEN);
            if (collapseElement) {
                // to ignore the case when there is no collapsible element (see sdx doku navigation, "all the basics") in a list of accordion
                this._openCollapseSection(collapseElement);
            }
        }
    };
    Accordion.prototype._openCollapseSection = function (el) {
        this._stopAnimations(el);
        el.style.display = "block";
        this.animation = _animejs2.default.timeline().add({
            targets: el,
            duration: ANIMATION_OPEN,
            height: el.scrollHeight + "px",
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                el.style.height = "auto";
                el.setAttribute("aria-expanded", "true");
                el.classList.add(CLASS_OPEN);
            }
        }).add({
            targets: el,
            duration: ANIMATION_VISIBLE,
            opacity: 1,
            easing: "linear",
            offset: ANIMATION_DELAY_OPEN
        });
    };
    Accordion.prototype._closeCollapseSection = function (el) {
        this._stopAnimations(el);
        this.animation = _animejs2.default.timeline().add({
            targets: el,
            duration: ANIMATION_OPEN,
            height: "0px",
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                el.style.removeProperty("display");
                el.style.removeProperty("opacity");
                el.style.removeProperty("height");
                el.setAttribute("aria-expanded", "false");
                el.classList.remove(CLASS_OPEN);
            }
        });
    };
    Accordion.prototype._stopAnimations = function (el) {
        if (this.lastAnimatedElement === el) {
            if (this.animation) {
                this.animation.pause();
            }
            _animejs2.default.remove(el);
        }
        this.lastAnimatedElement = el;
    };
    /**
     * Removes all event handlers and clears references.
     */
    Accordion.prototype.destroy = function () {
        var e_2, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_TOGGLE)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var toggle = _c.value;
                toggle.removeEventListener("click", this._sectionClickHandler);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._sectionClickHandler = null;
        this.element = null;
    };
    return Accordion;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".accordion", function (e) {
        new Accordion(e);
    });
}
exports.default = Accordion;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":35,"tslib":135}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _trunc = require("babel-runtime/core-js/math/trunc");

var _trunc2 = _interopRequireDefault(_trunc);

var _from = require("babel-runtime/core-js/array/from");

var _from2 = _interopRequireDefault(_from);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_SLIDER = ".carousel__container";
var QUERY_SLIDE_AREA = ".carousel__slider";
var QUERY_WRAPPER = ".carousel__slider-wrapper";
var QUERY_PAGINATION = ".carousel__pagination";
var CLASS_ACTIVE = "slide--active";
var CLASS_PREV = "slide--prev";
var CLASS_NEXT = "slide--next";
var CLASS_BULLET = "pagination-bullet";
var CLASS_BULLET_ACTIVE = "pagination-bullet--active";
var QUERY_BTN_PREV = ".carousel__button-prev";
var QUERY_BTN_NEXT = ".carousel__button-next";
var QUERY_BTN_WRAPPER = ".carousel__button-wrapper";
var ATTRIBUTE_INDEX = "js-index";
var ANIMATION_DURATION = 350;
var ANIMATION_EASING = "ease-in-out";
var TOUCH_DURATION = 300;
var TOUCH_DELTA_MIN = 25;
/**
 * The carousel component definition.
 */
var Carousel = /** @class */function (_super) {
    tslib_1.__extends(Carousel, _super);
    /**
     * Creates and initializes the carousel component.
     * @param {DomElement} element - The root element of the Carousel component.
     * @param {Number} index - The initial index.
     */
    function Carousel(element, index) {
        if (index === void 0) {
            index = 0;
        }
        var _this = _super.call(this, element) || this;
        _this._slider = _this.element.querySelector(QUERY_SLIDER);
        _this._wrapper = _this._slider.querySelector(QUERY_WRAPPER);
        _this._pagination = _this._slider.querySelector(QUERY_PAGINATION);
        _this._slideArea = _this._slider.querySelector(QUERY_SLIDE_AREA);
        _this._btnWrapper = _this.element.querySelector(QUERY_BTN_WRAPPER);
        _this._prevCtrl = _this.element.querySelector(QUERY_BTN_PREV);
        _this._nextCtrl = _this.element.querySelector(QUERY_BTN_NEXT);
        _this._slides = [];
        _this._index = index || 0;
        _this._slidesPerGroup = 1;
        _this._sliderWrapper = new SliderWrapper(_this._wrapper, _this._slideArea, _this.element);
        _this._sliderWrapper.index = _this._index;
        _this._additionalSlideMargin = 0;
        _this._resizeHandler = _this._onresize.bind(_this);
        _this._prevHandler = _this.prev.bind(_this);
        _this._nextHandler = _this.next.bind(_this);
        _this._paginationClickHandler = _this._handlePaginationClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._handleTouchstart = _this._onTouchstart.bind(_this);
        _this._handleTouchmove = _this._onTouchmove.bind(_this);
        _this._handleTouchend = _this._onTouchend.bind(_this);
        _this._initialize();
        _this.slide(_this._index, 0, false);
        _this._updateCtrlOffsets();
        return _this;
    }
    /**
     * Initializes the carousel component.
     * @private
     */
    Carousel.prototype._initialize = function () {
        // responsive helpers
        this._breakpointPhone = new _DomElement2.default("div").addClass("js-phone").element;
        this._breakpointTablet = new _DomElement2.default("div").addClass("js-tablet").element;
        this._breakpointDesktop = new _DomElement2.default("div").addClass("js-desktop").element;
        this.element.appendChild(this._breakpointPhone);
        this.element.appendChild(this._breakpointTablet);
        this.element.appendChild(this._breakpointDesktop);
        if (this._prevCtrl && this._nextCtrl) {
            this._prevCtrl.addEventListener("click", this._prevHandler);
            this._nextCtrl.addEventListener("click", this._nextHandler);
        }
        if (this._pagination) {
            this._pagination.addEventListener("click", this._paginationClickHandler);
        }
        this._slides = (0, _from2.default)(this._wrapper.children);
        if (this._slides.length === 0) {
            throw Error("Provide at least one slide to the slider");
        }
        for (var i = 0; i < this._slides.length; i++) {
            var slide = this._slides[i];
            slide.setAttribute(ATTRIBUTE_INDEX, String(i));
        }
        this._updateResponsiveOptions();
        this._sliderWrapper.initialize();
        this.reset();
        this.element.addEventListener("keydown", this._keydownHandler);
        this._slideArea.addEventListener("mousedown", this._handleTouchstart);
        this._slideArea.addEventListener("touchstart", this._handleTouchstart);
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
    };
    Carousel.prototype._isBreakpointActive = function (breakpoint) {
        var style = window.getComputedStyle(breakpoint);
        return style.visibility === "visible";
    };
    Carousel.prototype._onresize = function () {
        this.reset();
        this._updateCtrlOffsets();
    };
    /**
     * Makes sure the index is always in the range of available slide
     * In case it's to high or to low it is wrapped around
     * @param {Number} index - The index to adjust and sanitize
     * @returns {Number} index - The adjusted index
     * @private
     */
    Carousel.prototype._adjustIndex = function (index) {
        if (typeof index !== "number") {
            index = 0;
        }
        if (index < 0) {
            index = this._wrapround(index, 0, this._slides.length);
        } else if (index >= this._slides.length) {
            index %= this._slides.length;
        }
        return Math.floor(index / this._slidesPerGroup) * this._slidesPerGroup;
    };
    Carousel.prototype._wrapround = function (n, min, max) {
        if (n >= max) {
            return min;
        }
        if (n < min) {
            return max - 1;
        }
        return n;
    };
    Carousel.prototype._wraproundCount = function (a, b, min, max, direction) {
        if (direction === 0) {
            return 0;
        }
        if (a < min || a >= max) {
            throw new Error("Argument 'a' is out of range, Value: " + a + " Min: " + min + ", Max: " + max);
        }
        if (b < min || b >= max) {
            throw new Error("Argument 'b' is out of range, Value: " + b + " Min: " + min + ", Max: " + max);
        }
        var i = 0;
        while (a !== b) {
            i++;
            a = this._wrapround(a + direction, min, max);
        }
        return i;
    };
    Carousel.prototype._updateCtrlOffsets = function () {
        if (!this._nextCtrl || !this._prevCtrl || !this._btnWrapper) {
            return;
        }
        var prevCtrlMargin = 0;
        var nextCtrlMargin = 0;
        if (this._slidesPerGroup > 1) {
            var wrapperRect = this._btnWrapper.getBoundingClientRect();
            var prevSlideCount = Math.floor(0.5 * this._slidesPerGroup);
            var rightIndex = this._sliderWrapper.index + prevSlideCount + 1;
            var leftIndex = this._sliderWrapper.index - 1;
            if (this._slidesPerGroup % 2 !== 0) {
                leftIndex -= prevSlideCount;
            }
            if (leftIndex >= 0 && leftIndex < this._wrapper.children.length && rightIndex >= 0 && rightIndex < this._wrapper.children.length) {
                var leftSlide = this._sliderWrapper.getSlideProperties(leftIndex);
                var rightSlide = this._sliderWrapper.getSlideProperties(rightIndex);
                var btnWidth = this._prevCtrl.offsetWidth;
                if (btnWidth <= 0) {
                    btnWidth = 60;
                }
                prevCtrlMargin = leftSlide.right - wrapperRect.left - btnWidth;
                nextCtrlMargin = wrapperRect.right - rightSlide.left - btnWidth;
            }
        }
        var left = prevCtrlMargin !== 0 ? prevCtrlMargin + "px" : "";
        this._prevCtrl.style.left = left;
        var right = nextCtrlMargin !== 0 ? nextCtrlMargin + "px" : "";
        this._nextCtrl.style.right = right;
    };
    Carousel.prototype._updateActiveSlides = function (nextIndex) {
        var prevSlideCount = Math.floor(0.5 * (this._slidesPerGroup - 1));
        var evenGroup = this._slidesPerGroup % 2 === 0;
        for (var i = 0; i < this._wrapper.children.length; i++) {
            var slide = this._wrapper.children[i];
            if (i === nextIndex || evenGroup && i === nextIndex + 1) {
                Dom.addClass(slide, CLASS_ACTIVE);
            } else {
                Dom.removeClass(slide, CLASS_ACTIVE);
            }
            if (i < nextIndex && i >= nextIndex - prevSlideCount) {
                Dom.addClass(slide, CLASS_PREV);
            } else {
                Dom.removeClass(slide, CLASS_PREV);
            }
            if (i > nextIndex && (i <= nextIndex + prevSlideCount || evenGroup && i <= nextIndex + 1 + prevSlideCount)) {
                Dom.addClass(slide, CLASS_NEXT);
            } else {
                Dom.removeClass(slide, CLASS_NEXT);
            }
        }
    };
    /**
     * Updates and creates the pagination bullets.
     * @private
     */
    Carousel.prototype._updatePagination = function () {
        if (!this._pagination) {
            return;
        }
        var to = this._index;
        var bullets = this._pagination.children;
        var totalItems = Math.max(this._slides.length, bullets.length);
        var slideCount = Math.ceil(this._slides.length / this._slidesPerGroup);
        var activeSlideIndex = Math.floor(to / this._slidesPerGroup);
        for (var i = 0; i < totalItems; i++) {
            var bullet = void 0;
            if (bullets.length > i) {
                if (bullets.length <= slideCount) {
                    bullet = bullets[i];
                } else {
                    (0, _Utils.remove)(bullets[i]);
                }
            } else if (i < slideCount) {
                bullet = new _DomElement2.default("div").addClass(CLASS_BULLET).element;
                this._pagination.appendChild(bullet);
            }
            if (bullet && i < slideCount) {
                if (i === activeSlideIndex) {
                    Dom.addClass(bullet, CLASS_BULLET_ACTIVE);
                } else {
                    Dom.removeClass(bullet, CLASS_BULLET_ACTIVE);
                }
            }
        }
    };
    Carousel.prototype._handlePaginationClick = function (e) {
        if (!Dom.hasClass(e.target, CLASS_BULLET)) {
            return;
        }
        var index = (0, _from2.default)(this._pagination.children).indexOf(e.target);
        var slideNumber = index * this._slidesPerGroup;
        this.slideTo(slideNumber);
    };
    Carousel.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        switch (keycode) {
            case Inputs.KEY_ARROW_LEFT:
                this.prev();
                break;
            case Inputs.KEY_ARROW_RIGHT:
                this.next();
                break;
            case Inputs.KEY_ESCAPE:
                this.element.blur();
                break;
            default:
        }
    };
    Carousel.prototype._onTouchstart = function (event) {
        var touch = event.touches ? event.touches[0] : event;
        this._slideArea.removeEventListener("mousedown", this._handleTouchstart);
        this._slideArea.removeEventListener("touchstart", this._handleTouchstart);
        this._sliderWrapper.beginDrag();
        var pageX = touch.pageX;
        this._touchOffset = {
            x: pageX,
            time: Date.now()
        };
        this._delta = {
            x: 0,
            lastMove: pageX
        };
        document.addEventListener("mousemove", this._handleTouchmove);
        document.addEventListener("touchmove", this._handleTouchmove);
        document.addEventListener("mouseup", this._handleTouchend);
        document.addEventListener("mouseleave", this._handleTouchend);
        document.addEventListener("touchend", this._handleTouchend);
    };
    Carousel.prototype._onTouchmove = function (event) {
        var touch = event.touches ? event.touches[0] : event;
        var pageX = touch.pageX;
        var deltaMove = pageX - this._delta.lastMove;
        this._delta = {
            x: pageX - this._touchOffset.x,
            lastMove: pageX
        };
        if (this._touchOffset) {
            (0, _Utils.preventDefault)(event);
            this._sliderWrapper.move(deltaMove);
            this._cloneSlidesToFitWrapper(false, deltaMove);
        }
    };
    Carousel.prototype._onTouchend = function () {
        var duration = this._touchOffset ? Date.now() - this._touchOffset.time : undefined;
        var isValid = Number(duration) < TOUCH_DURATION && Math.abs(this._delta.x) > TOUCH_DELTA_MIN || Math.abs(this._delta.x) > this._frameWidth / 3;
        if (isValid) {
            var direction = (0, _Utils.clamp)(this._delta.x, -1, 1) * -1;
            this.slide(false, direction, true);
            this._sliderWrapper.endDrag();
        } else {
            // Slide back to the starting point of the drag operation
            this._sliderWrapper.cancelDrag();
        }
        this._touchOffset = undefined;
        this._slideArea.addEventListener("mousedown", this._handleTouchstart);
        this._slideArea.addEventListener("touchstart", this._handleTouchstart);
        document.removeEventListener("mousemove", this._handleTouchmove);
        document.removeEventListener("mouseup", this._handleTouchend);
        document.removeEventListener("mouseleave", this._handleTouchend);
        document.removeEventListener("touchmove", this._handleTouchmove);
        document.removeEventListener("touchend", this._handleTouchend);
    };
    /**
     * Updated parameters in regard to the currently active responsive
     * breakpoint.
     * @private
     */
    Carousel.prototype._updateResponsiveOptions = function () {
        if (this._isBreakpointActive(this._breakpointPhone)) {
            this._slidesPerGroup = 1;
        }
        if (this._isBreakpointActive(this._breakpointTablet)) {
            this._slidesPerGroup = 2;
        }
        if (this._isBreakpointActive(this._breakpointDesktop)) {
            this._slidesPerGroup = 3;
        }
        this._sliderWrapper.slidesPerGroup = this._slidesPerGroup;
    };
    /**
     * Clones the requested slide and adds it to the slider.
     * @param {Number} index - The original slide index of the template slide
     * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
     * @private
     */
    Carousel.prototype._cloneSlide = function (index, direction) {
        var clone = this._slides[index].cloneNode(true);
        Dom.removeClass(clone, CLASS_ACTIVE);
        Dom.removeClass(clone, CLASS_PREV);
        Dom.removeClass(clone, CLASS_NEXT);
        this._sliderWrapper.addSlide(clone, direction);
        var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
        clone.style.marginLeft = slideMargin;
        clone.style.marginRight = slideMargin;
        return clone.offsetWidth;
    };
    /**
     * Clones and adds the requested ammount of slides.
     * @param {Number} slideCount - The number of slides to add
     * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
     * @private
     */
    Carousel.prototype._cloneSlidesByCount = function (slideCount, direction) {
        var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
        var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);
        while (slideCount > 0) {
            index = this._wrapround(index + direction, 0, this._slides.length);
            this._cloneSlide(index, direction);
            slideCount--;
        }
    };
    /**
     * Calculates the scroll clount and inserts the required ammount of slides
     * in the apropriate direction.
     * @param {Number} nextIndex - The slide to scroll to
     * @param {Number} direction - The direction of the scroll
     * @private
     */
    Carousel.prototype._cloneSlidesByScrollCount = function (nextIndex, direction) {
        var scrollCount = this._wraproundCount(this._index, nextIndex, 0, this._slides.length, direction);
        var outerSlideProps = this._sliderWrapper.getSlideProperties(direction > 0 ? this._wrapper.children.length - 1 : 0);
        var indexToOuterSlideCount = this._wraproundCount(this._index, outerSlideProps.index, 0, this._slides.length, direction);
        var slidesToInsert = scrollCount - indexToOuterSlideCount;
        if (slidesToInsert > 0) {
            this._cloneSlidesByCount(slidesToInsert, direction);
        }
    };
    Carousel.prototype._cloneSlidesByToFill = function (spaceToFill, direction) {
        var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
        var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);
        while (spaceToFill > 0) {
            index = this._wrapround(index + direction, 0, this._slides.length);
            spaceToFill -= this._cloneSlide(index, direction);
        }
    };
    Carousel.prototype._cloneSlidesToFitWrapper = function (cleanup, slideDelta) {
        if (cleanup === void 0) {
            cleanup = true;
        }
        if (slideDelta === void 0) {
            slideDelta = 0;
        }
        var realIndex = this._sliderWrapper.index;
        var first;
        var last;
        if (cleanup === false) {
            first = this._sliderWrapper.getSlideProperties(0);
            last = this._sliderWrapper.getSlideProperties(this._wrapper.children.length - 1);
        } else {
            var result = this._sliderWrapper.getRemovableSlides(slideDelta);
            first = result.first;
            last = result.last;
            // Remove the slides from view
            for (var i = result.slides.length - 1; i >= 0; i--) {
                if (result.slides[i] === true) {
                    this._sliderWrapper.removeSlide(i);
                }
            }
        }
        var spaceToFill = this._sliderWrapper.getEmptySpace(first.left, last.right);
        // Check if additional slides are required on the left
        if (first.visible === true && spaceToFill.left > 0) {
            this._cloneSlidesByToFill(spaceToFill.left, -1);
        }
        // Check if additional slides are required on the right
        if (last.visible === true && spaceToFill.right > 0) {
            this._cloneSlidesByToFill(spaceToFill.right, 1);
        }
        return realIndex - this._sliderWrapper.index;
    };
    /**
     * Gets the real (wrapper) index for the slide with the given original index
     * @param {Number} index - The index to search for
     * @param {Number} direction - The direction in which to search
     * @returns {Number} The wrapper index
     * @private
     */
    Carousel.prototype._getRealIndexFor = function (index, direction) {
        var i = this._sliderWrapper.index;
        while (i >= 0 && i < this._wrapper.children.length) {
            var slideIndex = parseInt(this._wrapper.children[i].getAttribute(ATTRIBUTE_INDEX), 10);
            if (slideIndex === index) {
                return i;
            }
            i += direction;
        }
        throw new Error("Cloud not find real index for slide " + index + " in direction " + direction);
    };
    Object.defineProperty(Carousel.prototype, "index", {
        /**
         * Gets the index of the current active slide. If the slides are grouped evenly
         * the active slide is always the first in the group.
         * @returns {Number} The index of the active slide.
         */
        get: function get() {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    Carousel.prototype.reset = function () {
        this._frameWidth = this._slider.getBoundingClientRect().width || this._slider.offsetWidth;
        this._updateResponsiveOptions();
        if (this._nextCtrl) {
            this._nextCtrl.disabled = false;
        }
        if (this._prevCtrl) {
            this._prevCtrl.disabled = false;
        }
        if (this._slidesPerGroup === 1) {
            var style = window.getComputedStyle(this._slider.parentElement);
            var parentWidth = this._slider.parentElement.clientWidth + (parseFloat(style.marginLeft) || 0) + (parseFloat(style.marginRight) || 0);
            var outerMargin = Math.ceil(parentWidth - this._frameWidth);
            this._additionalSlideMargin = Math.ceil(outerMargin * 0.5) + 1;
        } else {
            this._additionalSlideMargin = 0;
        }
        var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
        for (var i = 0; i < this._wrapper.children.length; i++) {
            var slide = this._wrapper.children[i];
            slide.style.marginLeft = slideMargin;
            slide.style.marginRight = slideMargin;
        }
        this._sliderWrapper.onresize();
        this._cloneSlidesToFitWrapper(false);
        this._sliderWrapper.moveTo(this._sliderWrapper.index);
        this._updatePagination();
        this._updateActiveSlides(this._sliderWrapper.index);
    };
    /**
     * Moves the slider to the next item.
     */
    Carousel.prototype.prev = function () {
        this.slide(false, -1);
    };
    /**
     * Moves the slider to the previous item.
     */
    Carousel.prototype.next = function () {
        this.slide(false, 1);
    };
    Carousel.prototype.slide = function (nextIndex, direction, animate) {
        if (animate === void 0) {
            animate = true;
        }
        if (typeof nextIndex !== "number") {
            if (direction > 0) {
                nextIndex = this._index + this._slidesPerGroup;
                direction = 1;
            } else {
                nextIndex = this._index - this._slidesPerGroup;
                direction = -1;
            }
        }
        nextIndex = this._adjustIndex(nextIndex);
        if (!direction) {
            direction = (0, _Utils.clamp)(nextIndex - this._index, -1, 1);
        }
        // Make sure there are enought slides on screen
        this._cloneSlidesToFitWrapper(false);
        // Make sure there are enough slides for the scroll operation
        this._cloneSlidesByScrollCount(nextIndex, direction);
        var realIndex = this._getRealIndexFor(nextIndex, direction);
        var slideDelta = this._sliderWrapper.getSlideDelta(realIndex);
        realIndex = Math.max(realIndex - this._cloneSlidesToFitWrapper(true, slideDelta), 0);
        this._sliderWrapper.moveTo(realIndex, undefined, animate);
        // Update the active index
        this._index = nextIndex;
        // Mark slides as active
        this._updatePagination();
        this._updateActiveSlides(realIndex);
        // console.log(`Performed slide to ${this._index}, realIndex: ${this._sliderWrapper.index}`)
    };
    /**
     * Moves the slider to the selected slide.
     * @param {Number} index - The index of the slide to slide to.
     * @param {Boolean} animate - `True` if the slide should be animated; otherwise `false`. Defaults to `true`.
     */
    Carousel.prototype.slideTo = function (index, animate) {
        if (animate === void 0) {
            animate = true;
        }
        this.slide(index, undefined, animate);
    };
    /**
     * Destroys the components and frees all references.
     */
    Carousel.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this.element.removeEventListener("keydown", this._keydownHandler);
        this._slideArea.removeEventListener("mousedown", this._handleTouchstart);
        this._slideArea.removeEventListener("touchstart", this._handleTouchstart);
        this._breakpointPhone.remove();
        this._breakpointTablet.remove();
        this._breakpointDesktop.remove();
        if (this._prevCtrl && this._nextCtrl) {
            this._prevCtrl.removeEventListener("click", this._prevHandler);
            this._nextCtrl.removeEventListener("click", this._nextHandler);
        }
        this._prevCtrl = undefined;
        this._nextCtrl = undefined;
        if (this._pagination) {
            this._pagination.removeEventListener("click", this._paginationClickHandler);
            this._pagination = undefined;
        }
        this._sliderWrapper.destroy();
        this._sliderWrapper = undefined;
    };
    return Carousel;
}(_DomElement2.default);
var TRANSFORM = "transform";
var DURATION = "transitionDuration";
var TIMING = "transitionTimingFunction";
var SliderWrapper = /** @class */function () {
    function SliderWrapper(wrapperElement, slideAreaElement, carouselElement) {
        this._wrapperElement = wrapperElement;
        this._slideAreaElement = slideAreaElement;
        this._carouselElement = carouselElement;
        this._position = 0;
        this._index = 0;
        this._isdragging = false;
    }
    SliderWrapper.prototype._getSlide = function (index) {
        if (index < 0 || index >= this._wrapperElement.children.length) {
            throw new Error("Argument 'index' is out of range, Value: " + index + " Min: 0, Max: " + (this._wrapperElement.children.length - 1));
        }
        return this._wrapperElement.children[index];
    };
    SliderWrapper.prototype._setTransform = function (targetPosition, animated, duration, ease) {
        if (animated === void 0) {
            animated = false;
        }
        if (duration === void 0) {
            duration = ANIMATION_DURATION;
        }
        if (ease === void 0) {
            ease = ANIMATION_EASING;
        }
        if (animated === false) {
            duration = 0;
        }
        var style = this._wrapperElement.style;
        if (style) {
            style[DURATION] = duration + "ms";
            style[TIMING] = ease;
            // No sub pixel transitions.
            targetPosition = Math.floor(targetPosition);
            style[TRANSFORM] = "translate(" + targetPosition + "px, 0)";
            this._position = targetPosition;
        }
    };
    SliderWrapper.prototype._getWrapperSlidePosition = function (index) {
        var wrapperCenter = 0.5 * this._wrapperElement.offsetWidth;
        var slide = this._getSlide(index);
        var result = 0;
        // Calculate the position of the slide (centered)
        if (this._slidesPerGroup % 2 === 0) {
            var slideStyle = window.getComputedStyle(slide);
            var slideMargin = slideStyle ? parseInt(slideStyle.marginRight, 10) : 0;
            // Centered to the space between the two center slides of the group
            result = -slide.offsetLeft - slide.clientWidth + wrapperCenter - slideMargin;
        } else {
            result = -slide.offsetLeft - 0.5 * slide.clientWidth + wrapperCenter;
        }
        return result;
    };
    Object.defineProperty(SliderWrapper.prototype, "position", {
        get: function get() {
            return this._position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderWrapper.prototype, "index", {
        get: function get() {
            return this._index;
        },
        set: function set(index) {
            this._index = index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderWrapper.prototype, "slidesPerGroup", {
        set: function set(value) {
            this._slidesPerGroup = value;
        },
        enumerable: true,
        configurable: true
    });
    SliderWrapper.prototype.initialize = function () {
        this.onresize();
    };
    SliderWrapper.prototype.onresize = function () {
        // update the area offset for slide position calculation
        this._areaOffset = this._slideAreaElement.getBoundingClientRect().left;
        // Get the container dimensions
        var containerRect = this._carouselElement.getBoundingClientRect();
        this._containerMin = containerRect.left;
        this._containerMax = containerRect.right;
    };
    SliderWrapper.prototype.beginDrag = function () {
        this._isdragging = true;
        this._dragStartPosition = this._position;
    };
    SliderWrapper.prototype.cancelDrag = function () {
        this._isdragging = false;
        this._setTransform(this._dragStartPosition, true, ANIMATION_DURATION, ANIMATION_EASING);
        this._dragStartPosition = undefined;
    };
    SliderWrapper.prototype.endDrag = function () {
        this._isdragging = false;
        this._dragStartPosition = undefined;
    };
    SliderWrapper.prototype.move = function (delta, animated, duration, ease) {
        if (animated === void 0) {
            animated = false;
        }
        if (duration === void 0) {
            duration = ANIMATION_DURATION;
        }
        if (ease === void 0) {
            ease = ANIMATION_EASING;
        }
        delta = (0, _trunc2.default)(delta);
        if (Math.abs(delta) <= 0) {
            return;
        }
        var targetPosition = this._position += delta;
        this._setTransform(targetPosition, animated, duration, ease);
    };
    SliderWrapper.prototype.moveTo = function (index, delta, animated) {
        if (animated === void 0) {
            animated = false;
        }
        var newPosition = 0;
        if (!delta) {
            newPosition = this._getWrapperSlidePosition(index);
        } else {
            newPosition = this._position += delta;
        }
        this._index = index;
        this._setTransform(newPosition, animated);
    };
    SliderWrapper.prototype.addSlide = function (slide, position) {
        if (!slide) {
            throw new Error("Cannot add an undefined slide");
        }
        if (position !== -1 && position !== 1) {
            throw new Error("Argument out of range, 'position' must be either 1 or -1. Value " + position);
        }
        if (position > 0) {
            this._wrapperElement.appendChild(slide);
        } else {
            this._wrapperElement.insertBefore(slide, this._wrapperElement.children[0]);
            this._index++;
        }
        if (position < 0) {
            var width = slide.offsetWidth;
            var style = window.getComputedStyle(slide);
            var marginLeft = style ? parseInt(style.marginLeft, 10) : 0;
            var marginRight = style ? parseInt(style.marginRight, 10) : 0;
            this.move(-(width + marginLeft + marginRight));
        }
    };
    SliderWrapper.prototype.removeSlide = function (index) {
        var slide = this._getSlide(index);
        var width = slide.offsetWidth;
        if (index <= this._index) {
            width *= -1;
            this._index--;
        }
        (0, _Utils.remove)(slide);
        if (width < 0) {
            this.move(-width);
        }
    };
    SliderWrapper.prototype.getSlideDelta = function (index) {
        var currentPosition = this._position;
        if (this._isdragging === true) {
            currentPosition = this._dragStartPosition - this._position;
        }
        var newPosition = this._getWrapperSlidePosition(index);
        return newPosition - currentPosition;
    };
    SliderWrapper.prototype.getSlideProperties = function (index, delta) {
        if (delta === void 0) {
            delta = 0;
        }
        var currentOffset = this._areaOffset + this._position + delta;
        var currentLeft = currentOffset;
        var currentRight = currentOffset;
        var _a = tslib_1.__read([0, 0], 2),
            currentMarginLeft = _a[0],
            currentMarginRight = _a[1];
        var slide = this._getSlide(index);
        var slideIndex = parseInt(slide.getAttribute(ATTRIBUTE_INDEX), 10);
        for (var i = 0; i <= index; i++) {
            slide = this._getSlide(i);
            var slideStyle = window.getComputedStyle(slide);
            currentMarginLeft = parseInt(slideStyle.marginLeft, 10);
            currentMarginRight = parseInt(slideStyle.marginRight, 10);
            currentOffset += currentMarginLeft;
            currentLeft = currentOffset;
            currentRight = currentLeft + slide.offsetWidth;
            if (i < index) {
                currentOffset = currentRight + currentMarginRight;
            }
        }
        var visible = false;
        if (currentLeft > this._containerMin && currentLeft < this._containerMax || currentRight > this._containerMin && currentRight < this._containerMax) {
            visible = true;
        }
        return {
            visible: visible,
            index: slideIndex,
            left: currentLeft,
            right: currentRight,
            width: currentRight - currentLeft,
            marginLeft: currentMarginLeft,
            marginRight: currentMarginRight
        };
    };
    SliderWrapper.prototype.getRemovableSlides = function (delta) {
        var slides = [];
        var first;
        var last;
        var index = this._wrapperElement.children.length;
        while (index > 0) {
            index--;
            var propsNow = this.getSlideProperties(index);
            var propsNew = this.getSlideProperties(index, delta);
            if (index === this._wrapperElement.children.length - 1) {
                last = propsNew;
            }
            if (index === 0) {
                first = propsNew;
            }
            if (propsNow.visible === false && propsNew.visible === false && index !== this._index && this._isdragging === false) {
                slides.push(true);
            } else {
                slides.push(false);
            }
        }
        slides.reverse();
        var firstToKeep = slides.indexOf(false);
        var lastToKeep = slides.lastIndexOf(false);
        for (var i = firstToKeep; i < lastToKeep; i++) {
            slides[i] = false;
        }
        return {
            slides: slides,
            first: first,
            last: last
        };
    };
    SliderWrapper.prototype.getEmptySpace = function (left, right) {
        return {
            left: Math.max(Math.ceil(left - this._containerMin), 0),
            right: Math.max(Math.ceil(this._containerMax - right), 0)
        };
    };
    SliderWrapper.prototype.destroy = function () {
        this._wrapperElement = null;
        this._slideAreaElement = null;
        this._carouselElement = null;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    SliderWrapper.prototype.destory = function () {
        this.destroy();
    };
    return SliderWrapper;
}();
function init() {
    (0, _Utils.searchAndInitialize)(".carousel", function (e) {
        new Carousel(e);
    });
}
exports.default = Carousel;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"babel-runtime/core-js/array/from":36,"babel-runtime/core-js/math/trunc":38,"tslib":135}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DETAIL_RIGHT = ".detail-right";
var QUERY_DETAIL_BOTTOM = ".detail-bottom";
var QUERY_PROGRESS = ".bar-chart__progress";
var CLASS_UNLIMITED = "bar-chart-horizontal--unlimited";
var CLASS_LIMITED = "bar-chart-horizontal--limited";
var CLASS_DETAIL_VALUE = "value";
var CLASS_DETAIL_UNIT = "unit";
var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";
var ANIMATION_DURATION = 500;
/**
 * Bar Chart Horizontal Component.
 */
var BarChartHorizontal = /** @class */function (_super) {
    tslib_1.__extends(BarChartHorizontal, _super);
    /**
     * Creates and initializes the bar chart horizontal component.
     * @param {DomElement} - root element of the chart.
     */
    function BarChartHorizontal(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._legendItems = [];
        _this._initialize();
        return _this;
    }
    BarChartHorizontal.prototype._initialize = function () {
        this._unit = this.getAttribute("data-unit") || "";
        this._maxValue = parseFloat(this.getAttribute("data-max"));
        this._precision = parseInt(this.getAttribute("data-precision"), 10) || 0;
        this._isUnlimited = this.hasClass(CLASS_UNLIMITED);
        this._isLimited = this.hasClass(CLASS_LIMITED);
        this._progessWrapper = this.element.querySelector(QUERY_PROGRESS);
        if (this._isLimited === true) {
            this._detailRight = this.element.querySelector(QUERY_DETAIL_BOTTOM);
        } else {
            this._detailRight = this.element.querySelector(QUERY_DETAIL_RIGHT);
        }
        if (this._isUnlimited === false && this._isLimited === false) {
            this._legend = (0, _DomFunctions.getAttributeReference)(this.element, "data-legend");
        }
        if (!this._data) {
            this._data = (0, _ChartFunctions.tryGetData)(this.element);
        }
        this._render();
    };
    BarChartHorizontal.prototype._render = function () {
        var e_1, _a;
        var dataOne = this._data[0];
        var dataTwo = this._data[1];
        var tooltip = this._isLimited === false ? this._getTooltipContent(this._data) : undefined;
        var animatedValueElement;
        // Cleanup
        (0, _ChartFunctions.removeAllChildren)(this._detailRight);
        (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);
        try {
            // Clear only own legend items
            for (var _b = tslib_1.__values(this._legendItems), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                (0, _Utils.remove)(item);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._legendItems = [];
        if (dataOne) {
            if (this._isUnlimited === false || this._isUnlimited === true && !dataTwo) {
                var valElement = animatedValueElement = this._createValueElement(dataOne);
                this._detailRight.appendChild(valElement);
                if (this._isLimited === false) {
                    var separatorElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
                    separatorElement.innerText = " " + this._unit;
                    this._detailRight.appendChild(separatorElement);
                }
            }
            // Add the indicator
            var indicator = this._addIndicator(dataOne, tooltip);
            this._animateIndicator(indicator, 0);
            // Animate the value if required
            if (animatedValueElement && this._isLimited === true) {
                this._animateValueElement(animatedValueElement, dataOne.value);
            }
            // Add the legend
            if (this._legend) {
                var legendItem = (0, _ChartFunctions.createLegendItem)(dataOne);
                this._legend.appendChild(legendItem);
                this._legendItems.push(legendItem);
                this._animateLegend(legendItem, 0);
            }
        }
        if (dataTwo) {
            var valElement = this._createValueElement(dataTwo);
            var unitElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
            unitElement.innerText = " " + this._unit;
            this._detailRight.appendChild(valElement);
            this._detailRight.appendChild(unitElement);
            // Add the indicator
            var indicator = this._addIndicator(dataTwo, tooltip);
            this._animateIndicator(indicator, ANIMATION_DURATION);
            // Add the legend
            if (this._legend) {
                var legendItem = (0, _ChartFunctions.createLegendItem)(dataTwo);
                this._legend.appendChild(legendItem);
                this._legendItems.push(legendItem);
                this._animateLegend(legendItem, ANIMATION_DURATION);
            }
        }
        if (this._isLimited === true) {
            var valElement = this._createValueElement({ value: this._maxValue });
            var unitElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
            unitElement.innerText = " " + this._unit;
            this._detailRight.appendChild(valElement);
            this._detailRight.appendChild(unitElement);
        }
    };
    BarChartHorizontal.prototype._animateValueElement = function (animatedValueElement, toValue) {
        var counter = { var: 0 };
        (0, _animejs2.default)({
            targets: counter,
            var: toValue,
            duration: ANIMATION_DURATION,
            easing: "easeOutQuint",
            round: 1,
            update: function update() {
                animatedValueElement.innerText = "" + counter.var;
            }
        });
    };
    BarChartHorizontal.prototype._animateIndicator = function (indicatorWrapper, animationOffset) {
        var indicator = indicatorWrapper.getElementsByClassName("indicator")[0];
        var indicatorWidth = indicator.scrollWidth;
        indicator.style.width = "0px";
        (0, _animejs2.default)({
            targets: indicator,
            duration: ANIMATION_DURATION,
            width: indicatorWidth + "px",
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                indicator.style.width = "";
            }
        });
    };
    BarChartHorizontal.prototype._animateLegend = function (legendItem, animationOffset) {
        legendItem.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legendItem,
            duration: ANIMATION_DURATION,
            opacity: 1,
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                legendItem.style.opacity = null;
            }
        });
    };
    BarChartHorizontal.prototype._createValueElement = function (data) {
        var unlimitedPrefix = "";
        if (this._isUnlimited === true) {
            unlimitedPrefix = "+";
        }
        var value = parseFloat(data.value);
        if (value <= 0) {
            if (this._precision === 0) {
                value = "0";
            } else {
                value = ".";
                for (var i = 0; i < this._precision; i++) {
                    value += "0";
                }
            }
        } else {
            value = value.toFixed(this._precision);
        }
        var valueElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_VALUE).element;
        valueElement.innerText = "" + unlimitedPrefix + value;
        return valueElement;
    };
    BarChartHorizontal.prototype._addIndicator = function (data, tooltip) {
        var width = 100.0 / this._maxValue * data.value;
        var indicator = new _DomElement2.default("div").addClass(CLASS_INDICATOR);
        if ((0, _ChartFunctions.isColor)(data.color) === true) {
            indicator.setAttribute("style", "background-color: " + data.color + ";");
        } else {
            indicator.addClass(data.color);
        }
        var indicatorWrapper = new _DomElement2.default("div").addClass(CLASS_INDICATOR_WRAPPER).setAttribute("style", "width: " + width + "%").appendChild(indicator).setAttribute("onclick", "void(0)");
        if (tooltip && tooltip !== "") {
            indicatorWrapper.addClass(CLASS_TOOLTIP).addClass(CLASS_TOOLTIP_MULTILINE).setAttribute("aria-label", tooltip);
        }
        this._progessWrapper.appendChild(indicatorWrapper.element);
        return indicatorWrapper.element;
    };
    BarChartHorizontal.prototype._getTooltipContent = function (dataList) {
        var e_2, _a;
        var tooltip = "";
        try {
            for (var dataList_1 = tslib_1.__values(dataList), dataList_1_1 = dataList_1.next(); !dataList_1_1.done; dataList_1_1 = dataList_1.next()) {
                var data = dataList_1_1.value;
                tooltip += data.title + ": " + data.value + " " + this._unit + "\n";
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (dataList_1_1 && !dataList_1_1.done && (_a = dataList_1.return)) _a.call(dataList_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        return tooltip.trim();
    };
    /**
     * Updates the bar chart with the specified data definitions.
     * @param {Array} - bar chart data definitions.
     */
    BarChartHorizontal.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    BarChartHorizontal.prototype.destroy = function () {
        var e_3, _a;
        this._data = undefined;
        (0, _ChartFunctions.removeAllChildren)(this._detailRight);
        (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);
        this._detailRight = undefined;
        this._progessWrapper = undefined;
        try {
            for (var _b = tslib_1.__values(this._legendItems), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                (0, _Utils.remove)(item);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        this._legendItems = undefined;
        this._legend = undefined;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    BarChartHorizontal.prototype.destory = function () {
        this.destroy();
    };
    return BarChartHorizontal;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".bar-chart-horizontal", function (e) {
        new BarChartHorizontal(e);
    });
}
exports.default = BarChartHorizontal;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"./ChartFunctions":13,"animejs":35,"tslib":135}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DATA_CATEGORIES = ".js-data-list .js-category";
var QUERY_DATA_ITEMS = ".js-data-list .js-data";
var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".bar-chart__legend";
var CLASS_INDICATOR = "indicator";
var CLASS_LABEL_X = "axis-x-label";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_INDICATOR_INNER_WRAPPER = "indicator-wrapper-inner";
var CLASS_INDICATOR_EMPTY = "empty";
var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_LEFT = "tooltip--left";
var CLASS_TOOLTIP_RIGHT = "tooltip--right";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";
var ANIMATION_DURATION = 500;
/**
 * Bar Chart Horizontal Component.
 */
var BarChartVertical = /** @class */function (_super) {
    tslib_1.__extends(BarChartVertical, _super);
    /**
     * Creates and initializes the bar chart horizontal component.
     * @param element - root element of the chart.
     * @param data - data for the chart.
     */
    function BarChartVertical(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._initialize();
        return _this;
    }
    BarChartVertical.prototype._initialize = function () {
        this._unit = this.getAttribute("data-unit") || "";
        this._maxValue = parseFloat(this.getAttribute("data-max")) || 100;
        this._chart = this.element.querySelector(QUERY_CHART);
        this._legend = this.element.querySelector(QUERY_LEGEND);
        if (!this._data) {
            this._data = this._tryGetData(this.element);
        }
        this._render();
    };
    BarChartVertical.prototype._tryGetData = function (element) {
        var e_1, _a, e_2, _b, e_3, _c;
        var data = {
            categories: [],
            items: []
        };
        var categories = element.querySelectorAll(QUERY_DATA_CATEGORIES);
        var items = element.querySelectorAll(QUERY_DATA_ITEMS);
        try {
            for (var categories_1 = tslib_1.__values(categories), categories_1_1 = categories_1.next(); !categories_1_1.done; categories_1_1 = categories_1.next()) {
                var category = categories_1_1.value;
                data.categories.push({
                    title: (0, _DomFunctions.text)(category),
                    color: category.getAttribute("data-color")
                });
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (categories_1_1 && !categories_1_1.done && (_a = categories_1.return)) _a.call(categories_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        try {
            for (var items_1 = tslib_1.__values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                var item = items_1_1.value;
                var dataEnty = {
                    title: (0, _DomFunctions.text)(item),
                    class: item.getAttribute("data-class"),
                    values: []
                };
                var vals = item.getAttribute("data-value");
                if (vals) {
                    try {
                        for (var _d = (e_3 = void 0, tslib_1.__values(vals.split(","))), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var val = _e.value;
                            dataEnty.values.push(parseFloat(val));
                        }
                    } catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    } finally {
                        try {
                            if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                        } finally {
                            if (e_3) throw e_3.error;
                        }
                    }
                }
                data.items.push(dataEnty);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (items_1_1 && !items_1_1.done && (_b = items_1.return)) _b.call(items_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        return data;
    };
    BarChartVertical.prototype._getTooltipContent = function (entry, categories) {
        var tooltip = "";
        for (var i = 0; i < entry.values.length; i++) {
            tooltip += categories[i].title + ": " + entry.values[i] + " " + this._unit + "\n";
        }
        return tooltip.trim();
    };
    BarChartVertical.prototype._render = function () {
        var e_4, _a, e_5, _b;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            try {
                for (var _c = tslib_1.__values(this._data.categories), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var category = _d.value;
                    var legendItem = (0, _ChartFunctions.createLegendItem)(category);
                    this._legend.appendChild(legendItem);
                }
            } catch (e_4_1) {
                e_4 = { error: e_4_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_4) throw e_4.error;
                }
            }
        }
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        var animationStages = [];
        var leftSideItems = Math.floor(this._data.items.length / 2);
        try {
            for (var _e = tslib_1.__values(this._data.items), _f = _e.next(); !_f.done; _f = _e.next()) {
                var item = _f.value;
                var element = new _DomElement2.default("li");
                if (item.class) {
                    element.addClass(item.class);
                }
                var listElement = new _DomElement2.default("ul").addClass(CLASS_INDICATOR_WRAPPER);
                var wrapper = new _DomElement2.default("div").addClass(CLASS_INDICATOR_INNER_WRAPPER);
                listElement.appendChild(wrapper);
                element.appendChild(listElement);
                var tooltip = this._getTooltipContent(item, this._data.categories);
                if (tooltip) {
                    wrapper.addClass(CLASS_TOOLTIP).addClass(leftSideItems <= 0 ? CLASS_TOOLTIP_LEFT : CLASS_TOOLTIP_RIGHT).setAttribute("aria-label", tooltip);
                    if (item.values.length > 1) {
                        wrapper.addClass(CLASS_TOOLTIP_MULTILINE);
                    }
                }
                for (var i = 0; i < item.values.length; i++) {
                    var height = this._chart.offsetHeight / this._maxValue * item.values[i];
                    var indicator = new _DomElement2.default("li").addClass(CLASS_INDICATOR).setAttribute("style", "height: " + height + "px;");
                    if (height > 0) {
                        var color = this._data.categories[i].color;
                        if ((0, _ChartFunctions.isColor)(color)) {
                            indicator.setAttribute("style", "background-color: " + color + ";");
                        } else {
                            indicator.addClass(color);
                        }
                        if (animationStages.length <= i) {
                            animationStages.push([]);
                        }
                        animationStages[i].push(indicator.element);
                    } else {
                        indicator.addClass(CLASS_INDICATOR_EMPTY);
                    }
                    wrapper.appendChild(indicator);
                }
                var titleDomElement = new _DomElement2.default("div").addClass(CLASS_LABEL_X);
                var titleElement = titleDomElement.element;
                titleElement.innerText = item.title;
                element.appendChild(titleDomElement);
                this._chart.appendChild(element.element);
                leftSideItems -= 1;
            }
        } catch (e_5_1) {
            e_5 = { error: e_5_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_5) throw e_5.error;
            }
        }
        for (var i = 0; i < animationStages.length; i++) {
            var offset = ANIMATION_DURATION * i;
            this._animateBars(animationStages[i], offset);
            if (this._legend) {
                this._animateLegend(this._legend.children[i], offset);
            }
        }
    };
    BarChartVertical.prototype._animateBars = function (bars, animationOffset) {
        for (var i = 0; i < bars.length; i++) {
            var bar = bars[i];
            var barHeight = bar.style.height;
            bar.style.height = "0";
            (0, _animejs2.default)({
                targets: bars[i],
                height: barHeight,
                easing: "easeInOutQuint",
                duration: ANIMATION_DURATION,
                delay: animationOffset
            });
        }
    };
    BarChartVertical.prototype._animateLegend = function (legend, animationOffset) {
        legend.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legend,
            opacity: 1,
            easing: "easeInOutQuint",
            duration: ANIMATION_DURATION,
            delay: animationOffset
        });
    };
    /**
     * Updates the bar chart with the specified data definitions.
     * @param {Array} - bar chart data definitions.
     */
    BarChartVertical.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    BarChartVertical.prototype.destroy = function () {
        this._data = undefined;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            this._legend = undefined;
        }
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    BarChartVertical.prototype.destory = function () {
        this.destroy();
    };
    return BarChartVertical;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".bar-chart-vertical", function (e) {
        new BarChartVertical(e);
    });
}
exports.default = BarChartVertical;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"./ChartFunctions":13,"animejs":35,"tslib":135}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tryGetData = tryGetData;
exports.removeAllChildren = removeAllChildren;
exports.createLegendItem = createLegendItem;
exports.isColor = isColor;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DATA = ".js-data";
function tryGetData(element) {
    var e_1, _a;
    var data = [];
    var elements = element.querySelectorAll(QUERY_DATA);
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var entry = elements_1_1.value;
            var value = parseFloat(entry.getAttribute("data-value"));
            var color = entry.getAttribute("data-color");
            var title = (0, _DomFunctions.text)(entry);
            var item = {
                title: title,
                value: value,
                color: color
            };
            data.push(item);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    return data;
}
function removeAllChildren(node) {
    while (node.firstChild) {
        node.removeChild(node.firstChild);
    }
}
function createLegendItem(data) {
    var bullet = new _DomElement2.default("span").addClass("bullet");
    if (isColor(data.color) === true) {
        bullet.setAttribute("style", "background-color: " + data.color + ";");
    } else {
        bullet.addClass(data.color);
    }
    var caption = new _DomElement2.default("span").setHtml(data.title);
    return new _DomElement2.default("li").appendChild(bullet).appendChild(caption).element;
}
function isColor(str) {
    var pattern = /^#/i;
    return pattern.test(str);
}

},{"../DomElement":5,"../DomFunctions":6,"tslib":135}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".js-legend";
var DASH_SEPARATOR_WIDTH = 3;
var ANIMATION_DURATION = 1500;
var ANIMATION_DURATION_LEGEND = 500;
var QUERY_META_TITLE = ".meta .title";
var QUERY_META_SUBTITLE = ".meta .subtitle";
/**
 * Pie Chart Component.
 */
var PieChart = /** @class */function (_super) {
    tslib_1.__extends(PieChart, _super);
    /**
     * Creates and initializes the Pie Chart component.
     * @param {DomElement} - root element of the chart.
     * @param {Array} - pie chart data definitions.
     */
    function PieChart(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._initialize();
        return _this;
    }
    PieChart.prototype._initialize = function () {
        this._chart = this.element.querySelector(QUERY_CHART);
        this._legend = this.element.querySelector(QUERY_LEGEND);
        this._title = this.element.querySelector(QUERY_META_TITLE);
        this._subtitle = this.element.querySelector(QUERY_META_SUBTITLE);
        this._unit = this.getAttribute("data-unit") || "";
        this._alwaysShowLegend = this.element.hasAttribute("data-always-show-legend");
        if (!this._data) {
            this._data = (0, _ChartFunctions.tryGetData)(this.element);
        }
        this._render();
    };
    PieChart.prototype._render = function () {
        var total = this._data.reduce(function (a, b) {
            return a + b.value;
        }, 0);
        var r = 16;
        var dashTotal = 2 * r * Math.PI;
        var currentRotate = 9;
        // Cleanup
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
        }
        var percentageAdjustTotal = 0;
        var percentageAdjust = 0;
        var separatorPercentage = DASH_SEPARATOR_WIDTH / 100;
        for (var i = 0; i < this._data.length; i++) {
            var entry = this._data[i];
            var percentage = entry.value / total;
            if (percentage < separatorPercentage) {
                percentageAdjustTotal += separatorPercentage - percentage;
                percentageAdjust++;
            }
        }
        if (percentageAdjust > 0) {
            percentageAdjust = percentageAdjustTotal / (this._data.length - percentageAdjust);
        }
        var animations = _animejs2.default.timeline();
        var animationOffset = 0;
        var _loop_1 = function _loop_1(i) {
            var entry = this_1._data[i];
            var displayPercentage = entry.value / total;
            var percentage = Math.max(separatorPercentage, displayPercentage - percentageAdjust);
            var dashWidth = percentage * dashTotal - DASH_SEPARATOR_WIDTH;
            var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("viewBox", "0 0 34 34");
            svg.setAttribute("role", "img");
            svg.setAttribute("aria-labelledby", "title desc");
            var title = document.createElementNS("http://www.w3.org/2000/svg", "title");
            title.setAttribute("id", "title");
            title.innerHTML = "Pie chart segment " + Math.floor(displayPercentage * 100) + "%";
            var description = document.createElementNS("http://www.w3.org/2000/svg", "desc");
            description.setAttribute("id", "desc");
            description.innerHTML = entry.title + ": " + entry.value;
            var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", "17");
            circle.setAttribute("cy", "17");
            circle.setAttribute("r", String(r));
            if ((0, _ChartFunctions.isColor)(entry.color) === true) {
                circle.setAttribute("stroke", "" + entry.color);
            } else {
                circle.setAttribute("class", entry.color);
            }
            circle.setAttribute("role", "presentation");
            svg.setAttribute("style", "transform: rotate(" + currentRotate + "deg);");
            svg.appendChild(title);
            svg.appendChild(description);
            svg.appendChild(circle);
            this_1._chart.appendChild(svg);
            var animationDuration = ANIMATION_DURATION * percentage;
            circle.style.display = "none";
            var counter = { var: 0.5 };
            animations.add({
                targets: counter,
                var: dashWidth,
                begin: function begin() {
                    circle.style.display = "";
                },
                update: function update() {
                    circle.setAttribute("stroke-dasharray", counter.var + " " + dashTotal);
                },
                duration: animationDuration,
                easing: "easeInQuint"
            });
            // Legend
            if (this_1._legend && this_1._data.length > 1 || this_1._alwaysShowLegend) {
                var bullet = new _DomElement2.default("span").addClass("bullet");
                if ((0, _ChartFunctions.isColor)(entry.color) === true) {
                    bullet.setAttribute("style", "background-color: " + entry.color);
                } else {
                    bullet.addClass(entry.color);
                }
                var caption = new _DomElement2.default("span");
                var captionElement = caption.element;
                captionElement.innerText = entry.title;
                var legendItem = new _DomElement2.default("li").appendChild(bullet).appendChild(caption);
                this_1._legend.appendChild(legendItem.element);
                this_1._animateLegend(legendItem.element, animationOffset);
            }
            animationOffset += animationDuration;
            currentRotate += 360 * percentage;
            if (i === this_1._data.length - 1) {
                this_1._title.innerHTML = entry.value + " " + this_1._unit;
                this_1._subtitle.innerHTML = entry.title;
            }
        };
        var this_1 = this;
        for (var i = 0; i < this._data.length; i++) {
            _loop_1(i);
        }
    };
    PieChart.prototype._animateLegend = function (legendItem, animationOffset) {
        legendItem.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legendItem,
            duration: ANIMATION_DURATION_LEGEND,
            opacity: 1,
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                legendItem.style.opacity = null;
            }
        });
    };
    /**
     * Updates the pie chart with the specified data definitions.
     * @param {Array} - pie chart data definitions.
     */
    PieChart.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    PieChart.prototype.destroy = function () {
        this._data = undefined;
        this._title = undefined;
        this._subtitle = undefined;
        this._unit = undefined;
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        this._chart = undefined;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            this._legend = undefined;
        }
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    PieChart.prototype.destory = function () {
        this.destroy();
    };
    return PieChart;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".pie-chart", function (e) {
        new PieChart(e);
    });
}
exports.default = PieChart;

},{"../DomElement":5,"../Utils":8,"./ChartFunctions":13,"animejs":35,"tslib":135}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var ANIMATION_OPEN = 300;
/**
 * The Collapse component.
 */
var Collapse = /** @class */function (_super) {
    tslib_1.__extends(Collapse, _super);
    /**
     * Creates and initializes the Collapse component.
     * @param {DomElement} - The root element of the Collapse component.
     */
    function Collapse(element) {
        var _this = _super.call(this, element) || this;
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Collapse component.
     * @private
     */
    Collapse.prototype._initialize = function () {
        var dataTarget = this.element.getAttribute("data-target");
        if (dataTarget === null || dataTarget === "") {
            /* tslint:disable:no-console */
            console.error("A collapsible element requires a 'data-target' that specifies the element to collapse");
            console.info(this.element);
            /* tslint:enable:no-console */
            return;
        }
        var hiddenTarget = this.element.getAttribute("data-hidden");
        if (hiddenTarget !== null && hiddenTarget !== "") {
            this._hiddenIndicator = document.querySelector(hiddenTarget);
        }
        this._collapsibleElements = document.querySelectorAll(dataTarget);
        this.element.addEventListener("click", this._clickHandler);
    };
    Collapse.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.toggle();
    };
    /**
     * Toggles the collapseible.
     */
    Collapse.prototype.toggle = function () {
        var e_1, _a, e_2, _b;
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
            try {
                for (var _c = tslib_1.__values(this._collapsibleElements), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var s = _d.value;
                    this._openCollapse(s);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
        } else {
            (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
            try {
                for (var _e = tslib_1.__values(this._collapsibleElements), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var s = _f.value;
                    this._closeCollapse(s);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
        }
    };
    Collapse.prototype._openCollapse = function (el) {
        _animejs2.default.remove(el);
        el.style.display = "block";
        (0, _animejs2.default)({
            targets: el,
            duration: ANIMATION_OPEN,
            height: el.scrollHeight + "px",
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                var domEl = new _DomElement2.default(el);
                domEl.addClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "true");
    };
    Collapse.prototype._closeCollapse = function (el) {
        _animejs2.default.remove(el);
        (0, _animejs2.default)({
            targets: el,
            duration: ANIMATION_OPEN,
            height: 0,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                var domEl = new _DomElement2.default(el);
                domEl.removeClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "false");
    };
    /**
     * Removes all event handlers and clears references.
     */
    Collapse.prototype.destroy = function () {
        this._collapsibleElements = null;
        if (this._clickHandler) {
            this.element.removeEventListener("click", this._clickHandler);
        }
        this.element = null;
    };
    return Collapse;
}(_DomElement2.default);
function init() {
    var e_3, _a;
    var elements = document.querySelectorAll("[data-toggle='collapse']");
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            if (e.getAttribute("data-init") === "auto") {
                new Collapse(e);
            }
        }
    } catch (e_3_1) {
        e_3 = { error: e_3_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_3) throw e_3.error;
        }
    }
}
exports.default = Collapse;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":35,"tslib":135}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BORDER = "empty-state__border";
var CLASS_BORDER_MODAL = "empty-state__border--modal";
var CLASS_ACTIVE = "is-active";
var CLASS_HASFILES = "has-files";
var CLASS_MODAL = "empty-state--modal";
var CLASS_MODAL_CONTENT = "modal__content";
var QUERY_MODAL_BODY = ".modal__body";
var QUERY_FILE = "input[type='file']";
/**
 * Empty state pattern
 */
var EmptyState = /** @class */function (_super) {
    tslib_1.__extends(EmptyState, _super);
    /**
     * Creates and initializes the Empty-State pattern component.
     * @param {DomElement} - root element of the empty-state pattern.
     */
    function EmptyState(element) {
        var _this = _super.call(this, element) || this;
        _this._fileInput = _this.element.querySelector(QUERY_FILE);
        _this._button = _this.element.querySelector("label");
        _this._fileChangedHandler = _this._handleFileChanged.bind(_this);
        _this._preventEventsHandler = _this._preventDragEvents.bind(_this);
        _this._dragEnterHandler = _this._handleDragEnter.bind(_this);
        _this._dragLeaveHandler = _this._handleDragLeave.bind(_this);
        _this._dropHandler = _this._handleDrop.bind(_this);
        _this._isDragging = false;
        _this._initialize();
        return _this;
    }
    EmptyState.prototype._initialize = function () {
        var e_1, _a;
        if (this.hasClass(CLASS_MODAL)) {
            // handle modal dialogs
            this._dragArea = (0, _DomFunctions.parentWithClass)(this.element, CLASS_MODAL_CONTENT);
            var borderArea = this._dragArea.querySelector(QUERY_MODAL_BODY);
            borderArea.setAttribute("style", "pointer-events: none;");
            this._border = new _DomElement2.default("div").addClass(CLASS_BORDER).addClass(CLASS_BORDER_MODAL);
            borderArea.appendChild(this._border.element);
        } else {
            // normal modal dialog
            this._dragArea = this.element;
            var borderArea = (0, _DomFunctions.getRootElement)();
            this._border = new _DomElement2.default("div").addClass(CLASS_BORDER);
            if (!borderArea.querySelector("." + CLASS_BORDER)) {
                borderArea.appendChild(this._border.element);
            }
        }
        var form = this.element.querySelector("form");
        try {
            for (var _b = tslib_1.__values(["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var event_1 = _c.value;
                this.element.addEventListener(event_1, this._preventEventsHandler);
                form.addEventListener(event_1, this._preventEventsHandler);
                this._dragArea.addEventListener(event_1, this._preventEventsHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._dragArea.addEventListener("dragover", this._dragEnterHandler);
        this._dragArea.addEventListener("dragenter", this._dragEnterHandler);
        this._dragArea.addEventListener("dragleave", this._dragLeaveHandler);
        this._dragArea.addEventListener("dragend", this._dragLeaveHandler);
        this._dragArea.addEventListener("drop", this._dragLeaveHandler);
        this._dragArea.addEventListener("drop", this._dropHandler);
        this._fileInput.addEventListener("change", this._fileChangedHandler);
    };
    EmptyState.prototype._preventDragEvents = function (e) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    };
    EmptyState.prototype._handleDragEnter = function () {
        if (this._isDragging === true) {
            return;
        }
        this._isDragging = true;
        this._button.setAttribute("style", "pointer-events: none;");
        this.addClass(CLASS_ACTIVE);
        this._border.addClass(CLASS_ACTIVE);
    };
    EmptyState.prototype._handleDragLeave = function () {
        if (this._isDragging === false) {
            return;
        }
        this._isDragging = false;
        this._button.setAttribute("style", "");
        this.removeClass(CLASS_ACTIVE);
        this._border.removeClass(CLASS_ACTIVE);
    };
    EmptyState.prototype._handleDrop = function (e) {
        var dragEvent = e;
        this._fileInput.files = dragEvent.dataTransfer.files;
    };
    EmptyState.prototype._handleFileChanged = function () {
        var files = this._fileInput.files;
        if (files && files.length > 0) {
            this.addClass(CLASS_HASFILES);
        } else {
            this.removeClass(CLASS_HASFILES);
        }
    };
    Object.defineProperty(EmptyState.prototype, "files", {
        /**
         * Gets the currently selected files.
         */
        get: function get() {
            return this._fileInput.files;
        },
        enumerable: true,
        configurable: true
    });
    return EmptyState;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".empty-state", function (e) {
        new EmptyState(e);
    });
}
exports.default = EmptyState;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"tslib":135}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DROPDOWN = ".js-autocomplete";
var CLASS_RESULT = "autocomplete__result";
var CLASS_OPEN = "is-open";
var CLASS_HOVER = "js-hover";
var ATTRIBUTE_VALUE = "data-value";
var TIMEOUT_BLUR = 400;
/**
 * Autocomplete component
 * @fires Autocomplete#change
 */
var Autocomplete = /** @class */function (_super) {
    tslib_1.__extends(Autocomplete, _super);
    function Autocomplete(element, configuration) {
        var _this = _super.call(this, element) || this;
        _this._input = _this.element.querySelector("input");
        _this._dropdown = _this.element.querySelector(QUERY_DROPDOWN);
        // Setup event context
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._keyUpHandler = _this._handleKeyUp.bind(_this);
        _this._keyDownHandler = _this._handleKeyDown.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        if (configuration) {
            _this._minChars = configuration.minChars;
            _this._source = configuration.source;
        }
        if (!_this._minChars || _this._minChars < 0) {
            _this._minChars = 2;
        }
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Autocomplete component.
     * @private
     */
    Autocomplete.prototype._initialize = function () {
        this._clearSuggestions();
        if (this._input.getAttribute("disabled")) {
            this.disable();
        } else {
            this.enable();
        }
        // Disable browser autofill
        this._input.setAttribute("autocomplete", "off");
    };
    /**
     * The Autocomplete component configuration object
     * @callback Autocomplete~Suggest
     * @property {String} term - The current search term.
     * @property {String[]} matches - The list of matching strings.
     */
    /**
     * The Autocomplete component configuration object
     * @callback Autocomplete~Source
     * @property {String} term - The current search term.
     * @property {Autocomplete~Suggest} suggest - The autocomplete callback function to report the results.
     */
    /**
     * The Autocomplete component configuration object
     * @typedef {Object} Autocomplete~Config
     * @property {Number} minChars - The minimal required characters to start querying for autocomplete matches.
     * @property {Autocomplete~Source} source - The autocomplete source function.
     */
    /**
     * Updates the autocomplete component configuration for the current instance
     * @param {Autocomplete~Config} configuration The configuration object
     */
    Autocomplete.prototype.configure = function (configuration) {
        if (!configuration) {
            return;
        }
        if (configuration.minChars) {
            this._minChars = Math.min(configuration.minChars, 1);
        }
        if (configuration.source) {
            this._source = configuration.source;
        }
        this._clearSuggestions();
    };
    /**
     * Sets the select control to the enabled state.
     */
    Autocomplete.prototype.enable = function () {
        if (!this._input) {
            return;
        }
        this._input.removeAttribute("disabled");
        this._input.addEventListener("keyup", this._keyUpHandler);
        this._input.addEventListener("keydown", this._keyDownHandler);
        this._input.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the select control to the disabled state.
     */
    Autocomplete.prototype.disable = function () {
        if (!this._input) {
            return;
        }
        this._input.setAttribute("disabled", "true");
        this._input.removeEventListener("keyup", this._keyUpHandler);
        this._input.removeEventListener("keydown", this._keyDownHandler);
        this._input.removeEventListener("blur", this._blurHandler);
        this.close();
    };
    /**
     * Destroys the component and frees all references.
     */
    Autocomplete.prototype.destroy = function () {
        this.disable();
        this._keyUpHandler = undefined;
        this._keyDownHandler = undefined;
        this._windowClickHandler = undefined;
        this._blurHandler = undefined;
        this._input = undefined;
    };
    /**
     * Closes the suggestions dropdown.
     */
    Autocomplete.prototype.open = function () {
        this._dropdown.addEventListener("click", this._clickHandler);
        window.addEventListener("click", this._windowClickHandler);
        this.addClass(CLASS_OPEN);
    };
    /**
     * Opens the suggestions dropdown.
     */
    Autocomplete.prototype.close = function () {
        this._dropdown.removeEventListener("click", this._clickHandler);
        window.removeEventListener("click", this._windowClickHandler);
        this.removeClass(CLASS_OPEN);
    };
    Object.defineProperty(Autocomplete.prototype, "value", {
        /**
         * Gets the value of the input field.
         * @returns {String} The value of the input field.
         */
        get: function get() {
            return this._input.value;
        },
        enumerable: true,
        configurable: true
    });
    Autocomplete.prototype._handleClick = function (event) {
        if (!this._isDropdownTarget(event.target)) {
            return;
        }
        var current = event.target;
        while (current.nodeName !== "LI" && current.parentNode) {
            current = current.parentNode;
        }
        if (current.nodeName === "LI") {
            (0, _Utils.preventDefault)(event);
            this._selectItem(current);
        }
    };
    Autocomplete.prototype._handleBlur = function () {
        var _this = this;
        setTimeout(function () {
            _this.close();
        }, TIMEOUT_BLUR);
    };
    Autocomplete.prototype._handleKeyUp = function (evt) {
        var keycode = evt.which || evt.keyCode;
        if (Inputs.containsKey(keycode, [Inputs.KEY_ARROW_UP, Inputs.KEY_ARROW_DOWN, Inputs.KEY_ENTER, Inputs.KEY_TAB])) {
            // Do not handle these events on keyup
            (0, _Utils.preventDefault)(evt);
            return;
        }
        var target = evt.currentTarget;
        if (evt.currentTarget && target.value && target.value.length >= this._minChars) {
            this._getSuggestion(target.value);
        } else {
            this.close();
        }
    };
    Autocomplete.prototype._handleKeyDown = function (evt) {
        var keycode = evt.which || evt.keyCode;
        var isOpen = (0, _DomFunctions.hasClass)(this.element, CLASS_OPEN);
        if (keycode === Inputs.KEY_ESCAPE && isOpen === true) {
            // handle Escape key (ESC)
            this.close();
            (0, _Utils.preventDefault)(evt);
            return;
        }
        if (isOpen === true && Inputs.containsKey(keycode, [Inputs.KEY_ENTER, Inputs.KEY_TAB])) {
            var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);
            (0, _Utils.preventDefault)(evt);
            this._selectItem(focusedElement);
            return;
        }
        if (isOpen === true && Inputs.containsKey(keycode, [Inputs.KEY_ARROW_UP, Inputs.KEY_ARROW_DOWN])) {
            // Up and down arrows
            var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);
            if (focusedElement) {
                (0, _DomFunctions.removeClass)(focusedElement, CLASS_HOVER);
                var children = Array.prototype.slice.call(this._suggestionList.childNodes);
                var totalNodes = children.length - 1;
                var direction = keycode === Inputs.KEY_ARROW_UP ? -1 : 1;
                var index = children.indexOf(focusedElement);
                index = Math.max(Math.min(index + direction, totalNodes), 0);
                focusedElement = this._suggestionList.childNodes[index];
            } else {
                focusedElement = this._suggestionList.querySelector("li");
            }
            (0, _DomFunctions.addClass)(focusedElement, CLASS_HOVER);
            (0, _Utils.preventDefault)(evt);
            return;
        }
    };
    Autocomplete.prototype._handleWindowClick = function (event) {
        if (this._isDropdownTarget(event.target)) {
            return;
        }
        this.close();
    };
    Autocomplete.prototype._selectItem = function (item) {
        if (!item) {
            return;
        }
        var text = item.getAttribute(ATTRIBUTE_VALUE);
        if (text) {
            this._input.value = text;
            // Dispatch the changed event
            this.dispatchEvent("change");
        }
        this.close();
    };
    Autocomplete.prototype._isDropdownTarget = function (target) {
        var current = target;
        while (current !== this._dropdown && current.parentNode) {
            current = current.parentNode;
        }
        return current === this._dropdown;
    };
    Autocomplete.prototype._clearSuggestions = function () {
        // Clear the dropdown item
        (0, _DomFunctions.empty)(this._dropdown);
        this._suggestionList = document.createElement("ul");
        this._dropdown.appendChild(this._suggestionList);
    };
    Autocomplete.prototype._addSuggestion = function (text, term) {
        var sanitizedTerm = term.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
        var html = text.replace(new RegExp("(" + sanitizedTerm + ")", "gi"), "<strong>$1</strong>");
        var textElement = new _DomElement2.default("span").setHtml(html);
        var innerElement = new _DomElement2.default("div").addClass(CLASS_RESULT).appendChild(textElement);
        var liElement = new _DomElement2.default("li").setAttribute(ATTRIBUTE_VALUE, text).appendChild(innerElement);
        this._suggestionList.appendChild(liElement.element);
    };
    Autocomplete.prototype._getSuggestion = function (term) {
        var _this = this;
        if (!this._source) {
            throw new Error("The source function is undefined, cannot load suggestions");
        }
        this._source(term, function (matches, termused) {
            _this._onMatchesReceived(matches, termused);
        });
    };
    Autocomplete.prototype._onMatchesReceived = function (matches, term) {
        var e_1, _a;
        this._clearSuggestions();
        if (!matches || matches.length === 0) {
            this.close();
        } else {
            // Clear the dropdown item
            (0, _DomFunctions.empty)(this._suggestionList);
            try {
                for (var matches_1 = tslib_1.__values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
                    var match = matches_1_1.value;
                    this._addSuggestion(match, term);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return)) _a.call(matches_1);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            this.open();
        }
    };
    return Autocomplete;
}(_DomElement2.default);
/**
 * Change event
 *
 * @event Autocomplete#change
 * @type {object}
 */
function init() {
    (0, _Utils.searchAndInitialize)(".input-field--autocomplete", function (e) {
        new Autocomplete(e);
    });
}
exports.default = Autocomplete;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"tslib":135}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _flatpickr = require("flatpickr");

var _flatpickr2 = _interopRequireDefault(_flatpickr);

var _it = require("flatpickr/dist/l10n/it.js");

var _fr = require("flatpickr/dist/l10n/fr.js");

var _de = require("flatpickr/dist/l10n/de.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_flatpickr2.default.localize(_it.Italian);
_flatpickr2.default.localize(_fr.French);
_flatpickr2.default.localize(_de.German);
var DEFAULTS_FLATPICKR = {
    wrap: true,
    allowInput: true,
    locale: "de",
    dateFormat: "d.m.Y",
    time_24hr: true
};
var CLASS_HAS_VALUE = "is-fixed";
var CLASS_MESSAGE = ".message";
/**
 * Input field component
 */
var InputField = /** @class */function (_super) {
    tslib_1.__extends(InputField, _super);
    function InputField(element, datePickerOptions) {
        var _this = _super.call(this, element) || this;
        _this._changedHandler = _this.onValueChanged.bind(_this);
        _this._animationStartHandler = _this._onAnimationStart.bind(_this);
        _this._datePickerOptions = datePickerOptions;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the input field component.
     * @private
     */
    InputField.prototype._initialize = function () {
        this.element.addEventListener("input", this._changedHandler);
        if (this.element.getAttribute("type") === "password") {
            this.element.addEventListener("animationstart", this._animationStartHandler);
        }
        this._initializeDatePicker();
        this.onValueChanged();
    };
    InputField.prototype._initializeDatePicker = function () {
        var picker = this.element.parentElement;
        if (!picker || !picker.classList.contains("flatpickr")) {
            return;
        }
        if (!this._datePickerOptions) {
            try {
                this._datePickerOptions = JSON.parse(picker.dataset.options || "{}");
            } catch (e) {
                this._datePickerOptions = {};
                // tslint:disable-next-line:no-console
                console.warn("_initializeDatePicker JSON.parse failed", picker.dataset.options, e);
            }
        }
        this._flatpickrInstance = (0, _flatpickr2.default)(picker, (0, _assign2.default)({}, DEFAULTS_FLATPICKR, this._datePickerOptions));
    };
    InputField.prototype._destroyDatePicker = function () {
        if (this._flatpickrInstance) {
            this._flatpickrInstance.destroy();
        }
    };
    InputField.prototype._onAnimationStart = function (e) {
        if (e.animationName === "onAutoFillStart") {
            this.onValueChanged(true);
        }
    };
    /**
     * Notifies the input field component that it's value has been changed.
     */
    InputField.prototype.onValueChanged = function (force) {
        if (force === void 0) {
            force = false;
        }
        if (this.element.value && this.element.value !== "" || force === true) {
            this.addClass(CLASS_HAS_VALUE);
        } else {
            this.removeClass(CLASS_HAS_VALUE);
            this.element.value = "";
        }
    };
    /**
     * Destroys the component and frees all references.
     */
    InputField.prototype.destroy = function () {
        this.element.removeEventListener("input", this._changedHandler);
        if (this.element.getAttribute("type") === "password") {
            this.element.removeEventListener("animationstart", this._animationStartHandler);
        }
        this._changedHandler = undefined;
        this._animationStartHandler = undefined;
        this._destroyDatePicker();
    };
    /**
     * Displays the specified error text underneath the input field.
     * @param {text} text The error text/html to display; or undefined to hide the message.
     */
    InputField.prototype.showError = function (text) {
        var message;
        if (this.element.parentElement) {
            var msg_1 = this.element.parentElement.querySelector(CLASS_MESSAGE);
            if (msg_1) {
                message = new _DomElement2.default(msg_1);
            }
        }
        if (!text || text === "") {
            if (message) {
                (0, _Utils.remove)(message.element);
            }
            this.removeClass("invalid");
            return;
        }
        this.addClass("invalid");
        if (!message) {
            message = new _DomElement2.default("div").addClass("message");
            this.element.parentElement.appendChild(message.element);
        } else {
            message.empty();
        }
        var icon = new _DomElement2.default("i").addClass("icon").addClass("icon-026-exclamation-mark-circle").setAttribute("aria-hidden", "true");
        var msg = new _DomElement2.default("span").setHtml(text);
        message.appendChild(icon);
        message.appendChild(msg);
    };
    return InputField;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".input-field input", function (e) {
        new InputField(e);
    }, function (e) {
        return e.parentElement;
    });
}
exports.default = InputField;

},{"../DomElement":5,"../Utils":8,"babel-runtime/core-js/object/assign":41,"flatpickr":130,"flatpickr/dist/l10n/de.js":131,"flatpickr/dist/l10n/fr.js":132,"flatpickr/dist/l10n/it.js":133,"tslib":135}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isNan = require("babel-runtime/core-js/number/is-nan");

var _isNan2 = _interopRequireDefault(_isNan);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MARGIN_TICK = 32;
var CLASS_HTML5 = "html5";
var RANGE_LIGHT = "range--light";
var CLASS_CONTAINER = "range-container";
var CLASS_SLIDER = "range-slider";
var CLASS_ACTIVE = "range--active";
var CLASS_TRACK = "range-track";
var CLASS_TRACK_PROGRESS = "range-track__progress";
var CLASS_TICK = "range-tick";
var CLASS_TICK_LABEL = "range-tick__label";
var CLASS_TICK_ACTIVE = "range-tick--active";
var CLASS_THUMB = "range-thumb";
var CLASS_THUMB_VALUE = "range-thumb__value";
var CLASS_DISABLED = "range--disabled";
var CLASS_DRAGGING = "range--dragging";
/**
 * The range slider component definition.
 */
var Range = /** @class */function (_super) {
    tslib_1.__extends(Range, _super);
    function Range(element) {
        var _this = _super.call(this, element) || this;
        // Setup event context
        _this._downHandler = _this._handleDown.bind(_this);
        _this._moveHandler = _this._handleMove.bind(_this);
        _this._endHandler = _this._handleEnd.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._focusHandler = _this._handleFocus.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        _this._resizeHandler = _this.layout.bind(_this);
        _this._initialize();
        if (_this.element.disabled) {
            _this.disable();
        } else {
            _this.enable();
        }
        return _this;
    }
    /**
     * Initializes the range slider component.
     *
     * This method inspects the select definition and its options and
     * generates new stylable DOM elements around the original range input-element
     * definitions.
     * @private
     */
    Range.prototype._initialize = function () {
        if (this.hasClass(CLASS_HTML5)) {
            // This element uses HTML5 styling, do not touch it...
            return;
        }
        this._wrapperElement = new _DomElement2.default(this.element.parentElement);
        this._rangeContainer = new _DomElement2.default("div").addClass(CLASS_CONTAINER);
        this._rangeTrack = new _DomElement2.default("div").addClass(CLASS_TRACK);
        // check if range--light slider then add progress
        if (this._wrapperElement.hasClass(RANGE_LIGHT)) {
            this._rangeProgress = new _DomElement2.default("div").addClass(CLASS_TRACK_PROGRESS);
            this._rangeTrack.appendChild(this._rangeProgress);
        }
        this._rangeThumb = new _DomElement2.default("div").addClass(CLASS_THUMB);
        this._ticksWrapper = new _DomElement2.default("div").addClass(CLASS_SLIDER);
        this._rangeContainer.appendChild(this._rangeTrack);
        this._rangeContainer.appendChild(this._ticksWrapper);
        this._rangeContainer.appendChild(this._rangeThumb);
        // add container to wrapper
        this._wrapperElement.appendChild(this._rangeContainer);
        // get min & max definitions
        this._minValue = parseFloat(this.element.min) || 0;
        this._maxValue = parseFloat(this.element.max) || 1;
        // get the label/output format string
        this._formatter = window[this.getAttribute("formatter")];
        // get the output label and move it below the container
        if (this.element.id) {
            this._outputLabel = this._wrapperElement.find("output[for='" + this.element.id + "']");
            if (this._outputLabel) {
                this._wrapperElement.appendChild(this._outputLabel);
            }
        }
        if (!this.element.step) {
            // fix issues with float sliders if the step is undefined
            this.element.step = "any";
        }
        var options = this._getOptionsList();
        if (options && options.length) {
            this._addTicks(options);
        }
        if (this._rangeContainer.element.querySelectorAll("." + CLASS_TICK_LABEL).length <= 1) {
            this._thumbValue = new _DomElement2.default("div").addClass(CLASS_THUMB_VALUE);
            this._rangeThumb.appendChild(this._thumbValue);
        }
        this._trackValueTotal = this._maxValue - this._minValue;
        this.layout();
        this._updateTickState();
        // Apply the tab index
        var tabIndex = this.element.getAttribute("tabindex");
        if (tabIndex) {
            this._rangeContainer.setAttribute("tabindex", tabIndex);
        }
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
    };
    Range.prototype._getOptionsList = function () {
        var e_1, _a;
        var options = [];
        var listId = this.getAttribute("list");
        if (listId) {
            var dataList = document.querySelector("#" + listId);
            if (dataList) {
                try {
                    for (var _b = tslib_1.__values(dataList.querySelectorAll("option")), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var entry = _c.value;
                        var value = parseFloat(entry.innerText);
                        var label = entry.getAttribute("label") || parseFloat(value.toFixed(2));
                        options.push({
                            value: value,
                            label: label
                        });
                    }
                } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                } finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
            }
        }
        // Sort the list to enable snapping
        options = options.sort(function (a, b) {
            return a.value - b.value;
        });
        if (options.length > 1) {
            this._minValue = Number.MAX_VALUE;
            this._maxValue = Number.MIN_VALUE;
            for (var i = 0; i < options.length; i++) {
                this._minValue = Math.min(this._minValue, options[i].value);
                this._maxValue = Math.max(this._maxValue, options[i].value);
            }
        }
        return options;
    };
    Range.prototype._addTicks = function (dataItems) {
        var e_2, _a;
        try {
            for (var dataItems_1 = tslib_1.__values(dataItems), dataItems_1_1 = dataItems_1.next(); !dataItems_1_1.done; dataItems_1_1 = dataItems_1.next()) {
                var entry = dataItems_1_1.value;
                var tickElement = new _DomElement2.default("div").setAttribute("data-value", String(entry.value)).addClass(CLASS_TICK);
                var tickLabel = new _DomElement2.default("span").addClass(CLASS_TICK_LABEL).setHtml(String(entry.label));
                tickElement.appendChild(tickLabel);
                this._ticksWrapper.appendChild(tickElement);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (dataItems_1_1 && !dataItems_1_1.done && (_a = dataItems_1.return)) _a.call(dataItems_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    Range.prototype._isEventOnLabel = function (event) {
        return event.target.classList.contains(CLASS_TICK_LABEL);
    };
    Range.prototype._handleDown = function (event) {
        this._wrapperElement.addClass(CLASS_DRAGGING);
        this._rangeContainer.element.addEventListener("mouseup", this._endHandler);
        document.addEventListener("mousemove", this._moveHandler);
        document.addEventListener("mouseup", this._endHandler);
        this._rangeContainer.element.addEventListener("touchmove", this._moveHandler);
        document.addEventListener("touchend", this._endHandler);
        // Ignore clicks directly on the thumb
        if (event.target !== this._rangeThumb.element && !this._isEventOnLabel(event)) {
            var pos = this._getRelativePosition(event);
            this._setPosition(pos, true, false, false);
        }
    };
    Range.prototype._handleMove = function (event) {
        (0, _Utils.preventDefault)(event);
        this._unfocus();
        if (!this._isEventOnLabel(event)) {
            var pos = this._getRelativePosition(event);
            this._setPosition(pos, true, false, false);
        }
    };
    Range.prototype._handleEnd = function (event) {
        this._wrapperElement.removeClass(CLASS_DRAGGING);
        this._rangeContainer.element.removeEventListener("mouseup", this._endHandler);
        document.removeEventListener("mouseup", this._endHandler);
        document.removeEventListener("mousemove", this._moveHandler);
        this._rangeContainer.element.removeEventListener("touchmove", this._moveHandler);
        document.removeEventListener("touchend", this._endHandler);
        var pos = this._getRelativePosition(event);
        this._setPosition(pos, true, true, true);
        this._handleBlur();
    };
    Range.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            this._rangeContainer.element.blur();
            return;
        }
        var isUp = keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_RIGHT || keycode === Inputs.KEY_PAGE_UP;
        var isDown = keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_ARROW_LEFT || keycode === Inputs.KEY_PAGE_DOWN;
        if (isUp || isDown) {
            event.preventDefault();
            var direction = isDown ? -1 : 1;
            // make a larger step if its the vertical arrow or page keys
            if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_PAGE_UP || keycode === Inputs.KEY_PAGE_DOWN) {
                direction *= 10;
            }
            var val = this.value;
            if (this._ticksWrapper.element.childNodes.length > 1) {
                val = this._getNextValue(val, direction);
            } else {
                var step = this.element.step;
                if (!step || step === "any") {
                    step = "0.1";
                }
                var newVal = val + parseFloat(step) * direction;
                val = newVal;
            }
            this._setValue(val, true, true);
            return;
        }
    };
    Range.prototype._handleFocus = function () {
        this._rangeContainer.addClass(CLASS_ACTIVE);
    };
    Range.prototype._handleBlur = function () {
        this._rangeContainer.removeClass(CLASS_ACTIVE);
    };
    Range.prototype._unfocus = function () {
        if (document.selection) {
            document.selection.empty();
        } else {
            window.getSelection().removeAllRanges();
        }
    };
    Range.prototype._getRelativePosition = function (event) {
        var pageX;
        if ("pageX" in event) {
            pageX = event.pageX;
        } else {
            pageX = (event.touches[0] || event.changedTouches[0]).pageX;
        }
        return pageX - this._trackLeftPosition + this._grabPosition;
    };
    /**
     * Validates and updates the position and sets the corresponding value on the slider.
     * @param {position} the new position to set.
     * @param {updateValue} true if the value should be updated as well; otherwise false.
     * @param {snap} true if snapping should be used; otherwise false.
     * @param {animate} true if the UI update should be animated; otherwise false.
     * @private
     */
    Range.prototype._setPosition = function (position, updateValue, snap, animate) {
        if (updateValue === void 0) {
            updateValue = true;
        }
        if (snap === void 0) {
            snap = false;
        }
        if (animate === void 0) {
            animate = true;
        }
        if (position === undefined || position === null || (0, _isNan2.default)(position)) {
            throw new Error("Position is not a number");
        }
        // Clamp to min and max range
        var newPos = (0, _Utils.clamp)(position, this._trackPositionMin, this._trackPositionMax);
        if (updateValue) {
            var value = this._trackValueTotal / this._trackWidth * newPos + this._minValue;
            if (this._ticksWrapper.element.childNodes.length > 1 && snap) {
                var snapPos = this._getSnapPosition(newPos);
                newPos = snapPos.position;
                value = snapPos.value;
            } else if (this.element.step && this.element.step !== "any") {
                var step = parseFloat(this.element.step);
                value = Math.round(value / step) * step;
            }
            this._setValue(value, false, false);
        }
        if (animate && updateValue) {
            this._updateTickState();
        }
        if (animate) {
            (0, _animejs2.default)({
                targets: this._rangeThumb.element,
                duration: 200,
                left: newPos,
                easing: "easeInOutQuint"
            });
            if (this._rangeProgress) {
                (0, _animejs2.default)({
                    targets: this._rangeProgress.element,
                    duration: 200,
                    width: newPos,
                    easing: "easeInOutQuint"
                });
            }
        } else {
            this._rangeThumb.element.style.left = newPos + "px";
            if (this._rangeProgress) {
                this._rangeProgress.element.style.width = newPos + "px";
            }
        }
    };
    /**
     * Gets the snap value corresponding to the given value.
     * @param {value} the target value.
     * @returns an object containing the snap position and the corresponding value.
     * @private
     */
    Range.prototype._getSnapValue = function (value) {
        var ticks = this._ticksWrapper.element.children;
        var currentPosition = 0;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentValue = parseFloat(currentElement.getAttribute("data-value"));
            var currentWidth = currentElement.element.clientWidth;
            var nextElement = void 0;
            var nextValue = Number.MAX_VALUE;
            if (i < ticks.length - 1) {
                nextElement = new _DomElement2.default(ticks[i + 1]);
                nextValue = parseFloat(nextElement.getAttribute("data-value"));
            }
            // left most element
            if (i === 0 && value <= currentValue) {
                return {
                    value: currentValue,
                    position: MARGIN_TICK - this._grabPosition
                };
            }
            // right most element
            if (!nextElement && value >= currentValue) {
                return {
                    value: currentValue,
                    position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1
                };
            }
            if (value >= currentValue && value < nextValue) {
                return {
                    value: currentValue,
                    position: currentPosition + 0.5 * currentWidth - this._grabPosition
                };
            }
            currentPosition += currentWidth;
        }
        throw new Error("Could not determine snap value");
    };
    /**
     * Gets the snap position corresponding to the given position.
     * @param {position} the target position.
     * @returns an object containing the snap position and the corresponding value.
     * @private
     */
    Range.prototype._getSnapPosition = function (position) {
        if (position === undefined || position === null || (0, _isNan2.default)(position)) {
            throw new Error("position is not a number");
        }
        var ticks = this._ticksWrapper.element.children;
        var currentPosition = 0;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentValue = parseFloat(currentElement.getAttribute("data-value"));
            var currentWidth = currentElement.element.clientWidth;
            var nextElement = void 0;
            if (i < ticks.length - 1) {
                nextElement = new _DomElement2.default(ticks[i + 1]);
            }
            // left most element
            if (i === 0 && position <= currentPosition + currentWidth) {
                return {
                    value: currentValue,
                    position: MARGIN_TICK - this._grabPosition
                };
            }
            // right most element
            if (!nextElement && position >= currentPosition) {
                return {
                    value: currentValue,
                    position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1
                };
            }
            if (position >= currentPosition && position < currentPosition + currentWidth) {
                return {
                    value: currentValue,
                    position: currentPosition + 0.5 * currentWidth - this._grabPosition
                };
            }
            currentPosition += currentWidth;
        }
        throw new Error("Could not determine snap position");
    };
    /**
     * Gets the next value in the given direction with regards to snapping.
     * @param {value} The current value.
     * @param {direction} The direction (positive or negative integer).
     * @returns The next value.
     * @private
     */
    Range.prototype._getNextValue = function (value, direction) {
        var ticks = this._ticksWrapper.element.children;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentVal = parseFloat(currentElement.getAttribute("data-value"));
            if (value === currentVal) {
                var index = (0, _Utils.clamp)(i + direction, 0, ticks.length - 1);
                value = parseFloat(ticks[index].getAttribute("data-value"));
            }
        }
        return value;
    };
    Range.prototype._updateTickState = function () {
        if (this._ticksWrapper.element.childNodes.length > 1) {
            var activeTick = this._ticksWrapper.find("." + CLASS_TICK_ACTIVE);
            if (activeTick) {
                activeTick.removeClass(CLASS_TICK_ACTIVE);
            }
            var newActiveTick = this._ticksWrapper.find("." + CLASS_TICK + "[data-value='" + this.value + "']");
            if (newActiveTick) {
                newActiveTick.addClass(CLASS_TICK_ACTIVE);
            }
        }
    };
    Range.prototype._adjustTickLabelPosition = function (tickItem, left) {
        var label = new _DomElement2.default(tickItem.querySelector("." + CLASS_TICK_LABEL));
        var dummyElement = new _DomElement2.default("span").addClass(CLASS_TICK_LABEL).setAttribute("style", "visibility: hidden; display: inline-block;").setHtml(label.innerText);
        this._rangeContainer.appendChild(dummyElement);
        var width = dummyElement.element.clientWidth / 2;
        this._rangeContainer.removeChild(dummyElement);
        var floatPosition = left ? "left" : "right";
        if (width < MARGIN_TICK) {
            // center small items on the tick
            label.setAttribute("style", floatPosition + ": " + (MARGIN_TICK - Math.floor(width)) + "px; text-align: " + floatPosition + ";");
        }
    };
    Range.prototype._formatOutput = function (value, short) {
        if (this._formatter) {
            return this._formatter(value, short);
        }
        var str = parseFloat(value.toFixed(2));
        return str.toString();
    };
    /**
     * Validates and updates the range value.
     * @param {value} the new value to set.
     * @param {update} true if the UI should be updated; otherwise false.
     * @param {animate} true if the UI update should be animated; otherwise false.
     * @private
     */
    Range.prototype._setValue = function (value, update, animate) {
        if (update === void 0) {
            update = true;
        }
        if (animate === void 0) {
            animate = false;
        }
        var val = (0, _Utils.clamp)(value, this._minValue, this._maxValue);
        var position;
        if (this._ticksWrapper.element.childNodes.length > 1) {
            var snapValue = this._getSnapValue(val);
            position = snapValue.position;
            val = snapValue.value;
        } else {
            position = this._trackWidth / this._trackValueTotal * (value - this._minValue);
        }
        // If the calculation failed, fall back to the first tick position and disable the component
        if (!position) {
            position = this._getSnapPosition(val).position;
            this.disable();
        }
        this.element.value = String(val);
        if (this._thumbValue) {
            this._thumbValue.setHtml(this._formatOutput(val, true));
        }
        if (this._outputLabel) {
            this._outputLabel.setHtml(this._formatOutput(val, false));
        }
        if (update) {
            this._setPosition(position, false, false, animate);
            this._updateTickState();
        }
        this.dispatchEvent("input");
    };
    Object.defineProperty(Range.prototype, "value", {
        /**
         * Gets the current value.
         */
        get: function get() {
            return parseFloat(this.element.value);
        },
        /**
         * Sets the value of the range slider.
         */
        set: function set(value) {
            this._setValue(value, true, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Force the component to re-layout itself.
     */
    Range.prototype.layout = function () {
        this._grabPosition = Math.round(this._rangeThumb.element.offsetWidth / 2);
        var tickItems = this._rangeContainer.element.querySelectorAll("." + CLASS_TICK);
        var ticksOffset = tickItems && tickItems.length > 0 ? 2 * MARGIN_TICK : MARGIN_TICK;
        this._trackWidth = this._rangeTrack.element.offsetWidth - ticksOffset;
        this._trackPositionMin = 0;
        this._trackPositionMax = this._rangeTrack.element.clientWidth - this._rangeThumb.element.offsetWidth + 1;
        this._trackLeftPosition = this._rangeTrack.element.getBoundingClientRect().left + MARGIN_TICK;
        var itemCount = tickItems.length - 1;
        this._itemWidth = this._trackWidth / itemCount;
        var outerItemsWidth = this._itemWidth * 0.5 + MARGIN_TICK;
        for (var i = 0; i <= itemCount; i++) {
            var width = this._itemWidth;
            if (i === 0 || i === itemCount) {
                width = outerItemsWidth;
            }
            var item = new _DomElement2.default(tickItems[i]);
            item.setAttribute("style", "width: " + Math.floor(width) + "px;");
        }
        // adjust first and last label positions
        if (tickItems.length > 1) {
            this._adjustTickLabelPosition(tickItems[0], true);
            this._adjustTickLabelPosition(tickItems[tickItems.length - 1], false);
        }
        // update the value
        this._setValue(parseFloat(this.element.value), true, false);
    };
    /**
     * Destroys the components and frees all references.
     */
    Range.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this._downHandler = null;
        this._moveHandler = null;
        this._endHandler = null;
        this._focusHandler = null;
        this._blurHandler = null;
        this.element = null;
        this._rangeContainer = null;
        this._wrapperElement = null;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    Range.prototype.destoy = function () {
        this.destroy();
    };
    /**
     * Sets the component to the enabled state.
     */
    Range.prototype.enable = function () {
        this.element.removeAttribute("disabled");
        this._wrapperElement.removeClass(CLASS_DISABLED);
        this._rangeContainer.element.addEventListener("mousedown", this._downHandler);
        this._rangeContainer.element.addEventListener("touchstart", this._downHandler);
        this._rangeContainer.element.addEventListener("keydown", this._keydownHandler);
        this._rangeContainer.element.addEventListener("focus", this._focusHandler);
        this._rangeContainer.element.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the component to the disabled state.
     */
    Range.prototype.disable = function () {
        this.element.setAttribute("disabled", "");
        this._wrapperElement.addClass(CLASS_DISABLED);
        this._rangeContainer.element.removeEventListener("mousedown", this._downHandler);
        this._rangeContainer.element.removeEventListener("mouseup", this._endHandler);
        this._rangeContainer.element.removeEventListener("mousemove", this._moveHandler);
        this._rangeContainer.element.removeEventListener("touchstart", this._downHandler);
        this._rangeContainer.element.removeEventListener("focus", this._focusHandler);
        this._rangeContainer.element.removeEventListener("blur", this._blurHandler);
    };
    return Range;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("input[type='range']", function (e) {
        new Range(e);
    });
}
exports.default = Range;

},{"../DomElement":5,"../Inputs":7,"../Utils":8,"animejs":35,"babel-runtime/core-js/number/is-nan":39,"tslib":135}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_PLACEHOLDER = "select__placeholder";
var CLASS_THUMB = "select__thumb";
var CLASS_BUTTON = "select__button";
var CLASS_DROPDOWN = "select__dropdown";
var CLASS_OPEN = "select--open";
var CLASS_CLOSED = "select--closed";
var CLASS_DISABLED = "select--disabled";
var CLASS_FILTERABLE = "select--filterable";
var CLASS_ITEM = "dropdown-item";
var CLASS_ITEM_SELECTED = "dropdown-item--selected";
var CLASS_ITEM_FOCUSED = "dropdown-item--focused";
var CLASS_ITEM_DISABLED = "dropdown-item--disabled";
var CLASS_GROUP_ITEM = "dropdown-group";
var CLASS_GROUP_HEADER = "dropdown-group__item";
var QUERY_MESSAGE = ".message";
var TIMEOUT_CLOSE = 150;
var TIMEOUT_BLUR = 400;
/**
 * The select component API.
 */
var Select = /** @class */function (_super) {
    tslib_1.__extends(Select, _super);
    function Select(element) {
        var _this = _super.call(this, element) || this;
        // Minimum filter length
        _this._minFilterLength = 2;
        // The options the Select was initially created upon
        // These will be used as a basis for filtering
        _this._initialOptions = Array.prototype.slice.call(_this.element.children);
        _this._openByFocus = false;
        // Check for multi-selection
        _this._multiselection = _this.element.hasAttribute("multiple") === true;
        // Setup event context
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._handleDropdownClick = _this._handleClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._focusHandler = _this._handleFocus.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._filterKeydownHandler = _this._handleFilterKeydown.bind(_this);
        _this._filterKeyupHandler = _this._handleFilterKeyup.bind(_this);
        _this._filterFocusHandler = _this._handleFilterFocus.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the select component.
     *
     * This method inspects the select definition and its options and
     * generates new stylable DOM elements around the original select-element
     * definitions.
     * @private
     */
    Select.prototype._initialize = function () {
        var e_1, _a;
        var selectedOption = this.element.querySelector("option[selected]");
        var firstOption = this.element.querySelector("option");
        // Per default, set the last selected option to either the option with a "selected" attribute,
        // or, if not found, to the first available option
        this._lastSelectedOption = selectedOption || firstOption;
        this._wrapperElement = new _DomElement2.default(this.element.parentElement).addClass(CLASS_CLOSED);
        try {
            for (var _b = tslib_1.__values(this.classes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var cls = _c.value;
                this._wrapperElement.addClass(cls);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._dropdownElement = new _DomElement2.default("div").addClass(CLASS_DROPDOWN);
        if ((0, _Utils.internetExplorerOrEdgeVersion)() > 0 && (0, _Utils.internetExplorerOrEdgeVersion)() < 12) {
            // This is a workaround for IE browsers 11 and earlier where focusing
            // a scrollable dropdown list will close the dropdown prematurely.
            this._dropdownElement.element.addEventListener("mousedown", function (event) {
                return event.preventDefault();
            });
        }
        this._setupTarget();
        this._setupPlaceholder();
        this._wrapperElement.appendChild(this._dropdownElement);
        this._createOptions(this.element);
        this._updateSize();
        this._updateMessage();
        if (this.element.disabled) {
            this.disable();
        } else {
            this.enable();
        }
    };
    Select.prototype._setupTarget = function () {
        // move the id from the select element to the wrapper
        var id = this.element.getAttribute("id");
        if (id) {
            this.element.removeAttribute("id");
            this._wrapperElement.setAttribute("id", id);
        }
        // Apply the tab index
        var tabIndex = this.element.getAttribute("tabindex");
        if (tabIndex) {
            this._wrapperElement.setAttribute("tabIndex", tabIndex);
        }
    };
    Select.prototype._setupPlaceholder = function () {
        var _this = this;
        if (!this._selectButtonElement) {
            this._selectButtonElement = new _DomElement2.default("div").addClass(CLASS_BUTTON);
            this._wrapperElement.appendChild(this._selectButtonElement);
        }
        if (!this._thumbElement) {
            this._thumbElement = new _DomElement2.default("div").addClass(CLASS_THUMB);
            var thumbIcon = new _DomElement2.default("div").addClass("thumb-icon");
            var loader = new _DomElement2.default("div").addClass("loader-spinner").addClass("loader-spinner--small");
            this._thumbElement.appendChild(loader);
            this._thumbElement.appendChild(thumbIcon);
            this._selectButtonElement.appendChild(this._thumbElement);
        }
        var placeholderText = "";
        this._placeholderOption = this.element.querySelector("option[selected][disabled]") || undefined;
        if (this._placeholderOption) {
            placeholderText = Dom.text(this._placeholderOption);
            if (this._multiselection === true) {
                this._placeholderOption.selected = false;
            }
        }
        var selectedOption = this.element.querySelector("option[selected]:not([disabled])");
        if (selectedOption) {
            placeholderText = Dom.text(selectedOption);
        }
        if (!this._placeholderElement) {
            // When the Select is filterable, create an "input" as the placeholder element, otherwise a "span"
            if (this._isFilterable()) {
                this._placeholderElement = new _DomElement2.default("input");
                this._placeholderElement.addEventListener("keyup", function (e) {
                    return _this._handleFilterKeyup(e);
                });
                this._placeholderElement.addEventListener("keydown", function (e) {
                    return _this._handleFilterKeydown(e);
                });
                this._placeholderElement.addEventListener("focus", function (e) {
                    return _this._handleFilterFocus(e);
                });
            } else {
                this._placeholderElement = new _DomElement2.default("span");
            }
            this._placeholderElement.addClass(CLASS_PLACEHOLDER);
            this._selectButtonElement.appendChild(this._placeholderElement);
        }
        this._setPlaceholder(placeholderText);
        this._placeholderText = placeholderText;
        if (selectedOption && selectedOption !== this._placeholderOption) {
            this._updatePlaceholder(true);
        }
    };
    Select.prototype._updateMessage = function () {
        var messageNode = this._wrapperElement.element.querySelector(QUERY_MESSAGE);
        if (messageNode !== null) {
            this._wrapperElement.appendChild(new _DomElement2.default(messageNode));
        }
    };
    Select.prototype._isOptGroup = function (element) {
        return element.tagName.toUpperCase() === "OPTGROUP";
    };
    Select.prototype._isOption = function (element) {
        return element.tagName.toUpperCase() === "OPTION";
    };
    Select.prototype._createOptions = function (element) {
        for (var i = 0; i < element.children.length; i++) {
            var child = element.children[i];
            if (this._isOptGroup(child)) {
                this._appendGroup(child);
            }
            if (this._isOption(child)) {
                var option = this._createOption(child);
                if (option) {
                    this._dropdownElement.appendChild(option);
                }
            }
        }
    };
    Select.prototype._createOption = function (option) {
        var html = option.innerHTML;
        if (this._activeFilter) {
            var sanitizedActiveFilter = this._activeFilter.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
            html = html.replace(new RegExp("(" + sanitizedActiveFilter + ")", "gi"), "<strong>$1</strong>");
        }
        var opt = new _DomElement2.default("div").addClass(CLASS_ITEM).setHtml(html);
        if (option.selected) {
            opt.addClass(CLASS_ITEM_SELECTED);
        }
        if (option.disabled) {
            opt.addClass(CLASS_ITEM_DISABLED);
        }
        if (!this._isPlaceholder(option)) {
            opt.setAttribute("data-value", option.value);
            return opt;
        }
        return undefined;
    };
    Select.prototype._appendGroup = function (optgroup) {
        var e_2, _a;
        var label = optgroup.getAttribute("label");
        var group = new _DomElement2.default("div").addClass(CLASS_GROUP_ITEM);
        var groupHeader = new _DomElement2.default("div").addClass(CLASS_GROUP_HEADER).setHtml(label);
        group.appendChild(groupHeader);
        var options = optgroup.querySelectorAll("option");
        try {
            for (var options_1 = tslib_1.__values(options), options_1_1 = options_1.next(); !options_1_1.done; options_1_1 = options_1.next()) {
                var entry = options_1_1.value;
                var option = this._createOption(entry);
                if (option) {
                    group.appendChild(option);
                }
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (options_1_1 && !options_1_1.done && (_a = options_1.return)) _a.call(options_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._dropdownElement.appendChild(group);
        return group;
    };
    Select.prototype._updateSize = function () {
        var e_3, _a;
        // Note: Mirroring the DOM and measuring the items using their clientWidth was very
        // unreliable, therefore measuring was switched to the new HTML5 measureText method
        // margins and paddings arround the text are copied from the original placeholder items
        // dimension
        var placeholderStyle = window.getComputedStyle(this._placeholderElement.element);
        var paddingRight = parseFloat(placeholderStyle.paddingRight);
        var paddingLeft = parseFloat(placeholderStyle.paddingLeft);
        var font = this._placeholderElement.css("font");
        var textWidth = Dom.textWidth(this._placeholderText, font);
        var maxWidth = paddingLeft + paddingRight + textWidth;
        var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
        try {
            for (var options_2 = tslib_1.__values(options), options_2_1 = options_2.next(); !options_2_1.done; options_2_1 = options_2.next()) {
                var entry = options_2_1.value;
                var width = Dom.textWidth(Dom.text(entry), font) + paddingLeft + paddingRight;
                if (width > maxWidth) {
                    maxWidth = width;
                }
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (options_2_1 && !options_2_1.done && (_a = options_2.return)) _a.call(options_2);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
    };
    Select.prototype._isButtonTarget = function (target) {
        return target === this._wrapperElement.element || target === this._placeholderElement.element || target === this._selectButtonElement.element || target === this._thumbElement.element;
    };
    Select.prototype._isDropdownTarget = function (target) {
        var current = target;
        while (current !== this._dropdownElement.element && current.parentElement) {
            current = current.parentElement;
        }
        return current === this._dropdownElement.element;
    };
    /**
     * Updates the UI if the selection has changed and makes sure the
     * select control and the generated markup are synchronized.
     * @private
     */
    Select.prototype._selectedItemChanged = function (newItem, autoClose, multiselect) {
        var _this = this;
        if (autoClose === void 0) {
            autoClose = true;
        }
        if (multiselect === void 0) {
            multiselect = false;
        }
        var oldItems = this._dropdownElement.element.querySelectorAll("." + CLASS_ITEM_SELECTED);
        if (!newItem) {
            setTimeout(function () {
                return _this.close();
            }, TIMEOUT_CLOSE);
            return;
        }
        if (Dom.hasClass(newItem, CLASS_ITEM_DISABLED)) {
            return;
        }
        if (oldItems.length === 0 && !newItem) {
            throw new Error("Can not select undefined elements");
        }
        var oldItem = oldItems[0];
        if (multiselect === true) {
            oldItem = (0, _Utils.find)(oldItems, function (x) {
                return x.getAttribute("data-value") === newItem.getAttribute("data-value");
            });
        }
        var isDeselect = false;
        if (newItem && oldItem && oldItem === newItem) {
            // Click on a previously selected element -> deselect
            isDeselect = true;
            if (!this._placeholderOption && !multiselect) {
                // If there is no placeholder option, non multiselect options cannot be deselected
                return;
            }
            delete this._lastSelectedOption;
        }
        if (oldItem) {
            // Remove selection on the element
            var oldValue_1 = oldItem.getAttribute("data-value");
            var optElement = (0, _Utils.find)(this.element.options, function (x) {
                return !x.disabled && x.value === oldValue_1;
            });
            if (!optElement) {
                throw new Error("The option with value " + oldValue_1 + " does not exist");
            }
            // Unset Select value
            optElement.selected = false;
            Dom.removeClass(oldItem, CLASS_ITEM_SELECTED);
        }
        if (!isDeselect) {
            // Select an option
            // Select a new item
            var newValue_1 = newItem.getAttribute("data-value");
            var optElement = (0, _Utils.find)(this.element.options, function (x) {
                return !x.disabled && x.value === newValue_1;
            });
            if (!optElement) {
                throw new Error("The option with value " + newValue_1 + " does not exist");
            }
            // Set Select value
            optElement.selected = true;
            Dom.addClass(newItem, CLASS_ITEM_SELECTED);
            // Preserve selection
            this._lastSelectedOption = optElement;
        } else {
            // Deselect an option
            // Keep track of falling back to the placeholder (if any)
            if (this._placeholderOption) {
                this._lastSelectedOption = this._placeholderOption;
            }
        }
        var hasSelectedItems = true;
        if (this._multiselection === false && isDeselect) {
            // Handle no selection for non-multiselect states
            this._placeholderOption.selected = true;
            hasSelectedItems = false;
        }
        if (this._multiselection === true && this._getSelectedOptions().length === 0) {
            hasSelectedItems = false;
        }
        // Reset the filter if filterable
        if (this._activeFilter) {
            this._clearFilter();
        }
        this._updatePlaceholder(hasSelectedItems);
        // Dispatch the changed event
        this.dispatchEvent("change");
        if (autoClose && !multiselect) {
            setTimeout(function () {
                _this.close();
            }, TIMEOUT_CLOSE);
        }
    };
    Select.prototype._updatePlaceholder = function (hasSelectedItems) {
        var e_4, _a;
        var text = this._placeholderOption ? Dom.text(this._placeholderOption) : " ";
        if (hasSelectedItems === true) {
            var selectedItems = this._getSelectedOptions();
            if (selectedItems.length > 0) {
                text = "";
                try {
                    for (var selectedItems_1 = tslib_1.__values(selectedItems), selectedItems_1_1 = selectedItems_1.next(); !selectedItems_1_1.done; selectedItems_1_1 = selectedItems_1.next()) {
                        var item = selectedItems_1_1.value;
                        text += Dom.text(item) + ", ";
                    }
                } catch (e_4_1) {
                    e_4 = { error: e_4_1 };
                } finally {
                    try {
                        if (selectedItems_1_1 && !selectedItems_1_1.done && (_a = selectedItems_1.return)) _a.call(selectedItems_1);
                    } finally {
                        if (e_4) throw e_4.error;
                    }
                }
                text = text.substring(0, text.length - 2);
            }
        }
        this._setPlaceholder(text);
    };
    Select.prototype._getSelectedOptions = function () {
        var selectedOptions = [];
        if (this.element.options) {
            [].forEach.call(this.element.options, function (option) {
                if (option.selected && !option.disabled) {
                    selectedOptions.push(option);
                }
            });
        }
        return selectedOptions;
    };
    /**
     * Clone all of the initially set options (and optgroups) and returns them in a new array.
     * This serves as the basis for filtering. If a filter is present, it will be respected.
     */
    Select.prototype.getInitialOptions = function () {
        var filter = this._activeFilter || "";
        var filtered = [];
        var initialOptions = this._initialOptions;
        for (var i = 0; i < initialOptions.length; i++) {
            var child = initialOptions[i];
            if (this._isOptGroup(child)) {
                // handle <optgroup>
                var optGroupClone = child.cloneNode(false);
                var found = false;
                for (var j = 0; j < child.children.length; j++) {
                    var optionClone = child.children[j].cloneNode(true);
                    // Append on match
                    if (this._containsWord(optionClone.innerHTML, filter)) {
                        optGroupClone.appendChild(optionClone);
                        found = true;
                    }
                }
                // Push if any matches found
                if (found) {
                    filtered.push(optGroupClone);
                }
            } else if (this._isOption(child)) {
                // handle <option>
                var optionClone = child.cloneNode(true);
                // Push on match
                if (this._containsWord(optionClone.innerHTML, filter)) {
                    filtered.push(optionClone);
                }
            }
        }
        return filtered;
    };
    /**
     * Returns true if a text contains a given keyword, e.g. in "ca" in "Car"
     */
    Select.prototype._containsWord = function (text, keyword) {
        return text.toLowerCase().indexOf(keyword.toLowerCase()) > -1;
    };
    Select.prototype._handleFocus = function () {
        var _this = this;
        this.open();
        this._openByFocus = true;
        setTimeout(function () {
            _this._openByFocus = false;
        }, TIMEOUT_BLUR);
    };
    Select.prototype._handleBlur = function () {
        this.close();
    };
    Select.prototype._handleClick = function (event) {
        var handled = false;
        if (this._lastHandledEvent === event) {
            this._lastHandledEvent = undefined;
            return;
        }
        if (this._isButtonTarget(event.target) && this._openByFocus === false) {
            // handle header item clicks and toggle dropdown
            this.toggle();
            handled = true;
        }
        var newItem = event.target;
        if (!handled && Dom.hasClass(newItem, CLASS_ITEM)) {
            // handle clicks on dropdown items
            this._selectedItemChanged(newItem, true, this._multiselection);
            handled = true;
        }
        if (handled) {
            this._lastHandledEvent = event;
            (0, _Utils.preventDefault)(event);
        }
    };
    Select.prototype._handleWindowClick = function (event) {
        if (this._isDropdownTarget(event.target) || this._isButtonTarget(event.target)) {
            return;
        }
        this.close();
    };
    Select.prototype._focusOptionStartingWith = function (keycode, startIndex, options) {
        for (var index = startIndex; index < options.length; index++) {
            var item = new _DomElement2.default(options[index]);
            var value = item.innerText.toLowerCase();
            if (index > options.length) {
                index = 0;
            }
            if (value.startsWith(Inputs.getKeyValue(keycode))) {
                var newOption = new _DomElement2.default(options[index]);
                if (!newOption.hasClass(CLASS_ITEM_DISABLED)) {
                    (0, _Utils.scrollIntoView)(options[index]);
                    newOption.addClass(CLASS_ITEM_FOCUSED);
                    return newOption;
                }
            }
        }
        return undefined;
    };
    Select.prototype._handleKeydown = function (event) {
        var keyboardEvent = event;
        var evt = keyboardEvent || window.event;
        var keycode = keyboardEvent.which || keyboardEvent.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            if (this.isOpen()) {
                this.close();
            }
            evt.preventDefault();
            return;
        }
        if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN) {
            // Up and down arrows
            var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
            if (options.length > 0) {
                var newIndex = 0;
                var oldOption = void 0;
                var focusedElement = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);
                var searchFor = focusedElement ? CLASS_ITEM_FOCUSED : CLASS_ITEM_SELECTED;
                var newElement = void 0;
                for (var index = 0; index < options.length; index++) {
                    var direction = keycode === Inputs.KEY_ARROW_DOWN ? 1 : -1;
                    var item = new _DomElement2.default(options[index]);
                    // search for selected or focusedElement elements
                    if (item.hasClass(searchFor)) {
                        oldOption = item;
                        newIndex = index;
                        // get the next not disabled element in the appropriate direction
                        for (var count = 0; count < options.length; count++) {
                            newIndex += direction;
                            newIndex %= options.length;
                            if (newIndex < 0) {
                                newIndex = options.length - 1;
                            }
                            newElement = new _DomElement2.default(options[newIndex]);
                            if (!newElement.hasClass(CLASS_ITEM_DISABLED)) {
                                break;
                            }
                        }
                    }
                }
                // set the new element focused
                (0, _Utils.scrollIntoView)(options[newIndex]);
                var newOption = new _DomElement2.default(options[newIndex]);
                newOption.addClass(CLASS_ITEM_FOCUSED);
                if (oldOption) {
                    oldOption.removeClass(CLASS_ITEM_FOCUSED);
                }
            }
            evt.preventDefault();
            return;
        }
        if (Inputs.getKeyValue(keycode) && !this._isFilterable()) {
            // Keyboard keys
            var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
            if (options.length > 0) {
                var oldFocusIndex = 0;
                var hasFocusedOption = false;
                for (var index = 0; index < options.length; index++) {
                    var item = new _DomElement2.default(options[index]);
                    if (item.hasClass(CLASS_ITEM_FOCUSED)) {
                        item.removeClass(CLASS_ITEM_FOCUSED);
                        var value = item.innerText.toLowerCase();
                        if (value.startsWith(Inputs.getKeyValue(keycode))) {
                            hasFocusedOption = true;
                            oldFocusIndex = index;
                        }
                    }
                }
                var newOption = this._focusOptionStartingWith(keycode, hasFocusedOption ? oldFocusIndex + 1 : 0, options);
                if (newOption === undefined) {
                    this._focusOptionStartingWith(keycode, 0, options);
                }
            }
            evt.preventDefault();
            return;
        }
        if (keycode === Inputs.KEY_ENTER || keycode === Inputs.KEY_TAB) {
            // Handle enter and tab key by selecting the currently focused element
            var newItem = this._dropdownElement.element.querySelector("." + CLASS_ITEM_FOCUSED);
            this._selectedItemChanged(newItem, true, this._multiselection);
        }
    };
    /**
     * Fired when the user presses a key in the filter field
     */
    Select.prototype._handleFilterKeydown = function (e) {
        var keyboardEvent = e;
        var keycode = keyboardEvent.which || keyboardEvent.keyCode;
        // If the user hits the enter key while filtering and there's a single match, select it
        if (keycode === Inputs.KEY_ENTER) {
            var dropdownElements = this._dropdownElement.element.querySelectorAll("." + CLASS_ITEM);
            if (dropdownElements.length === 1) {
                this._selectedItemChanged(dropdownElements[0], true, this._multiselection);
                e.stopPropagation();
            }
        }
    };
    /**
     * Fired when the user releases a key in the filter field
     */
    Select.prototype._handleFilterKeyup = function (e) {
        var target = e.target;
        // Filter has changed
        if (target.value !== this._activeFilter && target.value !== this._placeholderText && target.value !== this._lastSelectedOption.innerHTML) {
            this._setFilter(target.value);
        }
    };
    /**
     * Fired when the user focusses the filter input field
     */
    Select.prototype._handleFilterFocus = function (e) {
        var target = e.target;
        setTimeout(function () {
            target.select();
        });
    };
    /**
     * Filters the Select by a given filter keyword
     * @param filter Keyword to filter by
     */
    Select.prototype._setFilter = function (filter) {
        if (filter === void 0) {
            filter = "";
        }
        this._activeFilter = filter.length >= this._minFilterLength ? filter : "";
        this.setOptions(this.getInitialOptions());
    };
    /**
     * Resets the filter
     */
    Select.prototype._clearFilter = function () {
        delete this._activeFilter;
        this.setOptions(this.getInitialOptions());
    };
    /**
     * Set new content and reload the Select
     * @param elements Array of new option (or optgroup) elements to display
     */
    Select.prototype.setOptions = function (options) {
        var _this = this;
        this._emptyNode(this.element);
        options.forEach(function (option) {
            _this.element.appendChild(option);
        });
        // Preserve selected value if the selected
        this.element.value = this._lastSelectedOption.value;
        this.reload();
    };
    /**
     * Clear all children of a given node
     * @param node Node
     */
    Select.prototype._emptyNode = function (node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    };
    /**
     * Returns whether an option is a placeholder option
     */
    Select.prototype._isPlaceholder = function (option) {
        return option.hasAttribute("disabled") && option.hasAttribute("selected");
    };
    /**
     * Update placeholder value
     * @param text Content of the placeholder
     */
    Select.prototype._setPlaceholder = function (text) {
        if (this._placeholderElement && text) {
            if (this._isFilterable()) {
                this._placeholderElement.element.value = text;
            } else {
                this._placeholderElement.setHtml(text);
            }
        }
    };
    Object.defineProperty(Select.prototype, "value", {
        /**
         * Gets the value of the currently selected option.
         * If multiple selection is enabled this property returns an array of values.
         */
        get: function get() {
            if (this._multiselection) {
                return this._getSelectedOptions().map(function (x) {
                    return x.value;
                });
            }
            if (this.element.value === "") {
                return null;
            }
            return this.element.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Select.prototype, "disabled", {
        /**
         * Enables or disables the select component depending on the
         * 'value' parameter.
         * @param {value} If true disables the control; false enables it.
         */
        set: function set(value) {
            if (value) {
                this.disable();
            } else {
                this.enable();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reloads the dropdown's option data definitions from the DOM and updates
     * the generated dropdown display items.
     */
    Select.prototype.reload = function () {
        // Remove all existing child elements
        this._emptyNode(this._dropdownElement.element);
        if (this._activeFilter === undefined) {
            // If the user is filtering, let the placeholder "input" alive
            this._setupPlaceholder();
        }
        this._createOptions(this.element);
        this._updateSize();
        this._updateMessage();
        if (!this._isFilterable()) {
            this._updatePlaceholder(!!this.value);
        }
    };
    /**
     * Sets the select control to the enabled state.
     */
    Select.prototype.enable = function () {
        this.element.removeAttribute("disabled");
        this._wrapperElement.removeClass(CLASS_DISABLED);
        window.addEventListener("click", this._windowClickHandler);
        this._wrapperElement.element.addEventListener("click", this._clickHandler);
        this._wrapperElement.element.addEventListener("keydown", this._keydownHandler);
        this._wrapperElement.element.addEventListener("focus", this._focusHandler);
        this._wrapperElement.element.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the select control to the disabled state.
     */
    Select.prototype.disable = function () {
        this.element.setAttribute("disabled", "");
        this._wrapperElement.addClass(CLASS_DISABLED);
        window.removeEventListener("click", this._windowClickHandler);
        this._wrapperElement.element.removeEventListener("click", this._clickHandler);
        this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);
        this._wrapperElement.element.removeEventListener("focus", this._focusHandler);
        this._wrapperElement.element.removeEventListener("blur", this._blurHandler);
        this.close();
    };
    /**
     * Toggles the open/closed state of the select dropdown.
     */
    Select.prototype.toggle = function () {
        if (this.isOpen()) {
            this.close();
        } else {
            this.open();
        }
    };
    /**
     * Gets if the select dropdown is open or closed.
     * @return {boolean} True if open; otherwise false.
     */
    Select.prototype.isOpen = function () {
        return this._wrapperElement.hasClass(CLASS_OPEN);
    };
    /**
     * Opens the select dropdown.
     */
    Select.prototype.open = function () {
        if (!this.isOpen()) {
            this._openByFocus = false;
            this._wrapperElement.removeClass(CLASS_CLOSED);
            this._wrapperElement.addClass(CLASS_OPEN);
            this._dropdownElement.element.addEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.addEventListener("tap", this._handleDropdownClick);
        }
    };
    /**
     * Closes the select dropdown.
     */
    Select.prototype.close = function () {
        if (this.isOpen()) {
            this._openByFocus = false;
            this._wrapperElement.removeClass(CLASS_OPEN);
            this._wrapperElement.addClass(CLASS_CLOSED);
            // If the Select is filterable and therefore has an input field,
            // reset the value of it to the chosen option
            if (this._isFilterable()) {
                // Unfocus input field
                this._placeholderElement.element.blur();
                if (!this._activeFilter || this._activeFilter === this._lastSelectedOption.innerHTML) {
                    this._setPlaceholder(this._lastSelectedOption.innerHTML);
                }
            }
            this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);
            var focusedItem = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);
            if (focusedItem) {
                focusedItem.removeClass(CLASS_ITEM_FOCUSED);
            }
        }
    };
    /**
     * Returns true when the element has the filter modifier class
     */
    Select.prototype._isFilterable = function () {
        return this._wrapperElement.hasClass(CLASS_FILTERABLE);
    };
    /**
     * Destroys the component and clears all references.
     */
    Select.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        if (this._dropdownElement) {
            this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);
            (0, _Utils.remove)(this._dropdownElement.element);
            this._dropdownElement = undefined;
        }
        if (this._placeholderElement) {
            this._placeholderElement.removeEventListener("keydown", this._filterKeydownHandler);
            this._placeholderElement.removeEventListener("keyup", this._filterKeyupHandler);
            this._placeholderElement.removeEventListener("focus", this._filterFocusHandler);
        }
        if (this._wrapperElement) {
            this._wrapperElement.element.removeEventListener("click", this._clickHandler);
            this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);
            this._wrapperElement.element.removeEventListener("focus", this._focusHandler);
            this._wrapperElement.element.removeEventListener("blur", this._blurHandler);
            this._wrapperElement = undefined;
        }
        if (this._selectButtonElement) {
            (0, _Utils.remove)(this._selectButtonElement.element);
            this._selectButtonElement = undefined;
        }
        this.removeClass(CLASS_CLOSED);
    };
    return Select;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("select", function (e) {
        new Select(e);
    });
}
exports.default = Select;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"tslib":135}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _maxSafeInteger = require("babel-runtime/core-js/number/max-safe-integer");

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_TEXTAREA = "textarea";
var CLASS_HAS_VALUE = "is-fixed";
/**
 * Textarea component
 */
var Textarea = /** @class */function (_super) {
    tslib_1.__extends(Textarea, _super);
    function Textarea(element) {
        var _this = _super.call(this, element) || this;
        _this._area = _this.element.querySelector(QUERY_TEXTAREA);
        _this._focusChangedHandler = _this._focusChanged.bind(_this);
        _this._valueChangedHandler = _this._onValueChanged.bind(_this);
        _this._resizeHandler = _this._updateHeight.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the textarea component.
     * @private
     */
    Textarea.prototype._initialize = function () {
        this._minRows = parseInt(this._area.getAttribute("data-min-rows") || "3", 10);
        this._maxRows = parseInt(this._area.getAttribute("data-max-rows"), 10) || _maxSafeInteger2.default;
        // Make sure min an max are property specified
        this._minRows = Math.min(this._minRows, this._maxRows);
        this._maxRows = Math.max(this._minRows, this._maxRows);
        this._lineHeight = parseInt(Dom.css(this._area, "line-height"), 10);
        this._updateBaseHeight = Dom.isHidden(this._area, true);
        this._calculateBaseHeight();
        // add event listeners
        this._area.addEventListener("focus", this._focusChangedHandler);
        this._area.addEventListener("blur", this._focusChangedHandler);
        this._area.addEventListener("input", this._valueChangedHandler);
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
        this._onValueChanged();
    };
    Textarea.prototype._calculateBaseHeight = function () {
        // temporary clear the content to take measurements
        var value = this._area.value;
        this._area.value = "";
        this._baseHeight = this._area.offsetHeight - this._lineHeight;
        this._baseScrollHeight = this._area.scrollHeight - this._lineHeight;
        // restore initial content
        this._area.value = value;
    };
    Textarea.prototype._focusChanged = function () {
        this._updateHeight();
    };
    Textarea.prototype._updateHeight = function () {
        var hasFocus = this._area === document.activeElement;
        var maxRows,
            rows = 0;
        if (this._updateBaseHeight === true && Dom.isHidden(this._area, true) === false) {
            this._calculateBaseHeight();
            this._updateBaseHeight = false;
        }
        // Calculate the apropriate size for the control
        if (!this._hasValue()) {
            // Handle empty states
            rows = hasFocus === true ? this._minRows : 1;
            maxRows = rows;
        } else {
            // Reset the height for calculation of the row count
            this._area.style.height = "auto";
            // Get the new height
            rows = Math.ceil((this._area.scrollHeight - this._baseScrollHeight) / this._lineHeight) + 1;
            maxRows = Math.max(Math.min(this._maxRows, rows), this._minRows);
        }
        if (rows > this._maxRows) {
            this._area.style.overflow = "auto";
        } else {
            this._area.style.overflow = "hidden";
        }
        var height = (maxRows - 1) * this._lineHeight + this._baseHeight;
        this._area.style.height = height + "px";
    };
    Textarea.prototype._hasValue = function () {
        return this._area.value && this._area.value.length > 0;
    };
    Textarea.prototype._onValueChanged = function () {
        if (this._hasValue()) {
            Dom.addClass(this._area, CLASS_HAS_VALUE);
        } else {
            Dom.removeClass(this._area, CLASS_HAS_VALUE);
            this._area.value = "";
        }
        this._updateHeight();
    };
    /**
     * Destroys the component and clears all references.
     */
    Textarea.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this._area.removeEventListener("focus", this._focusChangedHandler);
        this._area.removeEventListener("blur", this._focusChangedHandler);
        this._area.removeEventListener("input", this._valueChangedHandler);
        this._focusChangedHandler = null;
        this._valueChangedHander = null;
        this._area = null;
        this._minRows = null;
        this._maxRows = null;
        this._lineHeight = null;
        this._baseHeight = null;
        this._baseScrollHeight = null;
        this.element = null;
    };
    return Textarea;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".input-multiline, .input-field--multiline", function (e) {
        new Textarea(e);
    });
}
exports.default = Textarea;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"babel-runtime/core-js/number/max-safe-integer":40,"tslib":135}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Loader bar component
 */
var LoaderBar = /** @class */function (_super) {
    tslib_1.__extends(LoaderBar, _super);
    /**
     * Creates and initializes the LoaderBar component.
     * @param {Element} - The root element of the LoaderBar component.
     */
    function LoaderBar(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    LoaderBar.prototype._initialize = function () {
        this.progressElement = this.find(".indicator") || this;
        this.fileNameElement = this.find(".detail > .name");
        this.progressLabelElement = this.find(".progress");
        this.totalProgressElement = this.find(".progress > .file-size");
    };
    Object.defineProperty(LoaderBar.prototype, "progress", {
        /**
         * Gets the current progress value in the range of 0..1.
         */
        get: function get() {
            return this.value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 0..1.
         */
        set: function set(val) {
            // val = clamp(val, 0, 1)
            var percentage = (val * 100).toFixed(0);
            this.value = val;
            this.element.value = String(val);
            this.progressElement.setAttribute("style", "width: " + val * 100 + "%");
            if (this.progressLabelElement) {
                this.progressLabelElement.element.textContent = percentage + "%";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderBar.prototype, "filename", {
        /**
         * Gets the filename.
         * @returns {string} - The filename.
         */
        get: function get() {
            if (!this.fileNameElement) {
                return undefined;
            }
            return this.fileNameElement.element.innerHTML;
        },
        /**
         * Sets the filename.
         */
        set: function set(val) {
            if (!this.fileNameElement) {
                throw new Error("Cannot set the filename, missing detail element");
            }
            this.fileNameElement.setHtml(val || "");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderBar.prototype, "fileSize", {
        /**
         * Sets the file size label.
         */
        set: function set(val) {
            if (!this.totalProgressElement) {
                throw new Error("Cannot set the fileSize, missing detail element");
            }
            this.totalProgressElement.setHtml(val);
        },
        enumerable: true,
        configurable: true
    });
    return LoaderBar;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".loader-bar", function (e) {
        new LoaderBar(e);
    });
}
exports.default = LoaderBar;

},{"../DomElement":5,"../Utils":8,"tslib":135}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _popper = require("popper.js");

var _popper2 = _interopRequireDefault(_popper);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_MENU = "js-flyout";
var CLASS_TABS = "tabs";
var ANIMATION_OPEN = 300;
/**
 * A component for the flyout menu.
 */
var MenuFlyout = /** @class */function (_super) {
    tslib_1.__extends(MenuFlyout, _super);
    /**
     * Creates and initializes the flyout component.
     * @param element - The root element of the flyout menu component.
     */
    function MenuFlyout(element) {
        var _this = _super.call(this, element) || this;
        _this._animationDuration = ANIMATION_OPEN;
        _this._dynamicPlacement = false;
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the flyout component.
     * @private
     */
    MenuFlyout.prototype._initialize = function () {
        var dataTarget = this.element.getAttribute("data-target");
        if (dataTarget === null || dataTarget === "") {
            /* tslint:disable:no-console */
            console.error("A flyout menu element requires a 'data-target' that specifies the element to collapse");
            console.info(this.element);
            /* tslint:enable:no-console */
            return;
        }
        if (this._useDynamicPlacement()) {
            this._dynamicPlacement = true;
        }
        var hiddenTarget = this.element.getAttribute("data-hidden");
        if (hiddenTarget !== null && hiddenTarget !== "") {
            this._hiddenIndicator = document.querySelector(hiddenTarget) || undefined;
        }
        this._initFlyoutElement(dataTarget);
        this.element.addEventListener("click", this._clickHandler);
    };
    MenuFlyout.prototype._initFlyoutElement = function (dataTarget) {
        this._flyoutElement = document.querySelector(dataTarget);
        this._flyoutElement.style.opacity = "0";
        this._flyoutElement.style.transform = "translateY(-20px)";
    };
    MenuFlyout.prototype._handleClick = function () {
        this.toggle();
    };
    MenuFlyout.prototype._handleWindowClick = function (event) {
        var target = event.target;
        if ((0, _DomFunctions.parentWithClass)(target, CLASS_MENU) === this._flyoutElement) {
            return false;
        }
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    MenuFlyout.prototype._useDynamicPlacement = function () {
        return (0, _DomFunctions.parentWithClass)(this.element, CLASS_TABS);
    };
    MenuFlyout.prototype._openMenu = function (el) {
        _animejs2.default.remove(el);
        if (this._dynamicPlacement === true) {
            var popperOptions = {
                placement: "bottom",
                modifiers: {
                    flip: {
                        enabled: false
                    }
                },
                eventsEnabled: false
            };
            this._popperInstance = new _popper2.default(this.element, this._flyoutElement, popperOptions);
        }
        (0, _animejs2.default)({
            targets: el,
            duration: this._animationDuration,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            opacity: 1,
            translateY: "0px",
            begin: function begin() {
                el.style.display = "block";
            },
            complete: function complete() {
                (0, _DomFunctions.addClass)(el, CLASS_OPEN);
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "true");
        this.dispatchEvent("opened");
    };
    MenuFlyout.prototype._closeMenu = function (el) {
        _animejs2.default.remove(el);
        if (this._popperInstance) {
            this._popperInstance.destroy();
            this._popperInstance = undefined;
        }
        (0, _animejs2.default)({
            targets: el,
            duration: this._animationDuration,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            opacity: 0,
            translateY: "-20px",
            complete: function complete() {
                el.style.display = "none";
                (0, _DomFunctions.removeClass)(el, CLASS_OPEN);
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "false");
        this.dispatchEvent("closed");
    };
    Object.defineProperty(MenuFlyout.prototype, "animationDuration", {
        /**
         * Sets the opening animation duration.
         * @param {durationInSeconds} - The animation duration in seconds.
         */
        set: function set(durationInSeconds) {
            this._animationDuration = durationInSeconds;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens the flyout menu.
     * @fires Modal#opened
     */
    MenuFlyout.prototype.open = function () {
        var _this = this;
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === true) {
            return;
        }
        (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
        this._openMenu(this._flyoutElement);
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
        }, 50);
    };
    /**
     * Closes the flyout menu.
     * @fires Modal#closed
     */
    MenuFlyout.prototype.close = function () {
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            return;
        }
        (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        this._closeMenu(this._flyoutElement);
    };
    /**
     * Toggles the flyout menu.
     * @fires Modal#opened
     * @fires Modal#closed
     */
    MenuFlyout.prototype.toggle = function () {
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            this.open();
        } else {
            this.close();
        }
    };
    /**
     * Removes all event handlers and clears references.
     */
    MenuFlyout.prototype.destroy = function () {
        this._flyoutElement = null;
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        if (this._clickHandler) {
            this.element.removeEventListener("click", this._clickHandler);
        }
        if (this._popperInstance) {
            this._popperInstance.destroy();
            this._popperInstance = undefined;
        }
        this._clickHandler = null;
        this._windowClickHandler = null;
        this.element = null;
    };
    return MenuFlyout;
}(_DomElement2.default);
function init() {
    var e_1, _a;
    var elements = document.querySelectorAll("[data-toggle='flyout']");
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            if (e.getAttribute("data-init") === "auto") {
                new MenuFlyout(e);
            }
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
}
exports.default = MenuFlyout;

},{"../DomElement":5,"../DomFunctions":6,"animejs":35,"popper.js":134,"tslib":135}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _bodyScrollLock = require("body-scroll-lock");

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BACKDROP = "backdrop";
var CLASS_BACKDROP_OPEN = "backdrop--open";
var CLASS_OPEN = "modal--open";
var CLASS_TRIGGER = "modal-trigger";
var CLASS_BODY = "modal__body";
var CLASS_BUTTONS_OKAY = ".modal-close";
var CLASS_BUTTONS_CLOSE = ".modal-cancel";
/**
 * A component to open and close modal dialogs. It also handles cancellation and makes
 * sure that the modal background is present in the DOM.
 */
var Modal = /** @class */function (_super) {
    tslib_1.__extends(Modal, _super);
    function Modal(element) {
        var _this = _super.call(this, element) || this;
        _this._okayHandler = _this.close.bind(_this);
        _this._cancelHandler = _this._handleClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the range modal component.
     * @private
     */
    Modal.prototype._initialize = function () {
        // Create the backdrop
        this._backdrop = new _DomElement2.default("div").addClass(CLASS_BACKDROP);
        this._backdropParent = (0, _DomFunctions.getRootElement)();
        this._subscribeToTrigger();
    };
    Modal.prototype._subscribeToTrigger = function () {
        var e_1, _a;
        var triggerId = this.element.id;
        if (!triggerId) {
            return;
        }
        this._triggerClickHandler = this.open.bind(this);
        var triggerElements = document.querySelectorAll("." + CLASS_TRIGGER + "[href=" + triggerId + "]");
        try {
            for (var triggerElements_1 = tslib_1.__values(triggerElements), triggerElements_1_1 = triggerElements_1.next(); !triggerElements_1_1.done; triggerElements_1_1 = triggerElements_1.next()) {
                var triggerElement = triggerElements_1_1.value;
                triggerElement.addEventListener("click", this._triggerClickHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (triggerElements_1_1 && !triggerElements_1_1.done && (_a = triggerElements_1.return)) _a.call(triggerElements_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Modal.prototype._unsubscribeFromTrigger = function () {
        var e_2, _a;
        var triggerId = this.element.id;
        if (!triggerId) {
            return;
        }
        var triggerElements = document.querySelectorAll("." + CLASS_TRIGGER + "[href=" + triggerId + "]");
        try {
            for (var triggerElements_2 = tslib_1.__values(triggerElements), triggerElements_2_1 = triggerElements_2.next(); !triggerElements_2_1.done; triggerElements_2_1 = triggerElements_2.next()) {
                var triggerElement = triggerElements_2_1.value;
                triggerElement.removeEventListener("click", this._windowClickHandler);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (triggerElements_2_1 && !triggerElements_2_1.done && (_a = triggerElements_2.return)) _a.call(triggerElements_2);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._triggerClickHandler = undefined;
    };
    Modal.prototype._handleKeydown = function (event) {
        var keyboardEvent = event;
        var keycode = keyboardEvent.which || keyboardEvent.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            this.cancel();
            return;
        }
    };
    Modal.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.cancel();
    };
    Modal.prototype._close = function () {
        var e_3, _a, e_4, _b;
        var _this = this;
        (0, _bodyScrollLock.enableBodyScroll)(this.element);
        document.removeEventListener("keydown", this._keydownHandler);
        this._backdrop.element.removeEventListener("click", this._cancelHandler);
        this._backdrop.removeClass(CLASS_BACKDROP_OPEN);
        this.removeClass(CLASS_OPEN);
        try {
            for (var _c = tslib_1.__values(this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var closeButton = _d.value;
                closeButton.removeEventListener("click", this._cancelHandler);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        try {
            for (var _e = tslib_1.__values(this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var okayButton = _f.value;
                okayButton.removeEventListener("click", this._okayHandler);
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        setTimeout(function () {
            // remove the backdrop from the body
            _this._backdropParent.removeChild(_this._backdrop.element);
        }, 300);
    };
    /**
     * Opens the modal dialog.
     * @fires Modal#opened
     */
    Modal.prototype.open = function () {
        var _this = this;
        (0, _bodyScrollLock.disableBodyScroll)(this.element, {
            allowTouchMove: function allowTouchMove(el) {
                var currentEl = el;
                while (currentEl && currentEl !== document.body) {
                    // Check if the user is scrolling the modal body
                    if (currentEl.classList.contains(CLASS_BODY)) {
                        // Check if the element overflows
                        if (currentEl.scrollHeight > currentEl.clientHeight) {
                            return true;
                        }
                    }
                    currentEl = currentEl.parentNode;
                }
                return false;
            }
        });
        // add the backdrop to the body
        this._backdropParent.appendChild(this._backdrop.element);
        // set the element to flex as it is initially hidden
        this.element.style.display = "flex";
        // remove the style after the animation completes
        setTimeout(function () {
            _this.element.style.display = "";
        }, 800);
        // wait a bit to allow the browser to catch up and show the animation
        setTimeout(function () {
            var e_5, _a, e_6, _b;
            _this.addClass(CLASS_OPEN);
            _this._backdrop.addClass(CLASS_BACKDROP_OPEN);
            document.addEventListener("keydown", _this._keydownHandler);
            _this._backdrop.element.addEventListener("click", _this._cancelHandler);
            try {
                for (var _c = tslib_1.__values(_this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var closeButton = _d.value;
                    closeButton.addEventListener("click", _this._cancelHandler);
                }
            } catch (e_5_1) {
                e_5 = { error: e_5_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_5) throw e_5.error;
                }
            }
            try {
                for (var _e = tslib_1.__values(_this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var okayButton = _f.value;
                    okayButton.addEventListener("click", _this._okayHandler);
                }
            } catch (e_6_1) {
                e_6 = { error: e_6_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                    if (e_6) throw e_6.error;
                }
            }
            _this.element.addEventListener("click", function (e) {
                return e.stopPropagation();
            });
            _this.dispatchEvent("opened");
        }, 50);
    };
    /**
     * Cancels (and closes) the modal dialog.
     * @fires Modal#cancelled
     * @fires Modal#closed
     */
    Modal.prototype.cancel = function () {
        this.dispatchEvent("cancelled");
        this._close();
    };
    /**
     * Closes the modal dialog.
     * @fires Modal#closed
     */
    Modal.prototype.close = function () {
        this._close();
        this.dispatchEvent("closed");
    };
    /**
     * Destroys the component and frees all references.
     */
    Modal.prototype.destroy = function () {
        this.cancel();
        this._unsubscribeFromTrigger();
    };
    return Modal;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".modal", function (e) {
        new Modal(e);
    });
}
exports.default = Modal;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"body-scroll-lock":45,"tslib":135}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

var _SearchInput = require("../search/SearchInput");

var _SearchInput2 = _interopRequireDefault(_SearchInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";
var QUERY_NAV_HAMBURGER = ".nav-hamburger";
var QUERY_NAV_HB_BODY = ".nav__primary";
var CLASS_NAV_LINK = "nav-link--header";
var QUERY_NAV_LINK_ACTIVE = ".nav-link--header.is-active";
var QUERY_NAV_MOBILE = ".nav__level1 .nav__mainnav .nav__primary";
var QUERY_NAV_LEVEL0 = ".nav__level0";
var QUERY_NAV_LEVEL0_CONTAINER = ".nav__level0 .nav__subnav";
var QUERY_SECTION_OPEN = ".nav-section.is-open";
var QUERY_NAV_LEVEL1 = ".nav__level1 .nav__mainnav";
var QUERY_NAV_LEVEL0_LINK = ".nav-link.nav-link--header";
var QUERY_NAV_LEVEL1_LINK = ".nav-link--header";
var QUERY_NAV_COLUMN = ".nav-col";
var QUERY_NAV_COLUMN_ACTIVE = ".nav-col.is-active";
var QUERY_NAV_BODY = ".nav-body";
var QUERY_NAV_FOOTER = ".nav-footer";
var QUERY_SEARCH_ICON = ".nav-search";
var QUERY_SEARCH_FIELD = ".search__input";
var CLASS_SEARCH_DESKTOP = "search--desktop";
var ANIMATION_START_DELAY = 200;
var ANIMATION_OFFSET = 50;
var ANIMATION_BODY_DURATION = 300;
var ANIMATION_FOOTER_DURATION = 100;
/**
 * The navigation component definition.
 */
var Navigation = /** @class */function (_super) {
    tslib_1.__extends(Navigation, _super);
    function Navigation(element) {
        var _this = _super.call(this, element) || this;
        _this.animation = _animejs2.default.timeline();
        _this._navLevel0 = _this.element.querySelector(QUERY_NAV_LEVEL0) || document.createElement("div");
        _this._navLevel0Body = _this.element.querySelector(QUERY_NAV_LEVEL0_CONTAINER) || document.createElement("div");
        _this._navLevel1 = _this.element.querySelector(QUERY_NAV_LEVEL1) || document.createElement("div");
        _this._navMobile = _this.element.querySelector(QUERY_NAV_MOBILE) || document.createElement("div");
        if (!_this._navMobile.parentElement) {
            var dummyParent = document.createElement("div");
            dummyParent.appendChild(_this._navMobile);
        }
        _this._hamburgerElement = _this.element.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
        _this._searchComponents = [];
        _this._level0ClickHandler = _this._handleLevel0Click.bind(_this);
        _this._level1ClickHandler = _this._handleLevel1Click.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._searchClickHandler = _this._handleSearchClick.bind(_this);
        _this._initialize();
        return _this;
    }
    Navigation.prototype._resetMainTimeline = function () {
        var e_1, _a;
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i] = arguments[_i];
        }
        this.animation.pause();
        try {
            for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
                var el = elements_1_1.value;
                _animejs2.default.remove(el);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this.animation = _animejs2.default.timeline();
    };
    Navigation.prototype._isMobile = function () {
        return Dom.isHidden(this._hamburgerElement, true) === false;
    };
    Navigation.prototype._handleLevel0Click = function (event) {
        var isDesktop = !this._isMobile();
        if (isDesktop) {
            var navItems = new NavigationItems(this).fromLevel0(event.target);
            if (!navItems.section) {
                return;
            }
            var previousNavLink = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);
            var previousNavSection = this._navLevel0.querySelector(QUERY_SECTION_OPEN);
            this._toggleContainer(navItems.link, this._navLevel0Body, navItems.section, undefined, previousNavLink, this._navLevel0Body, previousNavSection, undefined, true);
        }
    };
    Navigation.prototype._handleLevel1Click = function (event) {
        var navItems = new NavigationItems(this).fromLevel1(event.target);
        var prevItems = navItems.previousLevel1();
        this._toggleContainer(navItems.link, navItems.container, navItems.section, navItems.footer, prevItems.link, prevItems.container, prevItems.section, prevItems.footer, false);
        return false;
    };
    Navigation.prototype._toggleContainer = function (navLink, navContainer, navSection, navFooter, previousNavLink, previousNavContainer, previousNavSection, previousNavFooter, animateContainer) {
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        var isDesktop = !this._isMobile();
        if (previousNavLink && previousNavLink !== navLink && navLink !== this._hamburgerElement) {
            Dom.removeClass(previousNavLink, CLASS_ACTIVE);
        }
        this._resetMainTimeline(navContainer, navSection, navFooter, previousNavContainer, previousNavSection, previousNavFooter);
        if (Dom.hasClass(navLink, CLASS_ACTIVE)) {
            Dom.removeClass(navLink, CLASS_ACTIVE);
            if (isDesktop) {
                this._onNavigationClosed();
                this._closeSection(navContainer, navSection, navFooter, true, animateContainer);
            } else if (navLink === this._hamburgerElement) {
                // Close mobile navigation
                this._onNavigationClosed();
                this._closeSection(navContainer, navSection, undefined, false, false);
            } else if (!isDesktop) {
                // Close the section
                this._closeSection(navContainer, navSection, navFooter, true, animateContainer);
            }
        } else {
            Dom.addClass(navLink, CLASS_ACTIVE);
            if (isDesktop) {
                Dom.addClass(this._navMobile, CLASS_OPEN);
                this._onNavigationOpened();
                if (previousNavContainer && previousNavSection) {
                    this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, true, animateContainer);
                }
                this._openSection(navContainer, navSection, navFooter, true, animateContainer);
            } else if (navLink === this._hamburgerElement) {
                // Open mobile navigation
                this._onNavigationOpened();
                this._openSection(navContainer, navSection, undefined, false, false);
            } else if (!isDesktop) {
                // Open section
                if (previousNavContainer && previousNavSection) {
                    this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, true, animateContainer);
                    this.animation = _animejs2.default.timeline();
                }
                this._openSection(navContainer, navSection, navFooter, true, animateContainer);
            }
        }
    };
    Navigation.prototype._onNavigationOpened = function () {
        Dom.addClass(this._navMobile, CLASS_OPEN);
        Dom.addClass(this._navMobile.parentElement, CLASS_OPEN);
        Dom.addClass(this._hamburgerElement, CLASS_ACTIVE);
        window.addEventListener("click", this._windowClickHandler);
        window.addEventListener("touchend", this._windowClickHandler);
    };
    Navigation.prototype._onNavigationClosed = function () {
        Dom.removeClass(this._navMobile, CLASS_OPEN);
        Dom.removeClass(this._navMobile.parentElement, CLASS_OPEN);
        Dom.removeClass(this._hamburgerElement, CLASS_ACTIVE);
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
    };
    Navigation.prototype._handleWindowClick = function (event) {
        var target = event.target;
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    Navigation.prototype._openSection = function (navContainer, navSection, navFooter, animateColumns, animateContainer) {
        var e_2, _a, e_3, _b;
        if (animateColumns === void 0) {
            animateColumns = true;
        }
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        if (!navSection || !navContainer) {
            return;
        }
        var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN);
        if (animateContainer === true) {
            var container = navContainer;
            navContainer = navSection;
            navSection = container;
        }
        Dom.addClass(navContainer, CLASS_OPEN);
        navSection.style.display = "block";
        this.animation.add({
            targets: navSection,
            duration: ANIMATION_BODY_DURATION,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            height: animateContainer ? navContainer.scrollHeight : navSection.scrollHeight,
            complete: function complete() {
                Dom.addClass(navSection, CLASS_OPEN);
                new _DomElement2.default(navSection).setAttribute("style", "");
            }
        });
        if (navFooter) {
            var navItems = navFooter.querySelectorAll(QUERY_NAV_COLUMN);
            try {
                for (var navItems_1 = tslib_1.__values(navItems), navItems_1_1 = navItems_1.next(); !navItems_1_1.done; navItems_1_1 = navItems_1.next()) {
                    var item = navItems_1_1.value;
                    Dom.addClass(item, CLASS_ACTIVE);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (navItems_1_1 && !navItems_1_1.done && (_a = navItems_1.return)) _a.call(navItems_1);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
            navFooter.style.display = "block";
            this.animation.add({
                targets: navFooter,
                duration: ANIMATION_FOOTER_DURATION,
                easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
                height: navFooter.scrollHeight,
                offset: "-=" + ANIMATION_FOOTER_DURATION,
                complete: function complete() {
                    Dom.addClass(navFooter, CLASS_OPEN);
                    new _DomElement2.default(navFooter).setAttribute("style", "");
                }
            });
        }
        if (animateColumns === true) {
            var delay = ANIMATION_START_DELAY;
            var _loop_1 = function _loop_1(item) {
                this_1.animation.add({
                    targets: item,
                    duration: 0,
                    offset: delay,
                    complete: function complete() {
                        Dom.addClass(item, CLASS_ACTIVE);
                    }
                });
                delay += ANIMATION_OFFSET;
            };
            var this_1 = this;
            try {
                for (var activeItems_1 = tslib_1.__values(activeItems), activeItems_1_1 = activeItems_1.next(); !activeItems_1_1.done; activeItems_1_1 = activeItems_1.next()) {
                    var item = activeItems_1_1.value;
                    _loop_1(item);
                }
            } catch (e_3_1) {
                e_3 = { error: e_3_1 };
            } finally {
                try {
                    if (activeItems_1_1 && !activeItems_1_1.done && (_b = activeItems_1.return)) _b.call(activeItems_1);
                } finally {
                    if (e_3) throw e_3.error;
                }
            }
        }
    };
    Navigation.prototype._closeSection = function (navContainer, navSection, navFooter, animateColumns, animateContainer) {
        var e_4, _a, e_5, _b;
        if (animateColumns === void 0) {
            animateColumns = true;
        }
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        if (!navSection || !navContainer) {
            return;
        }
        var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE);
        if (animateContainer === true) {
            var container = navContainer;
            navContainer = navSection;
            navSection = container;
        }
        if (animateColumns === true) {
            try {
                for (var activeItems_2 = tslib_1.__values(activeItems), activeItems_2_1 = activeItems_2.next(); !activeItems_2_1.done; activeItems_2_1 = activeItems_2.next()) {
                    var active = activeItems_2_1.value;
                    Dom.removeClass(active, CLASS_ACTIVE);
                }
            } catch (e_4_1) {
                e_4 = { error: e_4_1 };
            } finally {
                try {
                    if (activeItems_2_1 && !activeItems_2_1.done && (_a = activeItems_2.return)) _a.call(activeItems_2);
                } finally {
                    if (e_4) throw e_4.error;
                }
            }
        }
        this.animation.add({
            targets: navSection,
            duration: ANIMATION_BODY_DURATION,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            height: 0,
            offset: 0,
            complete: function complete() {
                Dom.removeClass(navContainer, CLASS_OPEN);
                Dom.removeClass(navSection, CLASS_OPEN);
                navSection.style.height = "";
            }
        });
        if (navFooter) {
            try {
                for (var _c = tslib_1.__values(navFooter.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var active = _d.value;
                    Dom.removeClass(active, CLASS_ACTIVE);
                }
            } catch (e_5_1) {
                e_5 = { error: e_5_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                } finally {
                    if (e_5) throw e_5.error;
                }
            }
            this.animation.add({
                targets: navFooter,
                duration: ANIMATION_FOOTER_DURATION,
                easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
                height: 0,
                offset: 0,
                complete: function complete() {
                    Dom.removeClass(navFooter, CLASS_OPEN);
                    navFooter.style.height = "";
                }
            });
        }
    };
    Navigation.prototype._handleSearchClick = function () {
        if (this._searchDesktop) {
            this._searchDesktop.open();
        }
    };
    /**
     * Initializes the navigation component.
     * @private
     */
    Navigation.prototype._initialize = function () {
        var e_6, _a, e_7, _b, e_8, _c;
        try {
            for (var _d = tslib_1.__values(this._navLevel0.querySelectorAll(QUERY_NAV_LEVEL0_LINK)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var navLink = _e.value;
                navLink.addEventListener("click", this._level0ClickHandler);
            }
        } catch (e_6_1) {
            e_6 = { error: e_6_1 };
        } finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            } finally {
                if (e_6) throw e_6.error;
            }
        }
        try {
            for (var _f = tslib_1.__values(this._navLevel1.querySelectorAll(QUERY_NAV_LEVEL1_LINK)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var navLink = _g.value;
                navLink.addEventListener("click", this._level1ClickHandler);
            }
        } catch (e_7_1) {
            e_7 = { error: e_7_1 };
        } finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            } finally {
                if (e_7) throw e_7.error;
            }
        }
        this._hamburgerElement.addEventListener("click", this._level1ClickHandler);
        // Desktop search icon
        var searchIcon = this.element.querySelector(QUERY_SEARCH_ICON);
        if (searchIcon) {
            searchIcon.addEventListener("click", this._searchClickHandler);
        }
        try {
            for (var _h = tslib_1.__values(this.element.querySelectorAll(QUERY_SEARCH_FIELD)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var search = _j.value;
                var searchComponent = new _SearchInput2.default(search);
                if (Dom.hasClass(search, CLASS_SEARCH_DESKTOP) || Dom.hasClass(search.parentElement, CLASS_SEARCH_DESKTOP)) {
                    this._searchDesktop = searchComponent;
                }
                this._searchComponents.push(searchComponent);
            }
        } catch (e_8_1) {
            e_8 = { error: e_8_1 };
        } finally {
            try {
                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            } finally {
                if (e_8) throw e_8.error;
            }
        }
    };
    /**
     * Closes the navigation.
     */
    Navigation.prototype.close = function () {
        var isMoble = this._isMobile();
        var level1 = this._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
        var level0 = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);
        if (!level1 && isMoble && Dom.hasClass(this._hamburgerElement, CLASS_ACTIVE)) {
            level1 = this._hamburgerElement;
        }
        var navItems;
        if (level1) {
            navItems = new NavigationItems(this).fromLevel1(level1);
        } else if (level0) {
            navItems = new NavigationItems(this).fromLevel0(level0);
        }
        if (navItems) {
            this._resetMainTimeline(navItems.container, navItems.section, navItems.footer);
            Dom.removeClass(navItems.link, CLASS_ACTIVE);
            this._onNavigationClosed();
            this._closeSection(navItems.container, navItems.section, navItems.footer, !isMoble, false);
        }
    };
    return Navigation;
}(_DomElement2.default);
var NavigationItems = /** @class */function () {
    function NavigationItems(nav) {
        this._navigation = nav;
    }
    Object.defineProperty(NavigationItems.prototype, "link", {
        get: function get() {
            return this._link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "container", {
        get: function get() {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "section", {
        get: function get() {
            return this._section;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "footer", {
        get: function get() {
            return this._footer;
        },
        enumerable: true,
        configurable: true
    });
    NavigationItems.prototype.fromLevel0 = function (navLink) {
        while (!Dom.hasClass(navLink, CLASS_NAV_LINK) && navLink.parentElement) {
            navLink = navLink.parentElement;
        }
        this._link = navLink;
        var toggleId = navLink.getAttribute("data-toggle");
        this._container = this._navigation._navLevel0Body;
        this._section = this._navigation._navLevel0.querySelector("#" + toggleId);
        return this;
    };
    NavigationItems.prototype.fromLevel1 = function (navLink) {
        while (navLink.parentElement) {
            if (navLink === this._navigation._hamburgerElement || Dom.hasClass(navLink, CLASS_NAV_LINK)) {
                break;
            }
            navLink = navLink.parentElement;
        }
        this._link = navLink;
        this._container = navLink.parentElement;
        this._section = this._container.querySelector(QUERY_NAV_BODY);
        this._footer = this._container.querySelector(QUERY_NAV_FOOTER);
        if (navLink === this._navigation._hamburgerElement) {
            this._container = this._navigation._navLevel1;
            this._section = this._container.querySelector(QUERY_NAV_HB_BODY);
        }
        return this;
    };
    NavigationItems.prototype.previousLevel1 = function () {
        var prev = new NavigationItems(this._navigation);
        prev._link = this._navigation._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
        prev._container = prev._link ? prev._link.parentElement : undefined;
        prev._section = prev._container ? prev._container.querySelector(QUERY_NAV_BODY) : undefined;
        prev._footer = prev._container ? prev._container.querySelector(QUERY_NAV_FOOTER) : undefined;
        return prev;
    };
    NavigationItems.prototype.isHamburger = function () {
        return this._link === this._navigation._hamburgerElement;
    };
    return NavigationItems;
}();
function init() {
    (0, _Utils.searchAndInitialize)(".nav", function (e) {
        new Navigation(e);
    });
}
exports.default = Navigation;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"../search/SearchInput":31,"animejs":35,"tslib":135}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomFunctions = require("../DomFunctions");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";
var QUERY_SITE_WRAPPER = ".js-site-wrapper";
var QUERY_NAV_HAMBURGER = ".js-site-wrapper .js-hamburger";
var QUERY_NAV_ITEM = ".js-nav-item";
var NAV_LINK_INITIAL_SCALE = 0.9;
var ANIMATION_DURATION_LINKS = 100;
var ANIMATION_DURATION_NAV = 300;
var ANIMATION_STAGGER_DELAY = 50;
/**
 * The navigation side component definition.
 */
var NavigationSide = /** @class */function (_super) {
    tslib_1.__extends(NavigationSide, _super);
    function NavigationSide(element) {
        var _this = _super.call(this, element) || this;
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._siteWrapper = document.querySelector(QUERY_SITE_WRAPPER);
        _this._hamburgerElement = document.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
        _this._navItems = _this.element.querySelectorAll(QUERY_NAV_ITEM);
        _this._initialize();
        return _this;
    }
    NavigationSide.prototype._initialize = function () {
        this._hamburgerElement.addEventListener("click", this._clickHandler);
        this._hamburgerElement.addEventListener("touchend", this._clickHandler);
    };
    NavigationSide.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.toggle();
    };
    NavigationSide.prototype._handleWindowClick = function (event) {
        var target = event.target;
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    /**
     * Toggles the side navigation.
     */
    NavigationSide.prototype.toggle = function () {
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            this.open();
        } else {
            this.close();
        }
    };
    /**
     * Opens the slide navigation.
     */
    NavigationSide.prototype.open = function () {
        var _this = this;
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
        }, 50);
        (0, _DomFunctions.addClass)(this._hamburgerElement, CLASS_ACTIVE);
        (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
        (0, _DomFunctions.addClass)(this._siteWrapper, CLASS_OPEN);
        var x = _animejs2.default.timeline();
        var off = ANIMATION_DURATION_NAV;
        this._navItems.forEach(function (element) {
            var el = element;
            el.style.opacity = "0";
            el.style.transform = "scale(" + NAV_LINK_INITIAL_SCALE + ")";
            x.add({
                targets: el,
                duration: ANIMATION_DURATION_LINKS,
                opacity: 1,
                scale: 1,
                easing: "linear",
                offset: off
            });
            off += ANIMATION_STAGGER_DELAY;
        });
    };
    /**
     * Closes the side navigation.
     */
    NavigationSide.prototype.close = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        (0, _DomFunctions.removeClass)(this._hamburgerElement, CLASS_ACTIVE);
        (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
        (0, _DomFunctions.removeClass)(this._siteWrapper, CLASS_OPEN);
    };
    /**
     * Destroys the component and removes all event
     * subscriptions and references.
     */
    NavigationSide.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        this._windowClickHandler = null;
        this._clickHandler = null;
        this._siteWrapper = null;
        this._hamburgerElement = null;
        this._navItems = null;
    };
    return NavigationSide;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".nav-side", function (e) {
        new NavigationSide(e);
    });
}
exports.default = NavigationSide;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":35,"tslib":135}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NotificationHeader = undefined;
exports.showOnHeader = showOnHeader;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_NOTIFICATION = "notification-header";
var CLASS_OPEN = "notification--open";
var CLASS_BUTTON_CLOSE = "notification__close";
/**
 * Creates and shows a notification with the specified message.
 * @memberof Notification
 * @param {String} containerId - The id of the container on where to show the notification.
 * @param {String} message - The message to show.
 * @param {Notification~Click} messageClickCallback - The callback that gets called when the user clicks on the notification message text.
 * @param {Notification~Cancel} cancelCallback - The callback that gets called when the user cancels the notification by closing it.
 * @param {String} modifierClass - The css modifier class for the notification; this is an optional parameter
 * @returns {NotificationHeader} The notification header item instance.
 */
function showOnHeader(containerId, message, messageClickCallback, cancelCallback, modifierClass) {
    var containerE = document.querySelector("#" + containerId);
    if (!containerE) {
        throw new Error("Could not find the container with id " + containerId);
    }
    var containerElement = new _DomElement2.default(containerE);
    var notificationElement = new NotificationHeader();
    if (modifierClass) {
        notificationElement.addClass(modifierClass);
    }
    notificationElement.message = message;
    notificationElement.messageClickCallback = messageClickCallback;
    notificationElement.cancelCallback = cancelCallback;
    containerElement.appendChild(notificationElement);
    notificationElement._open();
    return notificationElement;
}
/**
 * A component for displaying notifications on the page-header.
 * @inner
 * @memberof Notification
 */
var NotificationHeader = /** @class */function (_super) {
    tslib_1.__extends(NotificationHeader, _super);
    function NotificationHeader() {
        var _this = _super.call(this, "div") || this;
        _this._closeHandler = _this._handleClose.bind(_this);
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the range modal component.
     * @private
     */
    NotificationHeader.prototype._initialize = function () {
        this.addClass(CLASS_NOTIFICATION);
        this.addClass(CLASS_OPEN);
        var notificationContent = new _DomElement2.default("div").addClass("notification__content");
        this.appendChild(notificationContent);
        this._notificationBody = new _DomElement2.default("div").addClass("notification__body");
        notificationContent.appendChild(this._notificationBody);
        this._closeButton = new _DomElement2.default("button").addClass(CLASS_BUTTON_CLOSE).addClass("notification-cancel").setAttribute("aria-label", "Close");
        var closeIcon = new _DomElement2.default("i").addClass("icon").addClass("icon-022-close").setAttribute("aria-hidden", "true");
        this._closeButton.appendChild(closeIcon);
        notificationContent.appendChild(this._closeButton);
        this.element.addEventListener("click", this._clickHandler);
    };
    NotificationHeader.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        var closeNotification = true;
        if (this._callback) {
            if (this._callback(this) === false) {
                closeNotification = false;
            }
        }
        if (closeNotification === true) {
            this.close();
        }
    };
    NotificationHeader.prototype._handleClose = function (event) {
        (0, _Utils.preventDefault)(event);
        event.stopPropagation();
        if (this._cancelCallback) {
            this._cancelCallback(this);
        }
        this.close();
    };
    NotificationHeader.prototype._close = function () {
        this.removeClass(CLASS_OPEN);
        this._closeButton.element.removeEventListener("click", this._closeHandler);
        var el = this.element;
        setTimeout(function () {
            // remove the element from the dom
            if (el && el.parentElement) {
                el.parentElement.removeChild(el);
            }
        }, 300);
    };
    // called by showOnHeader
    NotificationHeader.prototype._open = function () {
        this.addClass(CLASS_OPEN);
        this._closeButton.element.addEventListener("click", this._closeHandler);
        this.dispatchEvent("opened");
    };
    Object.defineProperty(NotificationHeader.prototype, "messageClickCallback", {
        set: function set(callback) {
            this._callback = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationHeader.prototype, "cancelCallback", {
        /**
         * Sets the cancel callback function.
         * @param {function} - The callback function to call.
         */
        set: function set(callback) {
            this._cancelCallback = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationHeader.prototype, "message", {
        /**
         * Sets the notification message.
         * @param {String} - The message to set.
         */
        set: function set(value) {
            this._notificationBody.setHtml(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Closes the notification.
     */
    NotificationHeader.prototype.close = function () {
        this._close();
        this.dispatchEvent("closed");
    };
    return NotificationHeader;
}(_DomElement2.default);
exports.NotificationHeader = NotificationHeader;

},{"../DomElement":5,"../Utils":8,"tslib":135}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _sign = require("babel-runtime/core-js/math/sign");

var _sign2 = _interopRequireDefault(_sign);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_HEADER = ".progress-full__bar";
var CLASS_SECTIONS = ".progress-full__sections > span";
var CLASS_SECTION_ACTIVE = "section--active";
var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_CURRENT = "indicator--current";
var CLASS_INDICATOR_COMPLETED = "indicator--completed";
/**
 * Full progress bar component
 */
var ProgressFull = /** @class */function (_super) {
    tslib_1.__extends(ProgressFull, _super);
    /**
     * Creates and initializes the ProgressFull component.
     * @param {DomElement} - The root element of the ProgressFull component.
     */
    function ProgressFull(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    ProgressFull.prototype._initialize = function () {
        this._buttonClickHandler = this._handleButtonClick.bind(this);
        this._keydownHandler = this._handleKeydown.bind(this);
        this._headerElement = this.find(CLASS_HEADER);
        this._pages = this.element.querySelectorAll(CLASS_SECTIONS);
        this._minValue = 1;
        this._value = 1;
        this._total = this._pages.length;
        for (var index = 0; index < this._pages.length; index++) {
            if (this._pages[index].classList.contains(CLASS_SECTION_ACTIVE)) {
                this._value = index + 1;
            }
        }
        this._addIncicators();
        this._update(-1, this._value, false);
        // Apply the tab index
        var tabIndex = this.getAttribute("tabindex");
        if (tabIndex) {
            this.setAttribute("tabindex", "");
            this._headerElement.setAttribute("tabindex", tabIndex);
        }
        this._headerElement.element.addEventListener("click", this._buttonClickHandler);
        this._headerElement.element.addEventListener("keydown", this._keydownHandler);
    };
    ProgressFull.prototype._addIncicators = function () {
        for (var i = this._pages.length - 1; i >= 0; i--) {
            var indicatorElement = new _DomElement2.default("button").addClass(CLASS_INDICATOR).setAttribute("data-value", "" + (i + 1)).setHtml((i + 1).toString());
            this._headerElement.prependChild(indicatorElement);
        }
    };
    ProgressFull.prototype._update = function (oldValue, newValue, animate) {
        if (animate === void 0) {
            animate = true;
        }
        var indicators = this._headerElement.element.childNodes;
        for (var index = 0; index < indicators.length; index++) {
            var indicatorElement = new _DomElement2.default(indicators[index]);
            if (index + 1 < this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_CURRENT).addClass(CLASS_INDICATOR_COMPLETED);
            }
            if (index + 1 === this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).addClass(CLASS_INDICATOR_CURRENT);
            }
            if (index + 1 > this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).removeClass(CLASS_INDICATOR_CURRENT);
            }
        }
        if (oldValue !== newValue) {
            var direction = (0, _sign2.default)(oldValue - newValue);
            if (oldValue > 0 && oldValue !== newValue) {
                var oldSection_1 = new _DomElement2.default(this._pages[oldValue - 1]);
                if (animate) {
                    (0, _animejs2.default)({
                        targets: oldSection_1.element,
                        duration: 300,
                        left: 100 * direction,
                        opacity: 0,
                        easing: "easeInOutQuint",
                        complete: function complete() {
                            oldSection_1.removeClass(CLASS_SECTION_ACTIVE);
                            oldSection_1.setAttribute("style", "");
                        }
                    });
                } else {
                    oldSection_1.removeClass(CLASS_SECTION_ACTIVE);
                    oldSection_1.setAttribute("style", "");
                }
            }
            var newSection_1 = new _DomElement2.default(this._pages[newValue - 1]);
            if (animate) {
                var el = newSection_1.element;
                el.style.left = -100 * direction + "px";
                el.style.opacity = "0";
                newSection_1.addClass(CLASS_SECTION_ACTIVE);
                (0, _animejs2.default)({
                    targets: newSection_1.element,
                    duration: 300,
                    left: 0,
                    opacity: 1,
                    easing: "easeInOutQuint",
                    complete: function complete() {
                        newSection_1.setAttribute("style", "");
                    }
                });
            } else {
                newSection_1.addClass(CLASS_SECTION_ACTIVE);
                newSection_1.setAttribute("style", "");
            }
        }
    };
    ProgressFull.prototype._handleButtonClick = function (event) {
        var element = new _DomElement2.default(event.target);
        if (!element.hasClass(CLASS_INDICATOR)) {
            return;
        }
        var value = element.getAttribute("data-value");
        this.value = parseFloat(value);
    };
    ProgressFull.prototype._handleKeydown = function (event) {
        var keyboardEvent = event;
        var keycode = keyboardEvent.which || keyboardEvent.keyCode;
        if (keycode === Inputs.KEY_ARROW_RIGHT) {
            this.value++;
            (0, _Utils.preventDefault)(keyboardEvent);
            return;
        }
        if (keycode === Inputs.KEY_ARROW_LEFT) {
            this.value--;
            (0, _Utils.preventDefault)(keyboardEvent);
            return;
        }
        if (keycode >= Inputs.KEY_NR_0 && keycode <= Inputs.KEY_NR_9) {
            this.value = keycode - Inputs.KEY_NR_0;
            (0, _Utils.preventDefault)(keyboardEvent);
            return;
        }
    };
    Object.defineProperty(ProgressFull.prototype, "value", {
        /**
         * Gets the current progress value in the range of 1..total.
         */
        get: function get() {
            return this._value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 1..total.
         */
        set: function set(val) {
            var oldValue = this._value;
            this._value = (0, _Utils.clamp)(val, this._minValue, this._total);
            this._update(oldValue, this._value, true);
            this.dispatchEvent("changed");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProgressFull.prototype, "total", {
        /**
         * Gets the total progress value.
         */
        get: function get() {
            return this._total;
        },
        enumerable: true,
        configurable: true
    });
    return ProgressFull;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".progress-full", function (e) {
        new ProgressFull(e);
    });
}
exports.default = ProgressFull;

},{"../DomElement":5,"../Inputs":7,"../Utils":8,"animejs":35,"babel-runtime/core-js/math/sign":37,"tslib":135}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BAR = ".progress-light__bar";
var CLASS_PROGRESS = ".bar__progress";
var CLASS_PROGRESS_COMPLETED = "bar__progress--complete";
var CLASS_TICK = "bar__tick";
var CLASS_PAGE_CURRENT = ".detail__currentpage";
var CLASS_PAGE_TOTAL = ".detail__totalpage";
var CLASS_DISABLED = "arrow--disabled";
var CLASS_BUTTON_LEFT = ".arrow--left";
var CLASS_BUTTON_RIGHT = ".arrow--right";
/**
 * Light progress bar component
 */
var ProgressLight = /** @class */function (_super) {
    tslib_1.__extends(ProgressLight, _super);
    /**
     * Creates and initializes the ProgressLight component.
     * @param {DomElement} - The root element of the ProgressLight component.
     */
    function ProgressLight(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    ProgressLight.prototype._initialize = function () {
        this._buttonClickHandler = this._handleButtonClick.bind(this);
        this._animationCompletedHandler = this._handleAnimationCompleted.bind(this);
        this._barElement = this.find(CLASS_BAR);
        this._progressElement = this.find(CLASS_PROGRESS);
        this._pageCurrentElement = this.find(CLASS_PAGE_CURRENT);
        this._pageTotalElement = this.find(CLASS_PAGE_TOTAL);
        this._buttonLeft = this.find(CLASS_BUTTON_LEFT);
        this._buttonRight = this.find(CLASS_BUTTON_RIGHT);
        this._minValue = 1;
        this._total = Math.max(parseInt(this.getAttribute("total") || "100", 10), this._minValue);
        this._value = (0, _Utils.clamp)(parseInt(this.getAttribute("value") || "1", 10), this._minValue, this._total);
        this._layout();
        this._addTicks();
        this._update(false);
        this.enable();
    };
    ProgressLight.prototype._addTicks = function () {
        for (var i = 1; i < this._total; i++) {
            var position = this._itemWidth * i;
            var tickElement = new _DomElement2.default("div").addClass(CLASS_TICK).setAttribute("style", "left: " + position + "%");
            this._barElement.prependChild(tickElement);
        }
    };
    ProgressLight.prototype._update = function (animate) {
        var _this = this;
        if (animate === void 0) {
            animate = true;
        }
        this._pageCurrentElement.setHtml(this._value.toString());
        this._pageTotalElement.setHtml(this._total.toString());
        var position = this._value * this._itemWidth;
        // Add additional width to the last element to make sure
        // the rounded border on the left is filled as well
        if (this._value === this._total) {
            position += 5;
        }
        if (this._value >= this._total) {
            this._buttonRight.addClass(CLASS_DISABLED);
        } else {
            this._buttonRight.removeClass(CLASS_DISABLED);
        }
        if (this._value <= this._minValue) {
            this._buttonLeft.addClass(CLASS_DISABLED);
        } else {
            this._buttonLeft.removeClass(CLASS_DISABLED);
        }
        var el = this._progressElement.element;
        if (animate) {
            (0, _animejs2.default)({
                targets: this._progressElement.element,
                duration: 200,
                easing: "easeInOutQuint",
                width: this._barElement.element.clientWidth * position / 100,
                complete: function complete() {
                    el.style.width = position + "%";
                    _this._animationCompletedHandler({});
                }
            });
        } else {
            el.style.width = position + "%";
            this._animationCompletedHandler({});
        }
    };
    ProgressLight.prototype._layout = function () {
        this._itemWidth = Math.floor(100 / this._total);
    };
    ProgressLight.prototype._handleButtonClick = function (event) {
        if (event.target === this._buttonLeft.element) {
            this.value = this._value - 1;
        } else if (event.target === this._buttonRight.element) {
            this.value = this._value + 1;
        }
    };
    ProgressLight.prototype._handleAnimationCompleted = function () {
        if (this._value === this._total) {
            this._progressElement.addClass(CLASS_PROGRESS_COMPLETED);
        } else {
            this._progressElement.removeClass(CLASS_PROGRESS_COMPLETED);
        }
    };
    Object.defineProperty(ProgressLight.prototype, "value", {
        /**
         * Gets the current progress value in the range of 1..total.
         */
        get: function get() {
            return this._value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 1..total.
         */
        set: function set(val) {
            this._value = (0, _Utils.clamp)(val, this._minValue, this._total);
            this._update(true);
            this.dispatchEvent("changed");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProgressLight.prototype, "total", {
        /**
         * Gets the total progress value.
         */
        get: function get() {
            return this._total;
        },
        /**
         * Sets the total progress value and updates the UI accordingly.
         * @param {number} - The total progress positive integer value.
         */
        set: function set(value) {
            var e_1, _a;
            if (this._total === value) {
                return;
            }
            this._total = Math.max(value, this._minValue);
            this._value = (0, _Utils.clamp)(this._value, this._minValue, this._total);
            try {
                // Clear the ticks
                for (var _b = tslib_1.__values(this.element.querySelectorAll("." + CLASS_TICK)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var tick = _c.value;
                    this._barElement.element.removeChild(tick);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            this._layout();
            this._addTicks();
            this._update(false);
            this.dispatchEvent("totalchanged");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Enables the component.
     */
    ProgressLight.prototype.enable = function () {
        this._buttonLeft.element.addEventListener("click", this._buttonClickHandler);
        this._buttonRight.element.addEventListener("click", this._buttonClickHandler);
    };
    /**
     * Disables the component.
     */
    ProgressLight.prototype.disable = function () {
        this._buttonLeft.element.removeEventListener("click", this._buttonClickHandler);
        this._buttonRight.element.removeEventListener("click", this._buttonClickHandler);
    };
    return ProgressLight;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".progress-light", function (e) {
        new ProgressLight(e);
    });
}
exports.default = ProgressLight;

},{"../DomElement":5,"../Utils":8,"animejs":35,"tslib":135}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initBarChartVertical = exports.BarChartVertical = exports.initBarChartHorizontal = exports.BarChartHorizontal = exports.initPieChart = exports.PieChart = exports.initTable = exports.Table = exports.initCarousel = exports.Carousel = exports.initEmptyState = exports.EmptyState = exports.initSearchInput = exports.SearchInput = exports.initNavigationSide = exports.NavigationSide = exports.initNavigation = exports.Navigation = exports.initMenuFlyout = exports.MenuFlyout = exports.initAccordion = exports.Accordion = exports.initCollapse = exports.Collapse = exports.Notification = exports.Toolbar = exports.initModal = exports.Modal = exports.initProgressFull = exports.ProgressFull = exports.initProgressLight = exports.ProgressLight = exports.initAutocomplete = exports.Autocomplete = exports.initRange = exports.Range = exports.initSelect = exports.Select = exports.initTextarea = exports.Textarea = exports.initInputField = exports.InputField = exports.initLoaderBar = exports.LoaderBar = exports.utils = undefined;

var _Utils = require("./Utils");

var utils = _interopRequireWildcard(_Utils);

var _LoaderBar = require("./loader/LoaderBar");

var _LoaderBar2 = _interopRequireDefault(_LoaderBar);

var _InputField = require("./form/InputField");

var _InputField2 = _interopRequireDefault(_InputField);

var _Textarea = require("./form/Textarea");

var _Textarea2 = _interopRequireDefault(_Textarea);

var _Select = require("./form/Select");

var _Select2 = _interopRequireDefault(_Select);

var _Range = require("./form/Range");

var _Range2 = _interopRequireDefault(_Range);

var _Autocomplete = require("./form/Autocomplete");

var _Autocomplete2 = _interopRequireDefault(_Autocomplete);

var _ProgressLight = require("./progress/ProgressLight");

var _ProgressLight2 = _interopRequireDefault(_ProgressLight);

var _ProgressFull = require("./progress/ProgressFull");

var _ProgressFull2 = _interopRequireDefault(_ProgressFull);

var _Modal = require("./modal/Modal");

var _Modal2 = _interopRequireDefault(_Modal);

var _Toolbar = require("./toolbar/Toolbar");

var _Toolbar2 = _interopRequireDefault(_Toolbar);

var _Notification = require("./notification/Notification");

var Notification = _interopRequireWildcard(_Notification);

var _Collapse = require("./collapse/Collapse");

var _Collapse2 = _interopRequireDefault(_Collapse);

var _Accordion = require("./accordion/Accordion");

var _Accordion2 = _interopRequireDefault(_Accordion);

var _MenuFlyout = require("./menu/MenuFlyout");

var _MenuFlyout2 = _interopRequireDefault(_MenuFlyout);

var _Navigation = require("./navigation/Navigation");

var _Navigation2 = _interopRequireDefault(_Navigation);

var _NavigationSide = require("./navigation/NavigationSide");

var _NavigationSide2 = _interopRequireDefault(_NavigationSide);

var _SearchInput = require("./search/SearchInput");

var _SearchInput2 = _interopRequireDefault(_SearchInput);

var _EmptyState = require("./empty-states/EmptyState");

var _EmptyState2 = _interopRequireDefault(_EmptyState);

var _Carousel = require("./carousel/Carousel");

var _Carousel2 = _interopRequireDefault(_Carousel);

var _Table = require("./table/Table");

var _Table2 = _interopRequireDefault(_Table);

var _PieChart = require("./charts/PieChart");

var _PieChart2 = _interopRequireDefault(_PieChart);

var _BarChartHorizontal = require("./charts/BarChartHorizontal");

var _BarChartHorizontal2 = _interopRequireDefault(_BarChartHorizontal);

var _BarChartVertical = require("./charts/BarChartVertical");

var _BarChartVertical2 = _interopRequireDefault(_BarChartVertical);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* Form Components */
exports.utils = utils;
exports.LoaderBar = _LoaderBar2.default;
exports.initLoaderBar = _LoaderBar.init;
exports.InputField = _InputField2.default;
exports.initInputField = _InputField.init;
exports.Textarea = _Textarea2.default;
exports.initTextarea = _Textarea.init;
exports.Select = _Select2.default;
exports.initSelect = _Select.init;
exports.Range = _Range2.default;
exports.initRange = _Range.init;
exports.Autocomplete = _Autocomplete2.default;
exports.initAutocomplete = _Autocomplete.init;
exports.ProgressLight = _ProgressLight2.default;
exports.initProgressLight = _ProgressLight.init;
exports.ProgressFull = _ProgressFull2.default;
exports.initProgressFull = _ProgressFull.init;
exports.Modal = _Modal2.default;
exports.initModal = _Modal.init;
exports.Toolbar = _Toolbar2.default;
exports.Notification = Notification;
exports.Collapse = _Collapse2.default;
exports.initCollapse = _Collapse.init;
exports.Accordion = _Accordion2.default;
exports.initAccordion = _Accordion.init;
exports.MenuFlyout = _MenuFlyout2.default;
exports.initMenuFlyout = _MenuFlyout.init;
exports.Navigation = _Navigation2.default;
exports.initNavigation = _Navigation.init;
exports.NavigationSide = _NavigationSide2.default;
exports.initNavigationSide = _NavigationSide.init;
exports.SearchInput = _SearchInput2.default;
exports.initSearchInput = _SearchInput.init;
exports.EmptyState = _EmptyState2.default;
exports.initEmptyState = _EmptyState.init;
exports.Carousel = _Carousel2.default;
exports.initCarousel = _Carousel.init;
exports.Table = _Table2.default;
exports.initTable = _Table.init;
exports.PieChart = _PieChart2.default;
exports.initPieChart = _PieChart.init;
exports.BarChartHorizontal = _BarChartHorizontal2.default;
exports.initBarChartHorizontal = _BarChartHorizontal.init;
exports.BarChartVertical = _BarChartVertical2.default;
exports.initBarChartVertical = _BarChartVertical.init;

},{"./Utils":8,"./accordion/Accordion":9,"./carousel/Carousel":10,"./charts/BarChartHorizontal":11,"./charts/BarChartVertical":12,"./charts/PieChart":14,"./collapse/Collapse":15,"./empty-states/EmptyState":16,"./form/Autocomplete":17,"./form/InputField":18,"./form/Range":19,"./form/Select":20,"./form/Textarea":21,"./loader/LoaderBar":22,"./menu/MenuFlyout":23,"./modal/Modal":24,"./navigation/Navigation":25,"./navigation/NavigationSide":26,"./notification/Notification":27,"./progress/ProgressFull":28,"./progress/ProgressLight":29,"./search/SearchInput":31,"./table/Table":32,"./toolbar/Toolbar":33}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_SEARCH_INPUT = "input.search__field";
var QUERY_BTN_CLOSE = ".search__icon-close";
var QUERY_LIVE_SUGESTIONS = ".js-suggestions";
var QUERY_LIVE_FOOTER = ".js-footer";
var CLASS_ACTIVE = "is-active";
var CLASS_OPEN = "is-open";
var CLASS_SEARCH = "search";
var ANIMATION_SUGGESTIONS_DURATION = 300;
var ANIMATION_FOOTER_DURATION = 100;
var ANIMATION_FOOTER_DELAY = ANIMATION_SUGGESTIONS_DURATION - ANIMATION_FOOTER_DURATION;
/**
 * The search input component definition.
 */
var SearchInput = /** @class */function (_super) {
    tslib_1.__extends(SearchInput, _super);
    function SearchInput(element) {
        var _this = _super.call(this, element) || this;
        _this._isOpen = false;
        _this._input = _this.element.querySelector(QUERY_SEARCH_INPUT);
        _this._form = _this.element.querySelector("form");
        _this._btnClose = _this.element.querySelector(QUERY_BTN_CLOSE);
        var liveSearch = (0, _DomFunctions.getAttributeReference)(_this.element, "data-live");
        if (liveSearch) {
            _this._liveSuggestions = liveSearch.querySelector(QUERY_LIVE_SUGESTIONS) || undefined;
            _this._liveFooter = liveSearch.querySelector(QUERY_LIVE_FOOTER) || undefined;
            if (_this._liveSuggestions) {
                _this._liveContainer = _this._liveSuggestions.parentNode || undefined;
            }
        }
        _this._focusHandler = _this._handleInputFocus.bind(_this);
        _this._blurHandler = _this._handleInputBlur.bind(_this);
        _this._closeHandler = _this.close.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._resizeHandler = _this._handleResize.bind(_this);
        _this._initialize();
        return _this;
    }
    SearchInput.prototype._initialize = function () {
        this._input.addEventListener("focus", this._focusHandler);
        this._input.addEventListener("blur", this._blurHandler);
        if ((0, _Utils.internetExplorerOrEdgeVersion)() > 0) {
            // This is a workaround for IE browsers where a focused
            // input's cursor bleeds trough even if hidden
            window.addEventListener("resize", this._resizeHandler);
            window.addEventListener("orientationchange", this._resizeHandler);
        }
        if (this._btnClose) {
            this._btnClose.addEventListener("click", this._closeHandler);
        }
    };
    SearchInput.prototype._handleInputFocus = function () {
        this.addClass(CLASS_ACTIVE);
    };
    SearchInput.prototype._handleInputBlur = function () {
        this.removeClass(CLASS_ACTIVE);
    };
    SearchInput.prototype._handleWindowClick = function (event) {
        var target = event.target;
        if (!(0, _DomFunctions.parentWithClass)(target, CLASS_SEARCH)) {
            this.close();
            return false;
        }
        return true;
    };
    SearchInput.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            this.close();
            (0, _Utils.preventDefault)(event);
        }
    };
    SearchInput.prototype._handleResize = function () {
        var style = window.getComputedStyle(this.element);
        if (style.display === "none") {
            this._input.blur();
        }
    };
    SearchInput.prototype._resetMainTimeline = function () {
        if (this.animation) {
            this.animation.pause();
        }
        _animejs2.default.remove(this._liveSuggestions);
        _animejs2.default.remove(this._liveFooter);
        this.animation = _animejs2.default.timeline();
    };
    Object.defineProperty(SearchInput.prototype, "value", {
        /**
         * Gets the search input text content.
         * @returns {String} The input text.
         */
        get: function get() {
            return this._input.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens/activates the search input.
     */
    SearchInput.prototype.open = function () {
        var _this = this;
        this.addClass(CLASS_OPEN);
        this._input.focus();
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
            window.addEventListener("keydown", _this._keydownHandler);
        }, 50);
    };
    /**
     * Closes/deactivates the search input.
     */
    SearchInput.prototype.close = function () {
        this._form.reset();
        this.removeClass(CLASS_OPEN);
        this.closeLiveSearch();
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        window.removeEventListener("keydown", this._keydownHandler);
    };
    /**
     * Opens the live search suggestions.
     */
    SearchInput.prototype.openLiveSearch = function () {
        var _this = this;
        if (!this._liveSuggestions || this._isOpen) {
            return;
        }
        this._isOpen = true;
        (0, _DomFunctions.addClass)(this._liveContainer, CLASS_OPEN);
        this._resetMainTimeline();
        this._liveSuggestions.style.display = "block";
        this.animation.add({
            targets: this._liveSuggestions,
            duration: ANIMATION_SUGGESTIONS_DURATION,
            height: this._liveSuggestions.scrollHeight + "px",
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                var domEl = new _DomElement2.default(_this._liveSuggestions);
                domEl.addClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        if (this._liveFooter) {
            this._liveFooter.style.display = "block";
            this.animation.add({
                targets: this._liveFooter,
                duration: ANIMATION_FOOTER_DURATION,
                height: this._liveFooter.scrollHeight + "px",
                easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
                offset: ANIMATION_FOOTER_DELAY,
                complete: function complete() {
                    var domEl = new _DomElement2.default(_this._liveFooter);
                    domEl.addClass(CLASS_OPEN);
                    domEl.setAttribute("style", "");
                }
            });
        }
    };
    /**
     * Closes the live search suggestions.
     */
    SearchInput.prototype.closeLiveSearch = function () {
        var _this = this;
        if (!this._liveSuggestions || !this.isOpen) {
            return;
        }
        this._isOpen = false;
        this._resetMainTimeline();
        this._liveSuggestions.style.display = "block";
        this.animation.add({
            targets: this._liveSuggestions,
            duration: ANIMATION_SUGGESTIONS_DURATION,
            height: 0,
            easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
            complete: function complete() {
                var domEl = new _DomElement2.default(_this._liveSuggestions);
                domEl.removeClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
                (0, _DomFunctions.removeClass)(_this._liveContainer, CLASS_OPEN);
            }
        });
        if (this._liveFooter) {
            this._liveFooter.style.display = "block";
            this.animation.add({
                targets: this._liveFooter,
                duration: ANIMATION_FOOTER_DURATION,
                height: 0,
                easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
                offset: 0,
                complete: function complete() {
                    var domEl = new _DomElement2.default(_this._liveFooter);
                    domEl.removeClass(CLASS_OPEN);
                    domEl.setAttribute("style", "");
                }
            });
        }
    };
    /**
     * Destroys the component and clears all references.
     */
    SearchInput.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        window.removeEventListener("keydown", this._keydownHandler);
        this._input.removeEventListener("focus", this._focusHandler);
        this._input.removeEventListener("blur", this._blurHandler);
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        if (this._btnClose) {
            this._btnClose.removeEventListener("click", this._closeHandler);
        }
        this._input = null;
        this._form = null;
        this._btnClose = null;
        this._focusHandler = null;
        this._blurHandler = null;
        this._closeHandler = null;
        this._windowClickHandler = null;
        this._keydownHandler = null;
        this._liveSuggestions = null;
        this._liveFooter = null;
    };
    /**
     * Determines if the SearchInput is open/visible.
     * @return {Boolean} - True if open; otherwise false.
     */
    SearchInput.prototype.isOpen = function () {
        return this.hasClass(CLASS_OPEN);
    };
    return SearchInput;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".search.search__input", function (e) {
        new SearchInput(e);
    });
}
exports.default = SearchInput;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"animejs":35,"tslib":135}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_HEADER = "thead th";
var CLASS_SORTED_ASCENDING = "js-ascending";
var CLASS_SORTED_DESCENDING = "js-descending";
var CLASS_ARROW = "arrow-icon";
/**
 * The Table component. Adds additional capabilities to standard HTML 5 tables.
 */
var Table = /** @class */function (_super) {
    tslib_1.__extends(Table, _super);
    /**
     * Creates a new instance of the table component.
     */
    function Table(element) {
        var _this = _super.call(this, element) || this;
        _this._headerClickHandler = _this._handleHeaderClick.bind(_this);
        _this._body = _this.element.querySelector("tbody");
        _this._rows = _this._body.getElementsByTagName("tr");
        _this._initialize();
        return _this;
    }
    Table.prototype._initialize = function () {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                if (header.getAttribute("data-type")) {
                    header.addEventListener("click", this._headerClickHandler);
                    var arrowElement = new _DomElement2.default("div").addClass(CLASS_ARROW).element;
                    header.appendChild(arrowElement);
                }
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Table.prototype._handleHeaderClick = function (e) {
        var th = e.target;
        this.sort(th);
    };
    /**
     * Sorts the table according to the specified table header element.
     * The column is sorted ascending by default if no direction is specified and no
     * existing sort order class is found in the markup.
     *
     * If the displayed data is not suitable for sorting `<td/>` elements can define a `data-value` attribute
     * which is then used for the data-source.
     *
     * @param {TableHeader} tableHeader The header element of the row to sort by.
     * @param {Number} direction The direction to sort, `1` for ascending, `-1` for descending order. This parameter is optional.
     * @param {function} equalityComparer The equiality comparer function to compare individual cell values.
     */
    Table.prototype.sort = function (tableHeader, direction, equalityComparer) {
        var e_2, _a;
        if (!tableHeader || tableHeader.tagName !== "TH") {
            throw new Error("The parameter 'tableHeader' must be a valid column header node");
        }
        if (direction !== 1 && direction !== -1 && direction) {
            throw new Error("Parameter out of range, parameter 'direction' with value '" + direction + "' must be either -1, 1 or undefined");
        }
        var columnIndex = tableHeader.cellIndex;
        if (!equalityComparer) {
            var dataType = tableHeader.getAttribute("data-type");
            equalityComparer = this._getComparer(dataType);
        }
        if (columnIndex >= this.element.querySelectorAll(QUERY_HEADER).length) {
            throw new Error("Column out of range");
        }
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                if (header !== tableHeader) {
                    Dom.removeClass(header, CLASS_SORTED_ASCENDING);
                    Dom.removeClass(header, CLASS_SORTED_DESCENDING);
                }
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        if (Dom.hasClass(tableHeader, CLASS_SORTED_ASCENDING)) {
            Dom.removeClass(tableHeader, CLASS_SORTED_ASCENDING);
            Dom.addClass(tableHeader, CLASS_SORTED_DESCENDING);
            direction = direction || -1;
        } else {
            Dom.removeClass(tableHeader, CLASS_SORTED_DESCENDING);
            Dom.addClass(tableHeader, CLASS_SORTED_ASCENDING);
            direction = direction || 1;
        }
        this._quicksort(columnIndex, 0, this._rows.length - 1, direction, equalityComparer);
    };
    Table.prototype._getCell = function (column, row) {
        return this._rows[row].cells[column];
    };
    Table.prototype._getRow = function (row) {
        return this._rows[row];
    };
    Table.prototype._getComparer = function (dataType) {
        switch (dataType) {
            case "number":
                {
                    // parse the string as a number
                    return function (a, b) {
                        return parseFloat(a) - parseFloat(b);
                    };
                }
            default:
                {
                    // compare strings
                    return function (a, b) {
                        if (a < b) {
                            return -1;
                        }
                        if (a > b) {
                            return 1;
                        }
                        return 0;
                    };
                }
        }
    };
    Table.prototype._quicksort = function (column, left, right, direction, equalityComparer) {
        if (direction === void 0) {
            direction = 1;
        }
        if (right - left > 0) {
            var partition = this._partition(column, left, right, direction, equalityComparer);
            if (left < partition - 1) {
                this._quicksort(column, left, partition - 1, direction, equalityComparer);
            }
            if (partition < right) {
                this._quicksort(column, partition, right, direction, equalityComparer);
            }
        }
    };
    Table.prototype._partition = function (column, left, right, direction, equalityComparer) {
        if (direction === void 0) {
            direction = 1;
        }
        var pivot = this._getCell(column, Math.floor((right + left) / 2));
        var i = left;
        var j = right;
        while (i <= j) {
            while (this._equals(this._getCell(column, i), pivot, equalityComparer) * direction < 0) {
                i++;
            }
            while (this._equals(this._getCell(column, j), pivot, equalityComparer) * direction > 0) {
                j--;
            }
            if (i <= j) {
                this._swap(i, j);
                i++;
                j--;
            }
        }
        return i;
    };
    Table.prototype._equals = function (a, b, equalityComparer) {
        var dataA = a.getAttribute("data-value");
        var dataB = b.getAttribute("data-value");
        dataA = dataA || a.textContent || a.innerText;
        dataB = dataB || b.textContent || b.innerText;
        return equalityComparer(dataA, dataB);
    };
    Table.prototype._swap = function (i, j) {
        var tmpNode = this._body.replaceChild(this._getRow(i), this._getRow(j));
        var referenceRow = this._getRow(i);
        if (!referenceRow) {
            this._body.appendChild(tmpNode);
        } else {
            this._body.insertBefore(tmpNode, referenceRow);
        }
    };
    /**
     * Destroys the component and clears all references.
     */
    Table.prototype.destroy = function () {
        var e_3, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                header.removeEventListener("click", this._headerClickHandler);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        this._headerClickHandler = null;
        this._body = null;
        this._rows = null;
    };
    return Table;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("table", function (e) {
        new Table(e);
    });
}
exports.default = Table;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"tslib":135}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_ITEMS = ".toolbar__item";
var CLASS_SHOW = "item--show";
var ANIMATION_START_DELAY = 100;
var ANIMATION_OFFSET = 50;
/**
 * Toolbar component. Use this component to show and hide the
 * individual toolbar items.
 */
var Toolbar = /** @class */function (_super) {
    tslib_1.__extends(Toolbar, _super);
    function Toolbar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Makes the toolbar items visible.
     */
    Toolbar.prototype.show = function () {
        var delay = ANIMATION_START_DELAY;
        var items = this.element.querySelectorAll(CLASS_ITEMS);
        var timeline = _animejs2.default.timeline();
        var _loop_1 = function _loop_1(index) {
            timeline.add({
                targets: items[index],
                duration: 0,
                offset: delay,
                complete: function complete() {
                    items[index].classList.add(CLASS_SHOW);
                }
            });
            delay += ANIMATION_OFFSET;
        };
        for (var index = 0; index < items.length; index++) {
            _loop_1(index);
        }
    };
    /**
     * Hides the toolbar items.
     */
    Toolbar.prototype.hide = function () {
        var delay = ANIMATION_START_DELAY;
        var items = this.element.querySelectorAll(CLASS_ITEMS);
        var timeline = _animejs2.default.timeline();
        var _loop_2 = function _loop_2(index) {
            timeline.add({
                targets: items[index],
                duration: 0,
                offset: delay,
                complete: function complete() {
                    items[index].classList.remove(CLASS_SHOW);
                }
            });
            delay += ANIMATION_OFFSET;
        };
        for (var index = items.length - 1; index >= 0; index--) {
            _loop_2(index);
        }
    };
    /**
     * Toggles the toolbar items visibility.
     */
    Toolbar.prototype.toggle = function () {
        if (this.element.querySelectorAll("." + CLASS_SHOW).length === 0) {
            this.show();
        } else {
            this.hide();
        }
    };
    return Toolbar;
}(_DomElement2.default);
exports.default = Toolbar;

},{"../DomElement":5,"animejs":35,"tslib":135}],34:[function(require,module,exports){
'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * modernizr v3.8.0
 * Build https://modernizr.com/download?-hiddenscroll-touchevents-setclasses-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera
 *  Veeck

 * MIT License
 */

/*
 * Modernizr tests which native CSS3 and HTML5 features are available in the
 * current UA and makes the results available to you in two ways: as properties on
 * a global `Modernizr` object, and as classes on the `<html>` element. This
 * information allows you to progressively enhance your pages with a granular level
 * of control over the experience.
*/

;(function (window, document, undefined) {

  var tests = [];

  /**
   * ModernizrProto is the constructor for Modernizr
   *
   * @class
   * @access public
   */
  var ModernizrProto = {
    // The current version, dummy
    _version: '3.8.0',

    // Any settings that don't work as separate modules
    // can go in here as configuration.
    _config: {
      'classPrefix': '',
      'enableClasses': true,
      'enableJSClass': true,
      'usePrefixes': true
    },

    // Queue of tests
    _q: [],

    // Stub these for people who are listening
    on: function on(test, cb) {
      // I don't really think people should do this, but we can
      // safe guard it a bit.
      // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
      // This is in case people listen to synchronous tests. I would leave it out,
      // but the code to *disallow* sync tests in the real version of this
      // function is actually larger than this.
      var self = this;
      setTimeout(function () {
        cb(self[test]);
      }, 0);
    },

    addTest: function addTest(name, fn, options) {
      tests.push({ name: name, fn: fn, options: options });
    },

    addAsyncTest: function addAsyncTest(fn) {
      tests.push({ name: null, fn: fn });
    }
  };

  // Fake some of Object.create so we can force non test results to be non "own" properties.
  var Modernizr = function Modernizr() {};
  Modernizr.prototype = ModernizrProto;

  // Leak modernizr globally when you `require` it rather than force it here.
  // Overwrite name so constructor name is nicer :D
  Modernizr = new Modernizr();

  var classes = [];

  /**
   * is returns a boolean if the typeof an obj is exactly type.
   *
   * @access private
   * @function is
   * @param {*} obj - A thing we want to check the type of
   * @param {string} type - A string to compare the typeof against
   * @returns {boolean} true if the typeof the first parameter is exactly the specified type, false otherwise
   */
  function is(obj, type) {
    return (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === type;
  }

  ;

  /**
   * Run through all tests and detect their support in the current UA.
   *
   * @access private
   * @returns {void}
   */
  function testRunner() {
    var featureNames;
    var feature;
    var aliasIdx;
    var result;
    var nameIdx;
    var featureName;
    var featureNameSplit;

    for (var featureIdx in tests) {
      if (tests.hasOwnProperty(featureIdx)) {
        featureNames = [];
        feature = tests[featureIdx];
        // run the test, throw the return value into the Modernizr,
        // then based on that boolean, define an appropriate className
        // and push it into an array of classes we'll join later.
        //
        // If there is no name, it's an 'async' test that is run,
        // but not directly added to the object. That should
        // be done with a post-run addTest call.
        if (feature.name) {
          featureNames.push(feature.name.toLowerCase());

          if (feature.options && feature.options.aliases && feature.options.aliases.length) {
            // Add all the aliases into the names list
            for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
              featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
            }
          }
        }

        // Run the test, or use the raw value if it's not a function
        result = is(feature.fn, 'function') ? feature.fn() : feature.fn;

        // Set each of the names on the Modernizr object
        for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
          featureName = featureNames[nameIdx];
          // Support dot properties as sub tests. We don't do checking to make sure
          // that the implied parent tests have been added. You must call them in
          // order (either in the test, or make the parent test a dependency).
          //
          // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
          // hashtag famous last words
          featureNameSplit = featureName.split('.');

          if (featureNameSplit.length === 1) {
            Modernizr[featureNameSplit[0]] = result;
          } else {
            // cast to a Boolean, if not one already or if it doesnt exist yet (like inputtypes)
            if (!Modernizr[featureNameSplit[0]] || Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
              Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
            }

            Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
          }

          classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
        }
      }
    }
  }
  ;

  /**
   * docElement is a convenience wrapper to grab the root element of the document
   *
   * @access private
   * @returns {HTMLElement|SVGElement} The root element of the document
   */
  var docElement = document.documentElement;

  /**
   * A convenience helper to check if the document we are running in is an SVG document
   *
   * @access private
   * @returns {boolean}
   */
  var isSVG = docElement.nodeName.toLowerCase() === 'svg';

  /**
   * setClasses takes an array of class names and adds them to the root element
   *
   * @access private
   * @function setClasses
   * @param {string[]} classes - Array of class names
   */
  // Pass in an and array of class names, e.g.:
  //  ['no-webp', 'borderradius', ...]
  function setClasses(classes) {
    var className = docElement.className;
    var classPrefix = Modernizr._config.classPrefix || '';

    if (isSVG) {
      className = className.baseVal;
    }

    // Change `no-js` to `js` (independently of the `enableClasses` option)
    // Handle classPrefix on this too
    if (Modernizr._config.enableJSClass) {
      var reJS = new RegExp('(^|\\s)' + classPrefix + 'no-js(\\s|$)');
      className = className.replace(reJS, '$1' + classPrefix + 'js$2');
    }

    if (Modernizr._config.enableClasses) {
      // Add the new classes
      if (classes.length > 0) {
        className += ' ' + classPrefix + classes.join(' ' + classPrefix);
      }
      if (isSVG) {
        docElement.className.baseVal = className;
      } else {
        docElement.className = className;
      }
    }
  }

  ;

  /**
   * createElement is a convenience wrapper around document.createElement. Since we
   * use createElement all over the place, this allows for (slightly) smaller code
   * as well as abstracting away issues with creating elements in contexts other than
   * HTML documents (e.g. SVG documents).
   *
   * @access private
   * @function createElement
   * @returns {HTMLElement|SVGElement} An HTML or SVG element
   */
  function createElement() {
    if (typeof document.createElement !== 'function') {
      // This is the case in IE7, where the type of createElement is "object".
      // For this reason, we cannot call apply() as Object is not a Function.
      return document.createElement(arguments[0]);
    } else if (isSVG) {
      return document.createElementNS.call(document, 'http://www.w3.org/2000/svg', arguments[0]);
    } else {
      return document.createElement.apply(document, arguments);
    }
  }

  ;

  /**
   * getBody returns the body of a document, or an element that can stand in for
   * the body if a real body does not exist
   *
   * @access private
   * @function getBody
   * @returns {HTMLElement|SVGElement} Returns the real body of a document, or an
   * artificially created element that stands in for the body
   */
  function getBody() {
    // After page load injecting a fake body doesn't work so check if body exists
    var body = document.body;

    if (!body) {
      // Can't use the real body create a fake one.
      body = createElement(isSVG ? 'svg' : 'body');
      body.fake = true;
    }

    return body;
  }

  ;

  /**
   * injectElementWithStyles injects an element with style element and some CSS rules
   *
   * @access private
   * @function injectElementWithStyles
   * @param {string} rule - String representing a css rule
   * @param {Function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean} the result of the specified callback test
   */
  function injectElementWithStyles(rule, callback, nodes, testnames) {
    var mod = 'modernizr';
    var style;
    var ret;
    var node;
    var docOverflow;
    var div = createElement('div');
    var body = getBody();

    if (parseInt(nodes, 10)) {
      // In order not to give false positives we create a node for each test
      // This also allows the method to scale for unspecified uses
      while (nodes--) {
        node = createElement('div');
        node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
        div.appendChild(node);
      }
    }

    style = createElement('style');
    style.type = 'text/css';
    style.id = 's' + mod;

    // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
    // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
    (!body.fake ? div : body).appendChild(style);
    body.appendChild(div);

    if (style.styleSheet) {
      style.styleSheet.cssText = rule;
    } else {
      style.appendChild(document.createTextNode(rule));
    }
    div.id = mod;

    if (body.fake) {
      //avoid crashing IE8, if background image is used
      body.style.background = '';
      //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
      body.style.overflow = 'hidden';
      docOverflow = docElement.style.overflow;
      docElement.style.overflow = 'hidden';
      docElement.appendChild(body);
    }

    ret = callback(div, rule);
    // If this is done after page load we don't want to remove the body so check if body exists
    if (body.fake) {
      body.parentNode.removeChild(body);
      docElement.style.overflow = docOverflow;
      // Trigger layout so kinetic scrolling isn't disabled in iOS6+
      // eslint-disable-next-line
      docElement.offsetHeight;
    } else {
      div.parentNode.removeChild(div);
    }

    return !!ret;
  }

  ;

  /**
   * testStyles injects an element with style element and some CSS rules
   *
   * @memberOf Modernizr
   * @name Modernizr.testStyles
   * @optionName Modernizr.testStyles()
   * @optionProp testStyles
   * @access public
   * @function testStyles
   * @param {string} rule - String representing a css rule
   * @param {function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean}
   * @example
   *
   * `Modernizr.testStyles` takes a CSS rule and injects it onto the current page
   * along with (possibly multiple) DOM elements. This lets you check for features
   * that can not be detected by simply checking the [IDL](https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Interface_development_guide/IDL_interface_rules).
   *
   * ```js
   * Modernizr.testStyles('#modernizr { width: 9px; color: papayawhip; }', function(elem, rule) {
   *   // elem is the first DOM node in the page (by default #modernizr)
   *   // rule is the first argument you supplied - the CSS rule in string form
   *
   *   addTest('widthworks', elem.style.width === '9px')
   * });
   * ```
   *
   * If your test requires multiple nodes, you can include a third argument
   * indicating how many additional div elements to include on the page. The
   * additional nodes are injected as children of the `elem` that is returned as
   * the first argument to the callback.
   *
   * ```js
   * Modernizr.testStyles('#modernizr {width: 1px}; #modernizr2 {width: 2px}', function(elem) {
   *   document.getElementById('modernizr').style.width === '1px'; // true
   *   document.getElementById('modernizr2').style.width === '2px'; // true
   *   elem.firstChild === document.getElementById('modernizr2'); // true
   * }, 1);
   * ```
   *
   * By default, all of the additional elements have an ID of `modernizr[n]`, where
   * `n` is its index (e.g. the first additional, second overall is `#modernizr2`,
   * the second additional is `#modernizr3`, etc.).
   * If you want to have more meaningful IDs for your function, you can provide
   * them as the fourth argument, as an array of strings
   *
   * ```js
   * Modernizr.testStyles('#foo {width: 10px}; #bar {height: 20px}', function(elem) {
   *   elem.firstChild === document.getElementById('foo'); // true
   *   elem.lastChild === document.getElementById('bar'); // true
   * }, 2, ['foo', 'bar']);
   * ```
   */
  var testStyles = ModernizrProto.testStyles = injectElementWithStyles;

  /*!
  {
    "name": "Hidden Scrollbar",
    "property": "hiddenscroll",
    "authors": ["Oleg Korsunsky"],
    "tags": ["overlay"],
    "notes": [{
      "name": "Overlay Scrollbar description",
      "href": "https://developer.apple.com/library/mac/releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_7.html#//apple_ref/doc/uid/TP40010355-SW39"
    },{
      "name": "Video example of overlay scrollbars",
      "href": "https://gfycat.com/FoolishMeaslyAtlanticsharpnosepuffer"
    }]
  }
  !*/
  /* DOC
  Detects overlay scrollbars (when scrollbars on overflowed blocks are visible). This is found most commonly on mobile and OS X.
  */

  Modernizr.addTest('hiddenscroll', function () {
    return testStyles('#modernizr {width:100px;height:100px;overflow:scroll}', function (elem) {
      return elem.offsetWidth === elem.clientWidth;
    });
  });

  /**
   * List of property values to set for css tests. See ticket #21
   * https://github.com/modernizr/modernizr/issues/21
   *
   * @memberOf Modernizr
   * @name Modernizr._prefixes
   * @optionName Modernizr._prefixes
   * @optionProp prefixes
   * @access public
   * @example
   *
   * Modernizr._prefixes is the internal list of prefixes that we test against
   * inside of things like [prefixed](#modernizr-prefixed) and [prefixedCSS](#-code-modernizr-prefixedcss). It is simply
   * an array of kebab-case vendor prefixes you can use within your code.
   *
   * Some common use cases include
   *
   * Generating all possible prefixed version of a CSS property
   * ```js
   * var rule = Modernizr._prefixes.join('transform: rotate(20deg); ');
   *
   * rule === 'transform: rotate(20deg); webkit-transform: rotate(20deg); moz-transform: rotate(20deg); o-transform: rotate(20deg); ms-transform: rotate(20deg);'
   * ```
   *
   * Generating all possible prefixed version of a CSS value
   * ```js
   * rule = 'display:' +  Modernizr._prefixes.join('flex; display:') + 'flex';
   *
   * rule === 'display:flex; display:-webkit-flex; display:-moz-flex; display:-o-flex; display:-ms-flex; display:flex'
   * ```
   */
  // we use ['',''] rather than an empty array in order to allow a pattern of .`join()`ing prefixes to test
  // values in feature detects to continue to work
  var prefixes = ModernizrProto._config.usePrefixes ? ' -webkit- -moz- -o- -ms- '.split(' ') : ['', ''];

  // expose these for the plugin API. Look in the source for how to join() them against your input
  ModernizrProto._prefixes = prefixes;

  /**
   * Modernizr.mq tests a given media query, live against the current state of the window
   * adapted from matchMedia polyfill by Scott Jehl and Paul Irish
   * gist.github.com/786768
   *
   * @memberOf Modernizr
   * @name Modernizr.mq
   * @optionName Modernizr.mq()
   * @optionProp mq
   * @access public
   * @function mq
   * @param {string} mq - String of the media query we want to test
   * @returns {boolean}
   * @example
   * Modernizr.mq allows for you to programmatically check if the current browser
   * window state matches a media query.
   *
   * ```js
   *  var query = Modernizr.mq('(min-width: 900px)');
   *
   *  if (query) {
   *    // the browser window is larger than 900px
   *  }
   * ```
   *
   * Only valid media queries are supported, therefore you must always include values
   * with your media query
   *
   * ```js
   * // good
   *  Modernizr.mq('(min-width: 900px)');
   *
   * // bad
   *  Modernizr.mq('min-width');
   * ```
   *
   * If you would just like to test that media queries are supported in general, use
   *
   * ```js
   *  Modernizr.mq('only all'); // true if MQ are supported, false if not
   * ```
   *
   * Note that if the browser does not support media queries (e.g. old IE) mq will
   * always return false.
   */
  var mq = function () {
    var matchMedia = window.matchMedia || window.msMatchMedia;
    if (matchMedia) {
      return function (mq) {
        var mql = matchMedia(mq);
        return mql && mql.matches || false;
      };
    }

    return function (mq) {
      var bool = false;

      injectElementWithStyles('@media ' + mq + ' { #modernizr { position: absolute; } }', function (node) {
        bool = (window.getComputedStyle ? window.getComputedStyle(node, null) : node.currentStyle).position === 'absolute';
      });

      return bool;
    };
  }();

  ModernizrProto.mq = mq;

  /*!
  {
    "name": "Touch Events",
    "property": "touchevents",
    "caniuse": "touch",
    "tags": ["media", "attribute"],
    "notes": [{
      "name": "Touch Events spec",
      "href": "https://www.w3.org/TR/2013/WD-touch-events-20130124/"
    }],
    "warnings": [
      "** DEPRECATED see https://github.com/Modernizr/Modernizr/pull/2432 **",
      "Indicates if the browser supports the Touch Events spec, and does not necessarily reflect a touchscreen device"
    ],
    "knownBugs": [
      "False-positive on some configurations of Nokia N900",
      "False-positive on some BlackBerry 6.0 builds  https://github.com/Modernizr/Modernizr/issues/372#issuecomment-3112695"
    ]
  }
  !*/
  /* DOC
  Indicates if the browser supports the W3C Touch Events API.
  
  This *does not* necessarily reflect a touchscreen device:
  
  * Older touchscreen devices only emulate mouse events
  * Modern IE touch devices implement the Pointer Events API instead: use `Modernizr.pointerevents` to detect support for that
  * Some browsers & OS setups may enable touch APIs when no touchscreen is connected
  * Future browsers may implement other event models for touch interactions
  
  See this article: [You Can't Detect A Touchscreen](http://www.stucox.com/blog/you-cant-detect-a-touchscreen/).
  
  It's recommended to bind both mouse and touch/pointer events simultaneously  see [this HTML5 Rocks tutorial](https://www.html5rocks.com/en/mobile/touchandmouse/).
  
  This test will also return `true` for Firefox 4 Multitouch support.
  */

  // Chrome (desktop) used to lie about its support on this, but that has since been rectified: https://bugs.chromium.org/p/chromium/issues/detail?id=36415
  // Chrome also changed its behaviour since v70 and recommends the TouchEvent object for detection: https://www.chromestatus.com/feature/4764225348042752
  Modernizr.addTest('touchevents', function () {
    if ('ontouchstart' in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch) {
      return true;
    }

    // include the 'heartz' as a way to have a non matching MQ to help terminate the join
    // https://github.com/Modernizr/Modernizr/issues/1814
    var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');
    return mq(query);
  });

  // Run each test
  testRunner();

  // Remove the "no-js" class if it exists
  setClasses(classes);

  delete ModernizrProto.addTest;
  delete ModernizrProto.addAsyncTest;

  // Run the things that are supposed to run after the tests
  for (var i = 0; i < Modernizr._q.length; i++) {
    Modernizr._q[i]();
  }

  // Leak Modernizr namespace
  window.Modernizr = Modernizr;

  ;
})(window, document);

},{"babel-runtime/helpers/typeof":44}],35:[function(require,module,exports){
/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

'use strict';

// Defaults

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};

var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};

var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];

// Caching

var cache = {
  CSS: {},
  springs: {}
};

// Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) { return Array.isArray(a); },
  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
  svg: function (a) { return a instanceof SVGElement; },
  inp: function (a) { return a instanceof HTMLInputElement; },
  dom: function (a) { return a.nodeType || is.svg(a); },
  str: function (a) { return typeof a === 'string'; },
  fnc: function (a) { return typeof a === 'function'; },
  und: function (a) { return typeof a === 'undefined'; },
  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
  rgb: function (a) { return /^rgb/.test(a); },
  hsl: function (a) { return /^hsl/.test(a); },
  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }
};

// Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
}

// Spring solver inspired by Webkit Copyright  2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

function spring(string, duration) {

  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? (duration * t) / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) { return t; }
    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];
    if (cached) { return cached; }
    var frame = 1/6;
    var elapsed = 0;
    var rest = 0;
    while(true) {
      elapsed += frame;
      if (solver(elapsed) === 1) {
        rest++;
        if (rest >= 16) { break; }
      } else {
        rest = 0;
      }
    }
    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;

}

// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

function steps(steps) {
  if ( steps === void 0 ) steps = 10;

  return function (t) { return Math.round(t * steps) * (1 / steps); };
}

// BezierEasing https://github.com/gre/bezier-easing

var bezier = (function () {

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
  function C(aA1)      { return 3.0 * aA1 }

  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) { return aGuessT; }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {

    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {

      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) { return x; }
      if (x === 0 || x === 1) { return x; }
      return calcBezier(getTForX(x), mY1, mY2);
    }

  }

  return bezier;

})();

var penner = (function () {

  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)

  var eases = { linear: function () { return function (t) { return t; }; } };

  var functionEasings = {
    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
    Bounce: function () { return function (t) {
      var pow2, b = 4;
      while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
      return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)
    }; },
    Elastic: function (amplitude, period) {
      if ( amplitude === void 0 ) amplitude = 1;
      if ( period === void 0 ) period = .5;

      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return (t === 0 || t === 1) ? t : 
          -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
      }
    }
  };

  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];

  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
  });

  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;
    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
    eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 
      1 - easeIn(a, b)(t * -2 + 2) / 2; }; };
  });

  return eases;

})();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) { return easing; }
  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);
  switch (name) {
    case 'spring' : return spring(easing, duration);
    case 'cubicBezier' : return applyArguments(bezier, args);
    case 'steps' : return applyArguments(steps, args);
    default : return applyArguments(ease, args);
  }
}

// Strings

function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch(e) {
    return;
  }
}

// Arrays

function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];
  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];
      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }
  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
}

function toArray(o) {
  if (is.arr(o)) { return o; }
  if (is.str(o)) { o = selectString(o) || o; }
  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) { return a === val; });
}

// Objects

function cloneObject(o) {
  var clone = {};
  for (var p in o) { clone[p] = o[p]; }
  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
  return o;
}

// Colors

function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return ("rgba(" + r + "," + g + "," + b + ",1)");
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;
  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
}

function colorToRgb(val) {
  if (is.rgb(val)) { return rgbToRgba(val); }
  if (is.hex(val)) { return hexToRgba(val); }
  if (is.hsl(val)) { return hslToRgba(val); }
}

// Units

function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
  if (split) { return split[1]; }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
}

// Values

function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) { return val; }
  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);
  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
  var cached = cache.CSS[value + unit];
  if (!is.und(cached)) { return cached; }
  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) { return 'attribute'; }
  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
  if (el[prop] != null) { return 'object'; }
}

function getElementTransforms(el) {
  if (!is.dom(el)) { return; }
  var str = el.style.transform || '';
  var reg  = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;
  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }
  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform': return getTransformValue(target, propName, animatable, unit);
    case 'css': return getCSSValue(target, propName, unit);
    case 'attribute': return getAttribute(target, propName);
    default: return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);
  if (!operator) { return to; }
  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));
  switch (operator[0][0]) {
    case '+': return x + y + u;
    case '-': return x - y + u;
    case '*': return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) { return colorToRgb(val); }
  if (/\s/g.test(val)) { return val; }
  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
  if (unit) { return unitLess + unit; }
  return unitLess;
}

// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
}

function getLineLength(el) {
  return getDistance(
    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
  );
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;
  for (var i = 0 ; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
    previousPos = currentPos;
  }
  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}

// Path animation

function getTotalLength(el) {
  if (el.getTotalLength) { return el.getTotalLength(); }
  switch(el.tagName.toLowerCase()) {
    case 'circle': return getCircleLength(el);
    case 'rect': return getRectLength(el);
    case 'line': return getLineLength(el);
    case 'polyline': return getPolylineLength(el);
    case 'polygon': return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
}

// Motion path

function getParentSvgEl(el) {
  var parentEl = el.parentNode;
  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) { break; }
    parentEl = parentEl.parentNode;
  }
  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  }
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function(property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    }
  }
}

function getPathProgress(path, progress) {
  function point(offset) {
    if ( offset === void 0 ) offset = 0;

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }
  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  switch (path.property) {
    case 'x': return (p.x - svg.x) * svg.w;
    case 'y': return (p.y - svg.y) * svg.h;
    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
}

// Decompose value

function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: (is.str(val) || unit) ? value.split(rgx) : []
  }
}

// Animatables

function parseTargets(targets) {
  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
  });
}

// Properties

function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings);
  // Override duration if easing is a spring
  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = (l === 2 && !is.obj(prop[0]));
    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {value: prop};
    }
  }
  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
    // Default delay value should only be applied to the first tween
    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
    // Default endDelay value should only be applied to the last tween
    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
    return obj;
  }).map(function (k) { return mergeObjects(k, settings); });
}


function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
  var properties = {};
  var loop = function ( i ) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};
      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) { newKey.value = key[p]; }
        } else {
          newKey[p] = key[p];
        }
      }
      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop( i );
  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;
  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }
  return properties;
}

// Tweens

function normalizeTweenValues(tween, animatable) {
  var t = {};
  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);
    if (is.arr(value)) {
      value = value.map(function (v) { return getFunctionValue(v, animatable); });
      if (value.length === 1) { value = value[0]; }
    }
    t[p] = value;
  }
  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;
    if (is.und(to)) { to = previousValue; }
    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);
    if (tween.isColor) { tween.round = 1; }
    previousTween = tween;
    return tween;
  });
}

// Tween progress

var setProgressValue = {
  css: function (t, p, v) { return t.style[p] = v; },
  attribute: function (t, p, v) { return t.setAttribute(p, v); },
  object: function (t, p, v) { return t[p] = v; },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);
    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
      t.style.transform = str;
    }
  }
};

// Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
}

// Animations

function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);
  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    }
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) { return !is.und(a); });
}

// Create Instance

function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;
  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
}

// Core

var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = (function () {
  function play() { 
    raf = requestAnimationFrame(step);
  }
  function step(t) {
    var activeInstancesLength = activeInstances.length;
    if (activeInstancesLength) {
      var i = 0;
      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];
        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);
          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }
        i++;
      }
      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }
  return play;
})();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) { return ins.pause(); });
    pausedInstances = activeInstances.slice(0);
    anime.running = activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) { return ins.play(); });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
}

// Public Instance

function anime(params) {
  if ( params === void 0 ) params = {};


  var startTime = 0, lastTime = 0, now = 0;
  var children, childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;
    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }
    instance.reversed = !instance.reversed;
    children.forEach(function (child) { return child.reversed = instance.reversed; });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) { child.seek(time - child.timelineOffset); }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }
    } else {
      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;
    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength];
      // Only check for keyframes if there is more than one tween
      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = (void 0);
      for (var n = 0; n < toNumbersLength; n++) {
        var value = (void 0);
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;
        if (!tween.isPath) {
          value = fromNumber + (eased * (toNumber - fromNumber));
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }
        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }
        numbers.push(value);
      }
      // Manual Array.reduce for better performances
      var stringsLength = strings.length;
      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];
        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];
          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }
      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;
    if (children) { syncInstanceChildren(insTime); }
    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }
    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }
    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }
    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
      setAnimationsProgress(insDuration);
    }
    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }
      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }
    instance.currentTime = minMax(insTime, 0, insDuration);
    if (instance.began) { setCallback('update'); }
    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();
      if (!instance.remaining) {
        instance.paused = true;
        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');
          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;
        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function() {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;
    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  };

  // Set Value helper

  instance.set = function(targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function(t) {
    now = t;
    if (!startTime) { startTime = now; }
    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function(time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function() {
    instance.paused = true;
    resetTime();
  };

  instance.play = function() {
    if (!instance.paused) { return; }
    if (instance.completed) { instance.reset(); }
    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    if (!raf) { engine(); }
  };

  instance.reverse = function() {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function() {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) { instance.play(); }

  return instance;

}

// Remove targets from animation

function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);
  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);
    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);
      if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
    }
    if (!animations.length && !children.length) { instance.pause(); }
  }
}

// Stagger helpers

function stagger(val, params) {
  if ( params === void 0 ) params = {};

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) { fromIndex = 0; }
    if (fromCenter) { fromIndex = (t - 1) / 2; }
    if (fromLast) { fromIndex = t - 1; }
    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
          var toX = index%grid[0];
          var toY = Math.floor(index/grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') { value = -distanceX; }
          if (axis === 'y') { value = -distanceY; }
          values.push(value);
        }
        maxValue = Math.max.apply(Math, values);
      }
      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
    }
    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
  }
}

// Timeline

function timeline(params) {
  if ( params === void 0 ) params = {};

  var tl = anime(params);
  tl.duration = 0;
  tl.add = function(instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;
    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
    function passThrough(ins) { ins.passThrough = true; }
    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();
    if (tl.autoplay) { tl.play(); }
    return tl;
  };
  return tl;
}

anime.version = '3.1.0';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

module.exports = anime;

},{}],36:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":46}],37:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/sign"), __esModule: true };
},{"core-js/library/fn/math/sign":47}],38:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/trunc"), __esModule: true };
},{"core-js/library/fn/math/trunc":48}],39:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-nan"), __esModule: true };
},{"core-js/library/fn/number/is-nan":49}],40:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/max-safe-integer"), __esModule: true };
},{"core-js/library/fn/number/max-safe-integer":50}],41:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":51}],42:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":52}],43:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":53}],44:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":42,"../core-js/symbol/iterator":43}],45:[function(require,module,exports){
!function(e,t){if("function"==typeof define&&define.amd)define(["exports"],t);else if("undefined"!=typeof exports)t(exports);else{var o={};t(o),e.bodyScrollLock=o}}(this,function(exports){"use strict";function r(e){if(Array.isArray(e)){for(var t=0,o=Array(e.length);t<e.length;t++)o[t]=e[t];return o}return Array.from(e)}Object.defineProperty(exports,"__esModule",{value:!0});var l=!1;if("undefined"!=typeof window){var e={get passive(){l=!0}};window.addEventListener("testPassive",null,e),window.removeEventListener("testPassive",null,e)}var d="undefined"!=typeof window&&window.navigator&&window.navigator.platform&&/iP(ad|hone|od)/.test(window.navigator.platform),c=[],u=!1,a=-1,s=void 0,v=void 0,f=function(t){return c.some(function(e){return!(!e.options.allowTouchMove||!e.options.allowTouchMove(t))})},m=function(e){var t=e||window.event;return!!f(t.target)||(1<t.touches.length||(t.preventDefault&&t.preventDefault(),!1))},o=function(){setTimeout(function(){void 0!==v&&(document.body.style.paddingRight=v,v=void 0),void 0!==s&&(document.body.style.overflow=s,s=void 0)})};exports.disableBodyScroll=function(i,e){if(d){if(!i)return void console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");if(i&&!c.some(function(e){return e.targetElement===i})){var t={targetElement:i,options:e||{}};c=[].concat(r(c),[t]),i.ontouchstart=function(e){1===e.targetTouches.length&&(a=e.targetTouches[0].clientY)},i.ontouchmove=function(e){var t,o,n,r;1===e.targetTouches.length&&(o=i,r=(t=e).targetTouches[0].clientY-a,!f(t.target)&&(o&&0===o.scrollTop&&0<r?m(t):(n=o)&&n.scrollHeight-n.scrollTop<=n.clientHeight&&r<0?m(t):t.stopPropagation()))},u||(document.addEventListener("touchmove",m,l?{passive:!1}:void 0),u=!0)}}else{n=e,setTimeout(function(){if(void 0===v){var e=!!n&&!0===n.reserveScrollBarGap,t=window.innerWidth-document.documentElement.clientWidth;e&&0<t&&(v=document.body.style.paddingRight,document.body.style.paddingRight=t+"px")}void 0===s&&(s=document.body.style.overflow,document.body.style.overflow="hidden")});var o={targetElement:i,options:e||{}};c=[].concat(r(c),[o])}var n},exports.clearAllBodyScrollLocks=function(){d?(c.forEach(function(e){e.targetElement.ontouchstart=null,e.targetElement.ontouchmove=null}),u&&(document.removeEventListener("touchmove",m,l?{passive:!1}:void 0),u=!1),c=[],a=-1):(o(),c=[])},exports.enableBodyScroll=function(t){if(d){if(!t)return void console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");t.ontouchstart=null,t.ontouchmove=null,c=c.filter(function(e){return e.targetElement!==t}),u&&0===c.length&&(document.removeEventListener("touchmove",m,l?{passive:!1}:void 0),u=!1)}else 1===c.length&&c[0].targetElement===t?(o(),c=[]):c=c.filter(function(e){return e.targetElement!==t})}});

},{}],46:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;

},{"../../modules/_core":60,"../../modules/es6.array.from":117,"../../modules/es6.string.iterator":125}],47:[function(require,module,exports){
require('../../modules/es6.math.sign');
module.exports = require('../../modules/_core').Math.sign;

},{"../../modules/_core":60,"../../modules/es6.math.sign":119}],48:[function(require,module,exports){
require('../../modules/es6.math.trunc');
module.exports = require('../../modules/_core').Math.trunc;

},{"../../modules/_core":60,"../../modules/es6.math.trunc":120}],49:[function(require,module,exports){
require('../../modules/es6.number.is-nan');
module.exports = require('../../modules/_core').Number.isNaN;

},{"../../modules/_core":60,"../../modules/es6.number.is-nan":121}],50:[function(require,module,exports){
require('../../modules/es6.number.max-safe-integer');
module.exports = 0x1fffffffffffff;

},{"../../modules/es6.number.max-safe-integer":122}],51:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":60,"../../modules/es6.object.assign":123}],52:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":60,"../../modules/es6.object.to-string":124,"../../modules/es6.symbol":126,"../../modules/es7.symbol.async-iterator":127,"../../modules/es7.symbol.observable":128}],53:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":114,"../../modules/es6.string.iterator":125,"../../modules/web.dom.iterable":129}],54:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],55:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],56:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":78}],57:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":106,"./_to-iobject":108,"./_to-length":109}],58:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":59,"./_wks":115}],59:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],60:[function(require,module,exports){
var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],61:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":90,"./_property-desc":100}],62:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":54}],63:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],64:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":69}],65:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":70,"./_is-object":78}],66:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],67:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":95,"./_object-keys":98,"./_object-pie":99}],68:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":60,"./_ctx":62,"./_global":70,"./_has":71,"./_hide":72}],69:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],70:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],71:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],72:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":64,"./_object-dp":90,"./_property-desc":100}],73:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":70}],74:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":64,"./_dom-create":65,"./_fails":69}],75:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":59}],76:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":84,"./_wks":115}],77:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":59}],78:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],79:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":56}],80:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":72,"./_object-create":89,"./_property-desc":100,"./_set-to-string-tag":102,"./_wks":115}],81:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":68,"./_hide":72,"./_iter-create":80,"./_iterators":84,"./_library":85,"./_object-gpo":96,"./_redefine":101,"./_set-to-string-tag":102,"./_wks":115}],82:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":115}],83:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],84:[function(require,module,exports){
module.exports = {};

},{}],85:[function(require,module,exports){
module.exports = true;

},{}],86:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],87:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":69,"./_has":71,"./_is-object":78,"./_object-dp":90,"./_uid":112}],88:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":64,"./_fails":69,"./_iobject":75,"./_object-gops":95,"./_object-keys":98,"./_object-pie":99,"./_to-object":110}],89:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":56,"./_dom-create":65,"./_enum-bug-keys":66,"./_html":73,"./_object-dps":91,"./_shared-key":103}],90:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":56,"./_descriptors":64,"./_ie8-dom-define":74,"./_to-primitive":111}],91:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":56,"./_descriptors":64,"./_object-dp":90,"./_object-keys":98}],92:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":64,"./_has":71,"./_ie8-dom-define":74,"./_object-pie":99,"./_property-desc":100,"./_to-iobject":108,"./_to-primitive":111}],93:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":94,"./_to-iobject":108}],94:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":66,"./_object-keys-internal":97}],95:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],96:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":71,"./_shared-key":103,"./_to-object":110}],97:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":57,"./_has":71,"./_shared-key":103,"./_to-iobject":108}],98:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":66,"./_object-keys-internal":97}],99:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],100:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],101:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":72}],102:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":71,"./_object-dp":90,"./_wks":115}],103:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":104,"./_uid":112}],104:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":60,"./_global":70,"./_library":85}],105:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":63,"./_to-integer":107}],106:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":107}],107:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],108:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":63,"./_iobject":75}],109:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":107}],110:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":63}],111:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":78}],112:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],113:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":60,"./_global":70,"./_library":85,"./_object-dp":90,"./_wks-ext":114}],114:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":115}],115:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":70,"./_shared":104,"./_uid":112}],116:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":58,"./_core":60,"./_iterators":84,"./_wks":115}],117:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":61,"./_ctx":62,"./_export":68,"./_is-array-iter":76,"./_iter-call":79,"./_iter-detect":82,"./_to-length":109,"./_to-object":110,"./core.get-iterator-method":116}],118:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":55,"./_iter-define":81,"./_iter-step":83,"./_iterators":84,"./_to-iobject":108}],119:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":68,"./_math-sign":86}],120:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":68}],121:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":68}],122:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":68}],123:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":68,"./_object-assign":88}],124:[function(require,module,exports){

},{}],125:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":81,"./_string-at":105}],126:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":56,"./_descriptors":64,"./_enum-keys":67,"./_export":68,"./_fails":69,"./_global":70,"./_has":71,"./_hide":72,"./_is-array":77,"./_is-object":78,"./_library":85,"./_meta":87,"./_object-create":89,"./_object-dp":90,"./_object-gopd":92,"./_object-gopn":94,"./_object-gopn-ext":93,"./_object-gops":95,"./_object-keys":98,"./_object-pie":99,"./_property-desc":100,"./_redefine":101,"./_set-to-string-tag":102,"./_shared":104,"./_to-iobject":108,"./_to-object":110,"./_to-primitive":111,"./_uid":112,"./_wks":115,"./_wks-define":113,"./_wks-ext":114}],127:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":113}],128:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":113}],129:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":70,"./_hide":72,"./_iterators":84,"./_wks":115,"./es6.array.iterator":118}],130:[function(require,module,exports){
/* flatpickr v4.5.7, @license MIT */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.flatpickr = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition",
    ];
    var defaults = {
        _disable: [],
        _enable: [],
        allowInput: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" &&
            window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enable: [],
        enableSeconds: false,
        enableTime: false,
        errorHandler: function (err) {
            return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function (givenDate) {
            var date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0);
            // Thursday in current week decides the year.
            date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
            // January 4 is always in week 1.
            var week1 = new Date(date.getFullYear(), 0, 4);
            // Adjust to Thursday in week 1 and count number of weeks from date to week1.
            return (1 +
                Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                    3 +
                    ((week1.getDay() + 6) % 7)) /
                    7));
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: undefined,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
    };

    var english = {
        weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ]
        },
        months: {
            shorthand: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ],
            longhand: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function (nth) {
            var s = nth % 100;
            if (s > 3 && s < 21)
                return "th";
            switch (s % 10) {
                case 1:
                    return "st";
                case 2:
                    return "nd";
                case 3:
                    return "rd";
                default:
                    return "th";
            }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year"
    };

    var pad = function (number) { return ("0" + number).slice(-2); };
    var int = function (bool) { return (bool === true ? 1 : 0); };
    /* istanbul ignore next */
    function debounce(func, wait, immediate) {
        if (immediate === void 0) { immediate = false; }
        var timeout;
        return function () {
            var context = this, args = arguments;
            timeout !== null && clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            }, wait);
            if (immediate && !timeout)
                func.apply(context, args);
        };
    }
    var arrayify = function (obj) {
        return obj instanceof Array ? obj : [obj];
    };

    function toggleClass(elem, className, bool) {
        if (bool === true)
            return elem.classList.add(className);
        elem.classList.remove(className);
    }
    function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== undefined)
            e.textContent = content;
        return e;
    }
    function clearNode(node) {
        while (node.firstChild)
            node.removeChild(node.firstChild);
    }
    function findParent(node, condition) {
        if (condition(node))
            return node;
        else if (node.parentNode)
            return findParent(node.parentNode, condition);
        return undefined; // nothing found
    }
    function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
            numInput.type = "number";
        }
        else {
            numInput.type = "text";
            numInput.pattern = "\\d*";
        }
        if (opts !== undefined)
            for (var key in opts)
                numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
    }
    function getEventTarget(event) {
        if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
        }
        return event.target;
    }

    var do_nothing = function () { return undefined; };
    var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
    var revFormat = {
        D: do_nothing,
        F: function (dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        H: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        J: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        K: function (dateObj, amPM, locale) {
            dateObj.setHours((dateObj.getHours() % 12) +
                12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function (dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
        W: function (dateObj, weekNum) {
            var weekNumber = parseInt(weekNum);
            return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        },
        Y: function (dateObj, year) {
            dateObj.setFullYear(parseFloat(year));
        },
        Z: function (_, ISODate) { return new Date(ISODate); },
        d: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        h: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        i: function (dateObj, minutes) {
            dateObj.setMinutes(parseFloat(minutes));
        },
        j: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        l: do_nothing,
        m: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        u: function (_, unixMillSeconds) {
            return new Date(parseFloat(unixMillSeconds));
        },
        w: do_nothing,
        y: function (dateObj, year) {
            dateObj.setFullYear(2000 + parseFloat(year));
        }
    };
    var tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
    };
    var formats = {
        // get the date in UTC
        Z: function (date) { return date.toISOString(); },
        // weekday name, short, e.g. Thu
        D: function (date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        // full month name e.g. January
        F: function (date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        // padded hour 1-12
        G: function (date, locale, options) {
            return pad(formats.h(date, locale, options));
        },
        // hours with leading zero e.g. 03
        H: function (date) { return pad(date.getHours()); },
        // day (1-30) with ordinal suffix e.g. 1st, 2nd
        J: function (date, locale) {
            return locale.ordinal !== undefined
                ? date.getDate() + locale.ordinal(date.getDate())
                : date.getDate();
        },
        // AM/PM
        K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
        // shorthand month e.g. Jan, Sep, Oct, etc
        M: function (date, locale) {
            return monthToStr(date.getMonth(), true, locale);
        },
        // seconds 00-59
        S: function (date) { return pad(date.getSeconds()); },
        // unix timestamp
        U: function (date) { return date.getTime() / 1000; },
        W: function (date, _, options) {
            return options.getWeek(date);
        },
        // full year e.g. 2016
        Y: function (date) { return date.getFullYear(); },
        // day in month, padded (01-30)
        d: function (date) { return pad(date.getDate()); },
        // hour from 1-12 (am/pm)
        h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
        // minutes, padded with leading zero e.g. 09
        i: function (date) { return pad(date.getMinutes()); },
        // day in month (1-30)
        j: function (date) { return date.getDate(); },
        // weekday name, full, e.g. Thursday
        l: function (date, locale) {
            return locale.weekdays.longhand[date.getDay()];
        },
        // padded month number (01-12)
        m: function (date) { return pad(date.getMonth() + 1); },
        // the month number (1-12)
        n: function (date) { return date.getMonth() + 1; },
        // seconds 0-59
        s: function (date) { return date.getSeconds(); },
        // Unix Milliseconds
        u: function (date) { return date.getTime(); },
        // number of the day of the week
        w: function (date) { return date.getDay(); },
        // last two digits of year e.g. 16 for 2016
        y: function (date) { return String(date.getFullYear()).substring(2); }
    };

    var createDateFormatter = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (dateObj, frmt, overrideLocale) {
            var locale = overrideLocale || l10n;
            if (config.formatDate !== undefined) {
                return config.formatDate(dateObj, frmt, locale);
            }
            return frmt
                .split("")
                .map(function (c, i, arr) {
                return formats[c] && arr[i - 1] !== "\\"
                    ? formats[c](dateObj, locale, config)
                    : c !== "\\"
                        ? c
                        : "";
            })
                .join("");
        };
    };
    var createDateParser = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (date, givenFormat, timeless, customLocale) {
            if (date !== 0 && !date)
                return undefined;
            var locale = customLocale || l10n;
            var parsedDate;
            var date_orig = date;
            if (date instanceof Date)
                parsedDate = new Date(date.getTime());
            else if (typeof date !== "string" &&
                date.toFixed !== undefined // timestamp
            )
                // create a copy
                parsedDate = new Date(date);
            else if (typeof date === "string") {
                // date string
                var format = givenFormat || (config || defaults).dateFormat;
                var datestr = String(date).trim();
                if (datestr === "today") {
                    parsedDate = new Date();
                    timeless = true;
                }
                else if (/Z$/.test(datestr) ||
                    /GMT$/.test(datestr) // datestrings w/ timezone
                )
                    parsedDate = new Date(date);
                else if (config && config.parseDate)
                    parsedDate = config.parseDate(date, format);
                else {
                    parsedDate =
                        !config || !config.noCalendar
                            ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                            : new Date(new Date().setHours(0, 0, 0, 0));
                    var matched = void 0, ops = [];
                    for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                        var token_1 = format[i];
                        var isBackSlash = token_1 === "\\";
                        var escaped = format[i - 1] === "\\" || isBackSlash;
                        if (tokenRegex[token_1] && !escaped) {
                            regexStr += tokenRegex[token_1];
                            var match = new RegExp(regexStr).exec(date);
                            if (match && (matched = true)) {
                                ops[token_1 !== "Y" ? "push" : "unshift"]({
                                    fn: revFormat[token_1],
                                    val: match[++matchIndex]
                                });
                            }
                        }
                        else if (!isBackSlash)
                            regexStr += "."; // don't really care
                        ops.forEach(function (_a) {
                            var fn = _a.fn, val = _a.val;
                            return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                        });
                    }
                    parsedDate = matched ? parsedDate : undefined;
                }
            }
            /* istanbul ignore next */
            if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                config.errorHandler(new Error("Invalid date provided: " + date_orig));
                return undefined;
            }
            if (timeless === true)
                parsedDate.setHours(0, 0, 0, 0);
            return parsedDate;
        };
    };
    /**
     * Compute the difference in dates, measured in ms
     */
    function compareDates(date1, date2, timeless) {
        if (timeless === void 0) { timeless = true; }
        if (timeless !== false) {
            return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                new Date(date2.getTime()).setHours(0, 0, 0, 0));
        }
        return date1.getTime() - date2.getTime();
    }
    var isBetween = function (ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
    };
    var duration = {
        DAY: 86400000
    };

    if (typeof Object.assign !== "function") {
        Object.assign = function (target) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!target) {
                throw TypeError("Cannot convert undefined or null to object");
            }
            var _loop_1 = function (source) {
                if (source) {
                    Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
                }
            };
            for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                var source = args_1[_a];
                _loop_1(source);
            }
            return target;
        };
    }

    var DEBOUNCED_CHANGE_MS = 300;
    function FlatpickrInstance(element, instanceConfig) {
        var self = {
            config: __assign({}, flatpickr.defaultConfig),
            l10n: english
        };
        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        self._handlers = [];
        self._bind = bind;
        self._setHoursFromDate = setHoursFromDate;
        self._positionCalendar = positionCalendar;
        self.changeMonth = changeMonth;
        self.changeYear = changeYear;
        self.clear = clear;
        self.close = close;
        self._createElement = createElement;
        self.destroy = destroy;
        self.isEnabled = isEnabled;
        self.jumpToDate = jumpToDate;
        self.open = open;
        self.redraw = redraw;
        self.set = set;
        self.setDate = setDate;
        self.toggle = toggle;
        function setupHelperFunctions() {
            self.utils = {
                getDaysInMonth: function (month, yr) {
                    if (month === void 0) { month = self.currentMonth; }
                    if (yr === void 0) { yr = self.currentYear; }
                    if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                        return 29;
                    return self.l10n.daysInMonth[month];
                }
            };
        }
        function init() {
            self.element = self.input = element;
            self.isOpen = false;
            parseConfig();
            setupLocale();
            setupInputs();
            setupDates();
            setupHelperFunctions();
            if (!self.isMobile)
                build();
            bindEvents();
            if (self.selectedDates.length || self.config.noCalendar) {
                if (self.config.enableTime) {
                    setHoursFromDate(self.config.noCalendar
                        ? self.latestSelectedDateObj || self.config.minDate
                        : undefined);
                }
                updateValue(false);
            }
            setCalendarWidth();
            self.showTimeInput =
                self.selectedDates.length > 0 || self.config.noCalendar;
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            /* TODO: investigate this further
        
              Currently, there is weird positioning behavior in safari causing pages
              to scroll up. https://github.com/chmln/flatpickr/issues/563
        
              However, most browsers are not Safari and positioning is expensive when used
              in scale. https://github.com/chmln/flatpickr/issues/1096
            */
            if (!self.isMobile && isSafari) {
                positionCalendar();
            }
            triggerEvent("onReady");
        }
        function bindToInstance(fn) {
            return fn.bind(self);
        }
        function setCalendarWidth() {
            var config = self.config;
            if (config.weekNumbers === false && config.showMonths === 1)
                return;
            else if (config.noCalendar !== true) {
                window.requestAnimationFrame(function () {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.style.visibility = "hidden";
                        self.calendarContainer.style.display = "block";
                    }
                    if (self.daysContainer !== undefined) {
                        var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                        self.daysContainer.style.width = daysWidth + "px";
                        self.calendarContainer.style.width =
                            daysWidth +
                                (self.weekWrapper !== undefined
                                    ? self.weekWrapper.offsetWidth
                                    : 0) +
                                "px";
                        self.calendarContainer.style.removeProperty("visibility");
                        self.calendarContainer.style.removeProperty("display");
                    }
                });
            }
        }
        /**
         * The handler for all events targeting the time inputs
         */
        function updateTime(e) {
            if (self.selectedDates.length === 0) {
                setDefaultTime();
            }
            if (e !== undefined && e.type !== "blur") {
                timeWrapper(e);
            }
            var prevValue = self._input.value;
            setHoursFromInputs();
            updateValue();
            if (self._input.value !== prevValue) {
                self._debouncedChange();
            }
        }
        function ampm2military(hour, amPM) {
            return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
        }
        function military2ampm(hour) {
            switch (hour % 24) {
                case 0:
                case 12:
                    return 12;
                default:
                    return hour % 12;
            }
        }
        /**
         * Syncs the selected date object time with user's time input
         */
        function setHoursFromInputs() {
            if (self.hourElement === undefined || self.minuteElement === undefined)
                return;
            var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                ? (parseInt(self.secondElement.value, 10) || 0) % 60
                : 0;
            if (self.amPM !== undefined) {
                hours = ampm2military(hours, self.amPM.textContent);
            }
            var limitMinHours = self.config.minTime !== undefined ||
                (self.config.minDate &&
                    self.minDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                        0);
            var limitMaxHours = self.config.maxTime !== undefined ||
                (self.config.maxDate &&
                    self.maxDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                        0);
            if (limitMaxHours) {
                var maxTime = self.config.maxTime !== undefined
                    ? self.config.maxTime
                    : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                    minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                    seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                var minTime = self.config.minTime !== undefined
                    ? self.config.minTime
                    : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours())
                    minutes = Math.max(minutes, minTime.getMinutes());
                if (minutes === minTime.getMinutes())
                    seconds = Math.max(seconds, minTime.getSeconds());
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Syncs time input values with a date
         */
        function setHoursFromDate(dateObj) {
            var date = dateObj || self.latestSelectedDateObj;
            if (date)
                setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }
        function setDefaultHours() {
            var hours = self.config.defaultHour;
            var minutes = self.config.defaultMinute;
            var seconds = self.config.defaultSeconds;
            if (self.config.minDate !== undefined) {
                var min_hr = self.config.minDate.getHours();
                var min_minutes = self.config.minDate.getMinutes();
                hours = Math.max(hours, min_hr);
                if (hours === min_hr)
                    minutes = Math.max(min_minutes, minutes);
                if (hours === min_hr && minutes === min_minutes)
                    seconds = self.config.minDate.getSeconds();
            }
            if (self.config.maxDate !== undefined) {
                var max_hr = self.config.maxDate.getHours();
                var max_minutes = self.config.maxDate.getMinutes();
                hours = Math.min(hours, max_hr);
                if (hours === max_hr)
                    minutes = Math.min(max_minutes, minutes);
                if (hours === max_hr && minutes === max_minutes)
                    seconds = self.config.maxDate.getSeconds();
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Sets the hours, minutes, and optionally seconds
         * of the latest selected date object and the
         * corresponding time inputs
         * @param {Number} hours the hour. whether its military
         *                 or am-pm gets inferred from config
         * @param {Number} minutes the minutes
         * @param {Number} seconds the seconds (optional)
         */
        function setHours(hours, minutes, seconds) {
            if (self.latestSelectedDateObj !== undefined) {
                self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
            }
            if (!self.hourElement || !self.minuteElement || self.isMobile)
                return;
            self.hourElement.value = pad(!self.config.time_24hr
                ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
                : hours);
            self.minuteElement.value = pad(minutes);
            if (self.amPM !== undefined)
                self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
            if (self.secondElement !== undefined)
                self.secondElement.value = pad(seconds);
        }
        /**
         * Handles the year input and incrementing events
         * @param {Event} event the keyup or increment event
         */
        function onYearInput(event) {
            var year = parseInt(event.target.value) + (event.delta || 0);
            if (year / 1000 > 1 ||
                (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                changeYear(year);
            }
        }
        /**
         * Essentially addEventListener + tracking
         * @param {Element} element the element to addEventListener to
         * @param {String} event the event name
         * @param {Function} handler the event handler
         */
        function bind(element, event, handler, options) {
            if (event instanceof Array)
                return event.forEach(function (ev) { return bind(element, ev, handler, options); });
            if (element instanceof Array)
                return element.forEach(function (el) { return bind(el, event, handler, options); });
            element.addEventListener(event, handler, options);
            self._handlers.push({
                element: element,
                event: event,
                handler: handler,
                options: options
            });
        }
        /**
         * A mousedown handler which mimics click.
         * Minimizes latency, since we don't need to wait for mouseup in most cases.
         * Also, avoids handling right clicks.
         *
         * @param {Function} handler the event handler
         */
        function onClick(handler) {
            return function (evt) {
                evt.which === 1 && handler(evt);
            };
        }
        function triggerChange() {
            triggerEvent("onChange");
        }
        /**
         * Adds all the necessary event listeners
         */
        function bindEvents() {
            if (self.config.wrap) {
                ["open", "close", "toggle", "clear"].forEach(function (evt) {
                    Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                        return bind(el, "click", self[evt]);
                    });
                });
            }
            if (self.isMobile) {
                setupMobile();
                return;
            }
            var debouncedResize = debounce(onResize, 50);
            self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
            if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                bind(self.daysContainer, "mouseover", function (e) {
                    if (self.config.mode === "range")
                        onMouseOver(e.target);
                });
            bind(window.document.body, "keydown", onKeyDown);
            if (!self.config.static)
                bind(self._input, "keydown", onKeyDown);
            if (!self.config.inline && !self.config.static)
                bind(window, "resize", debouncedResize);
            if (window.ontouchstart !== undefined)
                bind(window.document, "click", documentClick);
            else
                bind(window.document, "mousedown", onClick(documentClick));
            bind(window.document, "focus", documentClick, { capture: true });
            if (self.config.clickOpens === true) {
                bind(self._input, "focus", self.open);
                bind(self._input, "mousedown", onClick(self.open));
            }
            if (self.daysContainer !== undefined) {
                bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
                bind(self.monthNav, ["keyup", "increment"], onYearInput);
                bind(self.daysContainer, "mousedown", onClick(selectDate));
            }
            if (self.timeContainer !== undefined &&
                self.minuteElement !== undefined &&
                self.hourElement !== undefined) {
                var selText = function (e) {
                    return e.target.select();
                };
                bind(self.timeContainer, ["increment"], updateTime);
                bind(self.timeContainer, "blur", updateTime, { capture: true });
                bind(self.timeContainer, "mousedown", onClick(timeIncrement));
                bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                if (self.secondElement !== undefined)
                    bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
                if (self.amPM !== undefined) {
                    bind(self.amPM, "mousedown", onClick(function (e) {
                        updateTime(e);
                        triggerChange();
                    }));
                }
            }
        }
        /**
         * Set the calendar view to a particular date.
         * @param {Date} jumpDate the date to set the view to
         */
        function jumpToDate(jumpDate) {
            var jumpTo = jumpDate !== undefined
                ? self.parseDate(jumpDate)
                : self.latestSelectedDateObj ||
                    (self.config.minDate && self.config.minDate > self.now
                        ? self.config.minDate
                        : self.config.maxDate && self.config.maxDate < self.now
                            ? self.config.maxDate
                            : self.now);
            try {
                if (jumpTo !== undefined) {
                    self.currentYear = jumpTo.getFullYear();
                    self.currentMonth = jumpTo.getMonth();
                }
            }
            catch (e) {
                /* istanbul ignore next */
                e.message = "Invalid date supplied: " + jumpTo;
                self.config.errorHandler(e);
            }
            self.redraw();
        }
        /**
         * The up/down arrow handler for time inputs
         * @param {Event} e the click event
         */
        function timeIncrement(e) {
            if (~e.target.className.indexOf("arrow"))
                incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
        }
        /**
         * Increments/decrements the value of input associ-
         * ated with the up/down arrow by dispatching an
         * "increment" event on the input.
         *
         * @param {Event} e the click event
         * @param {Number} delta the diff (usually 1 or -1)
         * @param {Element} inputElem the input element
         */
        function incrementNumInput(e, delta, inputElem) {
            var target = e && e.target;
            var input = inputElem ||
                (target && target.parentNode && target.parentNode.firstChild);
            var event = createEvent("increment");
            event.delta = delta;
            input && input.dispatchEvent(event);
        }
        function build() {
            var fragment = window.document.createDocumentFragment();
            self.calendarContainer = createElement("div", "flatpickr-calendar");
            self.calendarContainer.tabIndex = -1;
            if (!self.config.noCalendar) {
                fragment.appendChild(buildMonthNav());
                self.innerContainer = createElement("div", "flatpickr-innerContainer");
                if (self.config.weekNumbers) {
                    var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                    self.innerContainer.appendChild(weekWrapper);
                    self.weekNumbers = weekNumbers;
                    self.weekWrapper = weekWrapper;
                }
                self.rContainer = createElement("div", "flatpickr-rContainer");
                self.rContainer.appendChild(buildWeekdays());
                if (!self.daysContainer) {
                    self.daysContainer = createElement("div", "flatpickr-days");
                    self.daysContainer.tabIndex = -1;
                }
                buildDays();
                self.rContainer.appendChild(self.daysContainer);
                self.innerContainer.appendChild(self.rContainer);
                fragment.appendChild(self.innerContainer);
            }
            if (self.config.enableTime) {
                fragment.appendChild(buildTime());
            }
            toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
            toggleClass(self.calendarContainer, "animate", self.config.animate === true);
            toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
            self.calendarContainer.appendChild(fragment);
            var customAppend = self.config.appendTo !== undefined &&
                self.config.appendTo.nodeType !== undefined;
            if (self.config.inline || self.config.static) {
                self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                if (self.config.inline) {
                    if (!customAppend && self.element.parentNode)
                        self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                    else if (self.config.appendTo !== undefined)
                        self.config.appendTo.appendChild(self.calendarContainer);
                }
                if (self.config.static) {
                    var wrapper = createElement("div", "flatpickr-wrapper");
                    if (self.element.parentNode)
                        self.element.parentNode.insertBefore(wrapper, self.element);
                    wrapper.appendChild(self.element);
                    if (self.altInput)
                        wrapper.appendChild(self.altInput);
                    wrapper.appendChild(self.calendarContainer);
                }
            }
            if (!self.config.static && !self.config.inline)
                (self.config.appendTo !== undefined
                    ? self.config.appendTo
                    : window.document.body).appendChild(self.calendarContainer);
        }
        function createDay(className, date, dayNumber, i) {
            var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
            dayElement.dateObj = date;
            dayElement.$i = i;
            dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
            if (className.indexOf("hidden") === -1 &&
                compareDates(date, self.now) === 0) {
                self.todayDateElem = dayElement;
                dayElement.classList.add("today");
                dayElement.setAttribute("aria-current", "date");
            }
            if (dateIsEnabled) {
                dayElement.tabIndex = -1;
                if (isDateSelected(date)) {
                    dayElement.classList.add("selected");
                    self.selectedDateElem = dayElement;
                    if (self.config.mode === "range") {
                        toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                            compareDates(date, self.selectedDates[0], true) === 0);
                        toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                            compareDates(date, self.selectedDates[1], true) === 0);
                        if (className === "nextMonthDay")
                            dayElement.classList.add("inRange");
                    }
                }
            }
            else {
                dayElement.classList.add("disabled");
            }
            if (self.config.mode === "range") {
                if (isDateInRange(date) && !isDateSelected(date))
                    dayElement.classList.add("inRange");
            }
            if (self.weekNumbers &&
                self.config.showMonths === 1 &&
                className !== "prevMonthDay" &&
                dayNumber % 7 === 1) {
                self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
            }
            triggerEvent("onDayCreate", dayElement);
            return dayElement;
        }
        function focusOnDayElem(targetNode) {
            targetNode.focus();
            if (self.config.mode === "range")
                onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
            var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            for (var m = startMonth; m != endMonth; m += delta) {
                var month = self.daysContainer.children[m];
                var startIndex = delta > 0 ? 0 : month.children.length - 1;
                var endIndex = delta > 0 ? month.children.length : -1;
                for (var i = startIndex; i != endIndex; i += delta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                        return c;
                }
            }
            return undefined;
        }
        function getNextAvailableDay(current, delta) {
            var givenMonth = current.className.indexOf("Month") === -1
                ? current.dateObj.getMonth()
                : self.currentMonth;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            var loopDelta = delta > 0 ? 1 : -1;
            for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                var month = self.daysContainer.children[m];
                var startIndex = givenMonth - self.currentMonth === m
                    ? current.$i + delta
                    : delta < 0
                        ? month.children.length - 1
                        : 0;
                var numMonthDays = month.children.length;
                for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 &&
                        isEnabled(c.dateObj) &&
                        Math.abs(current.$i - i) >= Math.abs(delta))
                        return focusOnDayElem(c);
                }
            }
            self.changeMonth(loopDelta);
            focusOnDay(getFirstAvailableDay(loopDelta), 0);
            return undefined;
        }
        function focusOnDay(current, offset) {
            var dayFocused = isInView(document.activeElement || document.body);
            var startElem = current !== undefined
                ? current
                : dayFocused
                    ? document.activeElement
                    : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                        ? self.selectedDateElem
                        : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                            ? self.todayDateElem
                            : getFirstAvailableDay(offset > 0 ? 1 : -1);
            if (startElem === undefined)
                return self._input.focus();
            if (!dayFocused)
                return focusOnDayElem(startElem);
            getNextAvailableDay(startElem, offset);
        }
        function buildMonthDays(year, month) {
            var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
            var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
            var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
            var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
            // prepend days from the ending of previous month
            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
            }
            // Start at 1 since there is no 0th day
            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
            }
            // append days from the next month
            for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
            }
            //updateNavigationCurrentMonth();
            var dayContainer = createElement("div", "dayContainer");
            dayContainer.appendChild(days);
            return dayContainer;
        }
        function buildDays() {
            if (self.daysContainer === undefined) {
                return;
            }
            clearNode(self.daysContainer);
            // TODO: week numbers for each month
            if (self.weekNumbers)
                clearNode(self.weekNumbers);
            var frag = document.createDocumentFragment();
            for (var i = 0; i < self.config.showMonths; i++) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
            }
            self.daysContainer.appendChild(frag);
            self.days = self.daysContainer.firstChild;
            if (self.config.mode === "range" && self.selectedDates.length === 1) {
                onMouseOver();
            }
        }
        function buildMonth() {
            var container = createElement("div", "flatpickr-month");
            var monthNavFragment = window.document.createDocumentFragment();
            var monthElement = createElement("span", "cur-month");
            var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
            var yearElement = yearInput.getElementsByTagName("input")[0];
            yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
            if (self.config.minDate) {
                yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
            }
            if (self.config.maxDate) {
                yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                yearElement.disabled =
                    !!self.config.minDate &&
                        self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
            }
            var currentMonth = createElement("div", "flatpickr-current-month");
            currentMonth.appendChild(monthElement);
            currentMonth.appendChild(yearInput);
            monthNavFragment.appendChild(currentMonth);
            container.appendChild(monthNavFragment);
            return {
                container: container,
                yearElement: yearElement,
                monthElement: monthElement
            };
        }
        function buildMonths() {
            clearNode(self.monthNav);
            self.monthNav.appendChild(self.prevMonthNav);
            if (self.config.showMonths) {
                self.yearElements = [];
                self.monthElements = [];
            }
            for (var m = self.config.showMonths; m--;) {
                var month = buildMonth();
                self.yearElements.push(month.yearElement);
                self.monthElements.push(month.monthElement);
                self.monthNav.appendChild(month.container);
            }
            self.monthNav.appendChild(self.nextMonthNav);
        }
        function buildMonthNav() {
            self.monthNav = createElement("div", "flatpickr-months");
            self.yearElements = [];
            self.monthElements = [];
            self.prevMonthNav = createElement("span", "flatpickr-prev-month");
            self.prevMonthNav.innerHTML = self.config.prevArrow;
            self.nextMonthNav = createElement("span", "flatpickr-next-month");
            self.nextMonthNav.innerHTML = self.config.nextArrow;
            buildMonths();
            Object.defineProperty(self, "_hidePrevMonthArrow", {
                get: function () { return self.__hidePrevMonthArrow; },
                set: function (bool) {
                    if (self.__hidePrevMonthArrow !== bool) {
                        toggleClass(self.prevMonthNav, "disabled", bool);
                        self.__hidePrevMonthArrow = bool;
                    }
                }
            });
            Object.defineProperty(self, "_hideNextMonthArrow", {
                get: function () { return self.__hideNextMonthArrow; },
                set: function (bool) {
                    if (self.__hideNextMonthArrow !== bool) {
                        toggleClass(self.nextMonthNav, "disabled", bool);
                        self.__hideNextMonthArrow = bool;
                    }
                }
            });
            self.currentYearElement = self.yearElements[0];
            updateNavigationCurrentMonth();
            return self.monthNav;
        }
        function buildTime() {
            self.calendarContainer.classList.add("hasTime");
            if (self.config.noCalendar)
                self.calendarContainer.classList.add("noCalendar");
            self.timeContainer = createElement("div", "flatpickr-time");
            self.timeContainer.tabIndex = -1;
            var separator = createElement("span", "flatpickr-time-separator", ":");
            var hourInput = createNumberInput("flatpickr-hour");
            self.hourElement = hourInput.getElementsByTagName("input")[0];
            var minuteInput = createNumberInput("flatpickr-minute");
            self.minuteElement = minuteInput.getElementsByTagName("input")[0];
            self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
            self.hourElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getHours()
                : self.config.time_24hr
                    ? self.config.defaultHour
                    : military2ampm(self.config.defaultHour));
            self.minuteElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getMinutes()
                : self.config.defaultMinute);
            self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
            self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
            self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
            self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
            self.minuteElement.setAttribute("min", "0");
            self.minuteElement.setAttribute("max", "59");
            self.timeContainer.appendChild(hourInput);
            self.timeContainer.appendChild(separator);
            self.timeContainer.appendChild(minuteInput);
            if (self.config.time_24hr)
                self.timeContainer.classList.add("time24hr");
            if (self.config.enableSeconds) {
                self.timeContainer.classList.add("hasSeconds");
                var secondInput = createNumberInput("flatpickr-second");
                self.secondElement = secondInput.getElementsByTagName("input")[0];
                self.secondElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getSeconds()
                    : self.config.defaultSeconds);
                self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                self.secondElement.setAttribute("min", "0");
                self.secondElement.setAttribute("max", "59");
                self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                self.timeContainer.appendChild(secondInput);
            }
            if (!self.config.time_24hr) {
                // add self.amPM if appropriate
                self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                    ? self.hourElement.value
                    : self.config.defaultHour) > 11)]);
                self.amPM.title = self.l10n.toggleTitle;
                self.amPM.tabIndex = -1;
                self.timeContainer.appendChild(self.amPM);
            }
            return self.timeContainer;
        }
        function buildWeekdays() {
            if (!self.weekdayContainer)
                self.weekdayContainer = createElement("div", "flatpickr-weekdays");
            else
                clearNode(self.weekdayContainer);
            for (var i = self.config.showMonths; i--;) {
                var container = createElement("div", "flatpickr-weekdaycontainer");
                self.weekdayContainer.appendChild(container);
            }
            updateWeekdays();
            return self.weekdayContainer;
        }
        function updateWeekdays() {
            var firstDayOfWeek = self.l10n.firstDayOfWeek;
            var weekdays = self.l10n.weekdays.shorthand.slice();
            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
            }
            for (var i = self.config.showMonths; i--;) {
                self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
            }
        }
        /* istanbul ignore next */
        function buildWeeks() {
            self.calendarContainer.classList.add("hasWeeks");
            var weekWrapper = createElement("div", "flatpickr-weekwrapper");
            weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
            var weekNumbers = createElement("div", "flatpickr-weeks");
            weekWrapper.appendChild(weekNumbers);
            return {
                weekWrapper: weekWrapper,
                weekNumbers: weekNumbers
            };
        }
        function changeMonth(value, is_offset) {
            if (is_offset === void 0) { is_offset = true; }
            var delta = is_offset ? value : value - self.currentMonth;
            if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                (delta > 0 && self._hideNextMonthArrow === true))
                return;
            self.currentMonth += delta;
            if (self.currentMonth < 0 || self.currentMonth > 11) {
                self.currentYear += self.currentMonth > 11 ? 1 : -1;
                self.currentMonth = (self.currentMonth + 12) % 12;
                triggerEvent("onYearChange");
            }
            buildDays();
            triggerEvent("onMonthChange");
            updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent, toInitial) {
            if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
            if (toInitial === void 0) { toInitial = true; }
            self.input.value = "";
            if (self.altInput !== undefined)
                self.altInput.value = "";
            if (self.mobileInput !== undefined)
                self.mobileInput.value = "";
            self.selectedDates = [];
            self.latestSelectedDateObj = undefined;
            if (toInitial === true) {
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
            }
            self.showTimeInput = false;
            if (self.config.enableTime === true) {
                setDefaultHours();
            }
            self.redraw();
            if (triggerChangeEvent)
                // triggerChangeEvent is true (default) or an Event
                triggerEvent("onChange");
        }
        function close() {
            self.isOpen = false;
            if (!self.isMobile) {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.classList.remove("open");
                }
                if (self._input !== undefined) {
                    self._input.classList.remove("active");
                }
            }
            triggerEvent("onClose");
        }
        function destroy() {
            if (self.config !== undefined)
                triggerEvent("onDestroy");
            for (var i = self._handlers.length; i--;) {
                var h = self._handlers[i];
                h.element.removeEventListener(h.event, h.handler, h.options);
            }
            self._handlers = [];
            if (self.mobileInput) {
                if (self.mobileInput.parentNode)
                    self.mobileInput.parentNode.removeChild(self.mobileInput);
                self.mobileInput = undefined;
            }
            else if (self.calendarContainer && self.calendarContainer.parentNode) {
                if (self.config.static && self.calendarContainer.parentNode) {
                    var wrapper = self.calendarContainer.parentNode;
                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                    if (wrapper.parentNode) {
                        while (wrapper.firstChild)
                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                    }
                }
                else
                    self.calendarContainer.parentNode.removeChild(self.calendarContainer);
            }
            if (self.altInput) {
                self.input.type = "text";
                if (self.altInput.parentNode)
                    self.altInput.parentNode.removeChild(self.altInput);
                delete self.altInput;
            }
            if (self.input) {
                self.input.type = self.input._type;
                self.input.classList.remove("flatpickr-input");
                self.input.removeAttribute("readonly");
                self.input.value = "";
            }
            [
                "_showTimeInput",
                "latestSelectedDateObj",
                "_hideNextMonthArrow",
                "_hidePrevMonthArrow",
                "__hideNextMonthArrow",
                "__hidePrevMonthArrow",
                "isMobile",
                "isOpen",
                "selectedDateElem",
                "minDateHasTime",
                "maxDateHasTime",
                "days",
                "daysContainer",
                "_input",
                "_positionElement",
                "innerContainer",
                "rContainer",
                "monthNav",
                "todayDateElem",
                "calendarContainer",
                "weekdayContainer",
                "prevMonthNav",
                "nextMonthNav",
                "currentMonthElement",
                "currentYearElement",
                "navigationCurrentMonth",
                "selectedDateElem",
                "config",
            ].forEach(function (k) {
                try {
                    delete self[k];
                }
                catch (_) { }
            });
        }
        function isCalendarElem(elem) {
            if (self.config.appendTo && self.config.appendTo.contains(elem))
                return true;
            return self.calendarContainer.contains(elem);
        }
        function documentClick(e) {
            if (self.isOpen && !self.config.inline) {
                var eventTarget_1 = getEventTarget(e);
                var isCalendarElement = isCalendarElem(eventTarget_1);
                var isInput = eventTarget_1 === self.input ||
                    eventTarget_1 === self.altInput ||
                    self.element.contains(eventTarget_1) ||
                    // web components
                    // e.path is not present in all browsers. circumventing typechecks
                    (e.path &&
                        e.path.indexOf &&
                        (~e.path.indexOf(self.input) ||
                            ~e.path.indexOf(self.altInput)));
                var lostFocus = e.type === "blur"
                    ? isInput &&
                        e.relatedTarget &&
                        !isCalendarElem(e.relatedTarget)
                    : !isInput &&
                        !isCalendarElement &&
                        !isCalendarElem(e.relatedTarget);
                var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                    return elem.contains(eventTarget_1);
                });
                if (lostFocus && isIgnored) {
                    self.close();
                    if (self.config.mode === "range" && self.selectedDates.length === 1) {
                        self.clear(false);
                        self.redraw();
                    }
                }
            }
        }
        function changeYear(newYear) {
            if (!newYear ||
                (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                return;
            var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
            self.currentYear = newYearNum || self.currentYear;
            if (self.config.maxDate &&
                self.currentYear === self.config.maxDate.getFullYear()) {
                self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
            }
            else if (self.config.minDate &&
                self.currentYear === self.config.minDate.getFullYear()) {
                self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
            }
            if (isNewYear) {
                self.redraw();
                triggerEvent("onYearChange");
            }
        }
        function isEnabled(date, timeless) {
            if (timeless === void 0) { timeless = true; }
            var dateToCheck = self.parseDate(date, undefined, timeless); // timeless
            if ((self.config.minDate &&
                dateToCheck &&
                compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                (self.config.maxDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                return false;
            if (self.config.enable.length === 0 && self.config.disable.length === 0)
                return true;
            if (dateToCheck === undefined)
                return false;
            var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;
            for (var i = 0, d = void 0; i < array.length; i++) {
                d = array[i];
                if (typeof d === "function" &&
                    d(dateToCheck) // disabled by function
                )
                    return bool;
                else if (d instanceof Date &&
                    dateToCheck !== undefined &&
                    d.getTime() === dateToCheck.getTime())
                    // disabled by date
                    return bool;
                else if (typeof d === "string" && dateToCheck !== undefined) {
                    // disabled by date string
                    var parsed = self.parseDate(d, undefined, true);
                    return parsed && parsed.getTime() === dateToCheck.getTime()
                        ? bool
                        : !bool;
                }
                else if (
                // disabled by range
                typeof d === "object" &&
                    dateToCheck !== undefined &&
                    d.from &&
                    d.to &&
                    dateToCheck.getTime() >= d.from.getTime() &&
                    dateToCheck.getTime() <= d.to.getTime())
                    return bool;
            }
            return !bool;
        }
        function isInView(elem) {
            if (self.daysContainer !== undefined)
                return (elem.className.indexOf("hidden") === -1 &&
                    self.daysContainer.contains(elem));
            return false;
        }
        function onKeyDown(e) {
            // e.key                      e.keyCode
            // "Backspace"                        8
            // "Tab"                              9
            // "Enter"                           13
            // "Escape"     (IE "Esc")           27
            // "ArrowLeft"  (IE "Left")          37
            // "ArrowUp"    (IE "Up")            38
            // "ArrowRight" (IE "Right")         39
            // "ArrowDown"  (IE "Down")          40
            // "Delete"     (IE "Del")           46
            var isInput = e.target === self._input;
            var allowInput = self.config.allowInput;
            var allowKeydown = self.isOpen && (!allowInput || !isInput);
            var allowInlineKeydown = self.config.inline && isInput && !allowInput;
            if (e.keyCode === 13 && isInput) {
                if (allowInput) {
                    self.setDate(self._input.value, true, e.target === self.altInput
                        ? self.config.altFormat
                        : self.config.dateFormat);
                    return e.target.blur();
                }
                else
                    self.open();
            }
            else if (isCalendarElem(e.target) ||
                allowKeydown ||
                allowInlineKeydown) {
                var isTimeObj = !!self.timeContainer &&
                    self.timeContainer.contains(e.target);
                switch (e.keyCode) {
                    case 13:
                        if (isTimeObj) {
                            updateTime();
                            focusAndClose();
                        }
                        else
                            selectDate(e);
                        break;
                    case 27: // escape
                        e.preventDefault();
                        focusAndClose();
                        break;
                    case 8:
                    case 46:
                        if (isInput && !self.config.allowInput) {
                            e.preventDefault();
                            self.clear();
                        }
                        break;
                    case 37:
                    case 39:
                        if (!isTimeObj) {
                            e.preventDefault();
                            if (self.daysContainer !== undefined &&
                                (allowInput === false ||
                                    (document.activeElement && isInView(document.activeElement)))) {
                                var delta_1 = e.keyCode === 39 ? 1 : -1;
                                if (!e.ctrlKey)
                                    focusOnDay(undefined, delta_1);
                                else {
                                    e.stopPropagation();
                                    changeMonth(delta_1);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                            }
                        }
                        else if (self.hourElement)
                            self.hourElement.focus();
                        break;
                    case 38:
                    case 40:
                        e.preventDefault();
                        var delta = e.keyCode === 40 ? 1 : -1;
                        if ((self.daysContainer && e.target.$i !== undefined) ||
                            e.target === self.input) {
                            if (e.ctrlKey) {
                                e.stopPropagation();
                                changeYear(self.currentYear - delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                            else if (!isTimeObj)
                                focusOnDay(undefined, delta * 7);
                        }
                        else if (self.config.enableTime) {
                            if (!isTimeObj && self.hourElement)
                                self.hourElement.focus();
                            updateTime(e);
                            self._debouncedChange();
                        }
                        break;
                    case 9:
                        if (isTimeObj) {
                            var elems = [
                                self.hourElement,
                                self.minuteElement,
                                self.secondElement,
                                self.amPM,
                            ].filter(function (x) { return x; });
                            var i = elems.indexOf(e.target);
                            if (i !== -1) {
                                var target = elems[i + (e.shiftKey ? -1 : 1)];
                                if (target !== undefined) {
                                    e.preventDefault();
                                    target.focus();
                                }
                                else if (e.shiftKey) {
                                    e.preventDefault();
                                    self._input.focus();
                                }
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
            if (self.amPM !== undefined && e.target === self.amPM) {
                switch (e.key) {
                    case self.l10n.amPM[0].charAt(0):
                    case self.l10n.amPM[0].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[0];
                        setHoursFromInputs();
                        updateValue();
                        break;
                    case self.l10n.amPM[1].charAt(0):
                    case self.l10n.amPM[1].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[1];
                        setHoursFromInputs();
                        updateValue();
                        break;
                }
            }
            triggerEvent("onKeyDown", e);
        }
        function onMouseOver(elem) {
            if (self.selectedDates.length !== 1 ||
                (elem &&
                    (!elem.classList.contains("flatpickr-day") ||
                        elem.classList.contains("disabled"))))
                return;
            var hoverDate = elem
                ? elem.dateObj.getTime()
                : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime()), lastDate = self.daysContainer.lastChild
                .lastChild.dateObj.getTime();
            var containsDisabled = false;
            var minRange = 0, maxRange = 0;
            for (var t = rangeStartDate; t < lastDate; t += duration.DAY) {
                if (!isEnabled(new Date(t), true)) {
                    containsDisabled =
                        containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                    if (t < initialDate && (!minRange || t > minRange))
                        minRange = t;
                    else if (t > initialDate && (!maxRange || t < maxRange))
                        maxRange = t;
                }
            }
            for (var m = 0; m < self.config.showMonths; m++) {
                var month = self.daysContainer.children[m];
                var prevMonth = self.daysContainer.children[m - 1];
                var _loop_1 = function (i, l) {
                    var dayElem = month.children[i], date = dayElem.dateObj;
                    var timestamp = date.getTime();
                    var outOfRange = (minRange > 0 && timestamp < minRange) ||
                        (maxRange > 0 && timestamp > maxRange);
                    if (outOfRange) {
                        dayElem.classList.add("notAllowed");
                        ["inRange", "startRange", "endRange"].forEach(function (c) {
                            dayElem.classList.remove(c);
                        });
                        return "continue";
                    }
                    else if (containsDisabled && !outOfRange)
                        return "continue";
                    ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                        dayElem.classList.remove(c);
                    });
                    if (elem !== undefined) {
                        elem.classList.add(hoverDate < self.selectedDates[0].getTime()
                            ? "startRange"
                            : "endRange");
                        if (month.contains(elem) ||
                            !(m > 0 &&
                                prevMonth &&
                                prevMonth.lastChild.dateObj.getTime() >= timestamp)) {
                            if (initialDate < hoverDate && timestamp === initialDate)
                                dayElem.classList.add("startRange");
                            else if (initialDate > hoverDate && timestamp === initialDate)
                                dayElem.classList.add("endRange");
                            if (timestamp >= minRange &&
                                (maxRange === 0 || timestamp <= maxRange) &&
                                isBetween(timestamp, initialDate, hoverDate))
                                dayElem.classList.add("inRange");
                        }
                    }
                };
                for (var i = 0, l = month.children.length; i < l; i++) {
                    _loop_1(i, l);
                }
            }
        }
        function onResize() {
            if (self.isOpen && !self.config.static && !self.config.inline)
                positionCalendar();
        }
        function setDefaultTime() {
            self.setDate(self.config.minDate !== undefined
                ? new Date(self.config.minDate.getTime())
                : new Date(), false);
            setDefaultHours();
            updateValue();
        }
        function open(e, positionElement) {
            if (positionElement === void 0) { positionElement = self._positionElement; }
            if (self.isMobile === true) {
                if (e) {
                    e.preventDefault();
                    e.target && e.target.blur();
                }
                if (self.mobileInput !== undefined) {
                    self.mobileInput.focus();
                    self.mobileInput.click();
                }
                triggerEvent("onOpen");
                return;
            }
            if (self._input.disabled || self.config.inline)
                return;
            var wasOpen = self.isOpen;
            self.isOpen = true;
            if (!wasOpen) {
                self.calendarContainer.classList.add("open");
                self._input.classList.add("active");
                triggerEvent("onOpen");
                positionCalendar(positionElement);
            }
            if (self.config.enableTime === true && self.config.noCalendar === true) {
                if (self.selectedDates.length === 0) {
                    setDefaultTime();
                }
                if (self.config.allowInput === false &&
                    (e === undefined ||
                        !self.timeContainer.contains(e.relatedTarget))) {
                    setTimeout(function () { return self.hourElement.select(); }, 50);
                }
            }
        }
        function minMaxDateSetter(type) {
            return function (date) {
                var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
                var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
                if (dateObj !== undefined) {
                    self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                        dateObj.getHours() > 0 ||
                            dateObj.getMinutes() > 0 ||
                            dateObj.getSeconds() > 0;
                }
                if (self.selectedDates) {
                    self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                    if (!self.selectedDates.length && type === "min")
                        setHoursFromDate(dateObj);
                    updateValue();
                }
                if (self.daysContainer) {
                    redraw();
                    if (dateObj !== undefined)
                        self.currentYearElement[type] = dateObj.getFullYear().toString();
                    else
                        self.currentYearElement.removeAttribute(type);
                    self.currentYearElement.disabled =
                        !!inverseDateObj &&
                            dateObj !== undefined &&
                            inverseDateObj.getFullYear() === dateObj.getFullYear();
                }
            };
        }
        function parseConfig() {
            var boolOpts = [
                "wrap",
                "weekNumbers",
                "allowInput",
                "clickOpens",
                "time_24hr",
                "enableTime",
                "noCalendar",
                "altInput",
                "shorthandCurrentMonth",
                "inline",
                "static",
                "enableSeconds",
                "disableMobile",
            ];
            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
            var formats = {};
            self.config.parseDate = userConfig.parseDate;
            self.config.formatDate = userConfig.formatDate;
            Object.defineProperty(self.config, "enable", {
                get: function () { return self.config._enable; },
                set: function (dates) {
                    self.config._enable = parseDateRules(dates);
                }
            });
            Object.defineProperty(self.config, "disable", {
                get: function () { return self.config._disable; },
                set: function (dates) {
                    self.config._disable = parseDateRules(dates);
                }
            });
            var timeMode = userConfig.mode === "time";
            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                formats.dateFormat =
                    userConfig.noCalendar || timeMode
                        ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                        : flatpickr.defaultConfig.dateFormat +
                            " H:i" +
                            (userConfig.enableSeconds ? ":S" : "");
            }
            if (userConfig.altInput &&
                (userConfig.enableTime || timeMode) &&
                !userConfig.altFormat) {
                formats.altFormat =
                    userConfig.noCalendar || timeMode
                        ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                        : flatpickr.defaultConfig.altFormat +
                            (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
            }
            Object.defineProperty(self.config, "minDate", {
                get: function () { return self.config._minDate; },
                set: minMaxDateSetter("min")
            });
            Object.defineProperty(self.config, "maxDate", {
                get: function () { return self.config._maxDate; },
                set: minMaxDateSetter("max")
            });
            var minMaxTimeSetter = function (type) { return function (val) {
                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
            }; };
            Object.defineProperty(self.config, "minTime", {
                get: function () { return self.config._minTime; },
                set: minMaxTimeSetter("min")
            });
            Object.defineProperty(self.config, "maxTime", {
                get: function () { return self.config._maxTime; },
                set: minMaxTimeSetter("max")
            });
            if (userConfig.mode === "time") {
                self.config.noCalendar = true;
                self.config.enableTime = true;
            }
            Object.assign(self.config, formats, userConfig);
            for (var i = 0; i < boolOpts.length; i++)
                self.config[boolOpts[i]] =
                    self.config[boolOpts[i]] === true ||
                        self.config[boolOpts[i]] === "true";
            HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
                self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
            });
            self.isMobile =
                !self.config.disableMobile &&
                    !self.config.inline &&
                    self.config.mode === "single" &&
                    !self.config.disable.length &&
                    !self.config.enable.length &&
                    !self.config.weekNumbers &&
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            for (var i = 0; i < self.config.plugins.length; i++) {
                var pluginConf = self.config.plugins[i](self) || {};
                for (var key in pluginConf) {
                    if (HOOKS.indexOf(key) > -1) {
                        self.config[key] = arrayify(pluginConf[key])
                            .map(bindToInstance)
                            .concat(self.config[key]);
                    }
                    else if (typeof userConfig[key] === "undefined")
                        self.config[key] = pluginConf[key];
                }
            }
            triggerEvent("onParseConfig");
        }
        function setupLocale() {
            if (typeof self.config.locale !== "object" &&
                typeof flatpickr.l10ns[self.config.locale] === "undefined")
                self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
            self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"
                ? self.config.locale
                : self.config.locale !== "default"
                    ? flatpickr.l10ns[self.config.locale]
                    : undefined));
            tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
            self.formatDate = createDateFormatter(self);
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        }
        function positionCalendar(customPositionElement) {
            if (self.calendarContainer === undefined)
                return;
            triggerEvent("onPreCalendarPosition");
            var positionElement = customPositionElement || self._positionElement;
            var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                (configPosVertical !== "below" &&
                    distanceFromBottom < calendarHeight &&
                    inputBounds.top > calendarHeight);
            var top = window.pageYOffset +
                inputBounds.top +
                (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
            toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
            toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
            if (self.config.inline)
                return;
            var left = window.pageXOffset +
                inputBounds.left -
                (configPosHorizontal != null && configPosHorizontal === "center"
                    ? (calendarWidth - inputBounds.width) / 2
                    : 0);
            var right = window.document.body.offsetWidth - inputBounds.right;
            var rightMost = left + calendarWidth > window.document.body.offsetWidth;
            var centerMost = right + calendarWidth > window.document.body.offsetWidth;
            toggleClass(self.calendarContainer, "rightMost", rightMost);
            if (self.config.static)
                return;
            self.calendarContainer.style.top = top + "px";
            if (!rightMost) {
                self.calendarContainer.style.left = left + "px";
                self.calendarContainer.style.right = "auto";
            }
            else if (!centerMost) {
                self.calendarContainer.style.left = "auto";
                self.calendarContainer.style.right = right + "px";
            }
            else {
                var doc = document.styleSheets[0];
                // some testing environments don't have css support
                if (doc === undefined)
                    return;
                var bodyWidth = window.document.body.offsetWidth;
                var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                var centerBefore = ".flatpickr-calendar.centerMost:before";
                var centerAfter = ".flatpickr-calendar.centerMost:after";
                var centerIndex = doc.cssRules.length;
                var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                toggleClass(self.calendarContainer, "rightMost", false);
                toggleClass(self.calendarContainer, "centerMost", true);
                doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                self.calendarContainer.style.left = centerLeft + "px";
                self.calendarContainer.style.right = "auto";
            }
        }
        function redraw() {
            if (self.config.noCalendar || self.isMobile)
                return;
            updateNavigationCurrentMonth();
            buildDays();
        }
        function focusAndClose() {
            self._input.focus();
            if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                navigator.msMaxTouchPoints !== undefined) {
                // hack - bugs in the way IE handles focus keeps the calendar open
                setTimeout(self.close, 0);
            }
            else {
                self.close();
            }
        }
        function selectDate(e) {
            e.preventDefault();
            e.stopPropagation();
            var isSelectable = function (day) {
                return day.classList &&
                    day.classList.contains("flatpickr-day") &&
                    !day.classList.contains("disabled") &&
                    !day.classList.contains("notAllowed");
            };
            var t = findParent(e.target, isSelectable);
            if (t === undefined)
                return;
            var target = t;
            var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
            var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                selectedDate.getMonth() >
                    self.currentMonth + self.config.showMonths - 1) &&
                self.config.mode !== "range";
            self.selectedDateElem = target;
            if (self.config.mode === "single")
                self.selectedDates = [selectedDate];
            else if (self.config.mode === "multiple") {
                var selectedIndex = isDateSelected(selectedDate);
                if (selectedIndex)
                    self.selectedDates.splice(parseInt(selectedIndex), 1);
                else
                    self.selectedDates.push(selectedDate);
            }
            else if (self.config.mode === "range") {
                if (self.selectedDates.length === 2) {
                    self.clear(false, false);
                }
                self.latestSelectedDateObj = selectedDate;
                self.selectedDates.push(selectedDate);
                // unless selecting same date twice, sort ascendingly
                if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
            }
            setHoursFromInputs();
            if (shouldChangeMonth) {
                var isNewYear = self.currentYear !== selectedDate.getFullYear();
                self.currentYear = selectedDate.getFullYear();
                self.currentMonth = selectedDate.getMonth();
                if (isNewYear)
                    triggerEvent("onYearChange");
                triggerEvent("onMonthChange");
            }
            updateNavigationCurrentMonth();
            buildDays();
            updateValue();
            if (self.config.enableTime)
                setTimeout(function () { return (self.showTimeInput = true); }, 50);
            // maintain focus
            if (!shouldChangeMonth &&
                self.config.mode !== "range" &&
                self.config.showMonths === 1)
                focusOnDayElem(target);
            else if (self.selectedDateElem !== undefined &&
                self.hourElement === undefined) {
                self.selectedDateElem && self.selectedDateElem.focus();
            }
            if (self.hourElement !== undefined)
                self.hourElement !== undefined && self.hourElement.focus();
            if (self.config.closeOnSelect) {
                var single = self.config.mode === "single" && !self.config.enableTime;
                var range = self.config.mode === "range" &&
                    self.selectedDates.length === 2 &&
                    !self.config.enableTime;
                if (single || range) {
                    focusAndClose();
                }
            }
            triggerChange();
        }
        var CALLBACKS = {
            locale: [setupLocale, updateWeekdays],
            showMonths: [buildMonths, setCalendarWidth, buildWeekdays]
        };
        function set(option, value) {
            if (option !== null && typeof option === "object")
                Object.assign(self.config, option);
            else {
                self.config[option] = value;
                if (CALLBACKS[option] !== undefined)
                    CALLBACKS[option].forEach(function (x) { return x(); });
                else if (HOOKS.indexOf(option) > -1)
                    self.config[option] = arrayify(value);
            }
            self.redraw();
            updateValue(false);
        }
        function setSelectedDate(inputDate, format) {
            var dates = [];
            if (inputDate instanceof Array)
                dates = inputDate.map(function (d) { return self.parseDate(d, format); });
            else if (inputDate instanceof Date || typeof inputDate === "number")
                dates = [self.parseDate(inputDate, format)];
            else if (typeof inputDate === "string") {
                switch (self.config.mode) {
                    case "single":
                    case "time":
                        dates = [self.parseDate(inputDate, format)];
                        break;
                    case "multiple":
                        dates = inputDate
                            .split(self.config.conjunction)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    case "range":
                        dates = inputDate
                            .split(self.l10n.rangeSeparator)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    default:
                        break;
                }
            }
            else
                self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
            self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });
            if (self.config.mode === "range")
                self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
        }
        function setDate(date, triggerChange, format) {
            if (triggerChange === void 0) { triggerChange = false; }
            if (format === void 0) { format = self.config.dateFormat; }
            if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                return self.clear(triggerChange);
            setSelectedDate(date, format);
            self.showTimeInput = self.selectedDates.length > 0;
            self.latestSelectedDateObj = self.selectedDates[0];
            self.redraw();
            jumpToDate();
            setHoursFromDate();
            updateValue(triggerChange);
            if (triggerChange)
                triggerEvent("onChange");
        }
        function parseDateRules(arr) {
            return arr
                .slice()
                .map(function (rule) {
                if (typeof rule === "string" ||
                    typeof rule === "number" ||
                    rule instanceof Date) {
                    return self.parseDate(rule, undefined, true);
                }
                else if (rule &&
                    typeof rule === "object" &&
                    rule.from &&
                    rule.to)
                    return {
                        from: self.parseDate(rule.from, undefined),
                        to: self.parseDate(rule.to, undefined)
                    };
                return rule;
            })
                .filter(function (x) { return x; }); // remove falsy values
        }
        function setupDates() {
            self.selectedDates = [];
            self.now = self.parseDate(self.config.now) || new Date();
            // Workaround IE11 setting placeholder as the input's value
            var preloadedDate = self.config.defaultDate ||
                ((self.input.nodeName === "INPUT" ||
                    self.input.nodeName === "TEXTAREA") &&
                    self.input.placeholder &&
                    self.input.value === self.input.placeholder
                    ? null
                    : self.input.value);
            if (preloadedDate)
                setSelectedDate(preloadedDate, self.config.dateFormat);
            self._initialDate =
                self.selectedDates.length > 0
                    ? self.selectedDates[0]
                    : self.config.minDate &&
                        self.config.minDate.getTime() > self.now.getTime()
                        ? self.config.minDate
                        : self.config.maxDate &&
                            self.config.maxDate.getTime() < self.now.getTime()
                            ? self.config.maxDate
                            : self.now;
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
            if (self.selectedDates.length > 0)
                self.latestSelectedDateObj = self.selectedDates[0];
            if (self.config.minTime !== undefined)
                self.config.minTime = self.parseDate(self.config.minTime, "H:i");
            if (self.config.maxTime !== undefined)
                self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
            self.minDateHasTime =
                !!self.config.minDate &&
                    (self.config.minDate.getHours() > 0 ||
                        self.config.minDate.getMinutes() > 0 ||
                        self.config.minDate.getSeconds() > 0);
            self.maxDateHasTime =
                !!self.config.maxDate &&
                    (self.config.maxDate.getHours() > 0 ||
                        self.config.maxDate.getMinutes() > 0 ||
                        self.config.maxDate.getSeconds() > 0);
            Object.defineProperty(self, "showTimeInput", {
                get: function () { return self._showTimeInput; },
                set: function (bool) {
                    self._showTimeInput = bool;
                    if (self.calendarContainer)
                        toggleClass(self.calendarContainer, "showTimeInput", bool);
                    self.isOpen && positionCalendar();
                }
            });
        }
        function setupInputs() {
            self.input = self.config.wrap
                ? element.querySelector("[data-input]")
                : element;
            /* istanbul ignore next */
            if (!self.input) {
                self.config.errorHandler(new Error("Invalid input element specified"));
                return;
            }
            // hack: store previous type to restore it after destroy()
            self.input._type = self.input.type;
            self.input.type = "text";
            self.input.classList.add("flatpickr-input");
            self._input = self.input;
            if (self.config.altInput) {
                // replicate self.element
                self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
                self._input = self.altInput;
                self.altInput.placeholder = self.input.placeholder;
                self.altInput.disabled = self.input.disabled;
                self.altInput.required = self.input.required;
                self.altInput.tabIndex = self.input.tabIndex;
                self.altInput.type = "text";
                self.input.setAttribute("type", "hidden");
                if (!self.config.static && self.input.parentNode)
                    self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
            }
            if (!self.config.allowInput)
                self._input.setAttribute("readonly", "readonly");
            self._positionElement = self.config.positionElement || self._input;
        }
        function setupMobile() {
            var inputType = self.config.enableTime
                ? self.config.noCalendar
                    ? "time"
                    : "datetime-local"
                : "date";
            self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
            self.mobileInput.step = self.input.getAttribute("step") || "any";
            self.mobileInput.tabIndex = 1;
            self.mobileInput.type = inputType;
            self.mobileInput.disabled = self.input.disabled;
            self.mobileInput.required = self.input.required;
            self.mobileInput.placeholder = self.input.placeholder;
            self.mobileFormatStr =
                inputType === "datetime-local"
                    ? "Y-m-d\\TH:i:S"
                    : inputType === "date"
                        ? "Y-m-d"
                        : "H:i:S";
            if (self.selectedDates.length > 0) {
                self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
            }
            if (self.config.minDate)
                self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
            if (self.config.maxDate)
                self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
            self.input.type = "hidden";
            if (self.altInput !== undefined)
                self.altInput.type = "hidden";
            try {
                if (self.input.parentNode)
                    self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
            }
            catch (_a) { }
            bind(self.mobileInput, "change", function (e) {
                self.setDate(e.target.value, false, self.mobileFormatStr);
                triggerEvent("onChange");
                triggerEvent("onClose");
            });
        }
        function toggle(e) {
            if (self.isOpen === true)
                return self.close();
            self.open(e);
        }
        function triggerEvent(event, data) {
            // If the instance has been destroyed already, all hooks have been removed
            if (self.config === undefined)
                return;
            var hooks = self.config[event];
            if (hooks !== undefined && hooks.length > 0) {
                for (var i = 0; hooks[i] && i < hooks.length; i++)
                    hooks[i](self.selectedDates, self.input.value, self, data);
            }
            if (event === "onChange") {
                self.input.dispatchEvent(createEvent("change"));
                // many front-end frameworks bind to the input event
                self.input.dispatchEvent(createEvent("input"));
            }
        }
        function createEvent(name) {
            var e = document.createEvent("Event");
            e.initEvent(name, true, true);
            return e;
        }
        function isDateSelected(date) {
            for (var i = 0; i < self.selectedDates.length; i++) {
                if (compareDates(self.selectedDates[i], date) === 0)
                    return "" + i;
            }
            return false;
        }
        function isDateInRange(date) {
            if (self.config.mode !== "range" || self.selectedDates.length < 2)
                return false;
            return (compareDates(date, self.selectedDates[0]) >= 0 &&
                compareDates(date, self.selectedDates[1]) <= 0);
        }
        function updateNavigationCurrentMonth() {
            if (self.config.noCalendar || self.isMobile || !self.monthNav)
                return;
            self.yearElements.forEach(function (yearElement, i) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                self.monthElements[i].textContent =
                    monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) +
                        " ";
                yearElement.value = d.getFullYear().toString();
            });
            self._hidePrevMonthArrow =
                self.config.minDate !== undefined &&
                    (self.currentYear === self.config.minDate.getFullYear()
                        ? self.currentMonth <= self.config.minDate.getMonth()
                        : self.currentYear < self.config.minDate.getFullYear());
            self._hideNextMonthArrow =
                self.config.maxDate !== undefined &&
                    (self.currentYear === self.config.maxDate.getFullYear()
                        ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                        : self.currentYear > self.config.maxDate.getFullYear());
        }
        function getDateStr(format) {
            return self.selectedDates
                .map(function (dObj) { return self.formatDate(dObj, format); })
                .filter(function (d, i, arr) {
                return self.config.mode !== "range" ||
                    self.config.enableTime ||
                    arr.indexOf(d) === i;
            })
                .join(self.config.mode !== "range"
                ? self.config.conjunction
                : self.l10n.rangeSeparator);
        }
        /**
         * Updates the values of inputs associated with the calendar
         */
        function updateValue(triggerChange) {
            if (triggerChange === void 0) { triggerChange = true; }
            if (self.selectedDates.length === 0)
                return self.clear(triggerChange);
            if (self.mobileInput !== undefined && self.mobileFormatStr) {
                self.mobileInput.value =
                    self.latestSelectedDateObj !== undefined
                        ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                        : "";
            }
            self.input.value = getDateStr(self.config.dateFormat);
            if (self.altInput !== undefined) {
                self.altInput.value = getDateStr(self.config.altFormat);
            }
            if (triggerChange !== false)
                triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e) {
            e.preventDefault();
            var isPrevMonth = self.prevMonthNav.contains(e.target);
            var isNextMonth = self.nextMonthNav.contains(e.target);
            if (isPrevMonth || isNextMonth) {
                changeMonth(isPrevMonth ? -1 : 1);
            }
            else if (self.yearElements.indexOf(e.target) >= 0) {
                e.target.select();
            }
            else if (e.target.classList.contains("arrowUp")) {
                self.changeYear(self.currentYear + 1);
            }
            else if (e.target.classList.contains("arrowDown")) {
                self.changeYear(self.currentYear - 1);
            }
        }
        function timeWrapper(e) {
            e.preventDefault();
            var isKeyDown = e.type === "keydown", input = e.target;
            if (self.amPM !== undefined && e.target === self.amPM) {
                self.amPM.textContent =
                    self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
            }
            var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
            var newValue = curValue + step * delta;
            if (typeof input.value !== "undefined" && input.value.length === 2) {
                var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                if (newValue < min) {
                    newValue =
                        max +
                            newValue +
                            int(!isHourElem) +
                            (int(isHourElem) && int(!self.amPM));
                    if (isMinuteElem)
                        incrementNumInput(undefined, -1, self.hourElement);
                }
                else if (newValue > max) {
                    newValue =
                        input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                    if (isMinuteElem)
                        incrementNumInput(undefined, 1, self.hourElement);
                }
                if (self.amPM &&
                    isHourElem &&
                    (step === 1
                        ? newValue + curValue === 23
                        : Math.abs(newValue - curValue) > step)) {
                    self.amPM.textContent =
                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                }
                input.value = pad(newValue);
            }
        }
        init();
        return self;
    }
    /* istanbul ignore next */
    function _flatpickr(nodeList, config) {
        // static list
        var nodes = Array.prototype.slice
            .call(nodeList)
            .filter(function (x) { return x instanceof HTMLElement; });
        var instances = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            try {
                if (node.getAttribute("data-fp-omit") !== null)
                    continue;
                if (node._flatpickr !== undefined) {
                    node._flatpickr.destroy();
                    node._flatpickr = undefined;
                }
                node._flatpickr = FlatpickrInstance(node, config || {});
                instances.push(node._flatpickr);
            }
            catch (e) {
                console.error(e);
            }
        }
        return instances.length === 1 ? instances[0] : instances;
    }
    /* istanbul ignore next */
    if (typeof HTMLElement !== "undefined") {
        // browser env
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
        HTMLElement.prototype.flatpickr = function (config) {
            return _flatpickr([this], config);
        };
    }
    /* istanbul ignore next */
    var flatpickr = function (selector, config) {
        if (typeof selector === "string") {
            return _flatpickr(window.document.querySelectorAll(selector), config);
        }
        else if (selector instanceof Node) {
            return _flatpickr([selector], config);
        }
        else {
            return _flatpickr(selector, config);
        }
    };
    /* istanbul ignore next */
    flatpickr.defaultConfig = defaults;
    flatpickr.l10ns = {
        en: __assign({}, english),
        "default": __assign({}, english)
    };
    flatpickr.localize = function (l10n) {
        flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
    };
    flatpickr.setDefaults = function (config) {
        flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
    };
    flatpickr.parseDate = createDateParser({});
    flatpickr.formatDate = createDateFormatter({});
    flatpickr.compareDates = compareDates;
    /* istanbul ignore next */
    if (typeof jQuery !== "undefined") {
        jQuery.fn.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
    }
    Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
    };
    if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
    }

    return flatpickr;

}));

},{}],131:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.de = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var German = {
      weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
              "Sonntag",
              "Montag",
              "Dienstag",
              "Mittwoch",
              "Donnerstag",
              "Freitag",
              "Samstag",
          ]
      },
      months: {
          shorthand: [
              "Jan",
              "Feb",
              "Mr",
              "Apr",
              "Mai",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Okt",
              "Nov",
              "Dez",
          ],
          longhand: [
              "Januar",
              "Februar",
              "Mrz",
              "April",
              "Mai",
              "Juni",
              "Juli",
              "August",
              "September",
              "Oktober",
              "November",
              "Dezember",
          ]
      },
      firstDayOfWeek: 1,
      weekAbbreviation: "KW",
      rangeSeparator: " bis ",
      scrollTitle: "Zum ndern scrollen",
      toggleTitle: "Zum Umschalten klicken"
  };
  fp.l10ns.de = German;
  var de = fp.l10ns;

  exports.German = German;
  exports.default = de;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],132:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.fr = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var French = {
      firstDayOfWeek: 1,
      weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: [
              "dimanche",
              "lundi",
              "mardi",
              "mercredi",
              "jeudi",
              "vendredi",
              "samedi",
          ]
      },
      months: {
          shorthand: [
              "janv",
              "fvr",
              "mars",
              "avr",
              "mai",
              "juin",
              "juil",
              "aot",
              "sept",
              "oct",
              "nov",
              "dc",
          ],
          longhand: [
              "janvier",
              "fvrier",
              "mars",
              "avril",
              "mai",
              "juin",
              "juillet",
              "aot",
              "septembre",
              "octobre",
              "novembre",
              "dcembre",
          ]
      },
      ordinal: function (nth) {
          if (nth > 1)
              return "";
          return "er";
      },
      rangeSeparator: " au ",
      weekAbbreviation: "Sem",
      scrollTitle: "Dfiler pour augmenter la valeur",
      toggleTitle: "Cliquer pour basculer"
  };
  fp.l10ns.fr = French;
  var fr = fp.l10ns;

  exports.French = French;
  exports.default = fr;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],133:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.it = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var Italian = {
      weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: [
              "Domenica",
              "Luned",
              "Marted",
              "Mercoled",
              "Gioved",
              "Venerd",
              "Sabato",
          ]
      },
      months: {
          shorthand: [
              "Gen",
              "Feb",
              "Mar",
              "Apr",
              "Mag",
              "Giu",
              "Lug",
              "Ago",
              "Set",
              "Ott",
              "Nov",
              "Dic",
          ],
          longhand: [
              "Gennaio",
              "Febbraio",
              "Marzo",
              "Aprile",
              "Maggio",
              "Giugno",
              "Luglio",
              "Agosto",
              "Settembre",
              "Ottobre",
              "Novembre",
              "Dicembre",
          ]
      },
      firstDayOfWeek: 1,
      ordinal: function () { return ""; },
      rangeSeparator: " al ",
      weekAbbreviation: "Se",
      scrollTitle: "Scrolla per aumentare",
      toggleTitle: "Clicca per cambiare"
  };
  fp.l10ns.it = Italian;
  var it = fp.l10ns;

  exports.Italian = Italian;
  exports.default = it;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],134:[function(require,module,exports){
(function (global){
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.12.9
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Popper = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element && element.offsetParent;
  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    if (element) {
      return element.ownerDocument.documentElement;
    }

    return document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

/**
 * Tells if you are running Internet Explorer 10
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean} isIE10
 */
var isIE10 = undefined;

var isIE10$1 = function () {
  if (isIE10 === undefined) {
    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
  }
  return isIE10;
};

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE10$1() && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  if (isIE10$1()) {
    try {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } catch (err) {}
  } else {
    rect = element.getBoundingClientRect();
  }

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var isIE10 = isIE10$1();
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = getScroll(html);
  var scrollLeft = getScroll(html, 'left');

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = { top: 0, left: 0 };
  var offsetParent = findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var commonOffsetParent = findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length - 1; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.left = '';
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper.
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // floor sides to avoid blurry text
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.floor(popper.top),
    bottom: Math.floor(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

return Popper;

})));


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],135:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtYWluL2J1bmRsZS50cyIsIm1haW4vcG9seWZpbGxzL01hdGguc2lnbi50cyIsIm1haW4vcG9seWZpbGxzL3N0YXJ0c1dpdGgudHMiLCJtYWluL3NkeC1nbG9iYWwudHMiLCJtYWluL3NyYy9Eb21FbGVtZW50LnRzIiwibWFpbi9zcmMvRG9tRnVuY3Rpb25zLnRzIiwibWFpbi9zcmMvSW5wdXRzLnRzIiwibWFpbi9zcmMvVXRpbHMudHMiLCJtYWluL3NyYy9hY2NvcmRpb24vQWNjb3JkaW9uLnRzIiwibWFpbi9zcmMvY2Fyb3VzZWwvQ2Fyb3VzZWwudHMiLCJtYWluL3NyYy9jaGFydHMvQmFyQ2hhcnRIb3Jpem9udGFsLnRzIiwibWFpbi9zcmMvY2hhcnRzL0JhckNoYXJ0VmVydGljYWwudHMiLCJtYWluL3NyYy9jaGFydHMvQ2hhcnRGdW5jdGlvbnMudHMiLCJtYWluL3NyYy9jaGFydHMvUGllQ2hhcnQudHMiLCJtYWluL3NyYy9jb2xsYXBzZS9Db2xsYXBzZS50cyIsIm1haW4vc3JjL2VtcHR5LXN0YXRlcy9FbXB0eVN0YXRlLnRzIiwibWFpbi9zcmMvZm9ybS9BdXRvY29tcGxldGUudHMiLCJtYWluL3NyYy9mb3JtL0lucHV0RmllbGQudHMiLCJtYWluL3NyYy9mb3JtL1JhbmdlLnRzIiwibWFpbi9zcmMvZm9ybS9TZWxlY3QudHMiLCJtYWluL3NyYy9mb3JtL1RleHRhcmVhLnRzIiwibWFpbi9zcmMvbG9hZGVyL0xvYWRlckJhci50cyIsIm1haW4vc3JjL21lbnUvTWVudUZseW91dC50cyIsIm1haW4vc3JjL21vZGFsL01vZGFsLnRzIiwibWFpbi9zcmMvbmF2aWdhdGlvbi9OYXZpZ2F0aW9uLnRzIiwibWFpbi9zcmMvbmF2aWdhdGlvbi9OYXZpZ2F0aW9uU2lkZS50cyIsIm1haW4vc3JjL25vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb24udHMiLCJtYWluL3NyYy9wcm9ncmVzcy9Qcm9ncmVzc0Z1bGwudHMiLCJtYWluL3NyYy9wcm9ncmVzcy9Qcm9ncmVzc0xpZ2h0LnRzIiwibWFpbi9zcmMvc2R4LnRzIiwibWFpbi9zcmMvc2VhcmNoL1NlYXJjaElucHV0LnRzIiwibWFpbi9zcmMvdGFibGUvVGFibGUudHMiLCJtYWluL3NyYy90b29sYmFyL1Rvb2xiYXIudHMiLCJidWlsZC90cy9tb2Rlcm5penIuanMiLCJub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hdGgvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWF0aC90cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL21heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvYm9keS1zY3JvbGwtbG9jay9saWIvYm9keVNjcm9sbExvY2subWluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXRoL3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvdHJ1bmMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1uYW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLmpzIiwibm9kZV9tb2R1bGVzL2ZsYXRwaWNrci9kaXN0L2wxMG4vZGUuanMiLCJub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9mci5qcyIsIm5vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9sMTBuL2l0LmpzIiwibm9kZV9tb2R1bGVzL3BvcHBlci5qcy9kaXN0L3VtZC9wb3BwZXIuanMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FDT0E7Ozs7QUNQQTs7QUFDQSxJQUFJLEVBQUUsVUFBTixJQUFJLENBQUosRUFBdUI7QUFDcEIsU0FBQSxJQUFBLEdBQW9CLFVBQUEsQ0FBQSxFQUFrQjtBQUNyQyxlQUFRLElBQUQsQ0FBQyxHQUFELENBQUMsR0FBZSxJQUFELENBQUMsR0FBUyxDQUFWLENBQUMsR0FBYyxDQUFyQyxDQUFBO0FBREQsS0FBQTtBQUdGOzs7OztBQ0hELElBQUksQ0FBQyxPQUFBLFNBQUEsQ0FBTCxVQUFBLEVBQWtDO0FBQ2hDLFdBQUEsU0FBQSxDQUFBLFVBQUEsR0FBOEIsVUFBQSxZQUFBLEVBQUEsUUFBQSxFQUErQjtBQUMzRCxtQkFBVyxZQUFYLENBQUE7QUFDQSxlQUFPLEtBQUEsT0FBQSxDQUFBLFlBQUEsRUFBQSxRQUFBLE1BQVAsUUFBQTtBQUZGLEtBQUE7QUFJRDs7Ozs7Ozs7O0FDTkQ7O0FBQ0E7O0FBRUE7O0lBQUEsVTs7OztBQTRDQSxJQUFJLE1BQUcsUUFBQSxRQUFBLENBQUEsRUFBQSxFQUFBLFVBQUEsRUFFRCxPQUFBLEdBQUEsSUFGQyxFQUFBLEVBRXVCLEVBQzVCLFNBSEYsV0FFOEIsRUFGdkIsQ0FBUDtBQWhEQTs7QUFzREEsT0FBQSxHQUFBLEdBQUEsR0FBQTtBQUVBLFdBQUEsS0FBQSxDQUFBLGVBQUEsQ0FBaUMsWUFBQTtBQUMvQixlQUFBLGNBQUE7QUFDQSxlQUFBLFlBQUE7QUFDQSxlQUFBLFVBQUE7QUFDQSxlQUFBLGFBQUE7QUFDQSxlQUFBLGdCQUFBO0FBRUEsZUFBQSxpQkFBQTtBQUNBLGVBQUEsZ0JBQUE7QUFF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QUEsQ0FBQSxDQUFBO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFBLFNBQUEsR0FBQSxTQUFBOztBQUdGO0FBOWtCQyxDQUFBLEVBQUEsTUFBQSxFQUFBLFFBQUE7OztBQ3pCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x3Q0E7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjhFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNzRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qKlxuICogVGhlIG1haW4gU0RYIGJ1bmRsZS4gVGhpcyBpbmNsdWRlcyBhbGwgZGVwZW5kZW5jaWVzIHJlcXVpcmVkIHRvXG4gKiB1c2UgdGhlIFNEWCBsaWJyYXJ5IGFuZCBpcyBpbnRlbmRlZCB0byB1c2UgaW4gc3RhdGljIGNvbnRleHRzLlxuICovXG5cbmltcG9ydCBcIi4uL21vZGVybml6clwiXG5cbmltcG9ydCBcIi4vc2R4LWdsb2JhbFwiXG4iLCIvLyBNYXRoLnNpZ24gKHVzZWQgaW4gUHJvZ3Jlc3NGdWxsKVxuaWYgKCEoXCJzaWduXCIgaW4gTWF0aCkpIHtcbiAgKE1hdGggYXMgYW55KS5zaWduID0gZnVuY3Rpb24oeDogbnVtYmVyKSB7XG4gICAgcmV0dXJuICh4ID4gMCkgPyAxIDogKCh4IDwgMCkgPyAtMSA6ICt4KVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCkge1xuICBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAwXG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSA9PT0gcG9zaXRpb25cbiAgfVxufVxuIiwiLyogUG9seWZpbGxzICovXG5pbXBvcnQgXCIuL3BvbHlmaWxscy9NYXRoLnNpZ25cIlxuaW1wb3J0IFwiLi9wb2x5ZmlsbHMvc3RhcnRzV2l0aFwiXG5cbmltcG9ydCAqIGFzIHNkeEV4cG9ydHMgZnJvbSBcIi4vc3JjL3NkeFwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgU0RYR2xvYmFsIHtcbiAgVkVSU0lPTjogc3RyaW5nXG5cbiAgTG9hZGVyQmFyOiB0eXBlb2Ygc2R4RXhwb3J0cy5Mb2FkZXJCYXJcblxuICBTZWxlY3Q6IHR5cGVvZiBzZHhFeHBvcnRzLlNlbGVjdFxuICBJbnB1dEZpZWxkOiB0eXBlb2Ygc2R4RXhwb3J0cy5JbnB1dEZpZWxkXG4gIFRleHRhcmVhOiB0eXBlb2Ygc2R4RXhwb3J0cy5UZXh0YXJlYVxuICBBdXRvY29tcGxldGU6IHR5cGVvZiBzZHhFeHBvcnRzLkF1dG9jb21wbGV0ZVxuXG4gIFByb2dyZXNzTGlnaHQ6IHR5cGVvZiBzZHhFeHBvcnRzLlByb2dyZXNzTGlnaHRcbiAgUHJvZ3Jlc3NGdWxsOiB0eXBlb2Ygc2R4RXhwb3J0cy5Qcm9ncmVzc0Z1bGxcblxuICBSYW5nZTogdHlwZW9mIHNkeEV4cG9ydHMuUmFuZ2VcbiAgTW9kYWw6IHR5cGVvZiBzZHhFeHBvcnRzLk1vZGFsXG4gIFRvb2xiYXI6IHR5cGVvZiBzZHhFeHBvcnRzLlRvb2xiYXJcbiAgTm90aWZpY2F0aW9uOiB0eXBlb2Ygc2R4RXhwb3J0cy5Ob3RpZmljYXRpb25cblxuICBDb2xsYXBzZTogdHlwZW9mIHNkeEV4cG9ydHMuQ29sbGFwc2VcbiAgQWNjb3JkaW9uOiB0eXBlb2Ygc2R4RXhwb3J0cy5BY2NvcmRpb25cblxuICBNZW51Rmx5b3V0OiB0eXBlb2Ygc2R4RXhwb3J0cy5NZW51Rmx5b3V0XG5cbiAgTmF2aWdhdGlvbjogdHlwZW9mIHNkeEV4cG9ydHMuTmF2aWdhdGlvblxuICBOYXZpZ2F0aW9uU2lkZTogdHlwZW9mIHNkeEV4cG9ydHMuTmF2aWdhdGlvblNpZGVcbiAgU2VhcmNoSW5wdXQ6IHR5cGVvZiBzZHhFeHBvcnRzLlNlYXJjaElucHV0XG4gIEVtcHR5U3RhdGU6IHR5cGVvZiBzZHhFeHBvcnRzLkVtcHR5U3RhdGVcbiAgQ2Fyb3VzZWw6IHR5cGVvZiBzZHhFeHBvcnRzLkNhcm91c2VsXG5cbiAgVGFibGU6IHR5cGVvZiBzZHhFeHBvcnRzLlRhYmxlXG5cbiAgUGllQ2hhcnQ6IHR5cGVvZiBzZHhFeHBvcnRzLlBpZUNoYXJ0XG4gIEJhckNoYXJ0SG9yaXpvbnRhbDogdHlwZW9mIHNkeEV4cG9ydHMuQmFyQ2hhcnRIb3Jpem9udGFsXG4gIEJhckNoYXJ0VmVydGljYWw6IHR5cGVvZiBzZHhFeHBvcnRzLkJhckNoYXJ0VmVydGljYWxcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBzZHg6IFNEWEdsb2JhbFxuICB9XG59XG5cbmxldCBzZHggPSB7XG4gIC4uLnNkeEV4cG9ydHMsXG4gIC4uLih3aW5kb3cuc2R4IGFzIGFueSkgfHwge30sXG4gIFZFUlNJT046IFwiJFZFUlNJT04kXCJcbn1cblxud2luZG93LnNkeCA9IHNkeFxuXG5zZHhFeHBvcnRzLnV0aWxzLm9uRG9jdW1lbnRSZWFkeSgoKSA9PiB7XG4gIHNkeEV4cG9ydHMuaW5pdElucHV0RmllbGQoKVxuICBzZHhFeHBvcnRzLmluaXRUZXh0YXJlYSgpXG4gIHNkeEV4cG9ydHMuaW5pdFNlbGVjdCgpXG4gIHNkeEV4cG9ydHMuaW5pdExvYWRlckJhcigpXG4gIHNkeEV4cG9ydHMuaW5pdEF1dG9jb21wbGV0ZSgpXG5cbiAgc2R4RXhwb3J0cy5pbml0UHJvZ3Jlc3NMaWdodCgpXG4gIHNkeEV4cG9ydHMuaW5pdFByb2dyZXNzRnVsbCgpXG5cbiAgc2R4RXhwb3J0cy5pbml0UmFuZ2UoKVxuICBzZHhFeHBvcnRzLmluaXRNb2RhbCgpXG5cbiAgc2R4RXhwb3J0cy5pbml0QWNjb3JkaW9uKClcbiAgc2R4RXhwb3J0cy5pbml0Q29sbGFwc2UoKVxuICBzZHhFeHBvcnRzLmluaXRNZW51Rmx5b3V0KClcblxuICBzZHhFeHBvcnRzLmluaXROYXZpZ2F0aW9uKClcbiAgc2R4RXhwb3J0cy5pbml0TmF2aWdhdGlvblNpZGUoKVxuICBzZHhFeHBvcnRzLmluaXRTZWFyY2hJbnB1dCgpXG4gIHNkeEV4cG9ydHMuaW5pdEVtcHR5U3RhdGUoKVxuICBzZHhFeHBvcnRzLmluaXRDYXJvdXNlbCgpXG4gIHNkeEV4cG9ydHMuaW5pdFRhYmxlKClcblxuICBzZHhFeHBvcnRzLmluaXRQaWVDaGFydCgpXG4gIHNkeEV4cG9ydHMuaW5pdEJhckNoYXJ0SG9yaXpvbnRhbCgpXG4gIHNkeEV4cG9ydHMuaW5pdEJhckNoYXJ0VmVydGljYWwoKVxufSlcbiIsImltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi9Eb21GdW5jdGlvbnNcIlxuXG5sZXQgaHRtbEV2ZW50czoge1xuICBbZXZlbnROYW1lOiBzdHJpbmddOiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEEgd3JhcHBlciBjbGFzcyBmb3IgRE9NIEVsZW1lbnRzLlxuICovXG5jbGFzcyBEb21FbGVtZW50PFQgZXh0ZW5kcyBFbGVtZW50ID0gRWxlbWVudD4ge1xuICBwdWJsaWMgZWxlbWVudDogVFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSAtIFRoZSBlbGVtZW50IHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAtIFRoZSBET00gZWxlbWVudCB0byBjcmVhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBUIHwga2V5b2YgRWxlbWVudFRhZ05hbWVNYXApIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudCkgYXMgRWxlbWVudCBhcyBUXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgc3BlY2lmaWVkIENTUyBjbGFzcyB0byB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIGNsYXNzIG5hbWUgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtEb21FbGVtZW50fSBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBmbHVlbnQgY2hhaW5pbmcgb2YgY2FsbHMuXG4gICAqL1xuICBwdWJsaWMgYWRkQ2xhc3MobmFtZTogc3RyaW5nKSB7XG4gICAgRG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBDU1MgY2xhc3MgZnJvbSB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIGNsYXNzIG5hbWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtEb21FbGVtZW50fSBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBmbHVlbnQgY2hhaW5pbmcgb2YgY2FsbHMuXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlQ2xhc3MobmFtZTogc3RyaW5nKSB7XG4gICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIGhhc0NsYXNzKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiBEb20uaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBuYW1lKVxuICB9XG5cbiAgcHVibGljIHRvZ2dsZUNsYXNzKG5hbWU6IHN0cmluZykge1xuICAgIERvbS50b2dnbGVDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBjbGFzc2VzKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0XG4gIH1cblxuICBwdWJsaWMgc2V0SWQoaWQ6IHN0cmluZykge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IGlubmVyVGV4dCgpIHtcbiAgICByZXR1cm4gRG9tLnRleHQodGhpcy5lbGVtZW50KVxuICB9XG5cbiAgZ2V0IGlubmVySHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmlubmVySFRNTFxuICB9XG5cbiAgcHVibGljIHNldEh0bWwodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEhUTUwgc3RyaW5nXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHZhbHVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBnZXRBdHRyaWJ1dGUobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSlcbiAgfVxuXG4gIHB1YmxpYyBzZXRBdHRyaWJ1dGUobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHB1YmxpYyBhZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwPih0eXBlOiBULCBsaXN0ZW5lcjogKGU6IEV2ZW50KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwPih0eXBlOiBULCBsaXN0ZW5lcjogKGU6IEV2ZW50KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cblxuICBwdWJsaWMgYXBwZW5kQ2hpbGQobmV3Q2hpbGQ6IERvbUVsZW1lbnQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChuZXdDaGlsZC5lbGVtZW50KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgcHJlcGVuZENoaWxkKG5ld0NoaWxkOiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCEobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb21FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvdGhlciBEb21FbGVtZW50cyBjYW4gYmUgYWRkZWQgYXMgY2hpbGRyZW5cIilcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLmVsZW1lbnQsIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgaW5zZXJ0QmVmb3JlKG5ld0NoaWxkOiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCEobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb21FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvdGhlciBEb21FbGVtZW50cyBjYW4gYmUgYWRkZWQgYXMgY2hpbGRyZW5cIilcbiAgICB9XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCBpcyBub3QgYXR0YWNoZWRcIilcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQuZWxlbWVudCwgdGhpcy5lbGVtZW50KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgaW5zZXJ0QWZ0ZXIobmV3Q2hpbGQ6IERvbUVsZW1lbnQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IGlzIG5vdCBhdHRhY2hlZFwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdDaGlsZC5lbGVtZW50LCB0aGlzLmVsZW1lbnQubmV4dFNpYmxpbmcpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVDaGlsZChvbGRDaGlsZDogRG9tRWxlbWVudCkge1xuICAgIGlmICghKG9sZENoaWxkIGluc3RhbmNlb2YgRG9tRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgYSBEb21FbGVtZW50cyBjaGlsZCBjYW4gYmUgcmVtb3ZlZFwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZChvbGRDaGlsZC5lbGVtZW50KVxuICB9XG5cbiAgcHVibGljIGZpbmQoc2VsZWN0b3JzOiBzdHJpbmcpIHtcbiAgICBsZXQgZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9ycylcbiAgICBpZiAoZSkge1xuICAgICAgcmV0dXJuIG5ldyBEb21FbGVtZW50KGUgYXMgRWxlbWVudClcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBwdWJsaWMgd3JhcFdpdGhFbGVtZW50KHdyYXBwZXJFbGVtZW50OiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCBpcyBub3QgYXR0YWNoZWRcIilcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHdyYXBwZXJFbGVtZW50LmVsZW1lbnQsIHRoaXMuZWxlbWVudClcbiAgICB3cmFwcGVyRWxlbWVudC5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgZGlzcGF0Y2hFdmVudChldmVudE5hbWU6IHN0cmluZykge1xuICAgIGxldCBldmVudFxuICAgIGxldCBlbCA9IHRoaXMuZWxlbWVudFxuXG4gICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKVxuICAgICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSlcbiAgICB9IGVsc2UgaWYgKChkb2N1bWVudCBhcyBhbnkpLmNyZWF0ZUV2ZW50T2JqZWN0KSB7IC8vIElFIDwgOVxuICAgICAgZXZlbnQgPSAoZG9jdW1lbnQgYXMgYW55KS5jcmVhdGVFdmVudE9iamVjdCgpXG4gICAgICBldmVudC5ldmVudFR5cGUgPSBldmVudE5hbWVcbiAgICB9XG4gICAgZXZlbnQuZXZlbnROYW1lID0gZXZlbnROYW1lXG4gICAgaWYgKGVsLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgfSBlbHNlIGlmICgoZWwgYXMgYW55KS5maXJlRXZlbnQgJiYgaHRtbEV2ZW50c1tgb24ke2V2ZW50TmFtZX1gXSkgeyAvLyBJRSA8IDlcbiAgICAgIChlbCBhcyBhbnkpLmZpcmVFdmVudChgb24ke2V2ZW50LmV2ZW50VHlwZX1gLCBldmVudCkgLy8gY2FuIHRyaWdnZXIgb25seSByZWFsIGV2ZW50IChlLmcuICdjbGljaycpXG4gICAgfSBlbHNlIGlmIChlbFtldmVudE5hbWUgYXMga2V5b2YgRWxlbWVudF0pIHtcbiAgICAgIChlbCBhcyBhbnkpW2V2ZW50TmFtZV0oKVxuICAgIH0gZWxzZSBpZiAoZWxbYG9uJHtldmVudE5hbWV9YCBhcyBrZXlvZiBFbGVtZW50XSkge1xuICAgICAgKGVsIGFzIGFueSlbYG9uJHtldmVudE5hbWV9YF0oKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjc3MocHJvcGVydHk6IHN0cmluZykge1xuICAgIHJldHVybiBEb20uY3NzKHRoaXMuZWxlbWVudCwgcHJvcGVydHkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgY2hpbGQgbm9kZXMgb2YgdGhlIGN1cnJlbnQgRG9tRWxlbWVudC5cbiAgICovXG4gIHB1YmxpYyBlbXB0eSgpIHtcbiAgICBEb20uZW1wdHkodGhpcy5lbGVtZW50KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERvbUVsZW1lbnRcbiIsIlxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQ6IEVsZW1lbnQsIG5hbWU6IHN0cmluZykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgY2xhc3MgbmFtZVwiKVxuICB9XG5cbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50OiBFbGVtZW50LCBuYW1lOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGNsYXNzIG5hbWVcIilcbiAgfVxuXG4gIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShuYW1lKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudDogRWxlbWVudCwgbmFtZTogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBjbGFzcyBuYW1lXCIpXG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQ6IEVsZW1lbnQsIG5hbWU6IHN0cmluZykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgY2xhc3MgbmFtZVwiKVxuICB9XG5cbiAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKG5hbWUpXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBoaWRkZW4gZnJvbSB2aWV3LlxuICogQHBhcmFtIHtFbGVtZW50fSBFbGVtZW50IFRoZSBkb20gZWxlbWVudCB0byBjaGVjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZVBhcmVudHMgSWYgc2V0IHRvIGB0cnVlYCBzZWFyY2hlcyB1cCB0aGUgRE9NIGFuZCBjaGVja3MgcGFyZW50IHZpc2liaWxpdHkgYXMgd2VsbC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGlkZGVuKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBpbmNsdWRlUGFyZW50cyA9IGZhbHNlKTogYm9vbGVhbiB7XG4gIGlmIChpbmNsdWRlUGFyZW50cyA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpXG4gICAgcmV0dXJuIChzdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikgfHwgZWxlbWVudC5vZmZzZXRMZWZ0IDwgMFxuICB9XG5cbiAgbGV0IHJlc3VsdFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICB3aGlsZSAoKHJlc3VsdCA9IGlzSGlkZGVuKGVsZW1lbnQsIGZhbHNlKSkgPT09IGZhbHNlICYmIGVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnRcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0ZXh0IG9mIGFuIGVsZW1lbnQgYW4gbWFrZXMgc3VyZSB0aGlzIHdvcmtzIG9uIGFsbCBicm93c2Vycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQoZWxlbWVudDogRWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudCB8fCAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkuaW5uZXJUZXh0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJlbnRXaXRoQ2xhc3M8RSBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PihlbGVtZW50OiBFLCBjbGFzc05hbWU6IHN0cmluZyk6IEUgfCB1bmRlZmluZWQge1xuICBsZXQgY3VycmVudDogRSA9IGVsZW1lbnRcblxuICB3aGlsZSAoIWhhc0NsYXNzKGN1cnJlbnQsIGNsYXNzTmFtZSkgJiYgY3VycmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudCBhcyBFbGVtZW50IGFzIEVcbiAgfVxuXG4gIGlmIChoYXNDbGFzcyhjdXJyZW50LCBjbGFzc05hbWUpKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRleHRXaWR0aCh0ZXh0OiBzdHJpbmcsIGZvbnQ6IHN0cmluZykge1xuICAvLyBOT1RFOiB0aGlzIHdpZHRoIG1lYXN1cmluZyBhbGdvcml0aG0gaXMgYSBsb3QgZmFzdGVyXG4gIC8vIGJ1dCBkb2VzIHVuZm9ydHVuYXRlbHkgbm90IHdvcmsgb24gSUUgMTAuLi5cblxuICAvLyBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxuICAvLyBsZXQgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbiAgLy8gY29udGV4dC5mb250ID0gZm9udFxuICAvLyBsZXQgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dClcbiAgLy8gcmV0dXJuIE1hdGgucm91bmQobWV0cmljcy53aWR0aClcblxuICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICBkaXYuaW5uZXJIVE1MID0gdGV4dFxuXG4gIGRpdi5zdHlsZS5mb250ID0gZm9udFxuICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCJcbiAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpXG5cbiAgY29uc3QgcmVzdWx0ID0gZGl2Lm9mZnNldFdpZHRoXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzcyhlbGVtZW50OiBFbGVtZW50LCBwcm9wZXJ0eTogc3RyaW5nKSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNpbmdsZSBlbGVtZW50IHJlZmVyZW5jZWQgaW4gYW4gaXRlbXMgZGF0YS0qIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7RG9tRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHJlZmVyZW5jZSBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIC0gVGhlIG5hbWUgb2YgdGhlIHJlZmVyZW5jZSBhdHRyaWJ1dGUuXG4gKiBAcmV0dXJucyB7RG9tRWxlbWVudH0gVGhlIHJlZmVyZW5jZWQgZWxlbWVudDsgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHJlZmVyZW5jZSBpcyBpbnZhbGlkXG4gKiBvciB0aGUgYXR0cmlidXRlIGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVJlZmVyZW5jZTxJIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQsIE8gZXh0ZW5kcyBFbGVtZW50ID0gST4oZWxlbWVudDogSSwgYXR0cmlidXRlOiBzdHJpbmcpOiBPIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGF0dHJWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSlcblxuICBpZiAoIWF0dHJWYWx1ZSB8fCBhdHRyVmFsdWUgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhdHRyVmFsdWUpIGFzIEVsZW1lbnQgYXMgT1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRvY3VtZW50IHJvb3QgZWxlbWVudCAobm9ybWFsbHkgdGhlIGJvZHkgZWxlbWVudClcbiAqIElmIHRoZSBkb2N1bWVudCB1c2VzIGEgc2R4LWNvbnRhaW5lciB3cmFwcGVyIHRoaXMgaXMgcmV0dXJuZWQgaW5zdGVhZC5cbiAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgcm9vdCBkb20gZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvb3RFbGVtZW50KCkge1xuICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuc2R4LWNvbnRhaW5lclwiKVxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuYm9keVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBjaGlsZCBub2RlcyBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBEb20gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWxlbWVudDogRWxlbWVudCkge1xuICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpXG4gIH1cbn1cbiIsIi8qIEtleWJvYXJkIGlucHV0IGtleWNvZGUgZGVmaW5pdGlvbnMgKi9cblxuZXhwb3J0IGNvbnN0IEtFWV9UQUIgPSA5XG5leHBvcnQgY29uc3QgS0VZX0VOVEVSID0gMTNcbmV4cG9ydCBjb25zdCBLRVlfRVNDQVBFID0gMjdcblxuLy8gQXJyb3cga2V5c1xuZXhwb3J0IGNvbnN0IEtFWV9BUlJPV19VUCA9IDM4XG5leHBvcnQgY29uc3QgS0VZX0FSUk9XX0RPV04gPSA0MFxuZXhwb3J0IGNvbnN0IEtFWV9BUlJPV19MRUZUID0gMzdcbmV4cG9ydCBjb25zdCBLRVlfQVJST1dfUklHSFQgPSAzOVxuXG4vLyBQYWdlIGtleXNcbmV4cG9ydCBjb25zdCBLRVlfUEFHRV9VUCA9IDMzXG5leHBvcnQgY29uc3QgS0VZX1BBR0VfRE9XTiA9IDM0XG5cbi8vIE51bWJlcnNcbmV4cG9ydCBjb25zdCBLRVlfTlJfMCA9IDQ4XG5leHBvcnQgY29uc3QgS0VZX05SXzEgPSA0OVxuZXhwb3J0IGNvbnN0IEtFWV9OUl85ID0gNTdcblxuLy8gaGVscGVyIGZ1bmN0aW9uc1xuZXhwb3J0IGxldCBjb250YWluc0tleSA9IChrZXljb2RlOiBudW1iZXIsIGlucHV0c0tleXM6IG51bWJlcltdKSA9PiB7XG4gIGxldCBoYXNLZXkgPSBmYWxzZVxuICBpZiAoaW5wdXRzS2V5cyAmJiBpbnB1dHNLZXlzLmxlbmd0aCA+IDApIHtcbiAgICBbXS5mb3JFYWNoLmNhbGwoaW5wdXRzS2V5cywgKGlucHV0c0tleTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoa2V5Y29kZSA9PT0gaW5wdXRzS2V5KSB7XG4gICAgICAgIGhhc0tleSA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHJldHVybiBoYXNLZXlcbn1cblxuZXhwb3J0IGxldCBnZXRLZXlWYWx1ZSA9IChrZXljb2RlOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBpZiAoa2V5Y29kZSA8IDQ4IHx8IGtleWNvZGUgPiAxMDUpIHtcbiAgICByZXR1cm4gXCJcIlxuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDk2IDw9IGtleWNvZGUgJiYga2V5Y29kZSA8PSAxMDUgPyBrZXljb2RlIC0gNDggOiBrZXljb2RlKS50b0xvd2VyQ2FzZSgpXG59XG4iLCIvKipcbiAqIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjb21wbGV0ZWx5IHBhcnNlZC5cbiAqIEBwYXJhbSB7Y2FsbGJhY2t9IHZhbHVlIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Eb2N1bWVudFJlYWR5KGNhbGxiYWNrOiAoZT86IEV2ZW50KSA9PiB2b2lkKSB7XG4gIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlKVxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrKVxuICB9IGVsc2Uge1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSlcblxuICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UpXG4gIH1cbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IgYW5kIGNhbGxzIHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24gaWYgdGhlIGBkYXRhLWluaXRgIGF0dHJpYnV0ZSBpcyBwcmVzZW50IG9uIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtzZWxlY3Rvcn0gdmFsdWUgVGhlIHF1ZXJ5LlxuICogQHBhcmFtIHtjYWxsYmFja30gdmFsdWUgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpbml0U2VsZWN0b3IgVGhlIGluaXRpdGFsaXphdGlvbiBlbGVtZW50IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoQW5kSW5pdGlhbGl6ZTxcbiAgSyBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcFxuICA+KFxuICAgIHNlbGVjdG9yOiBLLFxuICAgIGNhbGxiYWNrOiAoZWw6IEhUTUxFbGVtZW50VGFnTmFtZU1hcFtLXSkgPT4gdm9pZCxcbiAgICBpbml0U2VsZWN0b3I/OiAoZWw6IEhUTUxFbGVtZW50VGFnTmFtZU1hcFtLXSkgPT4gRWxlbWVudFxuICApOiB2b2lkXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoQW5kSW5pdGlhbGl6ZTxcbiAgRSBleHRlbmRzIEVsZW1lbnRcbiAgPihcbiAgICBzZWxlY3Rvcjogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAoZWw6IEUpID0+IHZvaWQsXG4gICAgaW5pdFNlbGVjdG9yPzogKGVsOiBFKSA9PiBFbGVtZW50XG4gICk6IHZvaWRcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hBbmRJbml0aWFsaXplKFxuICBzZWxlY3Rvcjogc3RyaW5nLFxuICBjYWxsYmFjazogKGVsOiBFbGVtZW50KSA9PiB2b2lkLFxuICBpbml0U2VsZWN0b3I/OiAoZWw6IEVsZW1lbnQpID0+IEVsZW1lbnRcbik6IHZvaWQge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNhbGxiYWNrIGNhbm5vdCBiZSB1bmRlZmluZWRcIilcbiAgfVxuXG4gIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpIGFzIE5vZGVMaXN0T2Y8RWxlbWVudD5cblxuICBmb3IgKGxldCBlIG9mIGVsZW1lbnRzKSB7XG5cbiAgICBsZXQgaW5pdEVsZW1lbnQ6IEVsZW1lbnQgPSBlXG5cbiAgICBpZiAoaW5pdFNlbGVjdG9yKSB7XG4gICAgICBpbml0RWxlbWVudCA9IGluaXRTZWxlY3RvcihlKVxuICAgIH1cblxuICAgIGlmIChpbml0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluaXRcIikgPT09IFwiYXV0b1wiKSB7XG4gICAgICBjYWxsYmFjayhlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgd2hvc2UgdmFsdWUgaXMgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKlxuICogRXhhbXBsZTogbGltaXQgdGhlIG91dHB1dCBvZiB0aGlzIGNvbXB1dGF0aW9uIHRvIGJldHdlZW4gMCBhbmQgMjU1XG4gKiBVdGlscy5jbGFtcChudW1iZXIsIDAsIDI1NSlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG51bWJlciB0byBjbGFtcFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIG91dHB1dCByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIG91dHB1dCByYW5nZVxuICogQHJldHVybnMgQSBudW1iZXIgaW4gdGhlIHJhbmdlIFttaW4sIG1heF1cbiAqIEB0eXBlIE51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KVxufVxuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIEV2ZW50LnByZXZlbnREZWZhdWx0KCkuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50OiBFdmVudCkge1xuICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH0gZWxzZSB7XG4gICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgTm9kZS5yZW1vdmUoKS5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIHJlbW92ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShub2RlOiBOb2RlKSB7XG4gIGlmICghbm9kZSB8fCAhbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSlcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBwb2x5ZmlsbCBmb3IgdGhlIEFycmF5LmZpbmQoKSBtZXRob2QuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBleHByZXNzaW9uIC0gVGhlIGV4cHJlc3Npb24gdG8gZXZhbHVhdGUuIE11c3QgcmV0dXJuIHRydWUgaWYgdGhlIGVsZW1lbnQgbWF0Y2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VCA9IGFueT4oXG4gIGFycmF5OiBUW10gfCB7IGxlbmd0aDogbnVtYmVyLCBbaTogbnVtYmVyXTogVCB9LFxuICBleHByZXNzaW9uOiAoaXRlbTogVCkgPT4gYm9vbGVhblxuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgaXRlbSA9IGFycmF5W2ldXG4gICAgaWYgKGV4cHJlc3Npb24oaXRlbSkgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIENoZWNrcyB0aGUgdXNlcmFnZW50IGFuZCByZXR1cm5zIHRoZSBNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXIgLyBFZGdlIHZlcnNpb24uXG4gKiBJZiBhbm90aGVyIGJyb3dzZXIgaXMgZGV0ZWN0ZWQgMCBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uKHVzZXJBZ2VudDogc3RyaW5nID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAvLyBoYW5kbGUgSUUgYW5kIEVkZ2VcbiAgY29uc3QgaWVPckVkZ2UgPSB1c2VyQWdlbnQuc2VhcmNoKC9NU0lFIHxFZGdlWy9dLylcbiAgaWYgKGllT3JFZGdlID4gMCkge1xuICAgIHJldHVybiBwYXJzZUludCh1c2VyQWdlbnQuc3Vic3RyaW5nKGllT3JFZGdlICsgNSwgdXNlckFnZW50LmluZGV4T2YoXCIuXCIsIGllT3JFZGdlKSksIDEwKVxuICB9XG4gIC8vIGhhbmRsZSBJRTExXG4gIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIlRyaWRlbnQvXCIpID4gMCkge1xuICAgIGNvbnN0IHJ2ID0gdXNlckFnZW50LmluZGV4T2YoXCJydjpcIilcbiAgICByZXR1cm4gcGFyc2VJbnQodXNlckFnZW50LnN1YnN0cmluZyhydiArIDMsIHVzZXJBZ2VudC5pbmRleE9mKFwiLlwiLCBydikpLCAxMClcbiAgfVxuXG4gIHJldHVybiAwXG59XG5cbi8qKlxuICogVHJpZXMgdG8gbW92ZSBhIGNoaWxkIGVsZW1lbnQgdG8gdGhlIHRvcCBieSBzY3JvbGxpbmcgdGhlIHBhcmVudCBlbGVtZW50LCBpZiBpdCBpcyBub3QgYWxyZWFkeSBmdWxseSB2aXNpYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY2hpbGQ6IEhUTUxFbGVtZW50KSB7XG4gIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgY29uc3QgcGFyZW50UmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCBpc0Z1bGx5VmlzaWJsZSA9IGNoaWxkUmVjdC50b3AgPj0gcGFyZW50UmVjdC50b3AgJiYgY2hpbGRSZWN0LmJvdHRvbSA8PSBwYXJlbnRSZWN0LnRvcCArIHBhcmVudC5jbGllbnRIZWlnaHRcblxuICBpZiAoIWlzRnVsbHlWaXNpYmxlKSB7XG4gICAgcGFyZW50LnNjcm9sbFRvcCA9IGNoaWxkUmVjdC50b3AgKyBwYXJlbnQuc2Nyb2xsVG9wIC0gcGFyZW50UmVjdC50b3BcbiAgfVxufVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgYW5pbWUsIHsgQW5pbWVUaW1lbGluZUluc3RhbmNlIH0gZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9UT0dHTEUgPSBcIi5hY2NvcmRpb25fX3RvZ2dsZVwiXG5jb25zdCBRVUVSWV9PUEVOX1NFQ1RJT04gPSBcIi5hY2NvcmRpb25fX2l0ZW0uaXMtb3BlblwiXG5jb25zdCBRVUVSWV9DT0xMQVBTRSA9IFwiLmFjY29yZGlvbl9fY29sbGFwc2VcIlxuXG5jb25zdCBDTEFTU19JVEVNID0gXCJhY2NvcmRpb25fX2l0ZW1cIlxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5jb25zdCBDTEFTU19LRUVQX09QRU4gPSBcImFjY29yZGlvbl9fa2VlcC1vcGVuXCJcblxuY29uc3QgUkVHRVhfSElEREVOID0gL2FjY29yZGlvbi0taGlkZGVuLS4qL1xuXG5jb25zdCBBTklNQVRJT05fT1BFTiA9IDMwMFxuY29uc3QgQU5JTUFUSU9OX0RFTEFZX09QRU4gPSA1MFxuY29uc3QgQU5JTUFUSU9OX1ZJU0lCTEUgPSAxNTBcblxuLyoqXG4gKiBUaGUgQWNjb3JkaW9uIGNvbXBvbmVudFxuICovXG5jbGFzcyBBY2NvcmRpb24gZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfc2VjdGlvbkNsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2hpZGRlbkluZGljYXRvciE6IEhUTUxJbnB1dEVsZW1lbnRcbiAgcHJpdmF0ZSBhbmltYXRpb24hOiBBbmltZVRpbWVsaW5lSW5zdGFuY2VcbiAgcHJpdmF0ZSBsYXN0QW5pbWF0ZWRFbGVtZW50PzogSFRNTEVsZW1lbnRcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIEFjY29yZGlvbiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBBY2NvcmRpb24gY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9zZWN0aW9uQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlU2VjdGlvbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQWNjb3JkaW9uIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIikuc29tZSgoYykgPT4gUkVHRVhfSElEREVOLnRlc3QoYykpKSB7XG4gICAgICBsZXQgaW5kaWNhdG9yID0gbmV3IERvbUVsZW1lbnQ8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dFwiKVxuICAgICAgICAuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKVxuICAgICAgICAuYWRkQ2xhc3MoXCJqcy1oaWRkZW5cIilcblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChpbmRpY2F0b3IpXG4gICAgICB0aGlzLl9oaWRkZW5JbmRpY2F0b3IgPSBpbmRpY2F0b3IuZWxlbWVudFxuICAgIH1cblxuICAgIGZvciAobGV0IHRvZ2dsZSBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9UT0dHTEUpKSB7XG4gICAgICB0b2dnbGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3NlY3Rpb25DbGlja0hhbmRsZXIpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVTZWN0aW9uQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvcikge1xuICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5faGlkZGVuSW5kaWNhdG9yKVxuXG4gICAgICBpZiAoc3R5bGUudmlzaWJpbGl0eSAhPT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5hdlNlY3Rpb24gPSAoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5wYXJlbnRFbGVtZW50IVxuXG4gICAgd2hpbGUgKCFEb20uaGFzQ2xhc3MobmF2U2VjdGlvbiwgQ0xBU1NfSVRFTSkgJiYgbmF2U2VjdGlvbi5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBuYXZTZWN0aW9uID0gbmF2U2VjdGlvbi5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgbGV0IHByZXZTZWN0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfT1BFTl9TRUNUSU9OKVxuXG4gICAgaWYgKHByZXZTZWN0aW9uICYmIHByZXZTZWN0aW9uICE9PSBuYXZTZWN0aW9uKSB7XG4gICAgICBpZiAoIURvbS5oYXNDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX0tFRVBfT1BFTikpe1xuICAgICAgICB0aGlzLl90b2dnbGVTZWN0aW9uKHByZXZTZWN0aW9uKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3RvZ2dsZVNlY3Rpb24obmF2U2VjdGlvbilcbiAgfVxuXG4gIHByb3RlY3RlZCBfdG9nZ2xlU2VjdGlvbihhY2NTZWN0aW9uOiBFbGVtZW50KSB7XG4gICAgbGV0IGNvbGxhcHNlRWxlbWVudCA9IGFjY1NlY3Rpb24ucXVlcnlTZWxlY3RvcihRVUVSWV9DT0xMQVBTRSkhIGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAoRG9tLmhhc0NsYXNzKGFjY1NlY3Rpb24sIENMQVNTX09QRU4pKSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3MoYWNjU2VjdGlvbiwgQ0xBU1NfT1BFTilcbiAgICAgIHRoaXMuX2Nsb3NlQ29sbGFwc2VTZWN0aW9uKGNvbGxhcHNlRWxlbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgRG9tLmFkZENsYXNzKGFjY1NlY3Rpb24sIENMQVNTX09QRU4pXG4gICAgICBpZiAoY29sbGFwc2VFbGVtZW50KSB7IC8vIHRvIGlnbm9yZSB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIG5vIGNvbGxhcHNpYmxlIGVsZW1lbnQgKHNlZSBzZHggZG9rdSBuYXZpZ2F0aW9uLCBcImFsbCB0aGUgYmFzaWNzXCIpIGluIGEgbGlzdCBvZiBhY2NvcmRpb25cbiAgICAgICAgdGhpcy5fb3BlbkNvbGxhcHNlU2VjdGlvbihjb2xsYXBzZUVsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vcGVuQ29sbGFwc2VTZWN0aW9uKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuX3N0b3BBbmltYXRpb25zKGVsKVxuXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltZS50aW1lbGluZSgpXG4gICAgICAuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogZWwsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fT1BFTixcbiAgICAgICAgaGVpZ2h0OiBlbC5zY3JvbGxIZWlnaHQgKyBcInB4XCIsXG4gICAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IFwiYXV0b1wiXG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIilcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKENMQVNTX09QRU4pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogZWwsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fVklTSUJMRSxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgZWFzaW5nOiBcImxpbmVhclwiLFxuICAgICAgICBvZmZzZXQ6IEFOSU1BVElPTl9ERUxBWV9PUEVOXG4gICAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9zZUNvbGxhcHNlU2VjdGlvbihlbDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLl9zdG9wQW5pbWF0aW9ucyhlbClcblxuICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWUudGltZWxpbmUoKVxuICAgICAgLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX09QRU4sXG4gICAgICAgIGhlaWdodDogXCIwcHhcIixcbiAgICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpXG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJvcGFjaXR5XCIpXG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJoZWlnaHRcIilcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIilcbiAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX09QRU4pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgX3N0b3BBbmltYXRpb25zKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLmxhc3RBbmltYXRlZEVsZW1lbnQgPT09IGVsKSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24ucGF1c2UoKVxuICAgICAgfVxuICAgICAgYW5pbWUucmVtb3ZlKGVsKVxuICAgIH1cbiAgICB0aGlzLmxhc3RBbmltYXRlZEVsZW1lbnQgPSBlbFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IHRvZ2dsZSBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9UT0dHTEUpKSB7XG4gICAgICB0b2dnbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3NlY3Rpb25DbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5fc2VjdGlvbkNsaWNrSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5lbGVtZW50ID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmFjY29yZGlvblwiLCAoZSkgPT4ge1xuICAgIG5ldyBBY2NvcmRpb24oZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQWNjb3JkaW9uXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBjbGFtcCwgcHJldmVudERlZmF1bHQsIHJlbW92ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IFFVRVJZX1NMSURFUiA9IFwiLmNhcm91c2VsX19jb250YWluZXJcIlxuY29uc3QgUVVFUllfU0xJREVfQVJFQSA9IFwiLmNhcm91c2VsX19zbGlkZXJcIlxuY29uc3QgUVVFUllfV1JBUFBFUiA9IFwiLmNhcm91c2VsX19zbGlkZXItd3JhcHBlclwiXG5cbmNvbnN0IFFVRVJZX1BBR0lOQVRJT04gPSBcIi5jYXJvdXNlbF9fcGFnaW5hdGlvblwiXG5cbmNvbnN0IENMQVNTX0FDVElWRSA9IFwic2xpZGUtLWFjdGl2ZVwiXG5jb25zdCBDTEFTU19QUkVWID0gXCJzbGlkZS0tcHJldlwiXG5jb25zdCBDTEFTU19ORVhUID0gXCJzbGlkZS0tbmV4dFwiXG5cbmNvbnN0IENMQVNTX0JVTExFVCA9IFwicGFnaW5hdGlvbi1idWxsZXRcIlxuY29uc3QgQ0xBU1NfQlVMTEVUX0FDVElWRSA9IFwicGFnaW5hdGlvbi1idWxsZXQtLWFjdGl2ZVwiXG5cbmNvbnN0IFFVRVJZX0JUTl9QUkVWID0gXCIuY2Fyb3VzZWxfX2J1dHRvbi1wcmV2XCJcbmNvbnN0IFFVRVJZX0JUTl9ORVhUID0gXCIuY2Fyb3VzZWxfX2J1dHRvbi1uZXh0XCJcbmNvbnN0IFFVRVJZX0JUTl9XUkFQUEVSID0gXCIuY2Fyb3VzZWxfX2J1dHRvbi13cmFwcGVyXCJcblxuY29uc3QgQVRUUklCVVRFX0lOREVYID0gXCJqcy1pbmRleFwiXG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDM1MFxuY29uc3QgQU5JTUFUSU9OX0VBU0lORyA9IFwiZWFzZS1pbi1vdXRcIlxuXG5jb25zdCBUT1VDSF9EVVJBVElPTiA9IDMwMFxuY29uc3QgVE9VQ0hfREVMVEFfTUlOID0gMjVcblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZVByb3BlcnRpZXMge1xuICByaWdodDogbnVtYmVyXG4gIGxlZnQ6IG51bWJlclxuICB2aXNpYmxlOiBib29sZWFuXG4gIGluZGV4OiBudW1iZXJcbiAgd2lkdGg6IG51bWJlclxuICBtYXJnaW5MZWZ0OiBudW1iZXJcbiAgbWFyZ2luUmlnaHQ6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBEaXJlY3Rpb24gPSAwIHwgLTEgfCAxXG5cbi8qKlxuICogVGhlIGNhcm91c2VsIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBDYXJvdXNlbCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfc2xpZGVyOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF93cmFwcGVyOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9wYWdpbmF0aW9uPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfc2xpZGVBcmVhOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX2J0bldyYXBwZXI6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3ByZXZDdHJsOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9uZXh0Q3RybDogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9zbGlkZXM6IEhUTUxFbGVtZW50W11cblxuICBwcml2YXRlIF9pbmRleDogbnVtYmVyXG4gIHByaXZhdGUgX3NsaWRlc1Blckdyb3VwOiBudW1iZXJcblxuICBwcml2YXRlIF9zbGlkZXJXcmFwcGVyOiBTbGlkZXJXcmFwcGVyXG5cbiAgcHJpdmF0ZSBfYWRkaXRpb25hbFNsaWRlTWFyZ2luOiBudW1iZXJcblxuICBwcml2YXRlIF9yZXNpemVIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3ByZXZIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX25leHRIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3BhZ2luYXRpb25DbGlja0hhbmRsZXI6IChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9rZXlkb3duSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfaGFuZGxlVG91Y2hzdGFydDogKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9oYW5kbGVUb3VjaG1vdmU6IChldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfaGFuZGxlVG91Y2hlbmQ6IChldmVudDogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9icmVha3BvaW50UGhvbmUhOiBIVE1MRGl2RWxlbWVudFxuICBwcml2YXRlIF9icmVha3BvaW50VGFibGV0ITogSFRNTERpdkVsZW1lbnRcbiAgcHJpdmF0ZSBfYnJlYWtwb2ludERlc2t0b3AhOiBIVE1MRGl2RWxlbWVudFxuXG4gIHByaXZhdGUgX3RvdWNoT2Zmc2V0Pzoge1xuICAgIHg6IG51bWJlcjtcbiAgICB0aW1lOiBudW1iZXI7XG4gIH1cblxuICBwcml2YXRlIF9kZWx0YT86IHtcbiAgICB4OiBudW1iZXI7XG4gICAgbGFzdE1vdmU6IG51bWJlcjtcbiAgfVxuXG4gIHByaXZhdGUgX2ZyYW1lV2lkdGg/OiBudW1iZXJcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIGNhcm91c2VsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSBlbGVtZW50IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgQ2Fyb3VzZWwgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5pdGlhbCBpbmRleC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBpbmRleCA9IDApIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fc2xpZGVyID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0xJREVSKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl93cmFwcGVyID0gdGhpcy5fc2xpZGVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfV1JBUFBFUikhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fcGFnaW5hdGlvbiA9IHRoaXMuX3NsaWRlci5xdWVyeVNlbGVjdG9yKFFVRVJZX1BBR0lOQVRJT04pIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fc2xpZGVBcmVhID0gdGhpcy5fc2xpZGVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0xJREVfQVJFQSkhIGFzIEhUTUxFbGVtZW50XG5cbiAgICB0aGlzLl9idG5XcmFwcGVyID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQlROX1dSQVBQRVIpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX3ByZXZDdHJsID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQlROX1BSRVYpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX25leHRDdHJsID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQlROX05FWFQpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgdGhpcy5fc2xpZGVzID0gW11cblxuICAgIHRoaXMuX2luZGV4ID0gaW5kZXggfHwgMFxuICAgIHRoaXMuX3NsaWRlc1Blckdyb3VwID0gMVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlciA9IG5ldyBTbGlkZXJXcmFwcGVyKHRoaXMuX3dyYXBwZXIsIHRoaXMuX3NsaWRlQXJlYSwgdGhpcy5lbGVtZW50KVxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXggPSB0aGlzLl9pbmRleFxuICAgIHRoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbiA9IDBcblxuICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgPSB0aGlzLl9vbnJlc2l6ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcHJldkhhbmRsZXIgPSB0aGlzLnByZXYuYmluZCh0aGlzKVxuICAgIHRoaXMuX25leHRIYW5kbGVyID0gdGhpcy5uZXh0LmJpbmQodGhpcylcbiAgICB0aGlzLl9wYWdpbmF0aW9uQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlUGFnaW5hdGlvbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faGFuZGxlVG91Y2hzdGFydCA9IHRoaXMuX29uVG91Y2hzdGFydC5iaW5kKHRoaXMpXG4gICAgdGhpcy5faGFuZGxlVG91Y2htb3ZlID0gdGhpcy5fb25Ub3VjaG1vdmUuYmluZCh0aGlzKVxuICAgIHRoaXMuX2hhbmRsZVRvdWNoZW5kID0gdGhpcy5fb25Ub3VjaGVuZC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgICB0aGlzLnNsaWRlKHRoaXMuX2luZGV4LCAwLCBmYWxzZSlcblxuICAgIHRoaXMuX3VwZGF0ZUN0cmxPZmZzZXRzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIC8vIHJlc3BvbnNpdmUgaGVscGVyc1xuICAgIHRoaXMuX2JyZWFrcG9pbnRQaG9uZSA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwianMtcGhvbmVcIilcbiAgICAgIC5lbGVtZW50XG5cbiAgICB0aGlzLl9icmVha3BvaW50VGFibGV0ID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoXCJqcy10YWJsZXRcIilcbiAgICAgIC5lbGVtZW50XG5cbiAgICB0aGlzLl9icmVha3BvaW50RGVza3RvcCA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwianMtZGVza3RvcFwiKVxuICAgICAgLmVsZW1lbnRcblxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9icmVha3BvaW50UGhvbmUpXG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2JyZWFrcG9pbnRUYWJsZXQpXG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2JyZWFrcG9pbnREZXNrdG9wKVxuXG4gICAgaWYgKHRoaXMuX3ByZXZDdHJsICYmIHRoaXMuX25leHRDdHJsKSB7XG4gICAgICB0aGlzLl9wcmV2Q3RybC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcHJldkhhbmRsZXIpXG4gICAgICB0aGlzLl9uZXh0Q3RybC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbmV4dEhhbmRsZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhZ2luYXRpb24pIHtcbiAgICAgIHRoaXMuX3BhZ2luYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3BhZ2luYXRpb25DbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5fc2xpZGVzID0gQXJyYXkuZnJvbSh0aGlzLl93cmFwcGVyLmNoaWxkcmVuKSBhcyBIVE1MRWxlbWVudFtdXG4gICAgaWYgKHRoaXMuX3NsaWRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEVycm9yKFwiUHJvdmlkZSBhdCBsZWFzdCBvbmUgc2xpZGUgdG8gdGhlIHNsaWRlclwiKVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2xpZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2xpZGUgPSB0aGlzLl9zbGlkZXNbaV1cbiAgICAgIHNsaWRlLnNldEF0dHJpYnV0ZShBVFRSSUJVVEVfSU5ERVgsIFN0cmluZyhpKSlcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVSZXNwb25zaXZlT3B0aW9ucygpXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5pbml0aWFsaXplKClcblxuICAgIHRoaXMucmVzZXQoKVxuXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuXG4gICAgdGhpcy5fc2xpZGVBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcbiAgICB0aGlzLl9zbGlkZUFyZWEuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pc0JyZWFrcG9pbnRBY3RpdmUoYnJlYWtwb2ludDogSFRNTERpdkVsZW1lbnQpIHtcbiAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShicmVha3BvaW50KVxuICAgIHJldHVybiBzdHlsZS52aXNpYmlsaXR5ID09PSBcInZpc2libGVcIlxuICB9XG5cbiAgcHJvdGVjdGVkIF9vbnJlc2l6ZSgpIHtcbiAgICB0aGlzLnJlc2V0KClcbiAgICB0aGlzLl91cGRhdGVDdHJsT2Zmc2V0cygpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGUgaW5kZXggaXMgYWx3YXlzIGluIHRoZSByYW5nZSBvZiBhdmFpbGFibGUgc2xpZGVcbiAgICogSW4gY2FzZSBpdCdzIHRvIGhpZ2ggb3IgdG8gbG93IGl0IGlzIHdyYXBwZWQgYXJvdW5kXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBhZGp1c3QgYW5kIHNhbml0aXplXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGFkanVzdGVkIGluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2FkanVzdEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBpbmRleCA9IDBcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX3dyYXByb3VuZChpbmRleCwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aClcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuX3NsaWRlcy5sZW5ndGgpIHtcbiAgICAgIGluZGV4ICU9IHRoaXMuX3NsaWRlcy5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuX3NsaWRlc1Blckdyb3VwKSAqIHRoaXMuX3NsaWRlc1Blckdyb3VwXG4gIH1cblxuICBwcm90ZWN0ZWQgX3dyYXByb3VuZChuOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICAgIGlmIChuID49IG1heCkge1xuICAgICAgcmV0dXJuIG1pblxuICAgIH1cblxuICAgIGlmIChuIDwgbWluKSB7XG4gICAgICByZXR1cm4gbWF4IC0gMVxuICAgIH1cblxuICAgIHJldHVybiBuXG4gIH1cblxuICBwcm90ZWN0ZWQgX3dyYXByb3VuZENvdW50KGE6IG51bWJlciwgYjogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIGRpcmVjdGlvbjogRGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBpZiAoYSA8IG1pbiB8fCBhID49IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAnYScgaXMgb3V0IG9mIHJhbmdlLCBWYWx1ZTogJHthfSBNaW46ICR7bWlufSwgTWF4OiAke21heH1gKVxuICAgIH1cblxuICAgIGlmIChiIDwgbWluIHx8IGIgPj0gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICdiJyBpcyBvdXQgb2YgcmFuZ2UsIFZhbHVlOiAke2J9IE1pbjogJHttaW59LCBNYXg6ICR7bWF4fWApXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKGEgIT09IGIpIHtcbiAgICAgIGkrK1xuICAgICAgYSA9IHRoaXMuX3dyYXByb3VuZChhICsgZGlyZWN0aW9uLCBtaW4sIG1heClcbiAgICB9XG5cbiAgICByZXR1cm4gaVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGVDdHJsT2Zmc2V0cygpIHtcbiAgICBpZiAoIXRoaXMuX25leHRDdHJsIHx8ICF0aGlzLl9wcmV2Q3RybCB8fCAhdGhpcy5fYnRuV3JhcHBlcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHByZXZDdHJsTWFyZ2luID0gMFxuICAgIGxldCBuZXh0Q3RybE1hcmdpbiA9IDBcblxuICAgIGlmICh0aGlzLl9zbGlkZXNQZXJHcm91cCA+IDEpIHtcbiAgICAgIGxldCB3cmFwcGVyUmVjdCA9IHRoaXMuX2J0bldyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgICAgY29uc3QgcHJldlNsaWRlQ291bnQgPSBNYXRoLmZsb29yKDAuNSAqIHRoaXMuX3NsaWRlc1Blckdyb3VwKVxuICAgICAgY29uc3QgcmlnaHRJbmRleCA9IHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXggKyBwcmV2U2xpZGVDb3VudCArIDFcblxuICAgICAgbGV0IGxlZnRJbmRleCA9IHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXggLSAxXG4gICAgICBpZiAodGhpcy5fc2xpZGVzUGVyR3JvdXAgJSAyICE9PSAwKSB7XG4gICAgICAgIGxlZnRJbmRleCAtPSBwcmV2U2xpZGVDb3VudFxuICAgICAgfVxuXG4gICAgICBpZiAoKGxlZnRJbmRleCA+PSAwICYmIGxlZnRJbmRleCA8IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoKSAmJlxuICAgICAgICAocmlnaHRJbmRleCA+PSAwICYmIHJpZ2h0SW5kZXggPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgbGV0IGxlZnRTbGlkZSA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0U2xpZGVQcm9wZXJ0aWVzKGxlZnRJbmRleClcbiAgICAgICAgbGV0IHJpZ2h0U2xpZGUgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlUHJvcGVydGllcyhyaWdodEluZGV4KVxuXG4gICAgICAgIGxldCBidG5XaWR0aCA9IHRoaXMuX3ByZXZDdHJsLm9mZnNldFdpZHRoXG4gICAgICAgIGlmIChidG5XaWR0aCA8PSAwKSB7XG4gICAgICAgICAgYnRuV2lkdGggPSA2MFxuICAgICAgICB9XG5cbiAgICAgICAgcHJldkN0cmxNYXJnaW4gPSBsZWZ0U2xpZGUucmlnaHQgLSB3cmFwcGVyUmVjdC5sZWZ0IC0gYnRuV2lkdGhcbiAgICAgICAgbmV4dEN0cmxNYXJnaW4gPSB3cmFwcGVyUmVjdC5yaWdodCAtIHJpZ2h0U2xpZGUubGVmdCAtIGJ0bldpZHRoXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGxlZnQgPSBwcmV2Q3RybE1hcmdpbiAhPT0gMCA/IGAke3ByZXZDdHJsTWFyZ2lufXB4YCA6IFwiXCJcbiAgICB0aGlzLl9wcmV2Q3RybC5zdHlsZS5sZWZ0ID0gbGVmdFxuXG4gICAgbGV0IHJpZ2h0ID0gbmV4dEN0cmxNYXJnaW4gIT09IDAgPyBgJHtuZXh0Q3RybE1hcmdpbn1weGAgOiBcIlwiXG4gICAgdGhpcy5fbmV4dEN0cmwuc3R5bGUucmlnaHQgPSByaWdodFxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGVBY3RpdmVTbGlkZXMobmV4dEluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBwcmV2U2xpZGVDb3VudCA9IE1hdGguZmxvb3IoMC41ICogKHRoaXMuX3NsaWRlc1Blckdyb3VwIC0gMSkpXG4gICAgY29uc3QgZXZlbkdyb3VwID0gdGhpcy5fc2xpZGVzUGVyR3JvdXAgJSAyID09PSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzbGlkZSA9IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5baV1cblxuICAgICAgaWYgKGkgPT09IG5leHRJbmRleCB8fCAoZXZlbkdyb3VwICYmIGkgPT09IG5leHRJbmRleCArIDEpKSB7XG4gICAgICAgIERvbS5hZGRDbGFzcyhzbGlkZSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRG9tLnJlbW92ZUNsYXNzKHNsaWRlLCBDTEFTU19BQ1RJVkUpXG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgbmV4dEluZGV4ICYmIGkgPj0gbmV4dEluZGV4IC0gcHJldlNsaWRlQ291bnQpIHtcbiAgICAgICAgRG9tLmFkZENsYXNzKHNsaWRlLCBDTEFTU19QUkVWKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRG9tLnJlbW92ZUNsYXNzKHNsaWRlLCBDTEFTU19QUkVWKVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA+IG5leHRJbmRleCAmJiAoaSA8PSBuZXh0SW5kZXggKyBwcmV2U2xpZGVDb3VudCB8fCAoZXZlbkdyb3VwICYmIGkgPD0gbmV4dEluZGV4ICsgMSArIHByZXZTbGlkZUNvdW50KSkpIHtcbiAgICAgICAgRG9tLmFkZENsYXNzKHNsaWRlLCBDTEFTU19ORVhUKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRG9tLnJlbW92ZUNsYXNzKHNsaWRlLCBDTEFTU19ORVhUKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuZCBjcmVhdGVzIHRoZSBwYWdpbmF0aW9uIGJ1bGxldHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX3VwZGF0ZVBhZ2luYXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9wYWdpbmF0aW9uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdG8gPSB0aGlzLl9pbmRleFxuXG4gICAgbGV0IGJ1bGxldHMgPSB0aGlzLl9wYWdpbmF0aW9uLmNoaWxkcmVuXG4gICAgbGV0IHRvdGFsSXRlbXMgPSBNYXRoLm1heCh0aGlzLl9zbGlkZXMubGVuZ3RoLCBidWxsZXRzLmxlbmd0aClcbiAgICBsZXQgc2xpZGVDb3VudCA9IE1hdGguY2VpbCh0aGlzLl9zbGlkZXMubGVuZ3RoIC8gdGhpcy5fc2xpZGVzUGVyR3JvdXApXG4gICAgbGV0IGFjdGl2ZVNsaWRlSW5kZXggPSBNYXRoLmZsb29yKHRvIC8gdGhpcy5fc2xpZGVzUGVyR3JvdXApXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsSXRlbXM7IGkrKykge1xuICAgICAgbGV0IGJ1bGxldFxuXG4gICAgICBpZiAoYnVsbGV0cy5sZW5ndGggPiBpKSB7XG4gICAgICAgIGlmIChidWxsZXRzLmxlbmd0aCA8PSBzbGlkZUNvdW50KSB7XG4gICAgICAgICAgYnVsbGV0ID0gYnVsbGV0c1tpXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZShidWxsZXRzW2ldKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPCBzbGlkZUNvdW50KSB7XG4gICAgICAgIGJ1bGxldCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX0JVTExFVClcbiAgICAgICAgICAuZWxlbWVudFxuICAgICAgICB0aGlzLl9wYWdpbmF0aW9uLmFwcGVuZENoaWxkKGJ1bGxldClcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1bGxldCAmJiBpIDwgc2xpZGVDb3VudCkge1xuICAgICAgICBpZiAoaSA9PT0gYWN0aXZlU2xpZGVJbmRleCkge1xuICAgICAgICAgIERvbS5hZGRDbGFzcyhidWxsZXQsIENMQVNTX0JVTExFVF9BQ1RJVkUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRG9tLnJlbW92ZUNsYXNzKGJ1bGxldCwgQ0xBU1NfQlVMTEVUX0FDVElWRSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlUGFnaW5hdGlvbkNsaWNrKGU6IE1vdXNlRXZlbnQpIHtcbiAgICBpZiAoIURvbS5oYXNDbGFzcyhlLnRhcmdldCBhcyBFbGVtZW50LCBDTEFTU19CVUxMRVQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaW5kZXggPSBBcnJheS5mcm9tKHRoaXMuX3BhZ2luYXRpb24hLmNoaWxkcmVuKS5pbmRleE9mKGUudGFyZ2V0IGFzIEVsZW1lbnQpXG4gICAgbGV0IHNsaWRlTnVtYmVyID0gaW5kZXggKiB0aGlzLl9zbGlkZXNQZXJHcm91cFxuXG4gICAgdGhpcy5zbGlkZVRvKHNsaWRlTnVtYmVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGtleWNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXG5cbiAgICBzd2l0Y2ggKGtleWNvZGUpIHtcbiAgICAgIGNhc2UgSW5wdXRzLktFWV9BUlJPV19MRUZUOlxuICAgICAgICB0aGlzLnByZXYoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBJbnB1dHMuS0VZX0FSUk9XX1JJR0hUOlxuICAgICAgICB0aGlzLm5leHQoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBJbnB1dHMuS0VZX0VTQ0FQRTpcbiAgICAgICAgdGhpcy5lbGVtZW50LmJsdXIoKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX29uVG91Y2hzdGFydChldmVudDogVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQpIHtcbiAgICBjb25zdCB0b3VjaCA9IChldmVudCBhcyBUb3VjaEV2ZW50KS50b3VjaGVzID8gKGV2ZW50IGFzIFRvdWNoRXZlbnQpLnRvdWNoZXNbMF0gOiBldmVudCBhcyBNb3VzZUV2ZW50XG5cbiAgICB0aGlzLl9zbGlkZUFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuICAgIHRoaXMuX3NsaWRlQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5iZWdpbkRyYWcoKVxuICAgIGNvbnN0IHsgcGFnZVggfSA9IHRvdWNoXG5cbiAgICB0aGlzLl90b3VjaE9mZnNldCA9IHtcbiAgICAgIHg6IHBhZ2VYLFxuICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgIH1cblxuICAgIHRoaXMuX2RlbHRhID0ge1xuICAgICAgeDogMCxcbiAgICAgIGxhc3RNb3ZlOiBwYWdlWFxuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5faGFuZGxlVG91Y2htb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5faGFuZGxlVG91Y2htb3ZlKVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2hhbmRsZVRvdWNoZW5kKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vblRvdWNobW92ZShldmVudDogVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQpIHtcbiAgICBjb25zdCB0b3VjaCA9IChldmVudCBhcyBUb3VjaEV2ZW50KS50b3VjaGVzID8gKGV2ZW50IGFzIFRvdWNoRXZlbnQpLnRvdWNoZXNbMF0gOiBldmVudCBhcyBNb3VzZUV2ZW50XG4gICAgY29uc3QgeyBwYWdlWCB9ID0gdG91Y2hcblxuICAgIGxldCBkZWx0YU1vdmUgPSBwYWdlWCAtIHRoaXMuX2RlbHRhIS5sYXN0TW92ZVxuXG4gICAgdGhpcy5fZGVsdGEgPSB7XG4gICAgICB4OiBwYWdlWCAtIHRoaXMuX3RvdWNoT2Zmc2V0IS54LFxuICAgICAgbGFzdE1vdmU6IHBhZ2VYXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RvdWNoT2Zmc2V0KSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcblxuICAgICAgdGhpcy5fc2xpZGVyV3JhcHBlci5tb3ZlKGRlbHRhTW92ZSlcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGVzVG9GaXRXcmFwcGVyKGZhbHNlLCBkZWx0YU1vdmUpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vblRvdWNoZW5kKCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fdG91Y2hPZmZzZXQgPyBEYXRlLm5vdygpIC0gdGhpcy5fdG91Y2hPZmZzZXQudGltZSA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3QgaXNWYWxpZCA9IE51bWJlcihkdXJhdGlvbikgPCBUT1VDSF9EVVJBVElPTiAmJlxuICAgICAgTWF0aC5hYnModGhpcy5fZGVsdGEhLngpID4gVE9VQ0hfREVMVEFfTUlOIHx8XG4gICAgICBNYXRoLmFicyh0aGlzLl9kZWx0YSEueCkgPiB0aGlzLl9mcmFtZVdpZHRoISAvIDNcblxuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBjbGFtcCh0aGlzLl9kZWx0YSEueCwgLTEsIDEpICogLTEgYXMgRGlyZWN0aW9uXG4gICAgICB0aGlzLnNsaWRlKGZhbHNlLCBkaXJlY3Rpb24sIHRydWUpXG5cbiAgICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuZW5kRHJhZygpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNsaWRlIGJhY2sgdG8gdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBkcmFnIG9wZXJhdGlvblxuICAgICAgdGhpcy5fc2xpZGVyV3JhcHBlci5jYW5jZWxEcmFnKClcbiAgICB9XG5cbiAgICB0aGlzLl90b3VjaE9mZnNldCA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5fc2xpZGVBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcbiAgICB0aGlzLl9zbGlkZUFyZWEuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5faGFuZGxlVG91Y2htb3ZlKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2hhbmRsZVRvdWNoZW5kKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuX2hhbmRsZVRvdWNoZW5kKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5faGFuZGxlVG91Y2htb3ZlKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVkIHBhcmFtZXRlcnMgaW4gcmVnYXJkIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIHJlc3BvbnNpdmVcbiAgICogYnJlYWtwb2ludC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfdXBkYXRlUmVzcG9uc2l2ZU9wdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuX2lzQnJlYWtwb2ludEFjdGl2ZSh0aGlzLl9icmVha3BvaW50UGhvbmUpKSB7XG4gICAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IDFcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNCcmVha3BvaW50QWN0aXZlKHRoaXMuX2JyZWFrcG9pbnRUYWJsZXQpKSB7XG4gICAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IDJcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNCcmVha3BvaW50QWN0aXZlKHRoaXMuX2JyZWFrcG9pbnREZXNrdG9wKSkge1xuICAgICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSAzXG4gICAgfVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5zbGlkZXNQZXJHcm91cCA9IHRoaXMuX3NsaWRlc1Blckdyb3VwXG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSByZXF1ZXN0ZWQgc2xpZGUgYW5kIGFkZHMgaXQgdG8gdGhlIHNsaWRlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIG9yaWdpbmFsIHNsaWRlIGluZGV4IG9mIHRoZSB0ZW1wbGF0ZSBzbGlkZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0byBhZGQgdGhlIHNsaWRlcywgLTEgZm9yIGxlZnQsIDEgZm9yIHJpZ2h0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2Nsb25lU2xpZGUoaW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBudW1iZXIpIHtcbiAgICBsZXQgY2xvbmUgPSB0aGlzLl9zbGlkZXNbaW5kZXhdLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRWxlbWVudFxuICAgIERvbS5yZW1vdmVDbGFzcyhjbG9uZSwgQ0xBU1NfQUNUSVZFKVxuICAgIERvbS5yZW1vdmVDbGFzcyhjbG9uZSwgQ0xBU1NfUFJFVilcbiAgICBEb20ucmVtb3ZlQ2xhc3MoY2xvbmUsIENMQVNTX05FWFQpXG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmFkZFNsaWRlKGNsb25lLCBkaXJlY3Rpb24pXG5cbiAgICBsZXQgc2xpZGVNYXJnaW4gPSB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPiAwID8gYCR7dGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2lufXB4YCA6IFwiXCJcbiAgICBjbG9uZS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xpZGVNYXJnaW5cbiAgICBjbG9uZS5zdHlsZS5tYXJnaW5SaWdodCA9IHNsaWRlTWFyZ2luXG5cbiAgICByZXR1cm4gY2xvbmUub2Zmc2V0V2lkdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgYW5kIGFkZHMgdGhlIHJlcXVlc3RlZCBhbW1vdW50IG9mIHNsaWRlcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNsaWRlQ291bnQgLSBUaGUgbnVtYmVyIG9mIHNsaWRlcyB0byBhZGRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gYWRkIHRoZSBzbGlkZXMsIC0xIGZvciBsZWZ0LCAxIGZvciByaWdodFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9jbG9uZVNsaWRlc0J5Q291bnQoc2xpZGVDb3VudDogbnVtYmVyLCBkaXJlY3Rpb246IERpcmVjdGlvbikge1xuICAgIGxldCBvcmlnaW5hbEluZGV4ID0gZGlyZWN0aW9uIDwgMCA/IDAgOiB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCAtIDFcbiAgICBsZXQgaW5kZXggPSBwYXJzZUludCh0aGlzLl93cmFwcGVyLmNoaWxkcmVuW29yaWdpbmFsSW5kZXhdLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfSU5ERVgpISwgMTApXG5cbiAgICB3aGlsZSAoc2xpZGVDb3VudCA+IDApIHtcbiAgICAgIGluZGV4ID0gdGhpcy5fd3JhcHJvdW5kKGluZGV4ICsgZGlyZWN0aW9uLCAwLCB0aGlzLl9zbGlkZXMubGVuZ3RoKVxuICAgICAgdGhpcy5fY2xvbmVTbGlkZShpbmRleCwgZGlyZWN0aW9uKVxuICAgICAgc2xpZGVDb3VudC0tXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHNjcm9sbCBjbG91bnQgYW5kIGluc2VydHMgdGhlIHJlcXVpcmVkIGFtbW91bnQgb2Ygc2xpZGVzXG4gICAqIGluIHRoZSBhcHJvcHJpYXRlIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5leHRJbmRleCAtIFRoZSBzbGlkZSB0byBzY3JvbGwgdG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9jbG9uZVNsaWRlc0J5U2Nyb2xsQ291bnQobmV4dEluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogRGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgc2Nyb2xsQ291bnQgPSB0aGlzLl93cmFwcm91bmRDb3VudCh0aGlzLl9pbmRleCwgbmV4dEluZGV4LCAwLCB0aGlzLl9zbGlkZXMubGVuZ3RoLCBkaXJlY3Rpb24pXG5cbiAgICBjb25zdCBvdXRlclNsaWRlUHJvcHMgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlUHJvcGVydGllcyhkaXJlY3Rpb24gPiAwID8gdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGggLSAxIDogMClcbiAgICBjb25zdCBpbmRleFRvT3V0ZXJTbGlkZUNvdW50ID0gdGhpcy5fd3JhcHJvdW5kQ291bnQodGhpcy5faW5kZXgsIG91dGVyU2xpZGVQcm9wcy5pbmRleCwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aCwgZGlyZWN0aW9uKVxuXG4gICAgY29uc3Qgc2xpZGVzVG9JbnNlcnQgPSBzY3JvbGxDb3VudCAtIGluZGV4VG9PdXRlclNsaWRlQ291bnRcbiAgICBpZiAoc2xpZGVzVG9JbnNlcnQgPiAwKSB7XG4gICAgICB0aGlzLl9jbG9uZVNsaWRlc0J5Q291bnQoc2xpZGVzVG9JbnNlcnQsIGRpcmVjdGlvbilcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Nsb25lU2xpZGVzQnlUb0ZpbGwoc3BhY2VUb0ZpbGw6IG51bWJlciwgZGlyZWN0aW9uOiBEaXJlY3Rpb24pIHtcbiAgICBsZXQgb3JpZ2luYWxJbmRleCA9IGRpcmVjdGlvbiA8IDAgPyAwIDogdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgbGV0IGluZGV4ID0gcGFyc2VJbnQodGhpcy5fd3JhcHBlci5jaGlsZHJlbltvcmlnaW5hbEluZGV4XS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSEsIDEwKVxuXG4gICAgd2hpbGUgKHNwYWNlVG9GaWxsID4gMCkge1xuICAgICAgaW5kZXggPSB0aGlzLl93cmFwcm91bmQoaW5kZXggKyBkaXJlY3Rpb24sIDAsIHRoaXMuX3NsaWRlcy5sZW5ndGgpXG4gICAgICBzcGFjZVRvRmlsbCAtPSB0aGlzLl9jbG9uZVNsaWRlKGluZGV4LCBkaXJlY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihjbGVhbnVwID0gdHJ1ZSwgc2xpZGVEZWx0YSA9IDApIHtcbiAgICBjb25zdCByZWFsSW5kZXggPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4XG4gICAgbGV0IGZpcnN0OiBTbGlkZVByb3BlcnRpZXNcbiAgICBsZXQgbGFzdDogU2xpZGVQcm9wZXJ0aWVzXG5cbiAgICBpZiAoY2xlYW51cCA9PT0gZmFsc2UpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXMoMClcbiAgICAgIGxhc3QgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlUHJvcGVydGllcyh0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFJlbW92YWJsZVNsaWRlcyhzbGlkZURlbHRhKVxuICAgICAgZmlyc3QgPSByZXN1bHQuZmlyc3QhXG4gICAgICBsYXN0ID0gcmVzdWx0Lmxhc3QhXG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgc2xpZGVzIGZyb20gdmlld1xuICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5zbGlkZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHJlc3VsdC5zbGlkZXNbaV0gPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLnJlbW92ZVNsaWRlKGkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc3BhY2VUb0ZpbGwgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldEVtcHR5U3BhY2UoZmlyc3QubGVmdCwgbGFzdC5yaWdodClcblxuICAgIC8vIENoZWNrIGlmIGFkZGl0aW9uYWwgc2xpZGVzIGFyZSByZXF1aXJlZCBvbiB0aGUgbGVmdFxuICAgIGlmIChmaXJzdC52aXNpYmxlID09PSB0cnVlICYmIHNwYWNlVG9GaWxsLmxlZnQgPiAwKSB7XG4gICAgICB0aGlzLl9jbG9uZVNsaWRlc0J5VG9GaWxsKHNwYWNlVG9GaWxsLmxlZnQsIC0xKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFkZGl0aW9uYWwgc2xpZGVzIGFyZSByZXF1aXJlZCBvbiB0aGUgcmlnaHRcbiAgICBpZiAobGFzdC52aXNpYmxlID09PSB0cnVlICYmIHNwYWNlVG9GaWxsLnJpZ2h0ID4gMCkge1xuICAgICAgdGhpcy5fY2xvbmVTbGlkZXNCeVRvRmlsbChzcGFjZVRvRmlsbC5yaWdodCwgMSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhbEluZGV4IC0gdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlYWwgKHdyYXBwZXIpIGluZGV4IGZvciB0aGUgc2xpZGUgd2l0aCB0aGUgZ2l2ZW4gb3JpZ2luYWwgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIHNlYXJjaCBmb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gc2VhcmNoXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB3cmFwcGVyIGluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2dldFJlYWxJbmRleEZvcihpbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IERpcmVjdGlvbikge1xuICAgIGxldCBpID0gdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleFxuICAgIHdoaWxlIChpID49IDAgJiYgaSA8IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBsZXQgc2xpZGVJbmRleCA9IHBhcnNlSW50KHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5baV0uZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9JTkRFWCkhLCAxMClcbiAgICAgIGlmIChzbGlkZUluZGV4ID09PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gaVxuICAgICAgfVxuXG4gICAgICBpICs9IGRpcmVjdGlvblxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgQ2xvdWQgbm90IGZpbmQgcmVhbCBpbmRleCBmb3Igc2xpZGUgJHtpbmRleH0gaW4gZGlyZWN0aW9uICR7ZGlyZWN0aW9ufWApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgYWN0aXZlIHNsaWRlLiBJZiB0aGUgc2xpZGVzIGFyZSBncm91cGVkIGV2ZW5seVxuICAgKiB0aGUgYWN0aXZlIHNsaWRlIGlzIGFsd2F5cyB0aGUgZmlyc3QgaW4gdGhlIGdyb3VwLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGFjdGl2ZSBzbGlkZS5cbiAgICovXG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpIHtcbiAgICB0aGlzLl9mcmFtZVdpZHRoID0gdGhpcy5fc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAud2lkdGggfHwgdGhpcy5fc2xpZGVyLm9mZnNldFdpZHRoXG5cbiAgICB0aGlzLl91cGRhdGVSZXNwb25zaXZlT3B0aW9ucygpXG5cbiAgICBpZiAodGhpcy5fbmV4dEN0cmwpIHtcbiAgICAgICh0aGlzLl9uZXh0Q3RybCBhcyBhbnkpLmRpc2FibGVkID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHJldkN0cmwpIHtcbiAgICAgICh0aGlzLl9wcmV2Q3RybCBhcyBhbnkpLmRpc2FibGVkID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2xpZGVzUGVyR3JvdXAgPT09IDEpIHtcbiAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX3NsaWRlci5wYXJlbnRFbGVtZW50ISlcbiAgICAgIGxldCBwYXJlbnRXaWR0aCA9IHRoaXMuX3NsaWRlci5wYXJlbnRFbGVtZW50IS5jbGllbnRXaWR0aCArIChwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkxlZnQhKSB8fCAwKSArIChwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblJpZ2h0ISkgfHwgMClcblxuICAgICAgbGV0IG91dGVyTWFyZ2luID0gTWF0aC5jZWlsKHBhcmVudFdpZHRoIC0gdGhpcy5fZnJhbWVXaWR0aClcbiAgICAgIHRoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbiA9IE1hdGguY2VpbChvdXRlck1hcmdpbiAqIDAuNSkgKyAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbiA9IDBcbiAgICB9XG5cbiAgICBsZXQgc2xpZGVNYXJnaW4gPSB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPiAwID8gYCR7dGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2lufXB4YCA6IFwiXCJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzbGlkZSA9IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5baV0gYXMgSFRNTEVsZW1lbnRcbiAgICAgIHNsaWRlLnN0eWxlLm1hcmdpbkxlZnQgPSBzbGlkZU1hcmdpblxuICAgICAgc2xpZGUuc3R5bGUubWFyZ2luUmlnaHQgPSBzbGlkZU1hcmdpblxuICAgIH1cblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIub25yZXNpemUoKVxuICAgIHRoaXMuX2Nsb25lU2xpZGVzVG9GaXRXcmFwcGVyKGZhbHNlKVxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIubW92ZVRvKHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXgpXG5cbiAgICB0aGlzLl91cGRhdGVQYWdpbmF0aW9uKClcbiAgICB0aGlzLl91cGRhdGVBY3RpdmVTbGlkZXModGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleClcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgc2xpZGVyIHRvIHRoZSBuZXh0IGl0ZW0uXG4gICAqL1xuICBwdWJsaWMgcHJldigpIHtcbiAgICB0aGlzLnNsaWRlKGZhbHNlLCAtMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgc2xpZGVyIHRvIHRoZSBwcmV2aW91cyBpdGVtLlxuICAgKi9cbiAgcHVibGljIG5leHQoKSB7XG4gICAgdGhpcy5zbGlkZShmYWxzZSwgMSlcbiAgfVxuXG4gIHB1YmxpYyBzbGlkZShuZXh0SW5kZXg6IG51bWJlciB8IGZhbHNlLCBkaXJlY3Rpb24/OiBEaXJlY3Rpb24sIGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0SW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChkaXJlY3Rpb24hID4gMCkge1xuICAgICAgICBuZXh0SW5kZXggPSB0aGlzLl9pbmRleCArIHRoaXMuX3NsaWRlc1Blckdyb3VwXG4gICAgICAgIGRpcmVjdGlvbiA9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbmRleCA9IHRoaXMuX2luZGV4IC0gdGhpcy5fc2xpZGVzUGVyR3JvdXBcbiAgICAgICAgZGlyZWN0aW9uID0gLTFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0SW5kZXggPSB0aGlzLl9hZGp1c3RJbmRleChuZXh0SW5kZXgpXG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgZGlyZWN0aW9uID0gY2xhbXAobmV4dEluZGV4IC0gdGhpcy5faW5kZXgsIC0xLCAxKSBhcyBEaXJlY3Rpb25cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIGVub3VnaHQgc2xpZGVzIG9uIHNjcmVlblxuICAgIHRoaXMuX2Nsb25lU2xpZGVzVG9GaXRXcmFwcGVyKGZhbHNlKVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBlbm91Z2ggc2xpZGVzIGZvciB0aGUgc2Nyb2xsIG9wZXJhdGlvblxuICAgIHRoaXMuX2Nsb25lU2xpZGVzQnlTY3JvbGxDb3VudChuZXh0SW5kZXgsIGRpcmVjdGlvbilcblxuICAgIGxldCByZWFsSW5kZXggPSB0aGlzLl9nZXRSZWFsSW5kZXhGb3IobmV4dEluZGV4LCBkaXJlY3Rpb24pXG4gICAgbGV0IHNsaWRlRGVsdGEgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlRGVsdGEocmVhbEluZGV4KVxuICAgIHJlYWxJbmRleCA9IE1hdGgubWF4KHJlYWxJbmRleCAtIHRoaXMuX2Nsb25lU2xpZGVzVG9GaXRXcmFwcGVyKHRydWUsIHNsaWRlRGVsdGEpLCAwKVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5tb3ZlVG8ocmVhbEluZGV4LCB1bmRlZmluZWQsIGFuaW1hdGUpXG5cbiAgICAvLyBVcGRhdGUgdGhlIGFjdGl2ZSBpbmRleFxuICAgIHRoaXMuX2luZGV4ID0gbmV4dEluZGV4XG5cbiAgICAvLyBNYXJrIHNsaWRlcyBhcyBhY3RpdmVcbiAgICB0aGlzLl91cGRhdGVQYWdpbmF0aW9uKClcbiAgICB0aGlzLl91cGRhdGVBY3RpdmVTbGlkZXMocmVhbEluZGV4KVxuXG4gICAgLy8gY29uc29sZS5sb2coYFBlcmZvcm1lZCBzbGlkZSB0byAke3RoaXMuX2luZGV4fSwgcmVhbEluZGV4OiAke3RoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXh9YClcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgc2xpZGVyIHRvIHRoZSBzZWxlY3RlZCBzbGlkZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBzbGlkZSB0byBzbGlkZSB0by5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbmltYXRlIC0gYFRydWVgIGlmIHRoZSBzbGlkZSBzaG91bGQgYmUgYW5pbWF0ZWQ7IG90aGVyd2lzZSBgZmFsc2VgLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqL1xuICBwdWJsaWMgc2xpZGVUbyhpbmRleDogbnVtYmVyLCBhbmltYXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuc2xpZGUoaW5kZXgsIHVuZGVmaW5lZCwgYW5pbWF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50cyBhbmQgZnJlZXMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9zbGlkZUFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuICAgIHRoaXMuX3NsaWRlQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuXG4gICAgdGhpcy5fYnJlYWtwb2ludFBob25lLnJlbW92ZSgpXG4gICAgdGhpcy5fYnJlYWtwb2ludFRhYmxldC5yZW1vdmUoKVxuICAgIHRoaXMuX2JyZWFrcG9pbnREZXNrdG9wLnJlbW92ZSgpXG5cbiAgICBpZiAodGhpcy5fcHJldkN0cmwgJiYgdGhpcy5fbmV4dEN0cmwpIHtcbiAgICAgIHRoaXMuX3ByZXZDdHJsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wcmV2SGFuZGxlcilcbiAgICAgIHRoaXMuX25leHRDdHJsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9uZXh0SGFuZGxlcilcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9wcmV2Q3RybCA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9uZXh0Q3RybCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHRoaXMuX3BhZ2luYXRpb24pIHtcbiAgICAgIHRoaXMuX3BhZ2luYXRpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3BhZ2luYXRpb25DbGlja0hhbmRsZXIpO1xuICAgICAgKHRoaXMgYXMgYW55KS5fcGFnaW5hdGlvbiA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuZGVzdHJveSgpO1xuICAgICh0aGlzIGFzIGFueSkuX3NsaWRlcldyYXBwZXIgPSB1bmRlZmluZWRcbiAgfVxufVxuXG5jb25zdCBUUkFOU0ZPUk0gPSBcInRyYW5zZm9ybVwiXG5jb25zdCBEVVJBVElPTiA9IFwidHJhbnNpdGlvbkR1cmF0aW9uXCJcbmNvbnN0IFRJTUlORyA9IFwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXCJcblxuY2xhc3MgU2xpZGVyV3JhcHBlciB7XG4gIHByaXZhdGUgX3dyYXBwZXJFbGVtZW50OiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9zbGlkZUFyZWFFbGVtZW50OiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9jYXJvdXNlbEVsZW1lbnQ6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfcG9zaXRpb246IG51bWJlclxuICBwcml2YXRlIF9pbmRleDogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfaXNkcmFnZ2luZzogYm9vbGVhblxuICBwcml2YXRlIF9kcmFnU3RhcnRQb3NpdGlvbj86IG51bWJlclxuXG4gIHByaXZhdGUgX2FyZWFPZmZzZXQ/OiBudW1iZXJcblxuICBwcml2YXRlIF9zbGlkZXNQZXJHcm91cCE6IG51bWJlclxuXG4gIHByaXZhdGUgX2NvbnRhaW5lck1pbiE6IG51bWJlclxuICBwcml2YXRlIF9jb250YWluZXJNYXghOiBudW1iZXJcblxuICBjb25zdHJ1Y3Rvcih3cmFwcGVyRWxlbWVudDogSFRNTEVsZW1lbnQsIHNsaWRlQXJlYUVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjYXJvdXNlbEVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQgPSB3cmFwcGVyRWxlbWVudFxuICAgIHRoaXMuX3NsaWRlQXJlYUVsZW1lbnQgPSBzbGlkZUFyZWFFbGVtZW50XG4gICAgdGhpcy5fY2Fyb3VzZWxFbGVtZW50ID0gY2Fyb3VzZWxFbGVtZW50XG5cbiAgICB0aGlzLl9wb3NpdGlvbiA9IDBcbiAgICB0aGlzLl9pbmRleCA9IDBcbiAgICB0aGlzLl9pc2RyYWdnaW5nID0gZmFsc2VcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0U2xpZGUoaW5kZXg6IG51bWJlcikge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICdpbmRleCcgaXMgb3V0IG9mIHJhbmdlLCBWYWx1ZTogJHtpbmRleH0gTWluOiAwLCBNYXg6ICR7dGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMX1gKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlbltpbmRleF0gYXMgSFRNTEVsZW1lbnRcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0VHJhbnNmb3JtKHRhcmdldFBvc2l0aW9uOiBudW1iZXIsIGFuaW1hdGVkID0gZmFsc2UsIGR1cmF0aW9uID0gQU5JTUFUSU9OX0RVUkFUSU9OLCBlYXNlID0gQU5JTUFUSU9OX0VBU0lORykge1xuICAgIGlmIChhbmltYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGR1cmF0aW9uID0gMFxuICAgIH1cblxuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGVcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHN0eWxlW0RVUkFUSU9OXSA9IGAke2R1cmF0aW9ufW1zYFxuICAgICAgc3R5bGVbVElNSU5HXSA9IGVhc2VcblxuICAgICAgLy8gTm8gc3ViIHBpeGVsIHRyYW5zaXRpb25zLlxuICAgICAgdGFyZ2V0UG9zaXRpb24gPSBNYXRoLmZsb29yKHRhcmdldFBvc2l0aW9uKVxuXG4gICAgICBzdHlsZVtUUkFOU0ZPUk1dID0gYHRyYW5zbGF0ZSgke3RhcmdldFBvc2l0aW9ufXB4LCAwKWBcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb25cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFdyYXBwZXJTbGlkZVBvc2l0aW9uKGluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCB3cmFwcGVyQ2VudGVyID0gKDAuNSAqIHRoaXMuX3dyYXBwZXJFbGVtZW50Lm9mZnNldFdpZHRoKVxuICAgIGNvbnN0IHNsaWRlID0gdGhpcy5fZ2V0U2xpZGUoaW5kZXgpXG5cbiAgICBsZXQgcmVzdWx0ID0gMFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHNsaWRlIChjZW50ZXJlZClcbiAgICBpZiAodGhpcy5fc2xpZGVzUGVyR3JvdXAgJSAyID09PSAwKSB7XG4gICAgICBsZXQgc2xpZGVTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNsaWRlKVxuICAgICAgbGV0IHNsaWRlTWFyZ2luID0gc2xpZGVTdHlsZSA/IHBhcnNlSW50KHNsaWRlU3R5bGUubWFyZ2luUmlnaHQhLCAxMCkgOiAwXG4gICAgICAvLyBDZW50ZXJlZCB0byB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdHdvIGNlbnRlciBzbGlkZXMgb2YgdGhlIGdyb3VwXG4gICAgICByZXN1bHQgPSAtc2xpZGUub2Zmc2V0TGVmdCAtIChzbGlkZS5jbGllbnRXaWR0aCkgKyB3cmFwcGVyQ2VudGVyIC0gc2xpZGVNYXJnaW5cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gLXNsaWRlLm9mZnNldExlZnQgLSAoMC41ICogc2xpZGUuY2xpZW50V2lkdGgpICsgd3JhcHBlckNlbnRlclxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25cbiAgfVxuXG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhcbiAgfVxuXG4gIHNldCBpbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleFxuICB9XG5cbiAgc2V0IHNsaWRlc1Blckdyb3VwKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IHZhbHVlXG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLm9ucmVzaXplKClcbiAgfVxuXG4gIHB1YmxpYyBvbnJlc2l6ZSgpIHtcbiAgICAvLyB1cGRhdGUgdGhlIGFyZWEgb2Zmc2V0IGZvciBzbGlkZSBwb3NpdGlvbiBjYWxjdWxhdGlvblxuICAgIHRoaXMuX2FyZWFPZmZzZXQgPSB0aGlzLl9zbGlkZUFyZWFFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnRcblxuICAgIC8vIEdldCB0aGUgY29udGFpbmVyIGRpbWVuc2lvbnNcbiAgICBjb25zdCBjb250YWluZXJSZWN0ID0gdGhpcy5fY2Fyb3VzZWxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgdGhpcy5fY29udGFpbmVyTWluID0gY29udGFpbmVyUmVjdC5sZWZ0XG4gICAgdGhpcy5fY29udGFpbmVyTWF4ID0gY29udGFpbmVyUmVjdC5yaWdodFxuICB9XG5cbiAgcHVibGljIGJlZ2luRHJhZygpIHtcbiAgICB0aGlzLl9pc2RyYWdnaW5nID0gdHJ1ZVxuICAgIHRoaXMuX2RyYWdTdGFydFBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb25cbiAgfVxuXG4gIHB1YmxpYyBjYW5jZWxEcmFnKCkge1xuICAgIHRoaXMuX2lzZHJhZ2dpbmcgPSBmYWxzZVxuICAgIHRoaXMuX3NldFRyYW5zZm9ybSh0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiEsIHRydWUsIEFOSU1BVElPTl9EVVJBVElPTiwgQU5JTUFUSU9OX0VBU0lORylcblxuICAgIHRoaXMuX2RyYWdTdGFydFBvc2l0aW9uID0gdW5kZWZpbmVkXG4gIH1cblxuICBwdWJsaWMgZW5kRHJhZygpIHtcbiAgICB0aGlzLl9pc2RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcHVibGljIG1vdmUoZGVsdGE6IG51bWJlciwgYW5pbWF0ZWQgPSBmYWxzZSwgZHVyYXRpb24gPSBBTklNQVRJT05fRFVSQVRJT04sIGVhc2UgPSBBTklNQVRJT05fRUFTSU5HKSB7XG4gICAgZGVsdGEgPSBNYXRoLnRydW5jKGRlbHRhKVxuICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPD0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRhcmdldFBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gKz0gZGVsdGFcbiAgICB0aGlzLl9zZXRUcmFuc2Zvcm0odGFyZ2V0UG9zaXRpb24sIGFuaW1hdGVkLCBkdXJhdGlvbiwgZWFzZSlcbiAgfVxuXG4gIHB1YmxpYyBtb3ZlVG8oaW5kZXg6IG51bWJlciwgZGVsdGE/OiBudW1iZXIsIGFuaW1hdGVkID0gZmFsc2UpIHtcbiAgICBsZXQgbmV3UG9zaXRpb24gPSAwXG4gICAgaWYgKCFkZWx0YSkge1xuICAgICAgbmV3UG9zaXRpb24gPSB0aGlzLl9nZXRXcmFwcGVyU2xpZGVQb3NpdGlvbihpbmRleClcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiArPSBkZWx0YVxuICAgIH1cblxuICAgIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgICB0aGlzLl9zZXRUcmFuc2Zvcm0obmV3UG9zaXRpb24sIGFuaW1hdGVkKVxuICB9XG5cbiAgcHVibGljIGFkZFNsaWRlKHNsaWRlOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IG51bWJlcikge1xuICAgIGlmICghc2xpZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgYW4gdW5kZWZpbmVkIHNsaWRlXCIpXG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uICE9PSAtMSAmJiBwb3NpdGlvbiAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCBvdXQgb2YgcmFuZ2UsICdwb3NpdGlvbicgbXVzdCBiZSBlaXRoZXIgMSBvciAtMS4gVmFsdWUgJHtwb3NpdGlvbn1gKVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA+IDApIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHNsaWRlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5pbnNlcnRCZWZvcmUoc2xpZGUsIHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuWzBdKVxuICAgICAgdGhpcy5faW5kZXgrK1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgIGxldCB3aWR0aCA9IHNsaWRlLm9mZnNldFdpZHRoXG5cbiAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNsaWRlKVxuICAgICAgbGV0IG1hcmdpbkxlZnQgPSBzdHlsZSA/IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQhLCAxMCkgOiAwXG4gICAgICBsZXQgbWFyZ2luUmlnaHQgPSBzdHlsZSA/IHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0ISwgMTApIDogMFxuXG4gICAgICB0aGlzLm1vdmUoLSh3aWR0aCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodCkpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbW92ZVNsaWRlKGluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBzbGlkZSA9IHRoaXMuX2dldFNsaWRlKGluZGV4KVxuICAgIGxldCB3aWR0aCA9IHNsaWRlLm9mZnNldFdpZHRoXG5cbiAgICBpZiAoaW5kZXggPD0gdGhpcy5faW5kZXgpIHtcbiAgICAgIHdpZHRoICo9IC0xXG4gICAgICB0aGlzLl9pbmRleC0tXG4gICAgfVxuXG4gICAgcmVtb3ZlKHNsaWRlKVxuXG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgdGhpcy5tb3ZlKC13aWR0aClcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0U2xpZGVEZWx0YShpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uXG4gICAgaWYgKHRoaXMuX2lzZHJhZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMuX2RyYWdTdGFydFBvc2l0aW9uISAtIHRoaXMuX3Bvc2l0aW9uXG4gICAgfVxuXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLl9nZXRXcmFwcGVyU2xpZGVQb3NpdGlvbihpbmRleClcbiAgICByZXR1cm4gbmV3UG9zaXRpb24gLSBjdXJyZW50UG9zaXRpb25cbiAgfVxuXG4gIHB1YmxpYyBnZXRTbGlkZVByb3BlcnRpZXMoaW5kZXg6IG51bWJlciwgZGVsdGEgPSAwKTogU2xpZGVQcm9wZXJ0aWVzIHtcbiAgICBsZXQgY3VycmVudE9mZnNldCA9IHRoaXMuX2FyZWFPZmZzZXQhICsgdGhpcy5fcG9zaXRpb24gKyBkZWx0YVxuICAgIGxldCBjdXJyZW50TGVmdCA9IGN1cnJlbnRPZmZzZXRcbiAgICBsZXQgY3VycmVudFJpZ2h0ID0gY3VycmVudE9mZnNldFxuICAgIGxldCBbIGN1cnJlbnRNYXJnaW5MZWZ0LCBjdXJyZW50TWFyZ2luUmlnaHQgXSA9IFsgMCwgMCBdXG5cbiAgICBsZXQgc2xpZGUgPSB0aGlzLl9nZXRTbGlkZShpbmRleClcbiAgICBsZXQgc2xpZGVJbmRleCA9IHBhcnNlSW50KHNsaWRlLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfSU5ERVgpISwgMTApXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpbmRleDsgaSsrKSB7XG4gICAgICBzbGlkZSA9IHRoaXMuX2dldFNsaWRlKGkpXG4gICAgICBsZXQgc2xpZGVTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNsaWRlKVxuXG4gICAgICBjdXJyZW50TWFyZ2luTGVmdCA9IHBhcnNlSW50KHNsaWRlU3R5bGUubWFyZ2luTGVmdCEsIDEwKVxuICAgICAgY3VycmVudE1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoc2xpZGVTdHlsZS5tYXJnaW5SaWdodCEsIDEwKVxuXG4gICAgICBjdXJyZW50T2Zmc2V0ICs9IGN1cnJlbnRNYXJnaW5MZWZ0XG4gICAgICBjdXJyZW50TGVmdCA9IGN1cnJlbnRPZmZzZXRcbiAgICAgIGN1cnJlbnRSaWdodCA9IGN1cnJlbnRMZWZ0ICsgc2xpZGUub2Zmc2V0V2lkdGhcblxuICAgICAgaWYgKGkgPCBpbmRleCkge1xuICAgICAgICBjdXJyZW50T2Zmc2V0ID0gY3VycmVudFJpZ2h0ICsgY3VycmVudE1hcmdpblJpZ2h0XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHZpc2libGUgPSBmYWxzZVxuICAgIGlmICgoY3VycmVudExlZnQgPiB0aGlzLl9jb250YWluZXJNaW4gJiYgY3VycmVudExlZnQgPCB0aGlzLl9jb250YWluZXJNYXgpIHx8XG4gICAgICAoY3VycmVudFJpZ2h0ID4gdGhpcy5fY29udGFpbmVyTWluICYmIGN1cnJlbnRSaWdodCA8IHRoaXMuX2NvbnRhaW5lck1heCkpIHtcbiAgICAgIHZpc2libGUgPSB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpc2libGUsXG4gICAgICBpbmRleDogc2xpZGVJbmRleCxcbiAgICAgIGxlZnQ6IGN1cnJlbnRMZWZ0LFxuICAgICAgcmlnaHQ6IGN1cnJlbnRSaWdodCxcbiAgICAgIHdpZHRoOiBjdXJyZW50UmlnaHQgLSBjdXJyZW50TGVmdCxcbiAgICAgIG1hcmdpbkxlZnQ6IGN1cnJlbnRNYXJnaW5MZWZ0LFxuICAgICAgbWFyZ2luUmlnaHQ6IGN1cnJlbnRNYXJnaW5SaWdodFxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRSZW1vdmFibGVTbGlkZXMoZGVsdGE6IG51bWJlcikge1xuICAgIGxldCBzbGlkZXMgPSBbXVxuICAgIGxldCBmaXJzdDogU2xpZGVQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkXG4gICAgbGV0IGxhc3Q6IFNsaWRlUHJvcGVydGllcyB8IHVuZGVmaW5lZFxuXG4gICAgbGV0IGluZGV4ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoXG4gICAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgICAgaW5kZXgtLVxuXG4gICAgICBsZXQgcHJvcHNOb3cgPSB0aGlzLmdldFNsaWRlUHJvcGVydGllcyhpbmRleClcbiAgICAgIGxldCBwcm9wc05ldyA9IHRoaXMuZ2V0U2xpZGVQcm9wZXJ0aWVzKGluZGV4LCBkZWx0YSlcblxuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgIGxhc3QgPSBwcm9wc05ld1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgZmlyc3QgPSBwcm9wc05ld1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHNOb3cudmlzaWJsZSA9PT0gZmFsc2UgJiYgcHJvcHNOZXcudmlzaWJsZSA9PT0gZmFsc2UgJiZcbiAgICAgICAgaW5kZXggIT09IHRoaXMuX2luZGV4ICYmIHRoaXMuX2lzZHJhZ2dpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgIHNsaWRlcy5wdXNoKHRydWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZXMucHVzaChmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzbGlkZXMucmV2ZXJzZSgpXG5cbiAgICBsZXQgZmlyc3RUb0tlZXAgPSBzbGlkZXMuaW5kZXhPZihmYWxzZSlcbiAgICBsZXQgbGFzdFRvS2VlcCA9IHNsaWRlcy5sYXN0SW5kZXhPZihmYWxzZSlcblxuICAgIGZvciAobGV0IGkgPSBmaXJzdFRvS2VlcDsgaSA8IGxhc3RUb0tlZXA7IGkrKykge1xuICAgICAgc2xpZGVzW2ldID0gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2xpZGVzLFxuICAgICAgZmlyc3Q6IGZpcnN0IGFzIFNsaWRlUHJvcGVydGllcyxcbiAgICAgIGxhc3Q6IGxhc3QgYXMgU2xpZGVQcm9wZXJ0aWVzXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldEVtcHR5U3BhY2UobGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IE1hdGgubWF4KE1hdGguY2VpbChsZWZ0IC0gdGhpcy5fY29udGFpbmVyTWluKSwgMCksXG4gICAgICByaWdodDogTWF0aC5tYXgoTWF0aC5jZWlsKHRoaXMuX2NvbnRhaW5lck1heCAtIHJpZ2h0KSwgMClcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl93cmFwcGVyRWxlbWVudCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fc2xpZGVBcmVhRWxlbWVudCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fY2Fyb3VzZWxFbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBkZXN0cm95KCkgaW5zdGVhZC5cbiAgICogQHRvZG8gcmVtb3ZlIGluIHZlcnNpb24gMi4wLjBcbiAgICovXG4gIHB1YmxpYyBkZXN0b3J5KCkge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuY2Fyb3VzZWxcIiwgKGUpID0+IHtcbiAgICBuZXcgQ2Fyb3VzZWwoZSBhcyBIVE1MRWxlbWVudClcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2Fyb3VzZWxcbiIsImltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHJlbW92ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCB7IHRyeUdldERhdGEsIGNyZWF0ZUxlZ2VuZEl0ZW0sIGlzQ29sb3IsIHJlbW92ZUFsbENoaWxkcmVuLCBDaGFydERhdGEsIENoYXJ0QXhpcyB9IGZyb20gXCIuL0NoYXJ0RnVuY3Rpb25zXCJcblxuaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcblxuY29uc3QgUVVFUllfREVUQUlMX1JJR0hUID0gXCIuZGV0YWlsLXJpZ2h0XCJcbmNvbnN0IFFVRVJZX0RFVEFJTF9CT1RUT00gPSBcIi5kZXRhaWwtYm90dG9tXCJcbmNvbnN0IFFVRVJZX1BST0dSRVNTID0gXCIuYmFyLWNoYXJ0X19wcm9ncmVzc1wiXG5cbmNvbnN0IENMQVNTX1VOTElNSVRFRCA9IFwiYmFyLWNoYXJ0LWhvcml6b250YWwtLXVubGltaXRlZFwiXG5jb25zdCBDTEFTU19MSU1JVEVEID0gXCJiYXItY2hhcnQtaG9yaXpvbnRhbC0tbGltaXRlZFwiXG5cbmNvbnN0IENMQVNTX0RFVEFJTF9WQUxVRSA9IFwidmFsdWVcIlxuY29uc3QgQ0xBU1NfREVUQUlMX1VOSVQgPSBcInVuaXRcIlxuXG5jb25zdCBDTEFTU19JTkRJQ0FUT1IgPSBcImluZGljYXRvclwiXG5jb25zdCBDTEFTU19JTkRJQ0FUT1JfV1JBUFBFUiA9IFwiaW5kaWNhdG9yLXdyYXBwZXJcIlxuXG5jb25zdCBDTEFTU19UT09MVElQID0gXCJ0b29sdGlwXCJcbmNvbnN0IENMQVNTX1RPT0xUSVBfTVVMVElMSU5FID0gXCJ0b29sdGlwLS1tdWx0aWxpbmVcIlxuXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT04gPSA1MDBcblxuLyoqXG4gKiBCYXIgQ2hhcnQgSG9yaXpvbnRhbCBDb21wb25lbnQuXG4gKi9cbmNsYXNzIEJhckNoYXJ0SG9yaXpvbnRhbCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfZGF0YSE6IENoYXJ0RGF0YVxuXG4gIHByaXZhdGUgX2xlZ2VuZEl0ZW1zOiBIVE1MRWxlbWVudFtdXG4gIHByaXZhdGUgX3Byb2dlc3NXcmFwcGVyITogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF91bml0ITogc3RyaW5nXG4gIHByaXZhdGUgX21heFZhbHVlITogbnVtYmVyXG4gIHByaXZhdGUgX3ByZWNpc2lvbiE6IG51bWJlclxuXG4gIHByaXZhdGUgX2lzVW5saW1pdGVkITogYm9vbGVhblxuICBwcml2YXRlIF9pc0xpbWl0ZWQhOiBib29sZWFuXG5cbiAgcHJpdmF0ZSBfZGV0YWlsUmlnaHQhOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9sZWdlbmQhOiBIVE1MRWxlbWVudFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgYmFyIGNoYXJ0IGhvcml6b250YWwgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gcm9vdCBlbGVtZW50IG9mIHRoZSBjaGFydC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkYXRhPzogQ2hhcnREYXRhKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgIH1cblxuICAgIHRoaXMuX2xlZ2VuZEl0ZW1zID0gW11cblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX3VuaXQgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdW5pdFwiKSB8fCBcIlwiXG4gICAgdGhpcy5fbWF4VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYXhcIikhKVxuICAgIHRoaXMuX3ByZWNpc2lvbiA9IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjaXNpb25cIikhLCAxMCkgfHwgMFxuXG4gICAgdGhpcy5faXNVbmxpbWl0ZWQgPSB0aGlzLmhhc0NsYXNzKENMQVNTX1VOTElNSVRFRClcbiAgICB0aGlzLl9pc0xpbWl0ZWQgPSB0aGlzLmhhc0NsYXNzKENMQVNTX0xJTUlURUQpXG5cbiAgICB0aGlzLl9wcm9nZXNzV3JhcHBlciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX1BST0dSRVNTKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIGlmICh0aGlzLl9pc0xpbWl0ZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2RldGFpbFJpZ2h0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfREVUQUlMX0JPVFRPTSkhIGFzIEhUTUxFbGVtZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RldGFpbFJpZ2h0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfREVUQUlMX1JJR0hUKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNVbmxpbWl0ZWQgPT09IGZhbHNlICYmIHRoaXMuX2lzTGltaXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2xlZ2VuZCA9IGdldEF0dHJpYnV0ZVJlZmVyZW5jZSh0aGlzLmVsZW1lbnQsIFwiZGF0YS1sZWdlbmRcIikhXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdHJ5R2V0RGF0YSh0aGlzLmVsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVuZGVyKCkge1xuICAgIGxldCBkYXRhT25lID0gdGhpcy5fZGF0YVswXVxuICAgIGxldCBkYXRhVHdvID0gdGhpcy5fZGF0YVsxXVxuXG4gICAgbGV0IHRvb2x0aXAgPSB0aGlzLl9pc0xpbWl0ZWQgPT09IGZhbHNlID8gdGhpcy5fZ2V0VG9vbHRpcENvbnRlbnQodGhpcy5fZGF0YSkgOiB1bmRlZmluZWRcblxuICAgIGxldCBhbmltYXRlZFZhbHVlRWxlbWVudDogRWxlbWVudCB8IHVuZGVmaW5lZFxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2RldGFpbFJpZ2h0KVxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX3Byb2dlc3NXcmFwcGVyKVxuXG4gICAgLy8gQ2xlYXIgb25seSBvd24gbGVnZW5kIGl0ZW1zXG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9sZWdlbmRJdGVtcykge1xuICAgICAgcmVtb3ZlKGl0ZW0pXG4gICAgfVxuICAgIHRoaXMuX2xlZ2VuZEl0ZW1zID0gW11cblxuICAgIGlmIChkYXRhT25lKSB7XG4gICAgICBpZiAodGhpcy5faXNVbmxpbWl0ZWQgPT09IGZhbHNlIHx8ICh0aGlzLl9pc1VubGltaXRlZCA9PT0gdHJ1ZSAmJiAhZGF0YVR3bykpIHtcblxuICAgICAgICBsZXQgdmFsRWxlbWVudCA9IGFuaW1hdGVkVmFsdWVFbGVtZW50ID0gdGhpcy5fY3JlYXRlVmFsdWVFbGVtZW50KGRhdGFPbmUpXG4gICAgICAgIHRoaXMuX2RldGFpbFJpZ2h0LmFwcGVuZENoaWxkKHZhbEVsZW1lbnQpXG5cbiAgICAgICAgaWYgKHRoaXMuX2lzTGltaXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBzZXBhcmF0b3JFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19ERVRBSUxfVU5JVClcbiAgICAgICAgICAgIC5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgc2VwYXJhdG9yRWxlbWVudC5pbm5lclRleHQgPSBgICR7dGhpcy5fdW5pdH1gXG5cbiAgICAgICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZChzZXBhcmF0b3JFbGVtZW50KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgaW5kaWNhdG9yXG4gICAgICBsZXQgaW5kaWNhdG9yID0gdGhpcy5fYWRkSW5kaWNhdG9yKGRhdGFPbmUsIHRvb2x0aXApXG4gICAgICB0aGlzLl9hbmltYXRlSW5kaWNhdG9yKGluZGljYXRvciwgMClcblxuICAgICAgLy8gQW5pbWF0ZSB0aGUgdmFsdWUgaWYgcmVxdWlyZWRcbiAgICAgIGlmIChhbmltYXRlZFZhbHVlRWxlbWVudCAmJiB0aGlzLl9pc0xpbWl0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVZhbHVlRWxlbWVudChhbmltYXRlZFZhbHVlRWxlbWVudCBhcyBIVE1MRWxlbWVudCwgZGF0YU9uZS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSBsZWdlbmRcbiAgICAgIGlmICh0aGlzLl9sZWdlbmQpIHtcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbSA9IGNyZWF0ZUxlZ2VuZEl0ZW0oZGF0YU9uZSlcbiAgICAgICAgdGhpcy5fbGVnZW5kLmFwcGVuZENoaWxkKGxlZ2VuZEl0ZW0pXG4gICAgICAgIHRoaXMuX2xlZ2VuZEl0ZW1zLnB1c2gobGVnZW5kSXRlbSlcblxuICAgICAgICB0aGlzLl9hbmltYXRlTGVnZW5kKGxlZ2VuZEl0ZW0sIDApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGFUd28pIHtcbiAgICAgIGxldCB2YWxFbGVtZW50ID0gdGhpcy5fY3JlYXRlVmFsdWVFbGVtZW50KGRhdGFUd28pXG5cbiAgICAgIGxldCB1bml0RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19ERVRBSUxfVU5JVClcbiAgICAgICAgLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgIHVuaXRFbGVtZW50LmlubmVyVGV4dCA9IGAgJHt0aGlzLl91bml0fWBcblxuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodmFsRWxlbWVudClcbiAgICAgIHRoaXMuX2RldGFpbFJpZ2h0LmFwcGVuZENoaWxkKHVuaXRFbGVtZW50KVxuXG4gICAgICAvLyBBZGQgdGhlIGluZGljYXRvclxuICAgICAgbGV0IGluZGljYXRvciA9IHRoaXMuX2FkZEluZGljYXRvcihkYXRhVHdvLCB0b29sdGlwKVxuICAgICAgdGhpcy5fYW5pbWF0ZUluZGljYXRvcihpbmRpY2F0b3IsIEFOSU1BVElPTl9EVVJBVElPTilcblxuICAgICAgLy8gQWRkIHRoZSBsZWdlbmRcbiAgICAgIGlmICh0aGlzLl9sZWdlbmQpIHtcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbSA9IGNyZWF0ZUxlZ2VuZEl0ZW0oZGF0YVR3bylcbiAgICAgICAgdGhpcy5fbGVnZW5kLmFwcGVuZENoaWxkKGxlZ2VuZEl0ZW0pXG4gICAgICAgIHRoaXMuX2xlZ2VuZEl0ZW1zLnB1c2gobGVnZW5kSXRlbSlcblxuICAgICAgICB0aGlzLl9hbmltYXRlTGVnZW5kKGxlZ2VuZEl0ZW0sIEFOSU1BVElPTl9EVVJBVElPTilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNMaW1pdGVkID09PSB0cnVlKSB7XG4gICAgICBsZXQgdmFsRWxlbWVudCA9IHRoaXMuX2NyZWF0ZVZhbHVlRWxlbWVudCh7IHZhbHVlOiB0aGlzLl9tYXhWYWx1ZSB9KVxuXG4gICAgICBsZXQgdW5pdEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfREVUQUlMX1VOSVQpXG4gICAgICAgIC5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICB1bml0RWxlbWVudC5pbm5lclRleHQgPSBgICR7dGhpcy5fdW5pdH1gXG5cbiAgICAgIHRoaXMuX2RldGFpbFJpZ2h0LmFwcGVuZENoaWxkKHZhbEVsZW1lbnQpXG4gICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh1bml0RWxlbWVudClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9hbmltYXRlVmFsdWVFbGVtZW50KGFuaW1hdGVkVmFsdWVFbGVtZW50OiBIVE1MRWxlbWVudCwgdG9WYWx1ZTogbnVtYmVyKSB7XG4gICAgbGV0IGNvdW50ZXIgPSB7IHZhcjogMCB9XG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogY291bnRlcixcbiAgICAgIHZhcjogdG9WYWx1ZSxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT04sXG4gICAgICBlYXNpbmc6IFwiZWFzZU91dFF1aW50XCIsXG4gICAgICByb3VuZDogMSxcbiAgICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgICBhbmltYXRlZFZhbHVlRWxlbWVudCEuaW5uZXJUZXh0ID0gYCR7Y291bnRlci52YXJ9YFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIF9hbmltYXRlSW5kaWNhdG9yKGluZGljYXRvcldyYXBwZXI6IEhUTUxFbGVtZW50LCBhbmltYXRpb25PZmZzZXQ6IG51bWJlcikge1xuICAgIGNvbnN0IGluZGljYXRvciA9IGluZGljYXRvcldyYXBwZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImluZGljYXRvclwiKVswXSBhcyBIVE1MRWxlbWVudFxuICAgIGNvbnN0IGluZGljYXRvcldpZHRoID0gaW5kaWNhdG9yLnNjcm9sbFdpZHRoXG4gICAgaW5kaWNhdG9yLnN0eWxlLndpZHRoID0gXCIwcHhcIlxuXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogaW5kaWNhdG9yLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTixcbiAgICAgIHdpZHRoOiBpbmRpY2F0b3JXaWR0aCArIFwicHhcIixcbiAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgZGVsYXk6IGFuaW1hdGlvbk9mZnNldCxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGluZGljYXRvci5zdHlsZS53aWR0aCA9IFwiXCJcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBfYW5pbWF0ZUxlZ2VuZChsZWdlbmRJdGVtOiBIVE1MRWxlbWVudCwgYW5pbWF0aW9uT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBsZWdlbmRJdGVtLnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGxlZ2VuZEl0ZW0sXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgZGVsYXk6IGFuaW1hdGlvbk9mZnNldCxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGxlZ2VuZEl0ZW0uc3R5bGUub3BhY2l0eSA9IG51bGxcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jcmVhdGVWYWx1ZUVsZW1lbnQoZGF0YTogeyB2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIH0pIHtcbiAgICBsZXQgdW5saW1pdGVkUHJlZml4ID0gXCJcIlxuXG4gICAgaWYgKHRoaXMuX2lzVW5saW1pdGVkID09PSB0cnVlKSB7XG4gICAgICB1bmxpbWl0ZWRQcmVmaXggPSBcIitcIlxuICAgIH1cblxuICAgIGxldCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyID0gcGFyc2VGbG9hdCgoZGF0YS52YWx1ZSBhcyBzdHJpbmcpKVxuXG4gICAgaWYgKHZhbHVlIDw9IDApIHtcbiAgICAgIGlmICh0aGlzLl9wcmVjaXNpb24gPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBcIjBcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBcIi5cIlxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcHJlY2lzaW9uOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSArPSBcIjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9GaXhlZCh0aGlzLl9wcmVjaXNpb24pXG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWVFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19ERVRBSUxfVkFMVUUpXG4gICAgICAuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgIHZhbHVlRWxlbWVudC5pbm5lclRleHQgPSBgJHt1bmxpbWl0ZWRQcmVmaXh9JHt2YWx1ZX1gXG4gICAgcmV0dXJuIHZhbHVlRWxlbWVudFxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRJbmRpY2F0b3IoZGF0YTogQ2hhcnRBeGlzLCB0b29sdGlwPzogc3RyaW5nKSB7XG4gICAgbGV0IHdpZHRoID0gKCgxMDAuMCAvIHRoaXMuX21heFZhbHVlKSAqIGRhdGEudmFsdWUpXG5cbiAgICBsZXQgaW5kaWNhdG9yID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1IpXG5cbiAgICBpZiAoaXNDb2xvcihkYXRhLmNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgaW5kaWNhdG9yLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke2RhdGEuY29sb3J9O2ApXG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGljYXRvci5hZGRDbGFzcyhkYXRhLmNvbG9yKVxuICAgIH1cblxuICAgIGxldCBpbmRpY2F0b3JXcmFwcGVyID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfV1JBUFBFUilcbiAgICAgIC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgd2lkdGg6ICR7d2lkdGh9JWApXG4gICAgICAuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKVxuICAgICAgLnNldEF0dHJpYnV0ZShcIm9uY2xpY2tcIiwgXCJ2b2lkKDApXCIpXG5cbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwICE9PSBcIlwiKSB7XG4gICAgICBpbmRpY2F0b3JXcmFwcGVyXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19UT09MVElQKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVE9PTFRJUF9NVUxUSUxJTkUpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRvb2x0aXApXG4gICAgfVxuXG4gICAgdGhpcy5fcHJvZ2Vzc1dyYXBwZXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yV3JhcHBlci5lbGVtZW50KVxuICAgIHJldHVybiBpbmRpY2F0b3JXcmFwcGVyLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0VG9vbHRpcENvbnRlbnQoZGF0YUxpc3Q6IENoYXJ0RGF0YSkge1xuICAgIGxldCB0b29sdGlwID0gXCJcIlxuICAgIGZvciAobGV0IGRhdGEgb2YgZGF0YUxpc3QpIHtcbiAgICAgIHRvb2x0aXAgKz0gYCR7ZGF0YS50aXRsZX06ICR7ZGF0YS52YWx1ZX0gJHt0aGlzLl91bml0fVxcbmBcbiAgICB9XG5cbiAgICByZXR1cm4gdG9vbHRpcC50cmltKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBiYXIgY2hhcnQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IC0gYmFyIGNoYXJ0IGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRhdGE6IENoYXJ0RGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIGNsZWFycyByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fZGF0YSA9IHVuZGVmaW5lZFxuXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fZGV0YWlsUmlnaHQpXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fcHJvZ2Vzc1dyYXBwZXIpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fZGV0YWlsUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fcHJvZ2Vzc1dyYXBwZXIgPSB1bmRlZmluZWRcblxuICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fbGVnZW5kSXRlbXMpIHtcbiAgICAgIHJlbW92ZShpdGVtKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX2xlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX2xlZ2VuZCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBkZXN0cm95KCkgaW5zdGVhZC5cbiAgICogQHRvZG8gcmVtb3ZlIGluIHZlcnNpb24gMi4wLjBcbiAgICovXG4gIHB1YmxpYyBkZXN0b3J5KCkge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTEVsZW1lbnQ+KFwiLmJhci1jaGFydC1ob3Jpem9udGFsXCIsIChlKSA9PiB7XG4gICAgbmV3IEJhckNoYXJ0SG9yaXpvbnRhbChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJDaGFydEhvcml6b250YWxcbiIsImltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IHsgdGV4dCB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuaW1wb3J0IHsgY3JlYXRlTGVnZW5kSXRlbSwgaXNDb2xvciwgcmVtb3ZlQWxsQ2hpbGRyZW4sIENoYXJ0TGFiZWwgfSBmcm9tIFwiLi9DaGFydEZ1bmN0aW9uc1wiXG5cbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5cbmNvbnN0IFFVRVJZX0RBVEFfQ0FURUdPUklFUyA9IFwiLmpzLWRhdGEtbGlzdCAuanMtY2F0ZWdvcnlcIlxuY29uc3QgUVVFUllfREFUQV9JVEVNUyA9IFwiLmpzLWRhdGEtbGlzdCAuanMtZGF0YVwiXG5jb25zdCBRVUVSWV9DSEFSVCA9IFwiLmpzLWNoYXJ0XCJcbmNvbnN0IFFVRVJZX0xFR0VORCA9IFwiLmJhci1jaGFydF9fbGVnZW5kXCJcblxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SID0gXCJpbmRpY2F0b3JcIlxuY29uc3QgQ0xBU1NfTEFCRUxfWCA9IFwiYXhpcy14LWxhYmVsXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9XUkFQUEVSID0gXCJpbmRpY2F0b3Itd3JhcHBlclwiXG5jb25zdCBDTEFTU19JTkRJQ0FUT1JfSU5ORVJfV1JBUFBFUiA9IFwiaW5kaWNhdG9yLXdyYXBwZXItaW5uZXJcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX0VNUFRZID0gXCJlbXB0eVwiXG5cbmNvbnN0IENMQVNTX1RPT0xUSVAgPSBcInRvb2x0aXBcIlxuY29uc3QgQ0xBU1NfVE9PTFRJUF9MRUZUID0gXCJ0b29sdGlwLS1sZWZ0XCJcbmNvbnN0IENMQVNTX1RPT0xUSVBfUklHSFQgPSBcInRvb2x0aXAtLXJpZ2h0XCJcbmNvbnN0IENMQVNTX1RPT0xUSVBfTVVMVElMSU5FID0gXCJ0b29sdGlwLS1tdWx0aWxpbmVcIlxuXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT04gPSA1MDBcblxuZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yeSBleHRlbmRzIENoYXJ0TGFiZWwge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFFbnRyeSB7XG4gIHRpdGxlOiBzdHJpbmdcbiAgY2xhc3M6IHN0cmluZ1xuICB2YWx1ZXM6IG51bWJlcltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcnREYXRhIHtcbiAgY2F0ZWdvcmllczogQ2F0ZWdvcnlbXVxuICBpdGVtczogRGF0YUVudHJ5W11cbn1cblxuLyoqXG4gKiBCYXIgQ2hhcnQgSG9yaXpvbnRhbCBDb21wb25lbnQuXG4gKi9cbmNsYXNzIEJhckNoYXJ0VmVydGljYWwgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX2RhdGEhOiBDaGFydERhdGFcblxuICBwcml2YXRlIF91bml0ITogc3RyaW5nXG4gIHByaXZhdGUgX21heFZhbHVlITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfY2hhcnQhOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9sZWdlbmQhOiBIVE1MRWxlbWVudFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgYmFyIGNoYXJ0IGhvcml6b250YWwgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIHJvb3QgZWxlbWVudCBvZiB0aGUgY2hhcnQuXG4gICAqIEBwYXJhbSBkYXRhIC0gZGF0YSBmb3IgdGhlIGNoYXJ0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIGRhdGE/OiBDaGFydERhdGEpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fdW5pdCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS11bml0XCIpIHx8IFwiXCJcblxuICAgIHRoaXMuX21heFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtbWF4XCIpISkgfHwgMTAwXG5cbiAgICB0aGlzLl9jaGFydCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0NIQVJUKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9sZWdlbmQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9MRUdFTkQpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fdHJ5R2V0RGF0YSh0aGlzLmVsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfdHJ5R2V0RGF0YShlbGVtZW50OiBIVE1MRWxlbWVudCk6IENoYXJ0RGF0YSB7XG4gICAgY29uc3QgZGF0YTogQ2hhcnREYXRhID0ge1xuICAgICAgY2F0ZWdvcmllczogW10sXG4gICAgICBpdGVtczogW11cbiAgICB9XG5cbiAgICBjb25zdCBjYXRlZ29yaWVzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0RBVEFfQ0FURUdPUklFUylcbiAgICBjb25zdCBpdGVtcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9EQVRBX0lURU1TKVxuXG4gICAgZm9yIChjb25zdCBjYXRlZ29yeSBvZiBjYXRlZ29yaWVzKSB7XG4gICAgICBkYXRhLmNhdGVnb3JpZXMucHVzaChcbiAgICAgICAge1xuICAgICAgICAgIHRpdGxlOiB0ZXh0KGNhdGVnb3J5KSxcbiAgICAgICAgICBjb2xvcjogY2F0ZWdvcnkuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKSFcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgZGF0YUVudHk6IERhdGFFbnRyeSA9IHtcbiAgICAgICAgdGl0bGU6IHRleHQoaXRlbSksXG4gICAgICAgIGNsYXNzOiBpdGVtLmdldEF0dHJpYnV0ZShcImRhdGEtY2xhc3NcIikhLFxuICAgICAgICB2YWx1ZXM6IFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHMgPSBpdGVtLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIilcbiAgICAgIGlmICh2YWxzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHMuc3BsaXQoXCIsXCIpKSB7XG4gICAgICAgICAgZGF0YUVudHkudmFsdWVzLnB1c2gocGFyc2VGbG9hdCh2YWwpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRhdGEuaXRlbXMucHVzaChkYXRhRW50eSlcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRUb29sdGlwQ29udGVudChlbnRyeTogRGF0YUVudHJ5LCBjYXRlZ29yaWVzOiBDYXRlZ29yeVtdKSB7XG4gICAgbGV0IHRvb2x0aXAgPSBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyeS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvb2x0aXAgKz0gYCR7Y2F0ZWdvcmllc1tpXS50aXRsZX06ICR7ZW50cnkudmFsdWVzW2ldfSAke3RoaXMuX3VuaXR9XFxuYFxuICAgIH1cblxuICAgIHJldHVybiB0b29sdGlwLnRyaW0oKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9yZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKVxuXG4gICAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIHRoaXMuX2RhdGEuY2F0ZWdvcmllcykge1xuICAgICAgICBjb25zdCBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kSXRlbShjYXRlZ29yeSlcbiAgICAgICAgdGhpcy5fbGVnZW5kLmFwcGVuZENoaWxkKGxlZ2VuZEl0ZW0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fY2hhcnQpXG5cbiAgICBjb25zdCBhbmltYXRpb25TdGFnZXM6IEVsZW1lbnRbXVtdID0gW11cblxuICAgIGxldCBsZWZ0U2lkZUl0ZW1zID0gTWF0aC5mbG9vcih0aGlzLl9kYXRhLml0ZW1zLmxlbmd0aCAvIDIpXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2RhdGEuaXRlbXMpIHtcbiAgICAgIGxldCBlbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJsaVwiKVxuXG4gICAgICBpZiAoaXRlbS5jbGFzcykge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKGl0ZW0uY2xhc3MpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxpc3RFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJ1bFwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX1dSQVBQRVIpXG5cbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0lOTkVSX1dSQVBQRVIpXG4gICAgICBsaXN0RWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwcGVyKVxuXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGxpc3RFbGVtZW50KVxuXG4gICAgICBjb25zdCB0b29sdGlwID0gdGhpcy5fZ2V0VG9vbHRpcENvbnRlbnQoaXRlbSwgdGhpcy5fZGF0YS5jYXRlZ29yaWVzKVxuICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgd3JhcHBlclxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19UT09MVElQKVxuICAgICAgICAgIC5hZGRDbGFzcyhsZWZ0U2lkZUl0ZW1zIDw9IDAgPyBDTEFTU19UT09MVElQX0xFRlQgOiBDTEFTU19UT09MVElQX1JJR0hUKVxuICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRvb2x0aXApXG5cbiAgICAgICAgaWYgKGl0ZW0udmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB3cmFwcGVyLmFkZENsYXNzKENMQVNTX1RPT0xUSVBfTVVMVElMSU5FKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuX2NoYXJ0Lm9mZnNldEhlaWdodCAvIHRoaXMuX21heFZhbHVlKSAqIGl0ZW0udmFsdWVzW2ldXG5cbiAgICAgICAgY29uc3QgaW5kaWNhdG9yID0gbmV3IERvbUVsZW1lbnQoXCJsaVwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1IpXG4gICAgICAgICAgLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBoZWlnaHQ6ICR7aGVpZ2h0fXB4O2ApXG5cbiAgICAgICAgaWYgKGhlaWdodCA+IDApIHtcbiAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX2RhdGEuY2F0ZWdvcmllc1tpXS5jb2xvclxuICAgICAgICAgIGlmIChpc0NvbG9yKGNvbG9yKSkge1xuICAgICAgICAgICAgaW5kaWNhdG9yLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yfTtgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRpY2F0b3IuYWRkQ2xhc3MoY29sb3IpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuaW1hdGlvblN0YWdlcy5sZW5ndGggPD0gaSkge1xuICAgICAgICAgICAgYW5pbWF0aW9uU3RhZ2VzLnB1c2goW10pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5pbWF0aW9uU3RhZ2VzW2ldLnB1c2goaW5kaWNhdG9yLmVsZW1lbnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kaWNhdG9yLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9FTVBUWSlcbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0aXRsZURvbUVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfTEFCRUxfWClcbiAgICAgIGNvbnN0IHRpdGxlRWxlbWVudCA9IHRpdGxlRG9tRWxlbWVudC5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICB0aXRsZUVsZW1lbnQuaW5uZXJUZXh0ID0gaXRlbS50aXRsZVxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aXRsZURvbUVsZW1lbnQpXG5cbiAgICAgIHRoaXMuX2NoYXJ0LmFwcGVuZENoaWxkKGVsZW1lbnQuZWxlbWVudClcbiAgICAgIGxlZnRTaWRlSXRlbXMgLT0gMVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5pbWF0aW9uU3RhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBBTklNQVRJT05fRFVSQVRJT04gKiBpXG4gICAgICB0aGlzLl9hbmltYXRlQmFycyhhbmltYXRpb25TdGFnZXNbaV0gYXMgSFRNTEVsZW1lbnRbXSwgb2Zmc2V0KVxuXG4gICAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVMZWdlbmQodGhpcy5fbGVnZW5kLmNoaWxkcmVuW2ldIGFzIEhUTUxFbGVtZW50LCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYW5pbWF0ZUJhcnMoYmFyczogSFRNTEVsZW1lbnRbXSwgYW5pbWF0aW9uT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhciA9IGJhcnNbaV1cbiAgICAgIGNvbnN0IGJhckhlaWdodCA9IGJhci5zdHlsZS5oZWlnaHRcbiAgICAgIGJhci5zdHlsZS5oZWlnaHQgPSBcIjBcIlxuICAgICAgYW5pbWUoe1xuICAgICAgICB0YXJnZXRzOiBiYXJzW2ldLFxuICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT04sXG4gICAgICAgIGRlbGF5OiBhbmltYXRpb25PZmZzZXRcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYW5pbWF0ZUxlZ2VuZChsZWdlbmQ6IEhUTUxFbGVtZW50LCBhbmltYXRpb25PZmZzZXQ6IG51bWJlcikge1xuICAgIGxlZ2VuZC5zdHlsZS5vcGFjaXR5ID0gXCIwXCJcbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBsZWdlbmQsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OLFxuICAgICAgZGVsYXk6IGFuaW1hdGlvbk9mZnNldFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYmFyIGNoYXJ0IHdpdGggdGhlIHNwZWNpZmllZCBkYXRhIGRlZmluaXRpb25zLlxuICAgKiBAcGFyYW0ge0FycmF5fSAtIGJhciBjaGFydCBkYXRhIGRlZmluaXRpb25zLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZShkYXRhOiBDaGFydERhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICh0aGlzIGFzIGFueSkuX2RhdGEgPSB1bmRlZmluZWRcblxuICAgIGlmICh0aGlzLl9sZWdlbmQpIHtcbiAgICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2xlZ2VuZCk7XG4gICAgICAodGhpcyBhcyBhbnkpLl9sZWdlbmQgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGRlc3Ryb3koKSBpbnN0ZWFkLlxuICAgKiBAdG9kbyByZW1vdmUgaW4gdmVyc2lvbiAyLjAuMFxuICAgKi9cbiAgcHVibGljIGRlc3RvcnkoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIuYmFyLWNoYXJ0LXZlcnRpY2FsXCIsIChlKSA9PiB7XG4gICAgbmV3IEJhckNoYXJ0VmVydGljYWwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFyQ2hhcnRWZXJ0aWNhbFxuIiwiaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgdGV4dCB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXJ0TGFiZWwge1xuICB0aXRsZTogc3RyaW5nXG4gIGNvbG9yOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFydEF4aXMgZXh0ZW5kcyBDaGFydExhYmVsIHtcbiAgdmFsdWU6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBDaGFydERhdGEgPSBDaGFydEF4aXNbXVxuXG5jb25zdCBRVUVSWV9EQVRBID0gXCIuanMtZGF0YVwiXG5cbmV4cG9ydCBmdW5jdGlvbiB0cnlHZXREYXRhKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ2hhcnREYXRhIHtcbiAgbGV0IGRhdGEgPSBbXVxuICBsZXQgZWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfREFUQSlcblxuICBmb3IgKGxldCBlbnRyeSBvZiBlbGVtZW50cykge1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQoZW50cnkuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSEpXG4gICAgbGV0IGNvbG9yID0gZW50cnkuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKSFcbiAgICBsZXQgdGl0bGUgPSB0ZXh0KGVudHJ5KVxuXG4gICAgbGV0IGl0ZW0gPSB7XG4gICAgICB0aXRsZSxcbiAgICAgIHZhbHVlLFxuICAgICAgY29sb3JcbiAgICB9XG5cbiAgICBkYXRhLnB1c2goaXRlbSlcbiAgfVxuXG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGxDaGlsZHJlbihub2RlOiBOb2RlKSB7XG4gIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGVnZW5kSXRlbShkYXRhOiBDaGFydExhYmVsKSB7XG4gIGNvbnN0IGJ1bGxldCA9IG5ldyBEb21FbGVtZW50PEhUTUxTcGFuRWxlbWVudD4oXCJzcGFuXCIpXG4gICAgLmFkZENsYXNzKFwiYnVsbGV0XCIpXG5cbiAgaWYgKGlzQ29sb3IoZGF0YS5jb2xvcikgPT09IHRydWUpIHtcbiAgICBidWxsZXQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7ZGF0YS5jb2xvcn07YClcbiAgfSBlbHNlIHtcbiAgICBidWxsZXQuYWRkQ2xhc3MoZGF0YS5jb2xvcilcbiAgfVxuXG4gIGNvbnN0IGNhcHRpb24gPSBuZXcgRG9tRWxlbWVudDxIVE1MU3BhbkVsZW1lbnQ+KFwic3BhblwiKVxuICAgIC5zZXRIdG1sKGRhdGEudGl0bGUpXG5cbiAgcmV0dXJuIG5ldyBEb21FbGVtZW50PEhUTUxMSUVsZW1lbnQ+KFwibGlcIilcbiAgICAuYXBwZW5kQ2hpbGQoYnVsbGV0KVxuICAgIC5hcHBlbmRDaGlsZChjYXB0aW9uKVxuICAgIC5lbGVtZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbG9yKHN0cjogc3RyaW5nKSB7XG4gIGNvbnN0IHBhdHRlcm4gPSAvXiMvaVxuICByZXR1cm4gcGF0dGVybi50ZXN0KHN0cilcbn1cbiIsImltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IHsgcmVtb3ZlQWxsQ2hpbGRyZW4sIHRyeUdldERhdGEsIGlzQ29sb3IsIENoYXJ0RGF0YSB9IGZyb20gXCIuL0NoYXJ0RnVuY3Rpb25zXCJcbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5cbmNvbnN0IFFVRVJZX0NIQVJUID0gXCIuanMtY2hhcnRcIlxuY29uc3QgUVVFUllfTEVHRU5EID0gXCIuanMtbGVnZW5kXCJcblxuY29uc3QgREFTSF9TRVBBUkFUT1JfV0lEVEggPSAzXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT04gPSAxNTAwXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT05fTEVHRU5EID0gNTAwXG5cbmNvbnN0IFFVRVJZX01FVEFfVElUTEUgPSBcIi5tZXRhIC50aXRsZVwiXG5jb25zdCBRVUVSWV9NRVRBX1NVQlRJVExFID0gXCIubWV0YSAuc3VidGl0bGVcIlxuXG4vKipcbiAqIFBpZSBDaGFydCBDb21wb25lbnQuXG4gKi9cbmNsYXNzIFBpZUNoYXJ0IGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MRWxlbWVudD4ge1xuICBwcml2YXRlIF9kYXRhITogQ2hhcnREYXRhXG5cbiAgcHJpdmF0ZSBfY2hhcnQhOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9sZWdlbmQhOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF90aXRsZSE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3N1YnRpdGxlITogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF91bml0ITogc3RyaW5nXG4gIHByaXZhdGUgX2Fsd2F5c1Nob3dMZWdlbmQhOiBib29sZWFuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBQaWUgQ2hhcnQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gcm9vdCBlbGVtZW50IG9mIHRoZSBjaGFydC5cbiAgICogQHBhcmFtIHtBcnJheX0gLSBwaWUgY2hhcnQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkYXRhPzogQ2hhcnREYXRhKSB7XG4gICAgc3VwZXIoZWxlbWVudClcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9jaGFydCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0NIQVJUKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9sZWdlbmQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9MRUdFTkQpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX3RpdGxlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTUVUQV9USVRMRSkhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fc3VidGl0bGUgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9NRVRBX1NVQlRJVExFKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIHRoaXMuX3VuaXQgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdW5pdFwiKSB8fCBcIlwiXG4gICAgdGhpcy5fYWx3YXlzU2hvd0xlZ2VuZCA9IHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWFsd2F5cy1zaG93LWxlZ2VuZFwiKVxuXG4gICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdHJ5R2V0RGF0YSh0aGlzLmVsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVuZGVyKCkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fZGF0YS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKVxuICAgIGNvbnN0IHIgPSAxNlxuICAgIGNvbnN0IGRhc2hUb3RhbCA9ICgyICogciAqIE1hdGguUEkpXG5cbiAgICBsZXQgY3VycmVudFJvdGF0ZSA9IDlcblxuICAgIC8vIENsZWFudXBcbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9jaGFydClcblxuICAgIGlmICh0aGlzLl9sZWdlbmQpIHtcbiAgICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2xlZ2VuZClcbiAgICB9XG5cbiAgICBsZXQgcGVyY2VudGFnZUFkanVzdFRvdGFsID0gMFxuICAgIGxldCBwZXJjZW50YWdlQWRqdXN0ID0gMFxuICAgIGNvbnN0IHNlcGFyYXRvclBlcmNlbnRhZ2UgPSBEQVNIX1NFUEFSQVRPUl9XSURUSCAvIDEwMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX2RhdGFbaV1cblxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGVudHJ5LnZhbHVlIC8gdG90YWxcbiAgICAgIGlmIChwZXJjZW50YWdlIDwgc2VwYXJhdG9yUGVyY2VudGFnZSkge1xuICAgICAgICBwZXJjZW50YWdlQWRqdXN0VG90YWwgKz0gKHNlcGFyYXRvclBlcmNlbnRhZ2UgLSBwZXJjZW50YWdlKVxuICAgICAgICBwZXJjZW50YWdlQWRqdXN0KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGVyY2VudGFnZUFkanVzdCA+IDApIHtcbiAgICAgIHBlcmNlbnRhZ2VBZGp1c3QgPSBwZXJjZW50YWdlQWRqdXN0VG90YWwgLyAodGhpcy5fZGF0YS5sZW5ndGggLSBwZXJjZW50YWdlQWRqdXN0KVxuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBhbmltZS50aW1lbGluZSgpXG5cbiAgICBsZXQgYW5pbWF0aW9uT2Zmc2V0ID0gMFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9kYXRhW2ldXG5cbiAgICAgIGNvbnN0IGRpc3BsYXlQZXJjZW50YWdlID0gZW50cnkudmFsdWUgLyB0b3RhbFxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IE1hdGgubWF4KHNlcGFyYXRvclBlcmNlbnRhZ2UsIGRpc3BsYXlQZXJjZW50YWdlIC0gcGVyY2VudGFnZUFkanVzdClcblxuICAgICAgbGV0IGRhc2hXaWR0aCA9IChwZXJjZW50YWdlICogZGFzaFRvdGFsKSAtIERBU0hfU0VQQVJBVE9SX1dJRFRIXG5cbiAgICAgIGxldCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKVxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgMzQgMzRcIilcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpXG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIFwidGl0bGUgZGVzY1wiKVxuXG4gICAgICBsZXQgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInRpdGxlXCIpXG4gICAgICB0aXRsZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInRpdGxlXCIpXG4gICAgICB0aXRsZS5pbm5lckhUTUwgPSBgUGllIGNoYXJ0IHNlZ21lbnQgJHtNYXRoLmZsb29yKGRpc3BsYXlQZXJjZW50YWdlICogMTAwKX0lYFxuXG4gICAgICBsZXQgZGVzY3JpcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImRlc2NcIilcbiAgICAgIGRlc2NyaXB0aW9uLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiZGVzY1wiKVxuICAgICAgZGVzY3JpcHRpb24uaW5uZXJIVE1MID0gYCR7ZW50cnkudGl0bGV9OiAke2VudHJ5LnZhbHVlfWBcblxuICAgICAgbGV0IGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3hcIiwgXCIxN1wiKVxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIFwiMTdcIilcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyXCIsIFN0cmluZyhyKSlcblxuICAgICAgaWYgKGlzQ29sb3IoZW50cnkuY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgYCR7ZW50cnkuY29sb3J9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBlbnRyeS5jb2xvcilcbiAgICAgIH1cblxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIilcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgdHJhbnNmb3JtOiByb3RhdGUoJHtjdXJyZW50Um90YXRlfWRlZyk7YClcblxuICAgICAgc3ZnLmFwcGVuZENoaWxkKHRpdGxlKVxuICAgICAgc3ZnLmFwcGVuZENoaWxkKGRlc2NyaXB0aW9uKVxuICAgICAgc3ZnLmFwcGVuZENoaWxkKGNpcmNsZSlcbiAgICAgIHRoaXMuX2NoYXJ0LmFwcGVuZENoaWxkKHN2ZylcblxuICAgICAgbGV0IGFuaW1hdGlvbkR1cmF0aW9uID0gQU5JTUFUSU9OX0RVUkFUSU9OICogcGVyY2VudGFnZVxuICAgICAgY2lyY2xlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIlxuXG4gICAgICBsZXQgY291bnRlciA9IHsgdmFyOiAwLjUgfVxuICAgICAgYW5pbWF0aW9ucy5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBjb3VudGVyLFxuICAgICAgICB2YXI6IGRhc2hXaWR0aCxcbiAgICAgICAgYmVnaW46ICgpID0+IHtcbiAgICAgICAgICBjaXJjbGUuc3R5bGUuZGlzcGxheSA9IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgYCR7Y291bnRlci52YXJ9ICR7ZGFzaFRvdGFsfWApXG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBcImVhc2VJblF1aW50XCJcbiAgICAgIH0pXG5cbiAgICAgIC8vIExlZ2VuZFxuICAgICAgaWYgKHRoaXMuX2xlZ2VuZCAmJiAodGhpcy5fZGF0YS5sZW5ndGggPiAxKSB8fCB0aGlzLl9hbHdheXNTaG93TGVnZW5kKSB7XG4gICAgICAgIGxldCBidWxsZXQgPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgICAgICAuYWRkQ2xhc3MoXCJidWxsZXRcIilcblxuICAgICAgICBpZiAoaXNDb2xvcihlbnRyeS5jb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICBidWxsZXQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7ZW50cnkuY29sb3J9YClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWxsZXQuYWRkQ2xhc3MoZW50cnkuY29sb3IpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYXB0aW9uID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgIGNvbnN0IGNhcHRpb25FbGVtZW50ID0gY2FwdGlvbi5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICAgIGNhcHRpb25FbGVtZW50LmlubmVyVGV4dCA9IGVudHJ5LnRpdGxlXG5cbiAgICAgICAgbGV0IGxlZ2VuZEl0ZW0gPSBuZXcgRG9tRWxlbWVudChcImxpXCIpXG4gICAgICAgICAgLmFwcGVuZENoaWxkKGJ1bGxldClcbiAgICAgICAgICAuYXBwZW5kQ2hpbGQoY2FwdGlvbilcblxuICAgICAgICB0aGlzLl9sZWdlbmQuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbS5lbGVtZW50KVxuXG4gICAgICAgIHRoaXMuX2FuaW1hdGVMZWdlbmQobGVnZW5kSXRlbS5lbGVtZW50IGFzIEhUTUxFbGVtZW50LCBhbmltYXRpb25PZmZzZXQpXG4gICAgICB9XG4gICAgICBhbmltYXRpb25PZmZzZXQgKz0gYW5pbWF0aW9uRHVyYXRpb25cblxuICAgICAgY3VycmVudFJvdGF0ZSArPSAoMzYwICogcGVyY2VudGFnZSlcblxuICAgICAgaWYgKGkgPT09IHRoaXMuX2RhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLl90aXRsZS5pbm5lckhUTUwgPSBgJHtlbnRyeS52YWx1ZX0gJHt0aGlzLl91bml0fWBcbiAgICAgICAgdGhpcy5fc3VidGl0bGUuaW5uZXJIVE1MID0gZW50cnkudGl0bGVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9hbmltYXRlTGVnZW5kKGxlZ2VuZEl0ZW06IEhUTUxFbGVtZW50LCBhbmltYXRpb25PZmZzZXQ6IG51bWJlcikge1xuICAgIGxlZ2VuZEl0ZW0uc3R5bGUub3BhY2l0eSA9IFwiMFwiXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogbGVnZW5kSXRlbSxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT05fTEVHRU5ELFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgZGVsYXk6IGFuaW1hdGlvbk9mZnNldCxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGxlZ2VuZEl0ZW0uc3R5bGUub3BhY2l0eSA9IG51bGxcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBpZSBjaGFydCB3aXRoIHRoZSBzcGVjaWZpZWQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICogQHBhcmFtIHtBcnJheX0gLSBwaWUgY2hhcnQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoZGF0YTogQ2hhcnREYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3RpdGxlID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3N1YnRpdGxlID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3VuaXQgPSB1bmRlZmluZWRcblxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2NoYXJ0KTtcbiAgICAodGhpcyBhcyBhbnkpLl9jaGFydCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKTtcbiAgICAgICh0aGlzIGFzIGFueSkuX2xlZ2VuZCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVzdHJveSgpIGluc3RlYWQuXG4gICAqIEB0b2RvIHJlbW92ZSBpbiB2ZXJzaW9uIDIuMC4wXG4gICAqL1xuICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxFbGVtZW50PihcIi5waWUtY2hhcnRcIiwgKGUpID0+IHtcbiAgICBuZXcgUGllQ2hhcnQoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGllQ2hhcnRcbiIsImltcG9ydCB7IHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBhZGRDbGFzcywgaGFzQ2xhc3MsIHJlbW92ZUNsYXNzLCBpc0hpZGRlbiB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcblxuY29uc3QgQU5JTUFUSU9OX09QRU4gPSAzMDBcblxuLyoqXG4gKiBUaGUgQ29sbGFwc2UgY29tcG9uZW50LlxuICovXG5jbGFzcyBDb2xsYXBzZSBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9oaWRkZW5JbmRpY2F0b3IhOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9jb2xsYXBzaWJsZUVsZW1lbnRzITogTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5cbiAgcHJpdmF0ZSBfY2xpY2tIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIENvbGxhcHNlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIENvbGxhcHNlIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQ29sbGFwc2UgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGxldCBkYXRhVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpXG4gICAgaWYgKGRhdGFUYXJnZXQgPT09IG51bGwgfHwgZGF0YVRhcmdldCA9PT0gXCJcIikge1xuXG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmVycm9yKFwiQSBjb2xsYXBzaWJsZSBlbGVtZW50IHJlcXVpcmVzIGEgJ2RhdGEtdGFyZ2V0JyB0aGF0IHNwZWNpZmllcyB0aGUgZWxlbWVudCB0byBjb2xsYXBzZVwiKVxuICAgICAgY29uc29sZS5pbmZvKHRoaXMuZWxlbWVudClcbiAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaGlkZGVuVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtaGlkZGVuXCIpXG4gICAgaWYgKGhpZGRlblRhcmdldCAhPT0gbnVsbCAmJiBoaWRkZW5UYXJnZXQgIT09IFwiXCIpIHtcbiAgICAgIHRoaXMuX2hpZGRlbkluZGljYXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaGlkZGVuVGFyZ2V0KSEgYXMgSFRNTEVsZW1lbnRcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsYXBzaWJsZUVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkYXRhVGFyZ2V0KVxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgY29sbGFwc2VpYmxlLlxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuSW5kaWNhdG9yICYmIGlzSGlkZGVuKHRoaXMuX2hpZGRlbkluZGljYXRvciwgZmFsc2UpID09PSB0cnVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcblxuICAgICAgZm9yIChsZXQgcyBvZiB0aGlzLl9jb2xsYXBzaWJsZUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuX29wZW5Db2xsYXBzZShzKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5fY29sbGFwc2libGVFbGVtZW50cykge1xuICAgICAgICB0aGlzLl9jbG9zZUNvbGxhcHNlKHMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vcGVuQ29sbGFwc2UoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgYW5pbWUucmVtb3ZlKGVsKVxuXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogZWwsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX09QRU4sXG4gICAgICBoZWlnaHQ6IGVsLnNjcm9sbEhlaWdodCArIFwicHhcIixcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudChlbClcbiAgICAgICAgZG9tRWwuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gc2V0IGFyaWEgZXhwYW5kZWRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9zZUNvbGxhcHNlKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGFuaW1lLnJlbW92ZShlbClcblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBkb21FbCA9IG5ldyBEb21FbGVtZW50KGVsKVxuICAgICAgICBkb21FbC5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICBkb21FbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBzZXQgYXJpYSBleHBhbmRlZFxuICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICh0aGlzIGFzIGFueSkuX2NvbGxhcHNpYmxlRWxlbWVudHMgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMgYXMgYW55KS5fY2xpY2tIYW5kbGVyKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLmVsZW1lbnQgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS10b2dnbGU9J2NvbGxhcHNlJ11cIilcbiAgZm9yIChsZXQgZSBvZiBlbGVtZW50cykge1xuICAgIGlmIChlLmdldEF0dHJpYnV0ZShcImRhdGEtaW5pdFwiKSA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIG5ldyBDb2xsYXBzZShlIGFzIEhUTUxFbGVtZW50KVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2xsYXBzZVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBwYXJlbnRXaXRoQ2xhc3MsIGdldFJvb3RFbGVtZW50IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX0JPUkRFUiA9IFwiZW1wdHktc3RhdGVfX2JvcmRlclwiXG5jb25zdCBDTEFTU19CT1JERVJfTU9EQUwgPSBcImVtcHR5LXN0YXRlX19ib3JkZXItLW1vZGFsXCJcbmNvbnN0IENMQVNTX0FDVElWRSA9IFwiaXMtYWN0aXZlXCJcbmNvbnN0IENMQVNTX0hBU0ZJTEVTID0gXCJoYXMtZmlsZXNcIlxuY29uc3QgQ0xBU1NfTU9EQUwgPSBcImVtcHR5LXN0YXRlLS1tb2RhbFwiXG5jb25zdCBDTEFTU19NT0RBTF9DT05URU5UID0gXCJtb2RhbF9fY29udGVudFwiXG5cbmNvbnN0IFFVRVJZX01PREFMX0JPRFkgPSBcIi5tb2RhbF9fYm9keVwiXG5jb25zdCBRVUVSWV9GSUxFID0gXCJpbnB1dFt0eXBlPSdmaWxlJ11cIlxuXG4vKipcbiAqIEVtcHR5IHN0YXRlIHBhdHRlcm5cbiAqL1xuY2xhc3MgRW1wdHlTdGF0ZSBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9ib3JkZXIhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuXG4gIHByaXZhdGUgX2ZpbGVJbnB1dDogSFRNTElucHV0RWxlbWVudFxuICBwcml2YXRlIF9idXR0b246IEhUTUxMYWJlbEVsZW1lbnRcblxuICBwcml2YXRlIF9kcmFnQXJlYSE6IEVsZW1lbnRcblxuICBwcml2YXRlIF9maWxlQ2hhbmdlZEhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfcHJldmVudEV2ZW50c0hhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZHJhZ0VudGVySGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9kcmFnTGVhdmVIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2Ryb3BIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfaXNEcmFnZ2luZzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgRW1wdHktU3RhdGUgcGF0dGVybiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSByb290IGVsZW1lbnQgb2YgdGhlIGVtcHR5LXN0YXRlIHBhdHRlcm4uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2ZpbGVJbnB1dCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0ZJTEUpISBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgdGhpcy5fYnV0dG9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJsYWJlbFwiKSFcblxuICAgIHRoaXMuX2ZpbGVDaGFuZ2VkSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZpbGVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlciA9IHRoaXMuX3ByZXZlbnREcmFnRXZlbnRzLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcmFnRW50ZXJIYW5kbGVyID0gdGhpcy5faGFuZGxlRHJhZ0VudGVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcmFnTGVhdmVIYW5kbGVyID0gdGhpcy5faGFuZGxlRHJhZ0xlYXZlLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcm9wSGFuZGxlciA9IHRoaXMuX2hhbmRsZURyb3AuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNDbGFzcyhDTEFTU19NT0RBTCkpIHtcbiAgICAgIC8vIGhhbmRsZSBtb2RhbCBkaWFsb2dzXG4gICAgICB0aGlzLl9kcmFnQXJlYSA9IHBhcmVudFdpdGhDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX01PREFMX0NPTlRFTlQpIVxuICAgICAgbGV0IGJvcmRlckFyZWEgPSB0aGlzLl9kcmFnQXJlYS5xdWVyeVNlbGVjdG9yKFFVRVJZX01PREFMX0JPRFkpIVxuICAgICAgYm9yZGVyQXJlYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInBvaW50ZXItZXZlbnRzOiBub25lO1wiKVxuXG4gICAgICB0aGlzLl9ib3JkZXIgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0JPUkRFUilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0JPUkRFUl9NT0RBTClcblxuICAgICAgYm9yZGVyQXJlYS5hcHBlbmRDaGlsZCh0aGlzLl9ib3JkZXIuZWxlbWVudClcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgbW9kYWwgZGlhbG9nXG4gICAgICB0aGlzLl9kcmFnQXJlYSA9IHRoaXMuZWxlbWVudFxuICAgICAgbGV0IGJvcmRlckFyZWEgPSBnZXRSb290RWxlbWVudCgpXG5cbiAgICAgIHRoaXMuX2JvcmRlciA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQk9SREVSKVxuXG4gICAgICBpZiAoIWJvcmRlckFyZWEucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfQk9SREVSfWApKSB7XG4gICAgICAgIGJvcmRlckFyZWEuYXBwZW5kQ2hpbGQodGhpcy5fYm9yZGVyLmVsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiZm9ybVwiKSFcblxuICAgIGZvciAobGV0IGV2ZW50IG9mIFsgXCJkcmFnXCIsIFwiZHJhZ3N0YXJ0XCIsIFwiZHJhZ2VuZFwiLCBcImRyYWdvdmVyXCIsIFwiZHJhZ2VudGVyXCIsIFwiZHJhZ2xlYXZlXCIsIFwiZHJvcFwiIF0pIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlcilcbiAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5fcHJldmVudEV2ZW50c0hhbmRsZXIpXG4gICAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlcilcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5fZHJhZ0VudGVySGFuZGxlcilcbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsIHRoaXMuX2RyYWdFbnRlckhhbmRsZXIpXG5cbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIHRoaXMuX2RyYWdMZWF2ZUhhbmRsZXIpXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgdGhpcy5fZHJhZ0xlYXZlSGFuZGxlcilcbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLl9kcmFnTGVhdmVIYW5kbGVyKVxuXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5fZHJvcEhhbmRsZXIpXG4gICAgdGhpcy5fZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5fZmlsZUNoYW5nZWRIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9wcmV2ZW50RHJhZ0V2ZW50cyhlOiBFdmVudCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVEcmFnRW50ZXIoKSB7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlXG4gICAgdGhpcy5fYnV0dG9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwicG9pbnRlci1ldmVudHM6IG5vbmU7XCIpXG5cbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgICB0aGlzLl9ib3JkZXIuYWRkQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVEcmFnTGVhdmUoKSB7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLl9idXR0b24uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICAgIHRoaXMuX2JvcmRlci5yZW1vdmVDbGFzcyhDTEFTU19BQ1RJVkUpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZURyb3AoZTogRXZlbnQpIHtcbiAgICBjb25zdCBkcmFnRXZlbnQgPSBlIGFzIERyYWdFdmVudFxuICAgICh0aGlzLl9maWxlSW5wdXQgYXMgYW55KS5maWxlcyA9IGRyYWdFdmVudC5kYXRhVHJhbnNmZXIhLmZpbGVzXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUZpbGVDaGFuZ2VkKCkge1xuICAgIGxldCBmaWxlcyA9IHRoaXMuX2ZpbGVJbnB1dC5maWxlc1xuXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfSEFTRklMRVMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfSEFTRklMRVMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmaWxlcy5cbiAgICovXG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZUlucHV0LmZpbGVzXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuZW1wdHktc3RhdGVcIiwgKGUpID0+IHtcbiAgICBuZXcgRW1wdHlTdGF0ZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbXB0eVN0YXRlXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyBlbXB0eSwgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBoYXNDbGFzcyB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuXG5jb25zdCBRVUVSWV9EUk9QRE9XTiA9IFwiLmpzLWF1dG9jb21wbGV0ZVwiXG5jb25zdCBDTEFTU19SRVNVTFQgPSBcImF1dG9jb21wbGV0ZV9fcmVzdWx0XCJcbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfSE9WRVIgPSBcImpzLWhvdmVyXCJcbmNvbnN0IEFUVFJJQlVURV9WQUxVRSA9IFwiZGF0YS12YWx1ZVwiXG5cbmNvbnN0IFRJTUVPVVRfQkxVUiA9IDQwMFxuXG5leHBvcnQgaW50ZXJmYWNlIFNvdXJjZSB7XG4gIChcbiAgICB0ZXJtOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IChtYXRjaGVzOiBzdHJpbmdbXSwgdGVybXVzZWQ6IHN0cmluZykgPT4gdm9pZFxuICApOiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlQ29uZmlnIHtcbiAgbWluQ2hhcnM6IG51bWJlclxuICBzb3VyY2U6IFNvdXJjZVxufVxuXG4vKipcbiAqIEF1dG9jb21wbGV0ZSBjb21wb25lbnRcbiAqIEBmaXJlcyBBdXRvY29tcGxldGUjY2hhbmdlXG4gKi9cbmNsYXNzIEF1dG9jb21wbGV0ZSBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfc291cmNlITogU291cmNlXG4gIHByaXZhdGUgX21pbkNoYXJzITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnRcbiAgcHJpdmF0ZSBfc3VnZ2VzdGlvbkxpc3QhOiBIVE1MVUxpc3RFbGVtZW50XG4gIHByaXZhdGUgX2Ryb3Bkb3duOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX2NsaWNrSGFuZGxlcjogKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleVVwSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleURvd25IYW5kbGVyOiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYmx1ckhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgY29uZmlndXJhdGlvbj86IEF1dG9jb21wbGV0ZUNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9pbnB1dCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikhXG4gICAgdGhpcy5fZHJvcGRvd24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9EUk9QRE9XTikhIGFzIEhUTUxFbGVtZW50XG5cbiAgICAvLyBTZXR1cCBldmVudCBjb250ZXh0XG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlVcEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlVcC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5RG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlEb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKVxuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHRoaXMuX21pbkNoYXJzID0gY29uZmlndXJhdGlvbi5taW5DaGFyc1xuICAgICAgdGhpcy5fc291cmNlID0gY29uZmlndXJhdGlvbi5zb3VyY2VcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21pbkNoYXJzIHx8IHRoaXMuX21pbkNoYXJzIDwgMCkge1xuICAgICAgdGhpcy5fbWluQ2hhcnMgPSAyXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEF1dG9jb21wbGV0ZSBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fY2xlYXJTdWdnZXN0aW9ucygpXG5cbiAgICBpZiAodGhpcy5faW5wdXQuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIGJyb3dzZXIgYXV0b2ZpbGxcbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAY2FsbGJhY2sgQXV0b2NvbXBsZXRlflN1Z2dlc3RcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHRlcm0gLSBUaGUgY3VycmVudCBzZWFyY2ggdGVybS5cbiAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gbWF0Y2hlcyAtIFRoZSBsaXN0IG9mIG1hdGNoaW5nIHN0cmluZ3MuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAY2FsbGJhY2sgQXV0b2NvbXBsZXRlflNvdXJjZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdGVybSAtIFRoZSBjdXJyZW50IHNlYXJjaCB0ZXJtLlxuICAgKiBAcHJvcGVydHkge0F1dG9jb21wbGV0ZX5TdWdnZXN0fSBzdWdnZXN0IC0gVGhlIGF1dG9jb21wbGV0ZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZXBvcnQgdGhlIHJlc3VsdHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBBdXRvY29tcGxldGV+Q29uZmlnXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5DaGFycyAtIFRoZSBtaW5pbWFsIHJlcXVpcmVkIGNoYXJhY3RlcnMgdG8gc3RhcnQgcXVlcnlpbmcgZm9yIGF1dG9jb21wbGV0ZSBtYXRjaGVzLlxuICAgKiBAcHJvcGVydHkge0F1dG9jb21wbGV0ZX5Tb3VyY2V9IHNvdXJjZSAtIFRoZSBhdXRvY29tcGxldGUgc291cmNlIGZ1bmN0aW9uLlxuICAgKi9cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0F1dG9jb21wbGV0ZX5Db25maWd9IGNvbmZpZ3VyYXRpb24gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgY29uZmlndXJlKGNvbmZpZ3VyYXRpb24/OiBBdXRvY29tcGxldGVDb25maWcpIHtcbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb25maWd1cmF0aW9uLm1pbkNoYXJzKSB7XG4gICAgICB0aGlzLl9taW5DaGFycyA9IE1hdGgubWluKGNvbmZpZ3VyYXRpb24ubWluQ2hhcnMsIDEpXG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24uc291cmNlKSB7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBjb25maWd1cmF0aW9uLnNvdXJjZVxuICAgIH1cblxuICAgIHRoaXMuX2NsZWFyU3VnZ2VzdGlvbnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBlbmFibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuXG4gICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuX2tleVVwSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlEb3duSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QgY29udHJvbCB0byB0aGUgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZGlzYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcInRydWVcIilcblxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9rZXlVcEhhbmRsZXIpXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5RG93bkhhbmRsZXIpXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBmcmVlcyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fa2V5VXBIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX2tleURvd25IYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9ibHVySGFuZGxlciA9IHVuZGVmaW5lZDtcblxuICAgICh0aGlzIGFzIGFueSkuX2lucHV0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzdWdnZXN0aW9ucyBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyBvcGVuKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX09QRU4pXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIHN1Z2dlc3Rpb25zIGRyb3Bkb3duLlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkLlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIGlmICghdGhpcy5faXNEcm9wZG93blRhcmdldChldmVudC50YXJnZXQgYXMgTm9kZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBjdXJyZW50ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG4gICAgd2hpbGUgKGN1cnJlbnQubm9kZU5hbWUgIT09IFwiTElcIiAmJiBjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudC5ub2RlTmFtZSA9PT0gXCJMSVwiKSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICAgIHRoaXMuX3NlbGVjdEl0ZW0oY3VycmVudClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUJsdXIoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9LCBUSU1FT1VUX0JMVVIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleVVwKGV2dDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZ0LndoaWNoIHx8IGV2dC5rZXlDb2RlXG5cbiAgICBpZiAoSW5wdXRzLmNvbnRhaW5zS2V5KGtleWNvZGUsIFsgSW5wdXRzLktFWV9BUlJPV19VUCwgSW5wdXRzLktFWV9BUlJPV19ET1dOLCBJbnB1dHMuS0VZX0VOVEVSLCBJbnB1dHMuS0VZX1RBQiBdKSkge1xuICAgICAgLy8gRG8gbm90IGhhbmRsZSB0aGVzZSBldmVudHMgb24ga2V5dXBcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGV2dC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnRcblxuICAgIGlmIChldnQuY3VycmVudFRhcmdldCAmJiB0YXJnZXQudmFsdWUgJiYgdGFyZ2V0LnZhbHVlLmxlbmd0aCA+PSB0aGlzLl9taW5DaGFycykge1xuICAgICAgdGhpcy5fZ2V0U3VnZ2VzdGlvbih0YXJnZXQudmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5RG93bihldnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQga2V5Y29kZSA9IGV2dC53aGljaCB8fCBldnQua2V5Q29kZVxuICAgIGNvbnN0IGlzT3BlbiA9IGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSAmJiBpc09wZW4gPT09IHRydWUpIHtcbiAgICAgIC8vIGhhbmRsZSBFc2NhcGUga2V5IChFU0MpXG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc09wZW4gPT09IHRydWUgJiYgSW5wdXRzLmNvbnRhaW5zS2V5KGtleWNvZGUsIFsgSW5wdXRzLktFWV9FTlRFUiwgSW5wdXRzLktFWV9UQUIgXSkpIHtcbiAgICAgIGxldCBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX0hPVkVSfWApXG5cbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dClcbiAgICAgIHRoaXMuX3NlbGVjdEl0ZW0oZm9jdXNlZEVsZW1lbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNPcGVuID09PSB0cnVlICYmIElucHV0cy5jb250YWluc0tleShrZXljb2RlLCBbIElucHV0cy5LRVlfQVJST1dfVVAsIElucHV0cy5LRVlfQVJST1dfRE9XTiBdKSkge1xuICAgICAgLy8gVXAgYW5kIGRvd24gYXJyb3dzXG5cbiAgICAgIGxldCBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX0hPVkVSfWApIVxuICAgICAgaWYgKGZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGZvY3VzZWRFbGVtZW50LCBDTEFTU19IT1ZFUilcblxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX3N1Z2dlc3Rpb25MaXN0LmNoaWxkTm9kZXMpIGFzIEVsZW1lbnRbXVxuXG4gICAgICAgIGNvbnN0IHRvdGFsTm9kZXMgPSBjaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfVVAgPyAtMSA6IDFcblxuICAgICAgICBsZXQgaW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGZvY3VzZWRFbGVtZW50KVxuXG4gICAgICAgIGluZGV4ID0gTWF0aC5tYXgoTWF0aC5taW4oaW5kZXggKyBkaXJlY3Rpb24sIHRvdGFsTm9kZXMpLCAwKVxuICAgICAgICBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LmNoaWxkTm9kZXNbaW5kZXhdIGFzIEVsZW1lbnRcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9zdWdnZXN0aW9uTGlzdC5xdWVyeVNlbGVjdG9yKFwibGlcIikgYXMgRWxlbWVudFxuICAgICAgfVxuXG4gICAgICBhZGRDbGFzcyhmb2N1c2VkRWxlbWVudCwgQ0xBU1NfSE9WRVIpXG4gICAgICBwcmV2ZW50RGVmYXVsdChldnQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzRHJvcGRvd25UYXJnZXQoZXZlbnQudGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2VsZWN0SXRlbShpdGVtPzogRWxlbWVudCB8IG51bGwpIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSBpdGVtLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfVkFMVUUpXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdGV4dFxuXG4gICAgICAvLyBEaXNwYXRjaCB0aGUgY2hhbmdlZCBldmVudFxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpXG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzRHJvcGRvd25UYXJnZXQodGFyZ2V0OiBOb2RlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXRcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gdGhpcy5fZHJvcGRvd24gJiYgY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQgPT09IHRoaXMuX2Ryb3Bkb3duXG4gIH1cblxuICBwcm90ZWN0ZWQgX2NsZWFyU3VnZ2VzdGlvbnMoKSB7XG4gICAgLy8gQ2xlYXIgdGhlIGRyb3Bkb3duIGl0ZW1cbiAgICBlbXB0eSh0aGlzLl9kcm9wZG93bilcblxuICAgIHRoaXMuX3N1Z2dlc3Rpb25MaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpXG4gICAgdGhpcy5fZHJvcGRvd24uYXBwZW5kQ2hpbGQodGhpcy5fc3VnZ2VzdGlvbkxpc3QpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZFN1Z2dlc3Rpb24odGV4dDogc3RyaW5nLCB0ZXJtOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWRUZXJtID0gdGVybS5yZXBsYWNlKC9bLVxcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpXG4gICAgY29uc3QgaHRtbCA9IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKGAoJHtzYW5pdGl6ZWRUZXJtfSlgLCBcImdpXCIpLCBcIjxzdHJvbmc+JDE8L3N0cm9uZz5cIilcblxuICAgIGNvbnN0IHRleHRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAuc2V0SHRtbChodG1sKVxuXG4gICAgY29uc3QgaW5uZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19SRVNVTFQpXG4gICAgICAuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQpXG5cbiAgICBjb25zdCBsaUVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImxpXCIpXG4gICAgICAuc2V0QXR0cmlidXRlKEFUVFJJQlVURV9WQUxVRSwgdGV4dClcbiAgICAgIC5hcHBlbmRDaGlsZChpbm5lckVsZW1lbnQpXG5cbiAgICB0aGlzLl9zdWdnZXN0aW9uTGlzdC5hcHBlbmRDaGlsZChsaUVsZW1lbnQuZWxlbWVudClcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0U3VnZ2VzdGlvbih0ZXJtOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuX3NvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNvdXJjZSBmdW5jdGlvbiBpcyB1bmRlZmluZWQsIGNhbm5vdCBsb2FkIHN1Z2dlc3Rpb25zXCIpXG4gICAgfVxuXG4gICAgdGhpcy5fc291cmNlKHRlcm0sIChtYXRjaGVzLCB0ZXJtdXNlZCkgPT4ge1xuICAgICAgdGhpcy5fb25NYXRjaGVzUmVjZWl2ZWQobWF0Y2hlcywgdGVybXVzZWQpXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfb25NYXRjaGVzUmVjZWl2ZWQobWF0Y2hlczogc3RyaW5nW10sIHRlcm06IHN0cmluZykge1xuICAgIHRoaXMuX2NsZWFyU3VnZ2VzdGlvbnMoKVxuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xlYXIgdGhlIGRyb3Bkb3duIGl0ZW1cbiAgICAgIGVtcHR5KHRoaXMuX3N1Z2dlc3Rpb25MaXN0KVxuXG4gICAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuX2FkZFN1Z2dlc3Rpb24obWF0Y2gsIHRlcm0pXG4gICAgICB9XG5cbiAgICAgIHRoaXMub3BlbigpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hhbmdlIGV2ZW50XG4gKlxuICogQGV2ZW50IEF1dG9jb21wbGV0ZSNjaGFuZ2VcbiAqIEB0eXBlIHtvYmplY3R9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTEVsZW1lbnQ+KFwiLmlucHV0LWZpZWxkLS1hdXRvY29tcGxldGVcIiwgKGUpID0+IHtcbiAgICBuZXcgQXV0b2NvbXBsZXRlKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dG9jb21wbGV0ZVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcmVtb3ZlIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCBmbGF0cGlja3IgZnJvbSBcImZsYXRwaWNrclwiXG5cbmltcG9ydCB7IEl0YWxpYW4gfSBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvbDEwbi9pdC5qc1wiXG5pbXBvcnQgeyBGcmVuY2ggfSBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvbDEwbi9mci5qc1wiXG5pbXBvcnQgeyBHZXJtYW4gfSBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvbDEwbi9kZS5qc1wiXG5cbmZsYXRwaWNrci5sb2NhbGl6ZShJdGFsaWFuKVxuZmxhdHBpY2tyLmxvY2FsaXplKEZyZW5jaClcbmZsYXRwaWNrci5sb2NhbGl6ZShHZXJtYW4pXG5cbmNvbnN0IERFRkFVTFRTX0ZMQVRQSUNLUiA9IHtcbiAgd3JhcDogdHJ1ZSwgLy8gZW5hYmxlIGNhbGVuZGFyIHRvZ2dsZSBpY29uXG4gIGFsbG93SW5wdXQ6IHRydWUsIC8vIGRvbid0IHNldCBpbnB1dCB0byByZWFkb25seVxuICBsb2NhbGU6IFwiZGVcIiwgLy8gR2VybWFuIGlzIGRlZmF1bHRcbiAgZGF0ZUZvcm1hdDogXCJkLm0uWVwiLCAvLyAxNS4wMS4yMDE3XG4gIHRpbWVfMjRocjogdHJ1ZVxufVxuXG5jb25zdCBDTEFTU19IQVNfVkFMVUUgPSBcImlzLWZpeGVkXCJcbmNvbnN0IENMQVNTX01FU1NBR0UgPSBcIi5tZXNzYWdlXCJcblxuLyoqXG4gKiBJbnB1dCBmaWVsZCBjb21wb25lbnRcbiAqL1xuY2xhc3MgSW5wdXRGaWVsZCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTElucHV0RWxlbWVudD4ge1xuICBwcml2YXRlIF9jaGFuZ2VkSGFuZGxlcjogKCkgPT4gdm9pZFxuICBwcml2YXRlIF9hbmltYXRpb25TdGFydEhhbmRsZXI6IChlOiBBbmltYXRpb25FdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9mbGF0cGlja3JJbnN0YW5jZTogYW55XG4gIHByaXZhdGUgX2RhdGVQaWNrZXJPcHRpb25zOiBhbnlcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50LCBkYXRlUGlja2VyT3B0aW9ucz86IGFueSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9jaGFuZ2VkSGFuZGxlciA9IHRoaXMub25WYWx1ZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2FuaW1hdGlvblN0YXJ0SGFuZGxlciA9IHRoaXMuX29uQW5pbWF0aW9uU3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2RhdGVQaWNrZXJPcHRpb25zID0gZGF0ZVBpY2tlck9wdGlvbnNcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW5wdXQgZmllbGQgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5fY2hhbmdlZEhhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCB0aGlzLl9hbmltYXRpb25TdGFydEhhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZURhdGVQaWNrZXIoKVxuICAgIHRoaXMub25WYWx1ZUNoYW5nZWQoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplRGF0ZVBpY2tlcigpIHtcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudFxuICAgIGlmICghcGlja2VyIHx8ICFwaWNrZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyXCIpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kYXRlUGlja2VyT3B0aW9ucykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlck9wdGlvbnMgPSBKU09OLnBhcnNlKHBpY2tlci5kYXRhc2V0Lm9wdGlvbnMgfHwgXCJ7fVwiKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLl9kYXRlUGlja2VyT3B0aW9ucyA9IHt9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihcIl9pbml0aWFsaXplRGF0ZVBpY2tlciBKU09OLnBhcnNlIGZhaWxlZFwiLCBwaWNrZXIuZGF0YXNldC5vcHRpb25zLCBlKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9mbGF0cGlja3JJbnN0YW5jZSA9IGZsYXRwaWNrcihwaWNrZXIsIE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRTX0ZMQVRQSUNLUiwgdGhpcy5fZGF0ZVBpY2tlck9wdGlvbnMpKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9kZXN0cm95RGF0ZVBpY2tlcigpIHtcbiAgICBpZiAodGhpcy5fZmxhdHBpY2tySW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX2ZsYXRwaWNrckluc3RhbmNlLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb25BbmltYXRpb25TdGFydChlOiBBbmltYXRpb25FdmVudCkge1xuICAgIGlmIChlLmFuaW1hdGlvbk5hbWUgPT09IFwib25BdXRvRmlsbFN0YXJ0XCIpIHtcbiAgICAgIHRoaXMub25WYWx1ZUNoYW5nZWQodHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGlucHV0IGZpZWxkIGNvbXBvbmVudCB0aGF0IGl0J3MgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICovXG4gIHB1YmxpYyBvblZhbHVlQ2hhbmdlZChmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC52YWx1ZSAmJiB0aGlzLmVsZW1lbnQudmFsdWUgIT09IFwiXCIgfHwgZm9yY2UgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfSEFTX1ZBTFVFKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX0hBU19WQUxVRSlcbiAgICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IFwiXCJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgZnJlZXMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuX2NoYW5nZWRIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc3RhcnRcIiwgdGhpcy5fYW5pbWF0aW9uU3RhcnRIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX2NoYW5nZWRIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX2FuaW1hdGlvblN0YXJ0SGFuZGxlciA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5fZGVzdHJveURhdGVQaWNrZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXlzIHRoZSBzcGVjaWZpZWQgZXJyb3IgdGV4dCB1bmRlcm5lYXRoIHRoZSBpbnB1dCBmaWVsZC5cbiAgICogQHBhcmFtIHt0ZXh0fSB0ZXh0IFRoZSBlcnJvciB0ZXh0L2h0bWwgdG8gZGlzcGxheTsgb3IgdW5kZWZpbmVkIHRvIGhpZGUgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBwdWJsaWMgc2hvd0Vycm9yKHRleHQ6IHN0cmluZykge1xuICAgIGxldCBtZXNzYWdlXG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBsZXQgbXNnID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcihDTEFTU19NRVNTQUdFKVxuXG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBuZXcgRG9tRWxlbWVudChtc2cpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0IHx8IHRleHQgPT09IFwiXCIpIHtcbiAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIHJlbW92ZShtZXNzYWdlLmVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoXCJpbnZhbGlkXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmFkZENsYXNzKFwiaW52YWxpZFwiKVxuXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKFwibWVzc2FnZVwiKVxuXG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCEuYXBwZW5kQ2hpbGQobWVzc2FnZS5lbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmVtcHR5KClcbiAgICB9XG5cbiAgICBjb25zdCBpY29uID0gbmV3IERvbUVsZW1lbnQoXCJpXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uLTAyNi1leGNsYW1hdGlvbi1tYXJrLWNpcmNsZVwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKVxuXG4gICAgY29uc3QgbXNnID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAuc2V0SHRtbCh0ZXh0KVxuXG4gICAgbWVzc2FnZS5hcHBlbmRDaGlsZChpY29uKVxuICAgIG1lc3NhZ2UuYXBwZW5kQ2hpbGQobXNnKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxJbnB1dEVsZW1lbnQ+KFwiLmlucHV0LWZpZWxkIGlucHV0XCIsIChlKSA9PiB7XG4gICAgbmV3IElucHV0RmllbGQoZSlcbiAgfSwgKGUpID0+IGUucGFyZW50RWxlbWVudCEpXG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0RmllbGRcbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5cbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIGNsYW1wLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IE1BUkdJTl9USUNLID0gMzJcbmNvbnN0IENMQVNTX0hUTUw1ID0gXCJodG1sNVwiXG5jb25zdCBSQU5HRV9MSUdIVCA9IFwicmFuZ2UtLWxpZ2h0XCJcblxuY29uc3QgQ0xBU1NfQ09OVEFJTkVSID0gXCJyYW5nZS1jb250YWluZXJcIlxuY29uc3QgQ0xBU1NfU0xJREVSID0gXCJyYW5nZS1zbGlkZXJcIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJyYW5nZS0tYWN0aXZlXCJcblxuY29uc3QgQ0xBU1NfVFJBQ0sgPSBcInJhbmdlLXRyYWNrXCJcbmNvbnN0IENMQVNTX1RSQUNLX1BST0dSRVNTID0gXCJyYW5nZS10cmFja19fcHJvZ3Jlc3NcIlxuXG5jb25zdCBDTEFTU19USUNLID0gXCJyYW5nZS10aWNrXCJcbmNvbnN0IENMQVNTX1RJQ0tfTEFCRUwgPSBcInJhbmdlLXRpY2tfX2xhYmVsXCJcbmNvbnN0IENMQVNTX1RJQ0tfQUNUSVZFID0gXCJyYW5nZS10aWNrLS1hY3RpdmVcIlxuXG5jb25zdCBDTEFTU19USFVNQiA9IFwicmFuZ2UtdGh1bWJcIlxuY29uc3QgQ0xBU1NfVEhVTUJfVkFMVUUgPSBcInJhbmdlLXRodW1iX192YWx1ZVwiXG5jb25zdCBDTEFTU19ESVNBQkxFRCA9IFwicmFuZ2UtLWRpc2FibGVkXCJcblxuY29uc3QgQ0xBU1NfRFJBR0dJTkcgPSBcInJhbmdlLS1kcmFnZ2luZ1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0dGVyIHtcbiAgKHZhbHVlOiBudW1iZXIsIHNob3J0OiBib29sZWFuKTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uIHtcbiAgdmFsdWU6IG51bWJlclxuICBsYWJlbDogc3RyaW5nIHwgbnVtYmVyXG59XG5cbi8qKlxuICogVGhlIHJhbmdlIHNsaWRlciBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgUmFuZ2UgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxJbnB1dEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfZG93bkhhbmRsZXI6IChlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9tb3ZlSGFuZGxlcjogKGU6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2VuZEhhbmRsZXI6IChlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9rZXlkb3duSGFuZGxlcjogKGU6IEtleWJvYXJkRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZm9jdXNIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYmx1ckhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9yZXNpemVIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF93cmFwcGVyRWxlbWVudCE6IERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+XG4gIHByaXZhdGUgX3JhbmdlQ29udGFpbmVyITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfcmFuZ2VUcmFjayE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX3JhbmdlUHJvZ3Jlc3MhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuICBwcml2YXRlIF90aWNrc1dyYXBwZXIhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuICBwcml2YXRlIF9yYW5nZVRodW1iITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfdGh1bWJWYWx1ZSE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX291dHB1dExhYmVsPzogRG9tRWxlbWVudDxFbGVtZW50PlxuXG4gIHByaXZhdGUgX21pblZhbHVlITogbnVtYmVyXG4gIHByaXZhdGUgX21heFZhbHVlITogbnVtYmVyXG4gIHByaXZhdGUgX3RyYWNrVmFsdWVUb3RhbCE6IG51bWJlclxuXG4gIHByaXZhdGUgX2dyYWJQb3NpdGlvbiE6IG51bWJlclxuICBwcml2YXRlIF90cmFja1dpZHRoITogbnVtYmVyXG4gIHByaXZhdGUgX3RyYWNrUG9zaXRpb25NaW4hOiBudW1iZXJcbiAgcHJpdmF0ZSBfdHJhY2tQb3NpdGlvbk1heCE6IG51bWJlclxuICBwcml2YXRlIF90cmFja0xlZnRQb3NpdGlvbiE6IG51bWJlclxuICBwcml2YXRlIF9pdGVtV2lkdGghOiBudW1iZXJcblxuICBwcml2YXRlIF9mb3JtYXR0ZXIhOiBGb3JtYXR0ZXJcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIC8vIFNldHVwIGV2ZW50IGNvbnRleHRcbiAgICB0aGlzLl9kb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZURvd24uYmluZCh0aGlzKVxuICAgIHRoaXMuX21vdmVIYW5kbGVyID0gdGhpcy5faGFuZGxlTW92ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZW5kSGFuZGxlciA9IHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2ZvY3VzSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKVxuICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgPSB0aGlzLmxheW91dC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHJhbmdlIHNsaWRlciBjb21wb25lbnQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGluc3BlY3RzIHRoZSBzZWxlY3QgZGVmaW5pdGlvbiBhbmQgaXRzIG9wdGlvbnMgYW5kXG4gICAqIGdlbmVyYXRlcyBuZXcgc3R5bGFibGUgRE9NIGVsZW1lbnRzIGFyb3VuZCB0aGUgb3JpZ2luYWwgcmFuZ2UgaW5wdXQtZWxlbWVudFxuICAgKiBkZWZpbml0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcblxuICAgIGlmICh0aGlzLmhhc0NsYXNzKENMQVNTX0hUTUw1KSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHVzZXMgSFRNTDUgc3R5bGluZywgZG8gbm90IHRvdWNoIGl0Li4uXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50ISlcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQ09OVEFJTkVSKVxuXG4gICAgdGhpcy5fcmFuZ2VUcmFjayA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1RSQUNLKVxuXG4gICAgLy8gY2hlY2sgaWYgcmFuZ2UtLWxpZ2h0IHNsaWRlciB0aGVuIGFkZCBwcm9ncmVzc1xuICAgIGlmICh0aGlzLl93cmFwcGVyRWxlbWVudC5oYXNDbGFzcyhSQU5HRV9MSUdIVCkpIHtcbiAgICAgIHRoaXMuX3JhbmdlUHJvZ3Jlc3MgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RSQUNLX1BST0dSRVNTKVxuXG4gICAgICB0aGlzLl9yYW5nZVRyYWNrLmFwcGVuZENoaWxkKHRoaXMuX3JhbmdlUHJvZ3Jlc3MpXG4gICAgfVxuXG4gICAgdGhpcy5fcmFuZ2VUaHVtYiA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1RIVU1CKVxuXG4gICAgdGhpcy5fdGlja3NXcmFwcGVyID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfU0xJREVSKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VUcmFjaylcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl90aWNrc1dyYXBwZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VUaHVtYilcblxuICAgIC8vIGFkZCBjb250YWluZXIgdG8gd3JhcHBlclxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3JhbmdlQ29udGFpbmVyKVxuXG4gICAgLy8gZ2V0IG1pbiAmIG1heCBkZWZpbml0aW9uc1xuICAgIHRoaXMuX21pblZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQubWluKSB8fCAwXG4gICAgdGhpcy5fbWF4VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5tYXgpIHx8IDFcblxuICAgIC8vIGdldCB0aGUgbGFiZWwvb3V0cHV0IGZvcm1hdCBzdHJpbmdcbiAgICB0aGlzLl9mb3JtYXR0ZXIgPSAod2luZG93IGFzIGFueSlbdGhpcy5nZXRBdHRyaWJ1dGUoXCJmb3JtYXR0ZXJcIikhXVxuXG4gICAgLy8gZ2V0IHRoZSBvdXRwdXQgbGFiZWwgYW5kIG1vdmUgaXQgYmVsb3cgdGhlIGNvbnRhaW5lclxuICAgIGlmICh0aGlzLmVsZW1lbnQuaWQpIHtcbiAgICAgIHRoaXMuX291dHB1dExhYmVsID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZmluZChgb3V0cHV0W2Zvcj0nJHt0aGlzLmVsZW1lbnQuaWR9J11gKVxuICAgICAgaWYgKHRoaXMuX291dHB1dExhYmVsKSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX291dHB1dExhYmVsKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5lbGVtZW50LnN0ZXApIHtcbiAgICAgIC8vIGZpeCBpc3N1ZXMgd2l0aCBmbG9hdCBzbGlkZXJzIGlmIHRoZSBzdGVwIGlzIHVuZGVmaW5lZFxuICAgICAgdGhpcy5lbGVtZW50LnN0ZXAgPSBcImFueVwiXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KClcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhpcy5fYWRkVGlja3Mob3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19USUNLX0xBQkVMfWApLmxlbmd0aCA8PSAxKSB7XG4gICAgICB0aGlzLl90aHVtYlZhbHVlID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USFVNQl9WQUxVRSlcblxuICAgICAgdGhpcy5fcmFuZ2VUaHVtYi5hcHBlbmRDaGlsZCh0aGlzLl90aHVtYlZhbHVlKVxuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrVmFsdWVUb3RhbCA9IHRoaXMuX21heFZhbHVlIC0gdGhpcy5fbWluVmFsdWVcbiAgICB0aGlzLmxheW91dCgpXG5cbiAgICB0aGlzLl91cGRhdGVUaWNrU3RhdGUoKVxuXG4gICAgLy8gQXBwbHkgdGhlIHRhYiBpbmRleFxuICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpXG4gICAgaWYgKHRhYkluZGV4KSB7XG4gICAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCB0YWJJbmRleClcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0T3B0aW9uc0xpc3QoKSB7XG4gICAgbGV0IG9wdGlvbnM6IE9wdGlvbltdID0gW11cblxuICAgIGxldCBsaXN0SWQgPSB0aGlzLmdldEF0dHJpYnV0ZShcImxpc3RcIilcbiAgICBpZiAobGlzdElkKSB7XG4gICAgICBsZXQgZGF0YUxpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtsaXN0SWR9YClcbiAgICAgIGlmIChkYXRhTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBkYXRhTGlzdC5xdWVyeVNlbGVjdG9yQWxsKFwib3B0aW9uXCIpKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdChlbnRyeS5pbm5lclRleHQpXG4gICAgICAgICAgbGV0IGxhYmVsID0gZW50cnkuZ2V0QXR0cmlidXRlKFwibGFiZWxcIikgfHwgcGFyc2VGbG9hdCh2YWx1ZS50b0ZpeGVkKDIpKVxuXG4gICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbGFiZWxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdCB0byBlbmFibGUgc25hcHBpbmdcbiAgICBvcHRpb25zID0gb3B0aW9ucy5zb3J0KChhLCBiKSA9PiBhLnZhbHVlIC0gYi52YWx1ZSlcblxuICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX21pblZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgdGhpcy5fbWF4VmFsdWUgPSBOdW1iZXIuTUlOX1ZBTFVFXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9taW5WYWx1ZSA9IE1hdGgubWluKHRoaXMuX21pblZhbHVlLCBvcHRpb25zW2ldLnZhbHVlKVxuICAgICAgICB0aGlzLl9tYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMuX21heFZhbHVlLCBvcHRpb25zW2ldLnZhbHVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZFRpY2tzKGRhdGFJdGVtczogT3B0aW9uW10pIHtcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBkYXRhSXRlbXMpIHtcbiAgICAgIGxldCB0aWNrRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIFN0cmluZyhlbnRyeS52YWx1ZSkpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLKVxuXG4gICAgICBsZXQgdGlja0xhYmVsID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLX0xBQkVMKVxuICAgICAgICAuc2V0SHRtbChTdHJpbmcoZW50cnkubGFiZWwpKVxuXG4gICAgICB0aWNrRWxlbWVudC5hcHBlbmRDaGlsZCh0aWNrTGFiZWwpXG4gICAgICB0aGlzLl90aWNrc1dyYXBwZXIuYXBwZW5kQ2hpbGQodGlja0VsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pc0V2ZW50T25MYWJlbChldmVudDogRXZlbnQpIHtcbiAgICByZXR1cm4gKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfVElDS19MQUJFTClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRG93bihldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hZGRDbGFzcyhDTEFTU19EUkFHR0lORylcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fZW5kSGFuZGxlcilcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmVIYW5kbGVyKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fbW92ZUhhbmRsZXIpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG5cbiAgICAvLyBJZ25vcmUgY2xpY2tzIGRpcmVjdGx5IG9uIHRoZSB0aHVtYlxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3JhbmdlVGh1bWIuZWxlbWVudCAmJiAhdGhpcy5faXNFdmVudE9uTGFiZWwoZXZlbnQpKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5fZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudClcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvcywgdHJ1ZSwgZmFsc2UsIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlTW92ZShldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB0aGlzLl91bmZvY3VzKClcblxuICAgIGlmICghdGhpcy5faXNFdmVudE9uTGFiZWwoZXZlbnQpKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5fZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudClcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvcywgdHJ1ZSwgZmFsc2UsIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRW5kKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0RSQUdHSU5HKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fZW5kSGFuZGxlcilcblxuICAgIGxldCBwb3MgPSB0aGlzLl9nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50KVxuICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvcywgdHJ1ZSwgdHJ1ZSwgdHJ1ZSlcbiAgICB0aGlzLl9oYW5kbGVCbHVyKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRVNDQVBFKSB7XG4gICAgICAvLyBoYW5kbGUgRXNjYXBlIGtleSAoRVNDKVxuICAgICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5ibHVyKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlzVXAgPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfUklHSFRcbiAgICAgIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfUEFHRV9VUFxuXG4gICAgY29uc3QgaXNEb3duID0ga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19ET1dOIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfTEVGVFxuICAgICAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9QQUdFX0RPV05cblxuICAgIGlmIChpc1VwIHx8IGlzRG93bikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgICBsZXQgZGlyZWN0aW9uID0gaXNEb3duID8gLTEgOiAxXG5cbiAgICAgIC8vIG1ha2UgYSBsYXJnZXIgc3RlcCBpZiBpdHMgdGhlIHZlcnRpY2FsIGFycm93IG9yIHBhZ2Uga2V5c1xuICAgICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfVVAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19ET1dOIHx8XG4gICAgICAgIGtleWNvZGUgPT09IElucHV0cy5LRVlfUEFHRV9VUCB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX1BBR0VfRE9XTikge1xuICAgICAgICBkaXJlY3Rpb24gKj0gMTBcbiAgICAgIH1cblxuICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWVcbiAgICAgIGlmICh0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsID0gdGhpcy5fZ2V0TmV4dFZhbHVlKHZhbCwgZGlyZWN0aW9uKVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBsZXQgc3RlcDogc3RyaW5nIHwgbnVtYmVyID0gdGhpcy5lbGVtZW50LnN0ZXBcbiAgICAgICAgaWYgKCFzdGVwIHx8IHN0ZXAgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICBzdGVwID0gXCIwLjFcIlxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdWYWwgPSB2YWwgKyAocGFyc2VGbG9hdChzdGVwKSAqIGRpcmVjdGlvbilcbiAgICAgICAgdmFsID0gbmV3VmFsXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFZhbHVlKHZhbCwgdHJ1ZSwgdHJ1ZSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRm9jdXMoKSB7XG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuYWRkQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVCbHVyKCkge1xuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLnJlbW92ZUNsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5mb2N1cygpIHtcbiAgICBpZiAoKGRvY3VtZW50IGFzIGFueSkuc2VsZWN0aW9uKSB7XG4gICAgICAoZG9jdW1lbnQgYXMgYW55KS5zZWxlY3Rpb24uZW1wdHkoKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkhLnJlbW92ZUFsbFJhbmdlcygpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkge1xuICAgIGxldCBwYWdlWFxuICAgIGlmIChcInBhZ2VYXCIgaW4gZXZlbnQpIHtcbiAgICAgIHBhZ2VYID0gZXZlbnQucGFnZVhcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZVggPSAoZXZlbnQudG91Y2hlc1swXSB8fCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSkucGFnZVhcbiAgICB9XG5cbiAgICByZXR1cm4gcGFnZVggLSB0aGlzLl90cmFja0xlZnRQb3NpdGlvbiArIHRoaXMuX2dyYWJQb3NpdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhbmQgdXBkYXRlcyB0aGUgcG9zaXRpb24gYW5kIHNldHMgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb24gdGhlIHNsaWRlci5cbiAgICogQHBhcmFtIHtwb3NpdGlvbn0gdGhlIG5ldyBwb3NpdGlvbiB0byBzZXQuXG4gICAqIEBwYXJhbSB7dXBkYXRlVmFsdWV9IHRydWUgaWYgdGhlIHZhbHVlIHNob3VsZCBiZSB1cGRhdGVkIGFzIHdlbGw7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHBhcmFtIHtzbmFwfSB0cnVlIGlmIHNuYXBwaW5nIHNob3VsZCBiZSB1c2VkOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwYXJhbSB7YW5pbWF0ZX0gdHJ1ZSBpZiB0aGUgVUkgdXBkYXRlIHNob3VsZCBiZSBhbmltYXRlZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZXRQb3NpdGlvbihcbiAgICBwb3NpdGlvbjogbnVtYmVyLFxuICAgIHVwZGF0ZVZhbHVlID0gdHJ1ZSxcbiAgICBzbmFwID0gZmFsc2UsXG4gICAgYW5pbWF0ZSA9IHRydWVcbiAgKSB7XG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBvc2l0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zaXRpb24gaXMgbm90IGEgbnVtYmVyXCIpXG4gICAgfVxuXG4gICAgLy8gQ2xhbXAgdG8gbWluIGFuZCBtYXggcmFuZ2VcbiAgICBsZXQgbmV3UG9zID0gY2xhbXAocG9zaXRpb24sIHRoaXMuX3RyYWNrUG9zaXRpb25NaW4sIHRoaXMuX3RyYWNrUG9zaXRpb25NYXgpXG4gICAgaWYgKHVwZGF0ZVZhbHVlKSB7XG4gICAgICBsZXQgdmFsdWUgPSAodGhpcy5fdHJhY2tWYWx1ZVRvdGFsIC8gdGhpcy5fdHJhY2tXaWR0aCkgKiBuZXdQb3MgKyB0aGlzLl9taW5WYWx1ZVxuXG4gICAgICBpZiAodGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxICYmIHNuYXApIHtcbiAgICAgICAgbGV0IHNuYXBQb3MgPSB0aGlzLl9nZXRTbmFwUG9zaXRpb24obmV3UG9zKVxuICAgICAgICBuZXdQb3MgPSBzbmFwUG9zLnBvc2l0aW9uXG4gICAgICAgIHZhbHVlID0gc25hcFBvcy52YWx1ZVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuc3RlcCAmJiB0aGlzLmVsZW1lbnQuc3RlcCAhPT0gXCJhbnlcIikge1xuICAgICAgICBjb25zdCBzdGVwID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQuc3RlcClcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gc3RlcCkgKiBzdGVwXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFZhbHVlKHZhbHVlLCBmYWxzZSwgZmFsc2UpXG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGUgJiYgdXBkYXRlVmFsdWUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpY2tTdGF0ZSgpXG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgIGFuaW1lKHtcbiAgICAgICAgdGFyZ2V0czogdGhpcy5fcmFuZ2VUaHVtYi5lbGVtZW50LFxuICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICBsZWZ0OiBuZXdQb3MsXG4gICAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiXG4gICAgICB9KVxuXG4gICAgICBpZiAodGhpcy5fcmFuZ2VQcm9ncmVzcykge1xuICAgICAgICBhbmltZSh7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy5fcmFuZ2VQcm9ncmVzcy5lbGVtZW50LFxuICAgICAgICAgIGR1cmF0aW9uOiAyMDAsXG4gICAgICAgICAgd2lkdGg6IG5ld1BvcyxcbiAgICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIlxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQuc3R5bGUubGVmdCA9IG5ld1BvcyArIFwicHhcIlxuXG4gICAgICBpZiAodGhpcy5fcmFuZ2VQcm9ncmVzcykge1xuICAgICAgICB0aGlzLl9yYW5nZVByb2dyZXNzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBuZXdQb3MgKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc25hcCB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHt2YWx1ZX0gdGhlIHRhcmdldCB2YWx1ZS5cbiAgICogQHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNuYXAgcG9zaXRpb24gYW5kIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9nZXRTbmFwVmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGRyZW5cbiAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpXSlcbiAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikhKVxuICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IGN1cnJlbnRFbGVtZW50LmVsZW1lbnQuY2xpZW50V2lkdGhcblxuICAgICAgbGV0IG5leHRFbGVtZW50XG4gICAgICBsZXQgbmV4dFZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRVxuXG4gICAgICBpZiAoaSA8IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV4dEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpICsgMV0pXG4gICAgICAgIG5leHRWYWx1ZSA9IHBhcnNlRmxvYXQobmV4dEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSEpXG4gICAgICB9XG5cbiAgICAgIC8vIGxlZnQgbW9zdCBlbGVtZW50XG4gICAgICBpZiAoaSA9PT0gMCAmJiB2YWx1ZSA8PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBNQVJHSU5fVElDSyAtIHRoaXMuX2dyYWJQb3NpdGlvblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJpZ2h0IG1vc3QgZWxlbWVudFxuICAgICAgaWYgKCFuZXh0RWxlbWVudCAmJiB2YWx1ZSA+PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50UG9zaXRpb24gKyAoY3VycmVudFdpZHRoIC0gTUFSR0lOX1RJQ0spIC0gdGhpcy5fZ3JhYlBvc2l0aW9uIC0gMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA+PSBjdXJyZW50VmFsdWUgJiYgdmFsdWUgPCBuZXh0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50UG9zaXRpb24gKyAoMC41ICogY3VycmVudFdpZHRoKSAtIHRoaXMuX2dyYWJQb3NpdGlvblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSBjdXJyZW50V2lkdGhcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHNuYXAgdmFsdWVcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzbmFwIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge3Bvc2l0aW9ufSB0aGUgdGFyZ2V0IHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc25hcCBwb3NpdGlvbiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2dldFNuYXBQb3NpdGlvbihwb3NpdGlvbj86IG51bWJlciB8IG51bGwpIHtcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocG9zaXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3NpdGlvbiBpcyBub3QgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkcmVuXG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcblxuICAgICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaV0pXG4gICAgICBsZXQgY3VycmVudFZhbHVlID0gcGFyc2VGbG9hdChjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcbiAgICAgIGxldCBjdXJyZW50V2lkdGggPSBjdXJyZW50RWxlbWVudC5lbGVtZW50LmNsaWVudFdpZHRoXG5cbiAgICAgIGxldCBuZXh0RWxlbWVudFxuXG4gICAgICBpZiAoaSA8IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV4dEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpICsgMV0pXG4gICAgICB9XG5cbiAgICAgIC8vIGxlZnQgbW9zdCBlbGVtZW50XG4gICAgICBpZiAoaSA9PT0gMCAmJiBwb3NpdGlvbiA8PSBjdXJyZW50UG9zaXRpb24gKyBjdXJyZW50V2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBNQVJHSU5fVElDSyAtIHRoaXMuX2dyYWJQb3NpdGlvblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJpZ2h0IG1vc3QgZWxlbWVudFxuICAgICAgaWYgKCFuZXh0RWxlbWVudCAmJiBwb3NpdGlvbiA+PSBjdXJyZW50UG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50UG9zaXRpb24gKyAoY3VycmVudFdpZHRoIC0gTUFSR0lOX1RJQ0spIC0gdGhpcy5fZ3JhYlBvc2l0aW9uIC0gMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA+PSBjdXJyZW50UG9zaXRpb24gJiYgcG9zaXRpb24gPCAoY3VycmVudFBvc2l0aW9uICsgY3VycmVudFdpZHRoKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IGN1cnJlbnRQb3NpdGlvbiArICgwLjUgKiBjdXJyZW50V2lkdGgpIC0gdGhpcy5fZ3JhYlBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudFBvc2l0aW9uICs9IGN1cnJlbnRXaWR0aFxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgc25hcCBwb3NpdGlvblwiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5leHQgdmFsdWUgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiB3aXRoIHJlZ2FyZHMgdG8gc25hcHBpbmcuXG4gICAqIEBwYXJhbSB7dmFsdWV9IFRoZSBjdXJyZW50IHZhbHVlLlxuICAgKiBAcGFyYW0ge2RpcmVjdGlvbn0gVGhlIGRpcmVjdGlvbiAocG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlcikuXG4gICAqIEByZXR1cm5zIFRoZSBuZXh0IHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9nZXROZXh0VmFsdWUodmFsdWU6IG51bWJlciwgZGlyZWN0aW9uOiBudW1iZXIpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkcmVuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRpY2tzW2ldKVxuICAgICAgbGV0IGN1cnJlbnRWYWwgPSBwYXJzZUZsb2F0KGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikhKVxuXG4gICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnRWYWwpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gY2xhbXAoaSArIGRpcmVjdGlvbiwgMCwgdGlja3MubGVuZ3RoIC0gMSlcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRpY2tzW2luZGV4XS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlVGlja1N0YXRlKCkge1xuICAgIGlmICh0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBhY3RpdmVUaWNrID0gdGhpcy5fdGlja3NXcmFwcGVyLmZpbmQoYC4ke0NMQVNTX1RJQ0tfQUNUSVZFfWApXG4gICAgICBpZiAoYWN0aXZlVGljaykge1xuICAgICAgICBhY3RpdmVUaWNrLnJlbW92ZUNsYXNzKENMQVNTX1RJQ0tfQUNUSVZFKVxuICAgICAgfVxuICAgICAgbGV0IG5ld0FjdGl2ZVRpY2sgPSB0aGlzLl90aWNrc1dyYXBwZXIuZmluZChgLiR7Q0xBU1NfVElDS31bZGF0YS12YWx1ZT0nJHt0aGlzLnZhbHVlfSddYClcbiAgICAgIGlmIChuZXdBY3RpdmVUaWNrKSB7XG4gICAgICAgIG5ld0FjdGl2ZVRpY2suYWRkQ2xhc3MoQ0xBU1NfVElDS19BQ1RJVkUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGp1c3RUaWNrTGFiZWxQb3NpdGlvbihcbiAgICB0aWNrSXRlbTogRWxlbWVudCxcbiAgICBsZWZ0OiBib29sZWFuXG4gICkge1xuICAgIGNvbnN0IGxhYmVsID0gbmV3IERvbUVsZW1lbnQodGlja0l0ZW0ucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfVElDS19MQUJFTH1gKSEpXG5cbiAgICBsZXQgZHVtbXlFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfVElDS19MQUJFTClcbiAgICAgIC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInZpc2liaWxpdHk6IGhpZGRlbjsgZGlzcGxheTogaW5saW5lLWJsb2NrO1wiKVxuICAgICAgLnNldEh0bWwobGFiZWwuaW5uZXJUZXh0KVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoZHVtbXlFbGVtZW50KVxuXG4gICAgbGV0IHdpZHRoID0gZHVtbXlFbGVtZW50LmVsZW1lbnQuY2xpZW50V2lkdGggLyAyXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIucmVtb3ZlQ2hpbGQoZHVtbXlFbGVtZW50KVxuXG4gICAgY29uc3QgZmxvYXRQb3NpdGlvbiA9IGxlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIlxuXG4gICAgaWYgKHdpZHRoIDwgTUFSR0lOX1RJQ0spIHtcbiAgICAgIC8vIGNlbnRlciBzbWFsbCBpdGVtcyBvbiB0aGUgdGlja1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYCR7ZmxvYXRQb3NpdGlvbn06ICR7TUFSR0lOX1RJQ0sgLSBNYXRoLmZsb29yKHdpZHRoKX1weDsgdGV4dC1hbGlnbjogJHtmbG9hdFBvc2l0aW9ufTtgKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfZm9ybWF0T3V0cHV0KHZhbHVlOiBudW1iZXIsIHNob3J0OiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX2Zvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlcih2YWx1ZSwgc2hvcnQpXG4gICAgfVxuXG4gICAgY29uc3Qgc3RyID0gcGFyc2VGbG9hdCh2YWx1ZS50b0ZpeGVkKDIpKVxuICAgIHJldHVybiBzdHIudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhbmQgdXBkYXRlcyB0aGUgcmFuZ2UgdmFsdWUuXG4gICAqIEBwYXJhbSB7dmFsdWV9IHRoZSBuZXcgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3VwZGF0ZX0gdHJ1ZSBpZiB0aGUgVUkgc2hvdWxkIGJlIHVwZGF0ZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHBhcmFtIHthbmltYXRlfSB0cnVlIGlmIHRoZSBVSSB1cGRhdGUgc2hvdWxkIGJlIGFuaW1hdGVkOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NldFZhbHVlKFxuICAgIHZhbHVlOiBudW1iZXIsXG4gICAgdXBkYXRlID0gdHJ1ZSxcbiAgICBhbmltYXRlID0gZmFsc2VcbiAgKSB7XG4gICAgbGV0IHZhbCA9IGNsYW1wKHZhbHVlLCB0aGlzLl9taW5WYWx1ZSwgdGhpcy5fbWF4VmFsdWUpXG4gICAgbGV0IHBvc2l0aW9uXG5cbiAgICBpZiAodGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBzbmFwVmFsdWUgPSB0aGlzLl9nZXRTbmFwVmFsdWUodmFsKVxuICAgICAgcG9zaXRpb24gPSBzbmFwVmFsdWUucG9zaXRpb25cbiAgICAgIHZhbCA9IHNuYXBWYWx1ZS52YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbiA9ICh0aGlzLl90cmFja1dpZHRoIC8gdGhpcy5fdHJhY2tWYWx1ZVRvdGFsKSAqICh2YWx1ZSAtIHRoaXMuX21pblZhbHVlKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBjYWxjdWxhdGlvbiBmYWlsZWQsIGZhbGwgYmFjayB0byB0aGUgZmlyc3QgdGljayBwb3NpdGlvbiBhbmQgZGlzYWJsZSB0aGUgY29tcG9uZW50XG4gICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgcG9zaXRpb24gPSB0aGlzLl9nZXRTbmFwUG9zaXRpb24odmFsKS5wb3NpdGlvblxuICAgICAgdGhpcy5kaXNhYmxlKClcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBTdHJpbmcodmFsKVxuXG4gICAgaWYgKHRoaXMuX3RodW1iVmFsdWUpIHtcbiAgICAgIHRoaXMuX3RodW1iVmFsdWUuc2V0SHRtbCh0aGlzLl9mb3JtYXRPdXRwdXQodmFsLCB0cnVlKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3V0cHV0TGFiZWwpIHtcbiAgICAgIHRoaXMuX291dHB1dExhYmVsLnNldEh0bWwodGhpcy5fZm9ybWF0T3V0cHV0KHZhbCwgZmFsc2UpKVxuICAgIH1cblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvc2l0aW9uLCBmYWxzZSwgZmFsc2UsIGFuaW1hdGUpXG4gICAgICB0aGlzLl91cGRhdGVUaWNrU3RhdGUoKVxuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImlucHV0XCIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHJhbmdlIHNsaWRlci5cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fc2V0VmFsdWUodmFsdWUsIHRydWUsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQudmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdGhlIGNvbXBvbmVudCB0byByZS1sYXlvdXQgaXRzZWxmLlxuICAgKi9cbiAgcHVibGljIGxheW91dCgpIHtcbiAgICB0aGlzLl9ncmFiUG9zaXRpb24gPSBNYXRoLnJvdW5kKHRoaXMuX3JhbmdlVGh1bWIuZWxlbWVudC5vZmZzZXRXaWR0aCAvIDIpXG4gICAgY29uc3QgdGlja0l0ZW1zID0gdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19USUNLfWApXG4gICAgY29uc3QgdGlja3NPZmZzZXQgPSB0aWNrSXRlbXMgJiYgdGlja0l0ZW1zLmxlbmd0aCA+IDAgPyAoMiAqIE1BUkdJTl9USUNLKSA6IE1BUkdJTl9USUNLXG5cbiAgICB0aGlzLl90cmFja1dpZHRoID0gdGhpcy5fcmFuZ2VUcmFjay5lbGVtZW50Lm9mZnNldFdpZHRoIC0gdGlja3NPZmZzZXRcblxuICAgIHRoaXMuX3RyYWNrUG9zaXRpb25NaW4gPSAwXG4gICAgdGhpcy5fdHJhY2tQb3NpdGlvbk1heCA9IHRoaXMuX3JhbmdlVHJhY2suZWxlbWVudC5jbGllbnRXaWR0aCAtIHRoaXMuX3JhbmdlVGh1bWIuZWxlbWVudC5vZmZzZXRXaWR0aCArIDFcbiAgICB0aGlzLl90cmFja0xlZnRQb3NpdGlvbiA9IHRoaXMuX3JhbmdlVHJhY2suZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgTUFSR0lOX1RJQ0tcblxuICAgIGxldCBpdGVtQ291bnQgPSB0aWNrSXRlbXMubGVuZ3RoIC0gMVxuXG4gICAgdGhpcy5faXRlbVdpZHRoID0gdGhpcy5fdHJhY2tXaWR0aCAvIGl0ZW1Db3VudFxuICAgIGNvbnN0IG91dGVySXRlbXNXaWR0aCA9ICh0aGlzLl9pdGVtV2lkdGggKiAwLjUpICsgTUFSR0lOX1RJQ0tcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGl0ZW1Db3VudDsgaSsrKSB7XG4gICAgICBsZXQgd2lkdGggPSB0aGlzLl9pdGVtV2lkdGhcblxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gaXRlbUNvdW50KSB7XG4gICAgICAgIHdpZHRoID0gb3V0ZXJJdGVtc1dpZHRoXG4gICAgICB9XG5cbiAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQodGlja0l0ZW1zW2ldKVxuICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgd2lkdGg6ICR7TWF0aC5mbG9vcih3aWR0aCl9cHg7YClcbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgZmlyc3QgYW5kIGxhc3QgbGFiZWwgcG9zaXRpb25zXG4gICAgaWYgKHRpY2tJdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9hZGp1c3RUaWNrTGFiZWxQb3NpdGlvbih0aWNrSXRlbXNbMF0sIHRydWUpXG4gICAgICB0aGlzLl9hZGp1c3RUaWNrTGFiZWxQb3NpdGlvbih0aWNrSXRlbXNbdGlja0l0ZW1zLmxlbmd0aCAtIDFdLCBmYWxzZSlcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIHZhbHVlXG4gICAgdGhpcy5fc2V0VmFsdWUocGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQudmFsdWUpLCB0cnVlLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50cyBhbmQgZnJlZXMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcik7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9kb3duSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbW92ZUhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2VuZEhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2ZvY3VzSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYmx1ckhhbmRsZXIgPSBudWxsO1xuXG4gICAgKHRoaXMgYXMgYW55KS5lbGVtZW50ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9yYW5nZUNvbnRhaW5lciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fd3JhcHBlckVsZW1lbnQgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGRlc3Ryb3koKSBpbnN0ZWFkLlxuICAgKiBAdG9kbyByZW1vdmUgaW4gdmVyc2lvbiAyLjAuMFxuICAgKi9cbiAgcHVibGljIGRlc3RveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbXBvbmVudCB0byB0aGUgZW5hYmxlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBlbmFibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9kb3duSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbXBvbmVudCB0byB0aGUgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hZGRDbGFzcyhDTEFTU19ESVNBQkxFRClcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9kb3duSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmVIYW5kbGVyKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9kb3duSGFuZGxlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxJbnB1dEVsZW1lbnQ+KFwiaW5wdXRbdHlwZT0ncmFuZ2UnXVwiLCAoZSkgPT4ge1xuICAgIG5ldyBSYW5nZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBSYW5nZVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQsIGZpbmQsIHJlbW92ZSwgaW50ZXJuZXRFeHBsb3Jlck9yRWRnZVZlcnNpb24sIHNjcm9sbEludG9WaWV3IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi4vSW5wdXRzXCJcbmltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgQ0xBU1NfUExBQ0VIT0xERVIgPSBcInNlbGVjdF9fcGxhY2Vob2xkZXJcIlxuY29uc3QgQ0xBU1NfVEhVTUIgPSBcInNlbGVjdF9fdGh1bWJcIlxuY29uc3QgQ0xBU1NfQlVUVE9OID0gXCJzZWxlY3RfX2J1dHRvblwiXG5jb25zdCBDTEFTU19EUk9QRE9XTiA9IFwic2VsZWN0X19kcm9wZG93blwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcInNlbGVjdC0tb3BlblwiXG5jb25zdCBDTEFTU19DTE9TRUQgPSBcInNlbGVjdC0tY2xvc2VkXCJcbmNvbnN0IENMQVNTX0RJU0FCTEVEID0gXCJzZWxlY3QtLWRpc2FibGVkXCJcbmNvbnN0IENMQVNTX0ZJTFRFUkFCTEUgPSBcInNlbGVjdC0tZmlsdGVyYWJsZVwiXG5cbmNvbnN0IENMQVNTX0lURU0gPSBcImRyb3Bkb3duLWl0ZW1cIlxuY29uc3QgQ0xBU1NfSVRFTV9TRUxFQ1RFRCA9IFwiZHJvcGRvd24taXRlbS0tc2VsZWN0ZWRcIlxuY29uc3QgQ0xBU1NfSVRFTV9GT0NVU0VEID0gXCJkcm9wZG93bi1pdGVtLS1mb2N1c2VkXCJcbmNvbnN0IENMQVNTX0lURU1fRElTQUJMRUQgPSBcImRyb3Bkb3duLWl0ZW0tLWRpc2FibGVkXCJcblxuY29uc3QgQ0xBU1NfR1JPVVBfSVRFTSA9IFwiZHJvcGRvd24tZ3JvdXBcIlxuY29uc3QgQ0xBU1NfR1JPVVBfSEVBREVSID0gXCJkcm9wZG93bi1ncm91cF9faXRlbVwiXG5cbmNvbnN0IFFVRVJZX01FU1NBR0UgPSBcIi5tZXNzYWdlXCJcblxuY29uc3QgVElNRU9VVF9DTE9TRSA9IDE1MFxuY29uc3QgVElNRU9VVF9CTFVSID0gNDAwXG5cbi8qKlxuICogVGhlIHNlbGVjdCBjb21wb25lbnQgQVBJLlxuICovXG5jbGFzcyBTZWxlY3QgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxTZWxlY3RFbGVtZW50PiB7XG4gIHByaXZhdGUgX29wZW5CeUZvY3VzOiBib29sZWFuXG4gIHByaXZhdGUgX211bHRpc2VsZWN0aW9uOiBib29sZWFuXG4gIHByaXZhdGUgX2NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2hhbmRsZURyb3Bkb3duQ2xpY2s6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9rZXlkb3duSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2ZvY3VzSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2JsdXJIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyOiAoZTogTW91c2VFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9maWx0ZXJLZXlkb3duSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2ZpbHRlcktleXVwSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2ZpbHRlckZvY3VzSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfd3JhcHBlckVsZW1lbnQhOiBEb21FbGVtZW50XG4gIHByaXZhdGUgX2Ryb3Bkb3duRWxlbWVudCE6IERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+XG5cbiAgcHJpdmF0ZSBfc2VsZWN0QnV0dG9uRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSBfdGh1bWJFbGVtZW50ITogRG9tRWxlbWVudFxuXG4gIHByaXZhdGUgX3BsYWNlaG9sZGVyT3B0aW9uPzogSFRNTE9wdGlvbkVsZW1lbnRcbiAgcHJpdmF0ZSBfcGxhY2Vob2xkZXJFbGVtZW50ITogRG9tRWxlbWVudFxuICBwcml2YXRlIF9wbGFjZWhvbGRlclRleHQhOiBzdHJpbmdcblxuICBwcml2YXRlIF9sYXN0SGFuZGxlZEV2ZW50PzogRXZlbnRcbiAgcHJpdmF0ZSBfbGFzdFNlbGVjdGVkT3B0aW9uPzogSFRNTE9wdGlvbkVsZW1lbnRcblxuICAvLyBNaW5pbXVtIGZpbHRlciBsZW5ndGhcbiAgcHJpdmF0ZSBfbWluRmlsdGVyTGVuZ3RoID0gMlxuXG4gIC8vIFRoZSBrZXl3b3JkIHRoZSBTZWxlY3QgaXMgY3VycmVudGx5IGZpbHRlcmVkIGJ5XG4gIHByaXZhdGUgX2FjdGl2ZUZpbHRlcj86IHN0cmluZ1xuXG4gIC8vIFRoZSBvcHRpb25zIHRoZSBTZWxlY3Qgd2FzIGluaXRpYWxseSBjcmVhdGVkIHVwb25cbiAgLy8gVGhlc2Ugd2lsbCBiZSB1c2VkIGFzIGEgYmFzaXMgZm9yIGZpbHRlcmluZ1xuICBwcml2YXRlIF9pbml0aWFsT3B0aW9ucyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuZWxlbWVudC5jaGlsZHJlbilcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MU2VsZWN0RWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9vcGVuQnlGb2N1cyA9IGZhbHNlXG5cbiAgICAvLyBDaGVjayBmb3IgbXVsdGktc2VsZWN0aW9uXG4gICAgdGhpcy5fbXVsdGlzZWxlY3Rpb24gPSB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikgPT09IHRydWVcblxuICAgIC8vIFNldHVwIGV2ZW50IGNvbnRleHRcbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5faGFuZGxlRHJvcGRvd25DbGljayA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKVxuICAgIHRoaXMuX2ZvY3VzSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9maWx0ZXJLZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZpbHRlcktleWRvd24uYmluZCh0aGlzKVxuICAgIHRoaXMuX2ZpbHRlcktleXVwSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZpbHRlcktleXVwLmJpbmQodGhpcylcbiAgICB0aGlzLl9maWx0ZXJGb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVGaWx0ZXJGb2N1cy5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgc2VsZWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaW5zcGVjdHMgdGhlIHNlbGVjdCBkZWZpbml0aW9uIGFuZCBpdHMgb3B0aW9ucyBhbmRcbiAgICogZ2VuZXJhdGVzIG5ldyBzdHlsYWJsZSBET00gZWxlbWVudHMgYXJvdW5kIHRoZSBvcmlnaW5hbCBzZWxlY3QtZWxlbWVudFxuICAgKiBkZWZpbml0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBzZWxlY3RlZE9wdGlvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwib3B0aW9uW3NlbGVjdGVkXVwiKSBhcyBIVE1MT3B0aW9uRWxlbWVudFxuICAgIGNvbnN0IGZpcnN0T3B0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25cIikgYXMgSFRNTE9wdGlvbkVsZW1lbnRcblxuICAgIC8vIFBlciBkZWZhdWx0LCBzZXQgdGhlIGxhc3Qgc2VsZWN0ZWQgb3B0aW9uIHRvIGVpdGhlciB0aGUgb3B0aW9uIHdpdGggYSBcInNlbGVjdGVkXCIgYXR0cmlidXRlLFxuICAgIC8vIG9yLCBpZiBub3QgZm91bmQsIHRvIHRoZSBmaXJzdCBhdmFpbGFibGUgb3B0aW9uXG4gICAgdGhpcy5fbGFzdFNlbGVjdGVkT3B0aW9uID0gc2VsZWN0ZWRPcHRpb24gfHwgZmlyc3RPcHRpb25cblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQhKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0NMT1NFRClcblxuICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFkZENsYXNzKGNscylcbiAgICB9XG5cbiAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudDxIVE1MRWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19EUk9QRE9XTilcblxuICAgIGlmIChpbnRlcm5ldEV4cGxvcmVyT3JFZGdlVmVyc2lvbigpID4gMCAmJiBpbnRlcm5ldEV4cGxvcmVyT3JFZGdlVmVyc2lvbigpIDwgMTIpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBJRSBicm93c2VycyAxMSBhbmQgZWFybGllciB3aGVyZSBmb2N1c2luZ1xuICAgICAgLy8gYSBzY3JvbGxhYmxlIGRyb3Bkb3duIGxpc3Qgd2lsbCBjbG9zZSB0aGUgZHJvcGRvd24gcHJlbWF0dXJlbHkuXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChldmVudDogTW91c2VFdmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSlcbiAgICB9XG5cbiAgICB0aGlzLl9zZXR1cFRhcmdldCgpXG4gICAgdGhpcy5fc2V0dXBQbGFjZWhvbGRlcigpXG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9kcm9wZG93bkVsZW1lbnQpXG5cbiAgICB0aGlzLl9jcmVhdGVPcHRpb25zKHRoaXMuZWxlbWVudClcblxuICAgIHRoaXMuX3VwZGF0ZVNpemUoKVxuICAgIHRoaXMuX3VwZGF0ZU1lc3NhZ2UoKVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGUoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0dXBUYXJnZXQoKSB7XG4gICAgLy8gbW92ZSB0aGUgaWQgZnJvbSB0aGUgc2VsZWN0IGVsZW1lbnQgdG8gdGhlIHdyYXBwZXJcbiAgICBjb25zdCBpZCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpZFwiKVxuICAgIGlmIChpZCkge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZClcbiAgICB9XG5cbiAgICAvLyBBcHBseSB0aGUgdGFiIGluZGV4XG4gICAgY29uc3QgdGFiSW5kZXggPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIilcbiAgICBpZiAodGFiSW5kZXgpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIHRhYkluZGV4KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0dXBQbGFjZWhvbGRlcigpIHtcbiAgICBpZiAoIXRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQlVUVE9OKVxuXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGh1bWJFbGVtZW50KSB7XG4gICAgICB0aGlzLl90aHVtYkVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVEhVTUIpXG5cbiAgICAgIGxldCB0aHVtYkljb24gPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoXCJ0aHVtYi1pY29uXCIpXG5cbiAgICAgIGxldCBsb2FkZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoXCJsb2FkZXItc3Bpbm5lclwiKVxuICAgICAgICAuYWRkQ2xhc3MoXCJsb2FkZXItc3Bpbm5lci0tc21hbGxcIilcblxuICAgICAgdGhpcy5fdGh1bWJFbGVtZW50LmFwcGVuZENoaWxkKGxvYWRlcilcbiAgICAgIHRoaXMuX3RodW1iRWxlbWVudC5hcHBlbmRDaGlsZCh0aHVtYkljb24pXG4gICAgICB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3RodW1iRWxlbWVudClcbiAgICB9XG5cbiAgICBsZXQgcGxhY2Vob2xkZXJUZXh0ID0gXCJcIlxuXG4gICAgdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIm9wdGlvbltzZWxlY3RlZF1bZGlzYWJsZWRdXCIpIGFzIEhUTUxPcHRpb25FbGVtZW50IHx8IHVuZGVmaW5lZFxuXG4gICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uKSB7XG4gICAgICBwbGFjZWhvbGRlclRleHQgPSBEb20udGV4dCh0aGlzLl9wbGFjZWhvbGRlck9wdGlvbilcblxuICAgICAgaWYgKHRoaXMuX211bHRpc2VsZWN0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uLnNlbGVjdGVkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc2VsZWN0ZWRPcHRpb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIm9wdGlvbltzZWxlY3RlZF06bm90KFtkaXNhYmxlZF0pXCIpXG5cbiAgICBpZiAoc2VsZWN0ZWRPcHRpb24pIHtcbiAgICAgIHBsYWNlaG9sZGVyVGV4dCA9IERvbS50ZXh0KHNlbGVjdGVkT3B0aW9uKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50KSB7XG4gICAgICAvLyBXaGVuIHRoZSBTZWxlY3QgaXMgZmlsdGVyYWJsZSwgY3JlYXRlIGFuIFwiaW5wdXRcIiBhcyB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudCwgb3RoZXJ3aXNlIGEgXCJzcGFuXCJcbiAgICAgIGlmICh0aGlzLl9pc0ZpbHRlcmFibGUoKSkge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImlucHV0XCIpXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKGUpID0+IHRoaXMuX2hhbmRsZUZpbHRlcktleXVwKGUpKVxuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHRoaXMuX2hhbmRsZUZpbHRlcktleWRvd24oZSkpXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKGUpID0+IHRoaXMuX2hhbmRsZUZpbHRlckZvY3VzKGUpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5hZGRDbGFzcyhDTEFTU19QTEFDRUhPTERFUilcbiAgICAgIHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX3NldFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyVGV4dClcbiAgICB0aGlzLl9wbGFjZWhvbGRlclRleHQgPSBwbGFjZWhvbGRlclRleHRcblxuICAgIGlmIChzZWxlY3RlZE9wdGlvbiAmJiBzZWxlY3RlZE9wdGlvbiAhPT0gdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24pIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBsYWNlaG9sZGVyKHRydWUpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGVNZXNzYWdlKCkge1xuICAgIGNvbnN0IG1lc3NhZ2VOb2RlID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX01FU1NBR0UpXG4gICAgaWYgKG1lc3NhZ2VOb2RlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChuZXcgRG9tRWxlbWVudChtZXNzYWdlTm9kZSkpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNPcHRHcm91cChlbGVtZW50OiBFbGVtZW50KTogZWxlbWVudCBpcyBIVE1MT3B0R3JvdXBFbGVtZW50IHtcbiAgICByZXR1cm4gZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiT1BUR1JPVVBcIlxuICB9XG5cbiAgcHJpdmF0ZSBfaXNPcHRpb24oZWxlbWVudDogRWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTE9wdGlvbkVsZW1lbnQge1xuICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJPUFRJT05cIlxuICB9XG5cbiAgcHJvdGVjdGVkIF9jcmVhdGVPcHRpb25zKGVsZW1lbnQ6IEhUTUxTZWxlY3RFbGVtZW50KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hpbGQgPSBlbGVtZW50LmNoaWxkcmVuW2ldXG5cbiAgICAgIGlmICh0aGlzLl9pc09wdEdyb3VwKGNoaWxkKSkge1xuICAgICAgICB0aGlzLl9hcHBlbmRHcm91cChjaGlsZCBhcyBIVE1MT3B0R3JvdXBFbGVtZW50KVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNPcHRpb24oY2hpbGQpKSB7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLl9jcmVhdGVPcHRpb24oY2hpbGQgYXMgSFRNTE9wdGlvbkVsZW1lbnQpXG5cbiAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5hcHBlbmRDaGlsZChvcHRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NyZWF0ZU9wdGlvbihvcHRpb246IEhUTUxPcHRpb25FbGVtZW50KSB7XG4gICAgbGV0IGh0bWwgPSBvcHRpb24uaW5uZXJIVE1MXG5cbiAgICBpZiAodGhpcy5fYWN0aXZlRmlsdGVyKSB7XG4gICAgICBjb25zdCBzYW5pdGl6ZWRBY3RpdmVGaWx0ZXIgPSB0aGlzLl9hY3RpdmVGaWx0ZXIucmVwbGFjZSgvWy1cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKVxuICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZShuZXcgUmVnRXhwKGAoJHtzYW5pdGl6ZWRBY3RpdmVGaWx0ZXJ9KWAsIFwiZ2lcIiksIFwiPHN0cm9uZz4kMTwvc3Ryb25nPlwiKVxuICAgIH1cblxuICAgIGxldCBvcHQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0lURU0pXG4gICAgICAuc2V0SHRtbChodG1sKVxuXG4gICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgb3B0LmFkZENsYXNzKENMQVNTX0lURU1fU0VMRUNURUQpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi5kaXNhYmxlZCkge1xuICAgICAgb3B0LmFkZENsYXNzKENMQVNTX0lURU1fRElTQUJMRUQpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9pc1BsYWNlaG9sZGVyKG9wdGlvbikpIHtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIG9wdGlvbi52YWx1ZSlcbiAgICAgIHJldHVybiBvcHRcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBwcm90ZWN0ZWQgX2FwcGVuZEdyb3VwKG9wdGdyb3VwOiBIVE1MT3B0R3JvdXBFbGVtZW50KSB7XG4gICAgbGV0IGxhYmVsID0gb3B0Z3JvdXAuZ2V0QXR0cmlidXRlKFwibGFiZWxcIikhXG5cbiAgICBsZXQgZ3JvdXAgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0dST1VQX0lURU0pXG5cbiAgICBsZXQgZ3JvdXBIZWFkZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0dST1VQX0hFQURFUilcbiAgICAgIC5zZXRIdG1sKGxhYmVsKVxuXG4gICAgZ3JvdXAuYXBwZW5kQ2hpbGQoZ3JvdXBIZWFkZXIpXG5cbiAgICBsZXQgb3B0aW9ucyA9IG9wdGdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoXCJvcHRpb25cIilcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBvcHRpb25zKSB7XG4gICAgICBsZXQgb3B0aW9uID0gdGhpcy5fY3JlYXRlT3B0aW9uKGVudHJ5KVxuICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICBncm91cC5hcHBlbmRDaGlsZChvcHRpb24pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmFwcGVuZENoaWxkKGdyb3VwKVxuICAgIHJldHVybiBncm91cFxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGVTaXplKCkge1xuICAgIC8vIE5vdGU6IE1pcnJvcmluZyB0aGUgRE9NIGFuZCBtZWFzdXJpbmcgdGhlIGl0ZW1zIHVzaW5nIHRoZWlyIGNsaWVudFdpZHRoIHdhcyB2ZXJ5XG4gICAgLy8gdW5yZWxpYWJsZSwgdGhlcmVmb3JlIG1lYXN1cmluZyB3YXMgc3dpdGNoZWQgdG8gdGhlIG5ldyBIVE1MNSBtZWFzdXJlVGV4dCBtZXRob2RcbiAgICAvLyBtYXJnaW5zIGFuZCBwYWRkaW5ncyBhcnJvdW5kIHRoZSB0ZXh0IGFyZSBjb3BpZWQgZnJvbSB0aGUgb3JpZ2luYWwgcGxhY2Vob2xkZXIgaXRlbXNcbiAgICAvLyBkaW1lbnNpb25cbiAgICBjb25zdCBwbGFjZWhvbGRlclN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmVsZW1lbnQpXG5cbiAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChwbGFjZWhvbGRlclN0eWxlLnBhZGRpbmdSaWdodCEpXG4gICAgbGV0IHBhZGRpbmdMZWZ0ID0gcGFyc2VGbG9hdChwbGFjZWhvbGRlclN0eWxlLnBhZGRpbmdMZWZ0ISlcblxuICAgIGxldCBmb250ID0gdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmNzcyhcImZvbnRcIilcbiAgICBsZXQgdGV4dFdpZHRoID0gRG9tLnRleHRXaWR0aCh0aGlzLl9wbGFjZWhvbGRlclRleHQsIGZvbnQpXG4gICAgbGV0IG1heFdpZHRoID0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQgKyB0ZXh0V2lkdGhcblxuICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApXG4gICAgZm9yIChsZXQgZW50cnkgb2Ygb3B0aW9ucykge1xuICAgICAgbGV0IHdpZHRoID0gRG9tLnRleHRXaWR0aChEb20udGV4dChlbnRyeSksIGZvbnQpICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHRcblxuICAgICAgaWYgKHdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgbWF4V2lkdGggPSB3aWR0aFxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcHJvdGVjdGVkIF9pc0J1dHRvblRhcmdldCh0YXJnZXQ6IEV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuICh0YXJnZXQgPT09IHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQgfHxcbiAgICAgIHRhcmdldCA9PT0gdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmVsZW1lbnQgfHxcbiAgICAgIHRhcmdldCA9PT0gdGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudC5lbGVtZW50IHx8XG4gICAgICB0YXJnZXQgPT09IHRoaXMuX3RodW1iRWxlbWVudC5lbGVtZW50KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pc0Ryb3Bkb3duVGFyZ2V0KHRhcmdldDogRXZlbnRUYXJnZXQpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldCBhcyBIVE1MRWxlbWVudFxuICAgIHdoaWxlIChjdXJyZW50ICE9PSB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudCAmJiBjdXJyZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudCA9PT0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBVSSBpZiB0aGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkIGFuZCBtYWtlcyBzdXJlIHRoZVxuICAgKiBzZWxlY3QgY29udHJvbCBhbmQgdGhlIGdlbmVyYXRlZCBtYXJrdXAgYXJlIHN5bmNocm9uaXplZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfc2VsZWN0ZWRJdGVtQ2hhbmdlZChcbiAgICBuZXdJdGVtOiBFbGVtZW50LFxuICAgIGF1dG9DbG9zZSA9IHRydWUsXG4gICAgbXVsdGlzZWxlY3QgPSBmYWxzZVxuICApIHtcbiAgICBjb25zdCBvbGRJdGVtcyA9IHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX0lURU1fU0VMRUNURUR9YClcblxuICAgIGlmICghbmV3SXRlbSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNsb3NlKCksIFRJTUVPVVRfQ0xPU0UpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoRG9tLmhhc0NsYXNzKG5ld0l0ZW0sIENMQVNTX0lURU1fRElTQUJMRUQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoKG9sZEl0ZW1zLmxlbmd0aCA9PT0gMCkgJiYgIW5ld0l0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgc2VsZWN0IHVuZGVmaW5lZCBlbGVtZW50c1wiKVxuICAgIH1cblxuICAgIGxldCBvbGRJdGVtID0gb2xkSXRlbXNbMF1cblxuICAgIGlmIChtdWx0aXNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgb2xkSXRlbSA9IGZpbmQob2xkSXRlbXMsICh4KSA9PiB4LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikgPT09IG5ld0l0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSkhXG4gICAgfVxuXG4gICAgbGV0IGlzRGVzZWxlY3QgPSBmYWxzZVxuXG4gICAgaWYgKG5ld0l0ZW0gJiYgb2xkSXRlbSAmJiBvbGRJdGVtID09PSBuZXdJdGVtKSB7XG4gICAgICAvLyBDbGljayBvbiBhIHByZXZpb3VzbHkgc2VsZWN0ZWQgZWxlbWVudCAtPiBkZXNlbGVjdFxuICAgICAgaXNEZXNlbGVjdCA9IHRydWVcblxuICAgICAgaWYgKCF0aGlzLl9wbGFjZWhvbGRlck9wdGlvbiAmJiAhbXVsdGlzZWxlY3QpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcGxhY2Vob2xkZXIgb3B0aW9uLCBub24gbXVsdGlzZWxlY3Qgb3B0aW9ucyBjYW5ub3QgYmUgZGVzZWxlY3RlZFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvblxuICAgIH1cblxuICAgIGlmIChvbGRJdGVtKSB7XG4gICAgICAvLyBSZW1vdmUgc2VsZWN0aW9uIG9uIHRoZSBlbGVtZW50XG4gICAgICBsZXQgb2xkVmFsdWUgPSBvbGRJdGVtLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIilcbiAgICAgIGxldCBvcHRFbGVtZW50ID0gZmluZCh0aGlzLmVsZW1lbnQub3B0aW9ucywgKHgpID0+ICF4LmRpc2FibGVkICYmIHgudmFsdWUgPT09IG9sZFZhbHVlKVxuXG4gICAgICBpZiAoIW9wdEVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgb3B0aW9uIHdpdGggdmFsdWUgJHtvbGRWYWx1ZX0gZG9lcyBub3QgZXhpc3RgKVxuICAgICAgfVxuXG4gICAgICAvLyBVbnNldCBTZWxlY3QgdmFsdWVcbiAgICAgIG9wdEVsZW1lbnQuc2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgRG9tLnJlbW92ZUNsYXNzKG9sZEl0ZW0sIENMQVNTX0lURU1fU0VMRUNURUQpXG4gICAgfVxuXG4gICAgaWYgKCFpc0Rlc2VsZWN0KSB7IC8vIFNlbGVjdCBhbiBvcHRpb25cbiAgICAgIC8vIFNlbGVjdCBhIG5ldyBpdGVtXG4gICAgICBsZXQgbmV3VmFsdWUgPSBuZXdJdGVtLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIilcbiAgICAgIGxldCBvcHRFbGVtZW50ID0gZmluZCh0aGlzLmVsZW1lbnQub3B0aW9ucywgKHgpID0+ICF4LmRpc2FibGVkICYmIHgudmFsdWUgPT09IG5ld1ZhbHVlKVxuXG4gICAgICBpZiAoIW9wdEVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgb3B0aW9uIHdpdGggdmFsdWUgJHtuZXdWYWx1ZX0gZG9lcyBub3QgZXhpc3RgKVxuICAgICAgfVxuXG4gICAgICAvLyBTZXQgU2VsZWN0IHZhbHVlXG4gICAgICBvcHRFbGVtZW50LnNlbGVjdGVkID0gdHJ1ZVxuICAgICAgRG9tLmFkZENsYXNzKG5ld0l0ZW0sIENMQVNTX0lURU1fU0VMRUNURUQpXG5cbiAgICAgIC8vIFByZXNlcnZlIHNlbGVjdGlvblxuICAgICAgdGhpcy5fbGFzdFNlbGVjdGVkT3B0aW9uID0gb3B0RWxlbWVudFxuXG4gICAgfSBlbHNlIHsgLy8gRGVzZWxlY3QgYW4gb3B0aW9uXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGZhbGxpbmcgYmFjayB0byB0aGUgcGxhY2Vob2xkZXIgKGlmIGFueSlcbiAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlck9wdGlvbikge1xuICAgICAgICB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb24gPSB0aGlzLl9wbGFjZWhvbGRlck9wdGlvblxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBoYXNTZWxlY3RlZEl0ZW1zID0gdHJ1ZVxuXG4gICAgaWYgKHRoaXMuX211bHRpc2VsZWN0aW9uID09PSBmYWxzZSAmJiBpc0Rlc2VsZWN0KSB7XG4gICAgICAvLyBIYW5kbGUgbm8gc2VsZWN0aW9uIGZvciBub24tbXVsdGlzZWxlY3Qgc3RhdGVzXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbiEuc2VsZWN0ZWQgPSB0cnVlXG4gICAgICBoYXNTZWxlY3RlZEl0ZW1zID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbXVsdGlzZWxlY3Rpb24gPT09IHRydWUgJiYgdGhpcy5fZ2V0U2VsZWN0ZWRPcHRpb25zKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBoYXNTZWxlY3RlZEl0ZW1zID0gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBSZXNldCB0aGUgZmlsdGVyIGlmIGZpbHRlcmFibGVcbiAgICBpZiAodGhpcy5fYWN0aXZlRmlsdGVyKSB7XG4gICAgICB0aGlzLl9jbGVhckZpbHRlcigpXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUGxhY2Vob2xkZXIoaGFzU2VsZWN0ZWRJdGVtcylcblxuICAgIC8vIERpc3BhdGNoIHRoZSBjaGFuZ2VkIGV2ZW50XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpXG5cbiAgICBpZiAoYXV0b0Nsb3NlICYmICFtdWx0aXNlbGVjdCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfSwgVElNRU9VVF9DTE9TRSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZVBsYWNlaG9sZGVyKGhhc1NlbGVjdGVkSXRlbXM6IGJvb2xlYW4pIHtcbiAgICBsZXQgdGV4dCA9IHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uID8gRG9tLnRleHQodGhpcy5fcGxhY2Vob2xkZXJPcHRpb24pIDogXCIgXCJcblxuICAgIGlmIChoYXNTZWxlY3RlZEl0ZW1zID09PSB0cnVlKSB7XG4gICAgICBsZXQgc2VsZWN0ZWRJdGVtcyA9IHRoaXMuX2dldFNlbGVjdGVkT3B0aW9ucygpXG5cbiAgICAgIGlmIChzZWxlY3RlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGV4dCA9IFwiXCJcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBzZWxlY3RlZEl0ZW1zKSB7XG4gICAgICAgICAgdGV4dCArPSBgJHtEb20udGV4dChpdGVtKX0sIGBcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgdGV4dC5sZW5ndGggLSAyKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3NldFBsYWNlaG9sZGVyKHRleHQpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFNlbGVjdGVkT3B0aW9ucygpIHtcbiAgICBsZXQgc2VsZWN0ZWRPcHRpb25zOiBIVE1MT3B0aW9uRWxlbWVudFtdID0gW11cbiAgICBpZiAodGhpcy5lbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgIFtdLmZvckVhY2guY2FsbCh0aGlzLmVsZW1lbnQub3B0aW9ucywgKChvcHRpb246IEhUTUxPcHRpb25FbGVtZW50KSA9PiB7XG4gICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgJiYgIW9wdGlvbi5kaXNhYmxlZCkge1xuICAgICAgICAgIHNlbGVjdGVkT3B0aW9ucy5wdXNoKG9wdGlvbilcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZE9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZSBhbGwgb2YgdGhlIGluaXRpYWxseSBzZXQgb3B0aW9ucyAoYW5kIG9wdGdyb3VwcykgYW5kIHJldHVybnMgdGhlbSBpbiBhIG5ldyBhcnJheS5cbiAgICogVGhpcyBzZXJ2ZXMgYXMgdGhlIGJhc2lzIGZvciBmaWx0ZXJpbmcuIElmIGEgZmlsdGVyIGlzIHByZXNlbnQsIGl0IHdpbGwgYmUgcmVzcGVjdGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRJbml0aWFsT3B0aW9ucygpOiBFbGVtZW50W10ge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuX2FjdGl2ZUZpbHRlciB8fCBcIlwiXG4gICAgY29uc3QgZmlsdGVyZWQ6IEVsZW1lbnRbXSA9IFtdXG4gICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSB0aGlzLl9pbml0aWFsT3B0aW9uc1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0aWFsT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQ6IEVsZW1lbnQgPSBpbml0aWFsT3B0aW9uc1tpXSBhcyBFbGVtZW50XG5cbiAgICAgIGlmICh0aGlzLl9pc09wdEdyb3VwKGNoaWxkKSkgeyAvLyBoYW5kbGUgPG9wdGdyb3VwPlxuICAgICAgICBjb25zdCBvcHRHcm91cENsb25lOiBFbGVtZW50ID0gY2hpbGQuY2xvbmVOb2RlKGZhbHNlKSBhcyBFbGVtZW50XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlXG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbkNsb25lOiBFbGVtZW50ID0gY2hpbGQuY2hpbGRyZW5bal0uY2xvbmVOb2RlKHRydWUpIGFzIEVsZW1lbnRcblxuICAgICAgICAgIC8vIEFwcGVuZCBvbiBtYXRjaFxuICAgICAgICAgIGlmICh0aGlzLl9jb250YWluc1dvcmQob3B0aW9uQ2xvbmUuaW5uZXJIVE1MLCBmaWx0ZXIpKSB7XG4gICAgICAgICAgICBvcHRHcm91cENsb25lLmFwcGVuZENoaWxkKG9wdGlvbkNsb25lKVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVzaCBpZiBhbnkgbWF0Y2hlcyBmb3VuZFxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG9wdEdyb3VwQ2xvbmUpXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc09wdGlvbihjaGlsZCkpIHsgLy8gaGFuZGxlIDxvcHRpb24+XG4gICAgICAgIGNvbnN0IG9wdGlvbkNsb25lOiBFbGVtZW50ID0gY2hpbGQuY2xvbmVOb2RlKHRydWUpIGFzIEVsZW1lbnRcblxuICAgICAgICAvLyBQdXNoIG9uIG1hdGNoXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluc1dvcmQob3B0aW9uQ2xvbmUuaW5uZXJIVE1MLCBmaWx0ZXIpKSB7XG4gICAgICAgICAgZmlsdGVyZWQucHVzaChvcHRpb25DbG9uZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaWx0ZXJlZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIHRleHQgY29udGFpbnMgYSBnaXZlbiBrZXl3b3JkLCBlLmcuIGluIFwiY2FcIiBpbiBcIkNhclwiXG4gICAqL1xuICBwcml2YXRlIF9jb250YWluc1dvcmQodGV4dDogc3RyaW5nLCBrZXl3b3JkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGV4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoa2V5d29yZC50b0xvd2VyQ2FzZSgpKSA+IC0xXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMub3BlbigpXG4gICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSB0cnVlXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX29wZW5CeUZvY3VzID0gZmFsc2VcbiAgICB9LCBUSU1FT1VUX0JMVVIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUJsdXIoKSB7XG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIGxldCBoYW5kbGVkID0gZmFsc2VcblxuICAgIGlmICh0aGlzLl9sYXN0SGFuZGxlZEV2ZW50ID09PSBldmVudCkge1xuICAgICAgdGhpcy5fbGFzdEhhbmRsZWRFdmVudCA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzQnV0dG9uVGFyZ2V0KGV2ZW50LnRhcmdldCEpICYmIHRoaXMuX29wZW5CeUZvY3VzID09PSBmYWxzZSkge1xuICAgICAgLy8gaGFuZGxlIGhlYWRlciBpdGVtIGNsaWNrcyBhbmQgdG9nZ2xlIGRyb3Bkb3duXG4gICAgICB0aGlzLnRvZ2dsZSgpXG4gICAgICBoYW5kbGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBuZXdJdGVtID0gZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnRcblxuICAgIGlmICghaGFuZGxlZCAmJiBEb20uaGFzQ2xhc3MobmV3SXRlbSwgQ0xBU1NfSVRFTSkpIHtcbiAgICAgIC8vIGhhbmRsZSBjbGlja3Mgb24gZHJvcGRvd24gaXRlbXNcbiAgICAgIHRoaXMuX3NlbGVjdGVkSXRlbUNoYW5nZWQobmV3SXRlbSwgdHJ1ZSwgdGhpcy5fbXVsdGlzZWxlY3Rpb24pXG4gICAgICBoYW5kbGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICB0aGlzLl9sYXN0SGFuZGxlZEV2ZW50ID0gZXZlbnRcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNEcm9wZG93blRhcmdldChldmVudC50YXJnZXQhKSB8fCB0aGlzLl9pc0J1dHRvblRhcmdldChldmVudC50YXJnZXQhKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2ZvY3VzT3B0aW9uU3RhcnRpbmdXaXRoKGtleWNvZGU6IG51bWJlciwgc3RhcnRJbmRleDogbnVtYmVyLCBvcHRpb25zOiBOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pikge1xuICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgbGV0IGl0ZW0gPSBuZXcgRG9tRWxlbWVudChvcHRpb25zW2luZGV4XSlcbiAgICAgIGxldCB2YWx1ZSA9IGl0ZW0uaW5uZXJUZXh0LnRvTG93ZXJDYXNlKClcblxuICAgICAgaWYgKGluZGV4ID4gb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSAwXG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKElucHV0cy5nZXRLZXlWYWx1ZShrZXljb2RlKSkpIHtcbiAgICAgICAgbGV0IG5ld09wdGlvbiA9IG5ldyBEb21FbGVtZW50KG9wdGlvbnNbaW5kZXhdKVxuXG4gICAgICAgIGlmICghbmV3T3B0aW9uLmhhc0NsYXNzKENMQVNTX0lURU1fRElTQUJMRUQpKSB7XG4gICAgICAgICAgc2Nyb2xsSW50b1ZpZXcob3B0aW9uc1tpbmRleF0pXG4gICAgICAgICAgbmV3T3B0aW9uLmFkZENsYXNzKENMQVNTX0lURU1fRk9DVVNFRClcbiAgICAgICAgICByZXR1cm4gbmV3T3B0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBFdmVudCkge1xuICAgIGNvbnN0IGtleWJvYXJkRXZlbnQgPSBldmVudCBhcyBLZXlib2FyZEV2ZW50XG4gICAgbGV0IGV2dCA9IGtleWJvYXJkRXZlbnQgfHwgd2luZG93LmV2ZW50XG4gICAgbGV0IGtleWNvZGUgPSBrZXlib2FyZEV2ZW50LndoaWNoIHx8IGtleWJvYXJkRXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRVNDQVBFKSB7XG4gICAgICAvLyBoYW5kbGUgRXNjYXBlIGtleSAoRVNDKVxuICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfVVAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19ET1dOKSB7XG4gICAgICAvLyBVcCBhbmQgZG93biBhcnJvd3NcblxuICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX0lURU19YCkgYXMgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5cbiAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcblxuICAgICAgICBsZXQgbmV3SW5kZXggPSAwXG4gICAgICAgIGxldCBvbGRPcHRpb25cblxuICAgICAgICBsZXQgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5maW5kKGAuJHtDTEFTU19JVEVNX0ZPQ1VTRUR9YClcbiAgICAgICAgbGV0IHNlYXJjaEZvciA9IGZvY3VzZWRFbGVtZW50ID8gQ0xBU1NfSVRFTV9GT0NVU0VEIDogQ0xBU1NfSVRFTV9TRUxFQ1RFRFxuXG4gICAgICAgIGxldCBuZXdFbGVtZW50XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG9wdGlvbnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTiA/IDEgOiAtMVxuXG4gICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgRG9tRWxlbWVudChvcHRpb25zW2luZGV4XSlcblxuICAgICAgICAgIC8vIHNlYXJjaCBmb3Igc2VsZWN0ZWQgb3IgZm9jdXNlZEVsZW1lbnQgZWxlbWVudHNcbiAgICAgICAgICBpZiAoaXRlbS5oYXNDbGFzcyhzZWFyY2hGb3IpKSB7XG4gICAgICAgICAgICBvbGRPcHRpb24gPSBpdGVtXG4gICAgICAgICAgICBuZXdJbmRleCA9IGluZGV4XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgbmV4dCBub3QgZGlzYWJsZWQgZWxlbWVudCBpbiB0aGUgYXBwcm9wcmlhdGUgZGlyZWN0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgb3B0aW9ucy5sZW5ndGg7IGNvdW50KyspIHtcbiAgICAgICAgICAgICAgbmV3SW5kZXggKz0gZGlyZWN0aW9uXG4gICAgICAgICAgICAgIG5ld0luZGV4ICU9IG9wdGlvbnMubGVuZ3RoXG5cbiAgICAgICAgICAgICAgaWYgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gb3B0aW9ucy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tuZXdJbmRleF0pXG4gICAgICAgICAgICAgIGlmICghbmV3RWxlbWVudC5oYXNDbGFzcyhDTEFTU19JVEVNX0RJU0FCTEVEKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIG5ldyBlbGVtZW50IGZvY3VzZWRcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXcob3B0aW9uc1tuZXdJbmRleF0pXG4gICAgICAgIGxldCBuZXdPcHRpb24gPSBuZXcgRG9tRWxlbWVudChvcHRpb25zW25ld0luZGV4XSlcbiAgICAgICAgbmV3T3B0aW9uLmFkZENsYXNzKENMQVNTX0lURU1fRk9DVVNFRClcblxuICAgICAgICBpZiAob2xkT3B0aW9uKSB7XG4gICAgICAgICAgb2xkT3B0aW9uLnJlbW92ZUNsYXNzKENMQVNTX0lURU1fRk9DVVNFRClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKElucHV0cy5nZXRLZXlWYWx1ZShrZXljb2RlKSAmJiAhdGhpcy5faXNGaWx0ZXJhYmxlKCkpIHtcbiAgICAgIC8vIEtleWJvYXJkIGtleXNcblxuICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX0lURU19YCkgYXMgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5cbiAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcblxuICAgICAgICBsZXQgb2xkRm9jdXNJbmRleCA9IDBcbiAgICAgICAgbGV0IGhhc0ZvY3VzZWRPcHRpb24gPSBmYWxzZVxuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tpbmRleF0pXG5cbiAgICAgICAgICBpZiAoaXRlbS5oYXNDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpKSB7XG4gICAgICAgICAgICBpdGVtLnJlbW92ZUNsYXNzKENMQVNTX0lURU1fRk9DVVNFRClcblxuICAgICAgICAgICAgbGV0IHZhbHVlID0gaXRlbS5pbm5lclRleHQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoSW5wdXRzLmdldEtleVZhbHVlKGtleWNvZGUpKSkge1xuICAgICAgICAgICAgICBoYXNGb2N1c2VkT3B0aW9uID0gdHJ1ZVxuICAgICAgICAgICAgICBvbGRGb2N1c0luZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3T3B0aW9uID0gdGhpcy5fZm9jdXNPcHRpb25TdGFydGluZ1dpdGgoa2V5Y29kZSwgaGFzRm9jdXNlZE9wdGlvbiA/IG9sZEZvY3VzSW5kZXggKyAxIDogMCwgb3B0aW9ucylcbiAgICAgICAgaWYgKG5ld09wdGlvbiA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICB0aGlzLl9mb2N1c09wdGlvblN0YXJ0aW5nV2l0aChrZXljb2RlLCAwLCBvcHRpb25zKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FTlRFUiB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX1RBQikge1xuICAgICAgLy8gSGFuZGxlIGVudGVyIGFuZCB0YWIga2V5IGJ5IHNlbGVjdGluZyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgbGV0IG5ld0l0ZW0gPSB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU19JVEVNX0ZPQ1VTRUR9YCkhXG4gICAgICB0aGlzLl9zZWxlY3RlZEl0ZW1DaGFuZ2VkKG5ld0l0ZW0sIHRydWUsIHRoaXMuX211bHRpc2VsZWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgaW4gdGhlIGZpbHRlciBmaWVsZFxuICAgKi9cbiAgcHJpdmF0ZSBfaGFuZGxlRmlsdGVyS2V5ZG93bihlOiBFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGtleWJvYXJkRXZlbnQgPSBlIGFzIEtleWJvYXJkRXZlbnRcbiAgICBjb25zdCBrZXljb2RlID0ga2V5Ym9hcmRFdmVudC53aGljaCB8fCBrZXlib2FyZEV2ZW50LmtleUNvZGVcblxuICAgIC8vIElmIHRoZSB1c2VyIGhpdHMgdGhlIGVudGVyIGtleSB3aGlsZSBmaWx0ZXJpbmcgYW5kIHRoZXJlJ3MgYSBzaW5nbGUgbWF0Y2gsIHNlbGVjdCBpdFxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VOVEVSKSB7XG4gICAgICBjb25zdCBkcm9wZG93bkVsZW1lbnRzID0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfSVRFTX1gKVxuXG4gICAgICBpZiAoZHJvcGRvd25FbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJdGVtQ2hhbmdlZChkcm9wZG93bkVsZW1lbnRzWzBdLCB0cnVlLCB0aGlzLl9tdWx0aXNlbGVjdGlvbilcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGluIHRoZSBmaWx0ZXIgZmllbGRcbiAgICovXG4gIHByaXZhdGUgX2hhbmRsZUZpbHRlcktleXVwKGU6IEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudFxuXG4gICAgLy8gRmlsdGVyIGhhcyBjaGFuZ2VkXG4gICAgaWYgKHRhcmdldC52YWx1ZSAhPT0gdGhpcy5fYWN0aXZlRmlsdGVyICYmIHRhcmdldC52YWx1ZSAhPT0gdGhpcy5fcGxhY2Vob2xkZXJUZXh0ICYmIHRhcmdldC52YWx1ZSAhPT0gdGhpcy5fbGFzdFNlbGVjdGVkT3B0aW9uIS5pbm5lckhUTUwpIHtcbiAgICAgIHRoaXMuX3NldEZpbHRlcih0YXJnZXQudmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgZm9jdXNzZXMgdGhlIGZpbHRlciBpbnB1dCBmaWVsZFxuICAgKi9cbiAgcHJpdmF0ZSBfaGFuZGxlRmlsdGVyRm9jdXMoZTogRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRhcmdldC5zZWxlY3QoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgU2VsZWN0IGJ5IGEgZ2l2ZW4gZmlsdGVyIGtleXdvcmRcbiAgICogQHBhcmFtIGZpbHRlciBLZXl3b3JkIHRvIGZpbHRlciBieVxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0RmlsdGVyKGZpbHRlcjogc3RyaW5nID0gXCJcIik6IHZvaWQge1xuICAgIHRoaXMuX2FjdGl2ZUZpbHRlciA9IChmaWx0ZXIubGVuZ3RoID49IHRoaXMuX21pbkZpbHRlckxlbmd0aCkgPyBmaWx0ZXIgOiBcIlwiXG4gICAgdGhpcy5zZXRPcHRpb25zKHRoaXMuZ2V0SW5pdGlhbE9wdGlvbnMoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGZpbHRlclxuICAgKi9cbiAgcHJpdmF0ZSBfY2xlYXJGaWx0ZXIoKTogdm9pZCB7XG4gICAgZGVsZXRlIHRoaXMuX2FjdGl2ZUZpbHRlclxuICAgIHRoaXMuc2V0T3B0aW9ucyh0aGlzLmdldEluaXRpYWxPcHRpb25zKCkpXG4gIH1cblxuICAvKipcbiAgICogU2V0IG5ldyBjb250ZW50IGFuZCByZWxvYWQgdGhlIFNlbGVjdFxuICAgKiBAcGFyYW0gZWxlbWVudHMgQXJyYXkgb2YgbmV3IG9wdGlvbiAob3Igb3B0Z3JvdXApIGVsZW1lbnRzIHRvIGRpc3BsYXlcbiAgICovXG4gIHByaXZhdGUgc2V0T3B0aW9ucyhvcHRpb25zOiBFbGVtZW50W10pOiB2b2lkIHtcbiAgICB0aGlzLl9lbXB0eU5vZGUodGhpcy5lbGVtZW50KVxuXG4gICAgb3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChvcHRpb24pXG4gICAgfSlcblxuICAgIC8vIFByZXNlcnZlIHNlbGVjdGVkIHZhbHVlIGlmIHRoZSBzZWxlY3RlZFxuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEudmFsdWVcblxuICAgIHRoaXMucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgY2hpbGRyZW4gb2YgYSBnaXZlbiBub2RlXG4gICAqIEBwYXJhbSBub2RlIE5vZGVcbiAgICovXG4gIHByaXZhdGUgX2VtcHR5Tm9kZShub2RlOiBOb2RlKTogdm9pZCB7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBvcHRpb24gaXMgYSBwbGFjZWhvbGRlciBvcHRpb25cbiAgICovXG4gIHByaXZhdGUgX2lzUGxhY2Vob2xkZXIob3B0aW9uOiBIVE1MT3B0aW9uRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBvcHRpb24uaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgJiYgb3B0aW9uLmhhc0F0dHJpYnV0ZShcInNlbGVjdGVkXCIpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHBsYWNlaG9sZGVyIHZhbHVlXG4gICAqIEBwYXJhbSB0ZXh0IENvbnRlbnQgb2YgdGhlIHBsYWNlaG9sZGVyXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NldFBsYWNlaG9sZGVyKHRleHQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQgJiYgdGV4dCkge1xuICAgICAgaWYgKHRoaXMuX2lzRmlsdGVyYWJsZSgpKSB7XG4gICAgICAgICh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQgYXMgRG9tRWxlbWVudDxIVE1MSW5wdXRFbGVtZW50PikuZWxlbWVudC52YWx1ZSA9IHRleHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5zZXRIdG1sKHRleHQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlxuICAgKiBJZiBtdWx0aXBsZSBzZWxlY3Rpb24gaXMgZW5hYmxlZCB0aGlzIHByb3BlcnR5IHJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkT3B0aW9ucygpLm1hcCgoeCkgPT4geC52YWx1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbGVtZW50LnZhbHVlID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQudmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzZWxlY3QgY29tcG9uZW50IGRlcGVuZGluZyBvbiB0aGVcbiAgICogJ3ZhbHVlJyBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7dmFsdWV9IElmIHRydWUgZGlzYWJsZXMgdGhlIGNvbnRyb2w7IGZhbHNlIGVuYWJsZXMgaXQuXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsb2FkcyB0aGUgZHJvcGRvd24ncyBvcHRpb24gZGF0YSBkZWZpbml0aW9ucyBmcm9tIHRoZSBET00gYW5kIHVwZGF0ZXNcbiAgICogdGhlIGdlbmVyYXRlZCBkcm9wZG93biBkaXNwbGF5IGl0ZW1zLlxuICAgKi9cbiAgcHVibGljIHJlbG9hZCgpIHtcbiAgICAvLyBSZW1vdmUgYWxsIGV4aXN0aW5nIGNoaWxkIGVsZW1lbnRzXG4gICAgdGhpcy5fZW1wdHlOb2RlKHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50KVxuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZUZpbHRlciA9PT0gdW5kZWZpbmVkKSB7IC8vIElmIHRoZSB1c2VyIGlzIGZpbHRlcmluZywgbGV0IHRoZSBwbGFjZWhvbGRlciBcImlucHV0XCIgYWxpdmVcbiAgICAgIHRoaXMuX3NldHVwUGxhY2Vob2xkZXIoKVxuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZU9wdGlvbnModGhpcy5lbGVtZW50KVxuXG4gICAgdGhpcy5fdXBkYXRlU2l6ZSgpXG4gICAgdGhpcy5fdXBkYXRlTWVzc2FnZSgpXG5cbiAgICBpZiAoIXRoaXMuX2lzRmlsdGVyYWJsZSgpKSB7XG4gICAgICB0aGlzLl91cGRhdGVQbGFjZWhvbGRlcighIXRoaXMudmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBlbmFibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGVuYWJsZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19ESVNBQkxFRClcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0IGNvbnRyb2wgdG8gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZWQgc3RhdGUgb2YgdGhlIHNlbGVjdCBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGlmIHRoZSBzZWxlY3QgZHJvcGRvd24gaXMgb3BlbiBvciBjbG9zZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb3Blbjsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgcHVibGljIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlckVsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgc2VsZWN0IGRyb3Bkb3duLlxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgaWYgKCF0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aGlzLl9vcGVuQnlGb2N1cyA9IGZhbHNlXG5cbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0NMT1NFRClcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFkZENsYXNzKENMQVNTX09QRU4pXG5cbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHNlbGVjdCBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSBmYWxzZVxuXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfQ0xPU0VEKVxuXG4gICAgICAvLyBJZiB0aGUgU2VsZWN0IGlzIGZpbHRlcmFibGUgYW5kIHRoZXJlZm9yZSBoYXMgYW4gaW5wdXQgZmllbGQsXG4gICAgICAvLyByZXNldCB0aGUgdmFsdWUgb2YgaXQgdG8gdGhlIGNob3NlbiBvcHRpb25cbiAgICAgIGlmICh0aGlzLl9pc0ZpbHRlcmFibGUoKSkge1xuICAgICAgICAvLyBVbmZvY3VzIGlucHV0IGZpZWxkXG4gICAgICAgICh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuZWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS5ibHVyKClcblxuICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZUZpbHRlciB8fCB0aGlzLl9hY3RpdmVGaWx0ZXIgPT09IHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEuaW5uZXJIVE1MKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UGxhY2Vob2xkZXIodGhpcy5fbGFzdFNlbGVjdGVkT3B0aW9uIS5pbm5lckhUTUwpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGFwXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG5cbiAgICAgIGxldCBmb2N1c2VkSXRlbSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmZpbmQoYC4ke0NMQVNTX0lURU1fRk9DVVNFRH1gKVxuXG4gICAgICBpZiAoZm9jdXNlZEl0ZW0pIHtcbiAgICAgICAgZm9jdXNlZEl0ZW0ucmVtb3ZlQ2xhc3MoQ0xBU1NfSVRFTV9GT0NVU0VEKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZWxlbWVudCBoYXMgdGhlIGZpbHRlciBtb2RpZmllciBjbGFzc1xuICAgKi9cbiAgcHJpdmF0ZSBfaXNGaWx0ZXJhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVyRWxlbWVudC5oYXNDbGFzcyhDTEFTU19GSUxURVJBQkxFKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGNsZWFycyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuX2Ryb3Bkb3duRWxlbWVudCkge1xuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGFwXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG5cbiAgICAgIHJlbW92ZSh0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAodGhpcyBhcyBhbnkpLl9kcm9wZG93bkVsZW1lbnQgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50KSB7XG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fZmlsdGVyS2V5ZG93bkhhbmRsZXIpXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuX2ZpbHRlcktleXVwSGFuZGxlcilcbiAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZmlsdGVyRm9jdXNIYW5kbGVyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl93cmFwcGVyRWxlbWVudCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpO1xuXG4gICAgICAodGhpcyBhcyBhbnkpLl93cmFwcGVyRWxlbWVudCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50KSB7XG4gICAgICByZW1vdmUodGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudC5lbGVtZW50KTtcbiAgICAgICh0aGlzIGFzIGFueSkuX3NlbGVjdEJ1dHRvbkVsZW1lbnQgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX0NMT1NFRClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MU2VsZWN0RWxlbWVudD4oXCJzZWxlY3RcIiwgKGUpID0+IHtcbiAgICBuZXcgU2VsZWN0KGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdFxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IFFVRVJZX1RFWFRBUkVBID0gXCJ0ZXh0YXJlYVwiXG5jb25zdCBDTEFTU19IQVNfVkFMVUUgPSBcImlzLWZpeGVkXCJcblxuLyoqXG4gKiBUZXh0YXJlYSBjb21wb25lbnRcbiAqL1xuY2xhc3MgVGV4dGFyZWEgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfYXJlYTogSFRNTFRleHRBcmVhRWxlbWVudFxuXG4gIHByaXZhdGUgX2ZvY3VzQ2hhbmdlZEhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF92YWx1ZUNoYW5nZWRIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfcmVzaXplSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfbWluUm93cyE6IG51bWJlclxuICBwcml2YXRlIF9tYXhSb3dzITogbnVtYmVyXG4gIHByaXZhdGUgX2xpbmVIZWlnaHQhOiBudW1iZXJcblxuICBwcml2YXRlIF91cGRhdGVCYXNlSGVpZ2h0ITogYm9vbGVhblxuXG4gIHByaXZhdGUgX2Jhc2VIZWlnaHQhOiBudW1iZXJcbiAgcHJpdmF0ZSBfYmFzZVNjcm9sbEhlaWdodCE6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fYXJlYSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX1RFWFRBUkVBKSFcblxuICAgIHRoaXMuX2ZvY3VzQ2hhbmdlZEhhbmRsZXIgPSB0aGlzLl9mb2N1c0NoYW5nZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX3ZhbHVlQ2hhbmdlZEhhbmRsZXIgPSB0aGlzLl9vblZhbHVlQ2hhbmdlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IHRoaXMuX3VwZGF0ZUhlaWdodC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgdGV4dGFyZWEgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX21pblJvd3MgPSBwYXJzZUludCh0aGlzLl9hcmVhLmdldEF0dHJpYnV0ZShcImRhdGEtbWluLXJvd3NcIikgfHwgXCIzXCIsIDEwKVxuICAgIHRoaXMuX21heFJvd3MgPSBwYXJzZUludCh0aGlzLl9hcmVhLmdldEF0dHJpYnV0ZShcImRhdGEtbWF4LXJvd3NcIikhLCAxMCkgfHwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcblxuICAgIC8vIE1ha2Ugc3VyZSBtaW4gYW4gbWF4IGFyZSBwcm9wZXJ0eSBzcGVjaWZpZWRcbiAgICB0aGlzLl9taW5Sb3dzID0gTWF0aC5taW4odGhpcy5fbWluUm93cywgdGhpcy5fbWF4Um93cylcbiAgICB0aGlzLl9tYXhSb3dzID0gTWF0aC5tYXgodGhpcy5fbWluUm93cywgdGhpcy5fbWF4Um93cylcblxuICAgIHRoaXMuX2xpbmVIZWlnaHQgPSBwYXJzZUludChEb20uY3NzKHRoaXMuX2FyZWEsIFwibGluZS1oZWlnaHRcIiksIDEwKVxuXG4gICAgdGhpcy5fdXBkYXRlQmFzZUhlaWdodCA9IERvbS5pc0hpZGRlbih0aGlzLl9hcmVhLCB0cnVlKVxuICAgIHRoaXMuX2NhbGN1bGF0ZUJhc2VIZWlnaHQoKVxuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuX2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzQ2hhbmdlZEhhbmRsZXIpXG4gICAgdGhpcy5fYXJlYS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuX3ZhbHVlQ2hhbmdlZEhhbmRsZXIpXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIHRoaXMuX29uVmFsdWVDaGFuZ2VkKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2FsY3VsYXRlQmFzZUhlaWdodCgpIHtcbiAgICAvLyB0ZW1wb3JhcnkgY2xlYXIgdGhlIGNvbnRlbnQgdG8gdGFrZSBtZWFzdXJlbWVudHNcbiAgICBsZXQgdmFsdWUgPSB0aGlzLl9hcmVhLnZhbHVlXG4gICAgdGhpcy5fYXJlYS52YWx1ZSA9IFwiXCJcblxuICAgIHRoaXMuX2Jhc2VIZWlnaHQgPSB0aGlzLl9hcmVhLm9mZnNldEhlaWdodCAtIHRoaXMuX2xpbmVIZWlnaHRcbiAgICB0aGlzLl9iYXNlU2Nyb2xsSGVpZ2h0ID0gdGhpcy5fYXJlYS5zY3JvbGxIZWlnaHQgLSB0aGlzLl9saW5lSGVpZ2h0XG5cbiAgICAvLyByZXN0b3JlIGluaXRpYWwgY29udGVudFxuICAgIHRoaXMuX2FyZWEudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9mb2N1c0NoYW5nZWQoKSB7XG4gICAgdGhpcy5fdXBkYXRlSGVpZ2h0KClcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlSGVpZ2h0KCkge1xuICAgIGxldCBoYXNGb2N1cyA9IHRoaXMuX2FyZWEgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICBsZXQgbWF4Um93cywgcm93cyA9IDBcblxuICAgIGlmICh0aGlzLl91cGRhdGVCYXNlSGVpZ2h0ID09PSB0cnVlICYmIERvbS5pc0hpZGRlbih0aGlzLl9hcmVhLCB0cnVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUJhc2VIZWlnaHQoKVxuICAgICAgdGhpcy5fdXBkYXRlQmFzZUhlaWdodCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhcHJvcHJpYXRlIHNpemUgZm9yIHRoZSBjb250cm9sXG4gICAgaWYgKCF0aGlzLl9oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyBIYW5kbGUgZW1wdHkgc3RhdGVzXG4gICAgICByb3dzID0gaGFzRm9jdXMgPT09IHRydWUgPyB0aGlzLl9taW5Sb3dzIDogMVxuICAgICAgbWF4Um93cyA9IHJvd3NcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgdGhlIGhlaWdodCBmb3IgY2FsY3VsYXRpb24gb2YgdGhlIHJvdyBjb3VudFxuICAgICAgdGhpcy5fYXJlYS5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuXG4gICAgICAvLyBHZXQgdGhlIG5ldyBoZWlnaHRcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoKHRoaXMuX2FyZWEuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fYmFzZVNjcm9sbEhlaWdodCkgLyB0aGlzLl9saW5lSGVpZ2h0KSArIDFcbiAgICAgIG1heFJvd3MgPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLl9tYXhSb3dzLCByb3dzKSwgdGhpcy5fbWluUm93cylcbiAgICB9XG5cbiAgICBpZiAocm93cyA+IHRoaXMuX21heFJvd3MpIHtcbiAgICAgIHRoaXMuX2FyZWEuc3R5bGUub3ZlcmZsb3cgPSBcImF1dG9cIlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hcmVhLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIlxuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9ICgobWF4Um93cyAtIDEpICogdGhpcy5fbGluZUhlaWdodCkgKyB0aGlzLl9iYXNlSGVpZ2h0XG4gICAgdGhpcy5fYXJlYS5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhc1ZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9hcmVhLnZhbHVlICYmIHRoaXMuX2FyZWEudmFsdWUubGVuZ3RoID4gMFxuICB9XG5cbiAgcHJvdGVjdGVkIF9vblZhbHVlQ2hhbmdlZCgpIHtcbiAgICBpZiAodGhpcy5faGFzVmFsdWUoKSkge1xuICAgICAgRG9tLmFkZENsYXNzKHRoaXMuX2FyZWEsIENMQVNTX0hBU19WQUxVRSlcbiAgICB9IGVsc2Uge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuX2FyZWEsIENMQVNTX0hBU19WQUxVRSlcbiAgICAgIHRoaXMuX2FyZWEudmFsdWUgPSBcIlwiXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlSGVpZ2h0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBjbGVhcnMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIHRoaXMuX2FyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzQ2hhbmdlZEhhbmRsZXIpXG4gICAgdGhpcy5fYXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuX3ZhbHVlQ2hhbmdlZEhhbmRsZXIpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fZm9jdXNDaGFuZ2VkSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fdmFsdWVDaGFuZ2VkSGFuZGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9hcmVhID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9taW5Sb3dzID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9tYXhSb3dzID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9saW5lSGVpZ2h0ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9iYXNlSGVpZ2h0ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9iYXNlU2Nyb2xsSGVpZ2h0ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLmVsZW1lbnQgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuaW5wdXQtbXVsdGlsaW5lLCAuaW5wdXQtZmllbGQtLW11bHRpbGluZVwiLCAoZSkgPT4ge1xuICAgIG5ldyBUZXh0YXJlYShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0YXJlYVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbi8qKlxuICogTG9hZGVyIGJhciBjb21wb25lbnRcbiAqL1xuY2xhc3MgTG9hZGVyQmFyIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgcHJvZ3Jlc3NFbGVtZW50ITogRG9tRWxlbWVudFxuICBwcml2YXRlIGZpbGVOYW1lRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSBwcm9ncmVzc0xhYmVsRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSB0b3RhbFByb2dyZXNzRWxlbWVudCE6IERvbUVsZW1lbnRcblxuICBwcml2YXRlIHZhbHVlITogbnVtYmVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBMb2FkZXJCYXIgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgTG9hZGVyQmFyIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBsb2FkZXIgYmFyIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzRWxlbWVudCA9IHRoaXMuZmluZChcIi5pbmRpY2F0b3JcIikgfHwgdGhpc1xuICAgIHRoaXMuZmlsZU5hbWVFbGVtZW50ID0gdGhpcy5maW5kKFwiLmRldGFpbCA+IC5uYW1lXCIpIVxuICAgIHRoaXMucHJvZ3Jlc3NMYWJlbEVsZW1lbnQgPSB0aGlzLmZpbmQoXCIucHJvZ3Jlc3NcIikhXG4gICAgdGhpcy50b3RhbFByb2dyZXNzRWxlbWVudCA9IHRoaXMuZmluZChcIi5wcm9ncmVzcyA+IC5maWxlLXNpemVcIikhXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBwcm9ncmVzcyB2YWx1ZSBpbiB0aGUgcmFuZ2Ugb2YgMC4uMS5cbiAgICovXG4gIGdldCBwcm9ncmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAtIFRoZSBwcm9ncmVzcyBpbiB0aGUgcmFuZ2Ugb2YgMC4uMS5cbiAgICovXG4gIHNldCBwcm9ncmVzcyh2YWwpIHtcbiAgICAvLyB2YWwgPSBjbGFtcCh2YWwsIDAsIDEpXG5cbiAgICBsZXQgcGVyY2VudGFnZSA9ICh2YWwgKiAxMDApLnRvRml4ZWQoMClcblxuICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgKHRoaXMuZWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZSA9IFN0cmluZyh2YWwpXG5cbiAgICB0aGlzLnByb2dyZXNzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgd2lkdGg6ICR7dmFsICogMTAwfSVgKVxuXG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NMYWJlbEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3NMYWJlbEVsZW1lbnQuZWxlbWVudC50ZXh0Q29udGVudCA9IGAke3BlcmNlbnRhZ2V9JWBcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlsZW5hbWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGZpbGVuYW1lLlxuICAgKi9cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIGlmICghdGhpcy5maWxlTmFtZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maWxlTmFtZUVsZW1lbnQuZWxlbWVudC5pbm5lckhUTUxcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxlbmFtZS5cbiAgICovXG4gIHNldCBmaWxlbmFtZSh2YWw6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIGlmICghdGhpcy5maWxlTmFtZUVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIGZpbGVuYW1lLCBtaXNzaW5nIGRldGFpbCBlbGVtZW50XCIpXG4gICAgfVxuXG4gICAgdGhpcy5maWxlTmFtZUVsZW1lbnQuc2V0SHRtbCh2YWwgfHwgXCJcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxlIHNpemUgbGFiZWwuXG4gICAqL1xuICBzZXQgZmlsZVNpemUodmFsOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMudG90YWxQcm9ncmVzc0VsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIGZpbGVTaXplLCBtaXNzaW5nIGRldGFpbCBlbGVtZW50XCIpXG4gICAgfVxuXG4gICAgdGhpcy50b3RhbFByb2dyZXNzRWxlbWVudC5zZXRIdG1sKHZhbClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5sb2FkZXItYmFyXCIsIChlKSA9PiB7XG4gICAgbmV3IExvYWRlckJhcihlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2FkZXJCYXJcbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgUG9wcGVyIGZyb20gXCJwb3BwZXIuanNcIlxuXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBhZGRDbGFzcywgaGFzQ2xhc3MsIHJlbW92ZUNsYXNzLCBpc0hpZGRlbiwgcGFyZW50V2l0aENsYXNzIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfTUVOVSA9IFwianMtZmx5b3V0XCJcbmNvbnN0IENMQVNTX1RBQlMgPSBcInRhYnNcIlxuXG5jb25zdCBBTklNQVRJT05fT1BFTiA9IDMwMFxuXG4vKipcbiAqIEEgY29tcG9uZW50IGZvciB0aGUgZmx5b3V0IG1lbnUuXG4gKi9cbmNsYXNzIE1lbnVGbHlvdXQgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfY2xpY2tIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyOiAoZTogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9hbmltYXRpb25EdXJhdGlvbiA9IEFOSU1BVElPTl9PUEVOXG5cbiAgcHJpdmF0ZSBfZHluYW1pY1BsYWNlbWVudCA9IGZhbHNlXG5cbiAgcHJpdmF0ZSBfaGlkZGVuSW5kaWNhdG9yPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfZmx5b3V0RWxlbWVudCE6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfcG9wcGVySW5zdGFuY2U/OiBQb3BwZXJcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIGZseW91dCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgZmx5b3V0IG1lbnUgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGZseW91dCBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgbGV0IGRhdGFUYXJnZXQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10YXJnZXRcIilcbiAgICBpZiAoZGF0YVRhcmdldCA9PT0gbnVsbCB8fCBkYXRhVGFyZ2V0ID09PSBcIlwiKSB7XG5cbiAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIGZseW91dCBtZW51IGVsZW1lbnQgcmVxdWlyZXMgYSAnZGF0YS10YXJnZXQnIHRoYXQgc3BlY2lmaWVzIHRoZSBlbGVtZW50IHRvIGNvbGxhcHNlXCIpXG4gICAgICBjb25zb2xlLmluZm8odGhpcy5lbGVtZW50KVxuICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl91c2VEeW5hbWljUGxhY2VtZW50KCkpIHtcbiAgICAgIHRoaXMuX2R5bmFtaWNQbGFjZW1lbnQgPSB0cnVlXG4gICAgfVxuXG4gICAgbGV0IGhpZGRlblRhcmdldCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhpZGRlblwiKVxuICAgIGlmIChoaWRkZW5UYXJnZXQgIT09IG51bGwgJiYgaGlkZGVuVGFyZ2V0ICE9PSBcIlwiKSB7XG4gICAgICB0aGlzLl9oaWRkZW5JbmRpY2F0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGhpZGRlblRhcmdldCkgYXMgSFRNTEVsZW1lbnQgfHwgdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdEZseW91dEVsZW1lbnQoZGF0YVRhcmdldClcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRGbHlvdXRFbGVtZW50KGRhdGFUYXJnZXQ6IHN0cmluZykge1xuICAgIHRoaXMuX2ZseW91dEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRhdGFUYXJnZXQpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX2ZseW91dEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFwiMFwiXG4gICAgdGhpcy5fZmx5b3V0RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVkoLTIwcHgpXCJcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xpY2soKSB7XG4gICAgdGhpcy50b2dnbGUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVXaW5kb3dDbGljayhldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAocGFyZW50V2l0aENsYXNzKHRhcmdldCwgQ0xBU1NfTUVOVSkgPT09IHRoaXMuX2ZseW91dEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHdoaWxlICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCAmJiB0YXJnZXQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXNlRHluYW1pY1BsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gcGFyZW50V2l0aENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfVEFCUylcbiAgfVxuXG4gIHByb3RlY3RlZCBfb3Blbk1lbnUoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgYW5pbWUucmVtb3ZlKGVsKVxuXG4gICAgaWYgKHRoaXMuX2R5bmFtaWNQbGFjZW1lbnQgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHBvcHBlck9wdGlvbnM6IFBvcHBlci5Qb3BwZXJPcHRpb25zID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgIGZsaXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHNFbmFibGVkOiBmYWxzZVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZSA9IG5ldyBQb3BwZXIodGhpcy5lbGVtZW50LCB0aGlzLl9mbHlvdXRFbGVtZW50LCBwb3BwZXJPcHRpb25zKVxuICAgIH1cblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgZHVyYXRpb246IHRoaXMuX2FuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNsYXRlWTogXCIwcHhcIixcbiAgICAgIGJlZ2luOiAoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBhZGRDbGFzcyhlbCwgQ0xBU1NfT1BFTilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gc2V0IGFyaWEgZXhwYW5kZWRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwib3BlbmVkXCIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2Nsb3NlTWVudShlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBhbmltZS5yZW1vdmUoZWwpXG5cbiAgICBpZiAodGhpcy5fcG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLmRlc3Ryb3koKVxuICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBlbCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9hbmltYXRpb25EdXJhdGlvbixcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHRyYW5zbGF0ZVk6IFwiLTIwcHhcIixcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIlxuICAgICAgICByZW1vdmVDbGFzcyhlbCwgQ0xBU1NfT1BFTilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gc2V0IGFyaWEgZXhwYW5kZWRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIilcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNsb3NlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9wZW5pbmcgYW5pbWF0aW9uIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge2R1cmF0aW9uSW5TZWNvbmRzfSAtIFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG4gIHNldCBhbmltYXRpb25EdXJhdGlvbihkdXJhdGlvbkluU2Vjb25kczogbnVtYmVyKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uRHVyYXRpb24gPSBkdXJhdGlvbkluU2Vjb25kc1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBmbHlvdXQgbWVudS5cbiAgICogQGZpcmVzIE1vZGFsI29wZW5lZFxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IHRydWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcbiAgICB0aGlzLl9vcGVuTWVudSh0aGlzLl9mbHlvdXRFbGVtZW50KVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIH0sIDUwKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgZmx5b3V0IG1lbnUuXG4gICAqIEBmaXJlcyBNb2RhbCNjbG9zZWRcbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuSW5kaWNhdG9yICYmIGlzSGlkZGVuKHRoaXMuX2hpZGRlbkluZGljYXRvciwgZmFsc2UpID09PSB0cnVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgdGhpcy5fY2xvc2VNZW51KHRoaXMuX2ZseW91dEVsZW1lbnQpXG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZmx5b3V0IG1lbnUuXG4gICAqIEBmaXJlcyBNb2RhbCNvcGVuZWRcbiAgICogQGZpcmVzIE1vZGFsI2Nsb3NlZFxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl9mbHlvdXRFbGVtZW50ID0gbnVsbFxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5fY2xpY2tIYW5kbGVyKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLmRlc3Ryb3koKVxuICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9jbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3dpbmRvd0NsaWNrSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5lbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIGZseW91dCBtZW51IGlzIG9wZW5lZCBieSB0aGUgYW5jaG9yIGxpbmsgb3IgdXNpbmcgdGhlXG4gICAqIHtAbGluayBNZW51Rmx5b3V0I29wZW59IG1ldGhvZC5cbiAgICogQGV2ZW50IE1lbnVGbHlvdXQjb3BlbmVkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBmbHlvdXQgbWVudSBpcyBjbG9zZWQgYnkgdGhlIHVzZXIgb3IgdXNpbmcgdGhlXG4gICAqIHtAbGluayBNZW51Rmx5b3V0I2Nsb3NlfSBtZXRob2QuXG4gICAqIEBldmVudCBNZW51Rmx5b3V0I2Nsb3NlZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS10b2dnbGU9J2ZseW91dCddXCIpXG4gIGZvciAobGV0IGUgb2YgZWxlbWVudHMpIHtcbiAgICBpZiAoZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluaXRcIikgPT09IFwiYXV0b1wiKSB7XG4gICAgICBuZXcgTWVudUZseW91dChlKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZW51Rmx5b3V0XG4iLCJpbXBvcnQgeyBkaXNhYmxlQm9keVNjcm9sbCwgZW5hYmxlQm9keVNjcm9sbCB9IGZyb20gXCJib2R5LXNjcm9sbC1sb2NrXCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi4vSW5wdXRzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IGdldFJvb3RFbGVtZW50IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX0JBQ0tEUk9QID0gXCJiYWNrZHJvcFwiXG5jb25zdCBDTEFTU19CQUNLRFJPUF9PUEVOID0gXCJiYWNrZHJvcC0tb3BlblwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcIm1vZGFsLS1vcGVuXCJcbmNvbnN0IENMQVNTX1RSSUdHRVIgPSBcIm1vZGFsLXRyaWdnZXJcIlxuXG5jb25zdCBDTEFTU19CT0RZID0gXCJtb2RhbF9fYm9keVwiXG5cbmNvbnN0IENMQVNTX0JVVFRPTlNfT0tBWSA9IFwiLm1vZGFsLWNsb3NlXCJcbmNvbnN0IENMQVNTX0JVVFRPTlNfQ0xPU0UgPSBcIi5tb2RhbC1jYW5jZWxcIlxuXG4vKipcbiAqIEEgY29tcG9uZW50IHRvIG9wZW4gYW5kIGNsb3NlIG1vZGFsIGRpYWxvZ3MuIEl0IGFsc28gaGFuZGxlcyBjYW5jZWxsYXRpb24gYW5kIG1ha2VzXG4gKiBzdXJlIHRoYXQgdGhlIG1vZGFsIGJhY2tncm91bmQgaXMgcHJlc2VudCBpbiB0aGUgRE9NLlxuICovXG5jbGFzcyBNb2RhbCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfb2theUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9jYW5jZWxIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF93aW5kb3dDbGlja0hhbmRsZXI/OiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfdHJpZ2dlckNsaWNrSGFuZGxlcj86IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2JhY2tkcm9wITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfYmFja2Ryb3BQYXJlbnQhOiBFbGVtZW50XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fb2theUhhbmRsZXIgPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl9jYW5jZWxIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcmFuZ2UgbW9kYWwgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBiYWNrZHJvcFxuICAgIHRoaXMuX2JhY2tkcm9wID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQkFDS0RST1ApXG5cbiAgICB0aGlzLl9iYWNrZHJvcFBhcmVudCA9IGdldFJvb3RFbGVtZW50KClcbiAgICB0aGlzLl9zdWJzY3JpYmVUb1RyaWdnZXIoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmVUb1RyaWdnZXIoKSB7XG4gICAgY29uc3QgdHJpZ2dlcklkID0gdGhpcy5lbGVtZW50LmlkXG4gICAgaWYgKCF0cmlnZ2VySWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3RyaWdnZXJDbGlja0hhbmRsZXIgPSB0aGlzLm9wZW4uYmluZCh0aGlzKVxuXG4gICAgbGV0IHRyaWdnZXJFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1RSSUdHRVJ9W2hyZWY9JHt0cmlnZ2VySWR9XWApXG4gICAgZm9yIChsZXQgdHJpZ2dlckVsZW1lbnQgb2YgdHJpZ2dlckVsZW1lbnRzKSB7XG4gICAgICB0cmlnZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fdHJpZ2dlckNsaWNrSGFuZGxlciEpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZUZyb21UcmlnZ2VyKCkge1xuICAgIGNvbnN0IHRyaWdnZXJJZCA9IHRoaXMuZWxlbWVudC5pZFxuICAgIGlmICghdHJpZ2dlcklkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdHJpZ2dlckVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVFJJR0dFUn1baHJlZj0ke3RyaWdnZXJJZH1dYClcbiAgICBmb3IgKGxldCB0cmlnZ2VyRWxlbWVudCBvZiB0cmlnZ2VyRWxlbWVudHMpIHtcbiAgICAgIHRyaWdnZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIhKVxuICAgIH1cblxuICAgIHRoaXMuX3RyaWdnZXJDbGlja0hhbmRsZXIgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogRXZlbnQpIHtcbiAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gZXZlbnQgYXMgS2V5Ym9hcmRFdmVudFxuICAgIGxldCBrZXljb2RlID0ga2V5Ym9hcmRFdmVudC53aGljaCB8fCBrZXlib2FyZEV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIHRoaXMuY2FuY2VsKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgdGhpcy5jYW5jZWwoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9zZSgpIHtcbiAgICBlbmFibGVCb2R5U2Nyb2xsKHRoaXMuZWxlbWVudClcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIHRoaXMuX2JhY2tkcm9wLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NhbmNlbEhhbmRsZXIpXG5cbiAgICB0aGlzLl9iYWNrZHJvcC5yZW1vdmVDbGFzcyhDTEFTU19CQUNLRFJPUF9PUEVOKVxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcblxuICAgIGZvciAobGV0IGNsb3NlQnV0dG9uIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0JVVFRPTlNfQ0xPU0UpKSB7XG4gICAgICBjbG9zZUJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2FuY2VsSGFuZGxlcilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBva2F5QnV0dG9uIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0JVVFRPTlNfT0tBWSkpIHtcbiAgICAgIG9rYXlCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29rYXlIYW5kbGVyKVxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBiYWNrZHJvcCBmcm9tIHRoZSBib2R5XG4gICAgICB0aGlzLl9iYWNrZHJvcFBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLl9iYWNrZHJvcC5lbGVtZW50KVxuICAgIH0sIDMwMClcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbW9kYWwgZGlhbG9nLlxuICAgKiBAZmlyZXMgTW9kYWwjb3BlbmVkXG4gICAqL1xuICBwdWJsaWMgb3BlbigpIHtcbiAgICBkaXNhYmxlQm9keVNjcm9sbCh0aGlzLmVsZW1lbnQsIHtcbiAgICAgIGFsbG93VG91Y2hNb3ZlOiAoZWwpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnRFbCA9IGVsXG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnRFbCAmJiBjdXJyZW50RWwgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdXNlciBpcyBzY3JvbGxpbmcgdGhlIG1vZGFsIGJvZHlcbiAgICAgICAgICBpZiAoY3VycmVudEVsLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19CT0RZKSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgb3ZlcmZsb3dzXG4gICAgICAgICAgICBpZiAoY3VycmVudEVsLnNjcm9sbEhlaWdodCA+IGN1cnJlbnRFbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50RWwgPSBjdXJyZW50RWwucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIGFkZCB0aGUgYmFja2Ryb3AgdG8gdGhlIGJvZHlcbiAgICB0aGlzLl9iYWNrZHJvcFBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLl9iYWNrZHJvcC5lbGVtZW50KVxuXG4gICAgLy8gc2V0IHRoZSBlbGVtZW50IHRvIGZsZXggYXMgaXQgaXMgaW5pdGlhbGx5IGhpZGRlblxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCJcblxuICAgIC8vIHJlbW92ZSB0aGUgc3R5bGUgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJcIlxuICAgIH0sIDgwMClcblxuICAgIC8vIHdhaXQgYSBiaXQgdG8gYWxsb3cgdGhlIGJyb3dzZXIgdG8gY2F0Y2ggdXAgYW5kIHNob3cgdGhlIGFuaW1hdGlvblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgdGhpcy5fYmFja2Ryb3AuYWRkQ2xhc3MoQ0xBU1NfQkFDS0RST1BfT1BFTilcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG5cbiAgICAgIHRoaXMuX2JhY2tkcm9wLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NhbmNlbEhhbmRsZXIpXG5cbiAgICAgIGZvciAobGV0IGNsb3NlQnV0dG9uIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0JVVFRPTlNfQ0xPU0UpKSB7XG4gICAgICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBva2F5QnV0dG9uIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0JVVFRPTlNfT0tBWSkpIHtcbiAgICAgICAgb2theUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb2theUhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGU6IEV2ZW50KSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpKVxuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJvcGVuZWRcIilcbiAgICB9LCA1MClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIChhbmQgY2xvc2VzKSB0aGUgbW9kYWwgZGlhbG9nLlxuICAgKiBAZmlyZXMgTW9kYWwjY2FuY2VsbGVkXG4gICAqIEBmaXJlcyBNb2RhbCNjbG9zZWRcbiAgICovXG4gIHB1YmxpYyBjYW5jZWwoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2FuY2VsbGVkXCIpXG4gICAgdGhpcy5fY2xvc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwgZGlhbG9nLlxuICAgKiBAZmlyZXMgTW9kYWwjY2xvc2VkXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgdGhpcy5fY2xvc2UoKVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNsb3NlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jYW5jZWwoKVxuICAgIHRoaXMuX3Vuc3Vic2NyaWJlRnJvbVRyaWdnZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIG1vZGFsIGRpYWxvZyBpcyBvcGVuZWQgYnkgdGhlIGFuY2hvciBsaW5rIG9yIHVzaW5nIHRoZVxuICAgKiB7QGxpbmsgTW9kYWwjb3Blbn0gbWV0aG9kLlxuICAgKiBAZXZlbnQgTW9kYWwjb3BlbmVkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBtb2RhbCBkaWFsb2cgaXMgY2xvc2VkIGJ5IHRoZSB1c2VyIG9yIHVzaW5nIHRoZVxuICAgKiB7QGxpbmsgTW9kYWwjY2xvc2V9IG1ldGhvZC5cbiAgICogQGV2ZW50IE1vZGFsI2Nsb3NlZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgbW9kYWwgZGlhbG9nIGlzIGNhbmNlbGxlZCBieSB0aGUgdXNlciBvciB1c2luZyB0aGVcbiAgICoge0BsaW5rIE1vZGFsI2NhbmNlbH0gbWV0aG9kLlxuICAgKiBAZXZlbnQgTW9kYWwjY2FuY2VsbGVkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIubW9kYWxcIiwgKGUpID0+IHtcbiAgICBuZXcgTW9kYWwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kYWxcbiIsImltcG9ydCBhbmltZSwgeyBBbmltZVRpbWVsaW5lSW5zdGFuY2UgfSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCBTZWFyY2hJbnB1dCBmcm9tIFwiLi4vc2VhcmNoL1NlYXJjaElucHV0XCJcblxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcImlzLWFjdGl2ZVwiXG5cbmNvbnN0IFFVRVJZX05BVl9IQU1CVVJHRVIgPSBcIi5uYXYtaGFtYnVyZ2VyXCJcbmNvbnN0IFFVRVJZX05BVl9IQl9CT0RZID0gXCIubmF2X19wcmltYXJ5XCJcblxuY29uc3QgQ0xBU1NfTkFWX0xJTksgPSBcIm5hdi1saW5rLS1oZWFkZXJcIlxuY29uc3QgUVVFUllfTkFWX0xJTktfQUNUSVZFID0gXCIubmF2LWxpbmstLWhlYWRlci5pcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9OQVZfTU9CSUxFID0gXCIubmF2X19sZXZlbDEgLm5hdl9fbWFpbm5hdiAubmF2X19wcmltYXJ5XCJcbmNvbnN0IFFVRVJZX05BVl9MRVZFTDAgPSBcIi5uYXZfX2xldmVsMFwiXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwwX0NPTlRBSU5FUiA9IFwiLm5hdl9fbGV2ZWwwIC5uYXZfX3N1Ym5hdlwiXG5jb25zdCBRVUVSWV9TRUNUSU9OX09QRU4gPSBcIi5uYXYtc2VjdGlvbi5pcy1vcGVuXCJcblxuY29uc3QgUVVFUllfTkFWX0xFVkVMMSA9IFwiLm5hdl9fbGV2ZWwxIC5uYXZfX21haW5uYXZcIlxuXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwwX0xJTksgPSBcIi5uYXYtbGluay5uYXYtbGluay0taGVhZGVyXCJcbmNvbnN0IFFVRVJZX05BVl9MRVZFTDFfTElOSyA9IFwiLm5hdi1saW5rLS1oZWFkZXJcIlxuXG5jb25zdCBRVUVSWV9OQVZfQ09MVU1OID0gXCIubmF2LWNvbFwiXG5jb25zdCBRVUVSWV9OQVZfQ09MVU1OX0FDVElWRSA9IFwiLm5hdi1jb2wuaXMtYWN0aXZlXCJcblxuY29uc3QgUVVFUllfTkFWX0JPRFkgPSBcIi5uYXYtYm9keVwiXG5jb25zdCBRVUVSWV9OQVZfRk9PVEVSID0gXCIubmF2LWZvb3RlclwiXG5cbmNvbnN0IFFVRVJZX1NFQVJDSF9JQ09OID0gXCIubmF2LXNlYXJjaFwiXG5jb25zdCBRVUVSWV9TRUFSQ0hfRklFTEQgPSBcIi5zZWFyY2hfX2lucHV0XCJcbmNvbnN0IENMQVNTX1NFQVJDSF9ERVNLVE9QID0gXCJzZWFyY2gtLWRlc2t0b3BcIlxuXG5jb25zdCBBTklNQVRJT05fU1RBUlRfREVMQVkgPSAyMDBcbmNvbnN0IEFOSU1BVElPTl9PRkZTRVQgPSA1MFxuXG5jb25zdCBBTklNQVRJT05fQk9EWV9EVVJBVElPTiA9IDMwMFxuY29uc3QgQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTiA9IDEwMFxuXG4vKipcbiAqIFRoZSBuYXZpZ2F0aW9uIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBOYXZpZ2F0aW9uIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHB1YmxpYyBfbmF2TGV2ZWwwOiBIVE1MRWxlbWVudFxuICBwdWJsaWMgX25hdkxldmVsMEJvZHk6IEhUTUxFbGVtZW50XG4gIHB1YmxpYyBfbmF2TGV2ZWwxOiBIVE1MRWxlbWVudFxuXG4gIHB1YmxpYyBfaGFtYnVyZ2VyRWxlbWVudDogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9uYXZNb2JpbGU6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfc2VhcmNoQ29tcG9uZW50czogU2VhcmNoSW5wdXRbXVxuXG4gIHByaXZhdGUgX2xldmVsMENsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2xldmVsMUNsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3NlYXJjaENsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBhbmltYXRpb246IEFuaW1lVGltZWxpbmVJbnN0YW5jZSA9IGFuaW1lLnRpbWVsaW5lKClcbiAgcHJpdmF0ZSBfc2VhcmNoRGVza3RvcD86IFNlYXJjaElucHV0XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9uYXZMZXZlbDAgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfTEVWRUwwKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fbmF2TGV2ZWwwQm9keSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MRVZFTDBfQ09OVEFJTkVSKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fbmF2TGV2ZWwxID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xFVkVMMSkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuXG4gICAgdGhpcy5fbmF2TW9iaWxlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX01PQklMRSkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIGlmICghdGhpcy5fbmF2TW9iaWxlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGxldCBkdW1teVBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIGR1bW15UGFyZW50LmFwcGVuZENoaWxkKHRoaXMuX25hdk1vYmlsZSlcbiAgICB9XG5cbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0hBTUJVUkdFUikgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIHRoaXMuX3NlYXJjaENvbXBvbmVudHMgPSBbXVxuXG4gICAgdGhpcy5fbGV2ZWwwQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlTGV2ZWwwQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2xldmVsMUNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUxldmVsMUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fc2VhcmNoQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlU2VhcmNoQ2xpY2suYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3Jlc2V0TWFpblRpbWVsaW5lKC4uLmVsZW1lbnRzOiBIVE1MRWxlbWVudFtdKSB7XG4gICAgdGhpcy5hbmltYXRpb24ucGF1c2UoKVxuICAgIGZvciAobGV0IGVsIG9mIGVsZW1lbnRzKSB7XG4gICAgICBhbmltZS5yZW1vdmUoZWwhKVxuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1lLnRpbWVsaW5lKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNNb2JpbGUoKSB7XG4gICAgcmV0dXJuIERvbS5pc0hpZGRlbih0aGlzLl9oYW1idXJnZXJFbGVtZW50LCB0cnVlKSA9PT0gZmFsc2VcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlTGV2ZWwwQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgY29uc3QgaXNEZXNrdG9wID0gIXRoaXMuX2lzTW9iaWxlKClcblxuICAgIGlmIChpc0Rlc2t0b3ApIHtcbiAgICAgIGxldCBuYXZJdGVtcyA9IG5ldyBOYXZpZ2F0aW9uSXRlbXModGhpcylcbiAgICAgICAgLmZyb21MZXZlbDAoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxuXG4gICAgICBpZiAoIW5hdkl0ZW1zLnNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBwcmV2aW91c05hdkxpbmsgPSB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfTElOS19BQ1RJVkUpISBhcyBIVE1MRWxlbWVudFxuICAgICAgbGV0IHByZXZpb3VzTmF2U2VjdGlvbiA9IHRoaXMuX25hdkxldmVsMC5xdWVyeVNlbGVjdG9yKFFVRVJZX1NFQ1RJT05fT1BFTikhIGFzIEhUTUxFbGVtZW50XG5cbiAgICAgIHRoaXMuX3RvZ2dsZUNvbnRhaW5lcihcbiAgICAgICAgbmF2SXRlbXMubGluayxcbiAgICAgICAgdGhpcy5fbmF2TGV2ZWwwQm9keSxcbiAgICAgICAgbmF2SXRlbXMuc2VjdGlvbixcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBwcmV2aW91c05hdkxpbmssXG4gICAgICAgIHRoaXMuX25hdkxldmVsMEJvZHksXG4gICAgICAgIHByZXZpb3VzTmF2U2VjdGlvbixcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVMZXZlbDFDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBsZXQgbmF2SXRlbXMgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMpXG4gICAgICAuZnJvbUxldmVsMShldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpXG5cbiAgICBsZXQgcHJldkl0ZW1zID0gbmF2SXRlbXMucHJldmlvdXNMZXZlbDEoKVxuXG4gICAgdGhpcy5fdG9nZ2xlQ29udGFpbmVyKFxuICAgICAgbmF2SXRlbXMubGluayxcbiAgICAgIG5hdkl0ZW1zLmNvbnRhaW5lcixcbiAgICAgIG5hdkl0ZW1zLnNlY3Rpb24sXG4gICAgICBuYXZJdGVtcy5mb290ZXIsXG4gICAgICBwcmV2SXRlbXMubGluayxcbiAgICAgIHByZXZJdGVtcy5jb250YWluZXIsXG4gICAgICBwcmV2SXRlbXMuc2VjdGlvbixcbiAgICAgIHByZXZJdGVtcy5mb290ZXIsXG4gICAgICBmYWxzZVxuICAgIClcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJvdGVjdGVkIF90b2dnbGVDb250YWluZXIoXG4gICAgbmF2TGluazogSFRNTEVsZW1lbnQsXG4gICAgbmF2Q29udGFpbmVyPzogSFRNTEVsZW1lbnQsXG4gICAgbmF2U2VjdGlvbj86IEhUTUxFbGVtZW50LFxuICAgIG5hdkZvb3Rlcj86IEhUTUxFbGVtZW50LFxuICAgIHByZXZpb3VzTmF2TGluaz86IEhUTUxFbGVtZW50LFxuICAgIHByZXZpb3VzTmF2Q29udGFpbmVyPzogSFRNTEVsZW1lbnQsXG4gICAgcHJldmlvdXNOYXZTZWN0aW9uPzogSFRNTEVsZW1lbnQsXG4gICAgcHJldmlvdXNOYXZGb290ZXI/OiBIVE1MRWxlbWVudCxcbiAgICBhbmltYXRlQ29udGFpbmVyID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgaXNEZXNrdG9wID0gIXRoaXMuX2lzTW9iaWxlKClcblxuICAgIGlmIChwcmV2aW91c05hdkxpbmsgJiYgcHJldmlvdXNOYXZMaW5rICE9PSBuYXZMaW5rICYmIG5hdkxpbmsgIT09IHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQpIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhwcmV2aW91c05hdkxpbmssIENMQVNTX0FDVElWRSlcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZShuYXZDb250YWluZXIhLCBuYXZTZWN0aW9uISwgbmF2Rm9vdGVyISwgcHJldmlvdXNOYXZDb250YWluZXIhLCBwcmV2aW91c05hdlNlY3Rpb24hLCBwcmV2aW91c05hdkZvb3RlciEpXG5cbiAgICBpZiAoRG9tLmhhc0NsYXNzKG5hdkxpbmssIENMQVNTX0FDVElWRSkpIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZMaW5rLCBDTEFTU19BQ1RJVkUpXG5cbiAgICAgIGlmIChpc0Rlc2t0b3ApIHtcbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uQ2xvc2VkKClcblxuICAgICAgICB0aGlzLl9jbG9zZVNlY3Rpb24obmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCBuYXZGb290ZXIsIHRydWUsIGFuaW1hdGVDb250YWluZXIpXG4gICAgICB9IGVsc2UgaWYgKG5hdkxpbmsgPT09IHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ2xvc2UgbW9iaWxlIG5hdmlnYXRpb25cbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uQ2xvc2VkKClcblxuICAgICAgICB0aGlzLl9jbG9zZVNlY3Rpb24obmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCB1bmRlZmluZWQsIGZhbHNlLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzRGVza3RvcCkge1xuICAgICAgICAvLyBDbG9zZSB0aGUgc2VjdGlvblxuICAgICAgICB0aGlzLl9jbG9zZVNlY3Rpb24obmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCBuYXZGb290ZXIsIHRydWUsIGFuaW1hdGVDb250YWluZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5hZGRDbGFzcyhuYXZMaW5rLCBDTEFTU19BQ1RJVkUpXG5cbiAgICAgIGlmIChpc0Rlc2t0b3ApIHtcbiAgICAgICAgRG9tLmFkZENsYXNzKHRoaXMuX25hdk1vYmlsZSwgQ0xBU1NfT1BFTilcbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uT3BlbmVkKClcblxuICAgICAgICBpZiAocHJldmlvdXNOYXZDb250YWluZXIgJiYgcHJldmlvdXNOYXZTZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKHByZXZpb3VzTmF2Q29udGFpbmVyLCBwcmV2aW91c05hdlNlY3Rpb24sIHByZXZpb3VzTmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5TZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfSBlbHNlIGlmIChuYXZMaW5rID09PSB0aGlzLl9oYW1idXJnZXJFbGVtZW50KSB7XG4gICAgICAgIC8vIE9wZW4gbW9iaWxlIG5hdmlnYXRpb25cbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uT3BlbmVkKClcblxuICAgICAgICB0aGlzLl9vcGVuU2VjdGlvbihuYXZDb250YWluZXIsIG5hdlNlY3Rpb24sIHVuZGVmaW5lZCwgZmFsc2UsIGZhbHNlKVxuICAgICAgfSBlbHNlIGlmICghaXNEZXNrdG9wKSB7XG4gICAgICAgIC8vIE9wZW4gc2VjdGlvblxuICAgICAgICBpZiAocHJldmlvdXNOYXZDb250YWluZXIgJiYgcHJldmlvdXNOYXZTZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKHByZXZpb3VzTmF2Q29udGFpbmVyLCBwcmV2aW91c05hdlNlY3Rpb24sIHByZXZpb3VzTmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWUudGltZWxpbmUoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5TZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb25OYXZpZ2F0aW9uT3BlbmVkKCkge1xuICAgIERvbS5hZGRDbGFzcyh0aGlzLl9uYXZNb2JpbGUsIENMQVNTX09QRU4pXG4gICAgRG9tLmFkZENsYXNzKHRoaXMuX25hdk1vYmlsZS5wYXJlbnRFbGVtZW50ISwgQ0xBU1NfT1BFTilcbiAgICBEb20uYWRkQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX29uTmF2aWdhdGlvbkNsb3NlZCgpIHtcbiAgICBEb20ucmVtb3ZlQ2xhc3ModGhpcy5fbmF2TW9iaWxlLCBDTEFTU19PUEVOKVxuICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLl9uYXZNb2JpbGUucGFyZW50RWxlbWVudCEsIENMQVNTX09QRU4pXG4gICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIENMQVNTX0FDVElWRSlcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVXaW5kb3dDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICB3aGlsZSAodGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBwcm90ZWN0ZWQgX29wZW5TZWN0aW9uKFxuICAgIG5hdkNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICAgIG5hdlNlY3Rpb24/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZGb290ZXI/OiBIVE1MRWxlbWVudCxcbiAgICBhbmltYXRlQ29sdW1ucyA9IHRydWUsXG4gICAgYW5pbWF0ZUNvbnRhaW5lciA9IGZhbHNlXG4gICkge1xuICAgIGlmICghbmF2U2VjdGlvbiB8fCAhbmF2Q29udGFpbmVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgYWN0aXZlSXRlbXMgPSBuYXZTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfTkFWX0NPTFVNTilcblxuICAgIGlmIChhbmltYXRlQ29udGFpbmVyID09PSB0cnVlKSB7XG4gICAgICBsZXQgY29udGFpbmVyID0gbmF2Q29udGFpbmVyXG4gICAgICBuYXZDb250YWluZXIgPSBuYXZTZWN0aW9uXG4gICAgICBuYXZTZWN0aW9uID0gY29udGFpbmVyXG4gICAgfVxuXG4gICAgRG9tLmFkZENsYXNzKG5hdkNvbnRhaW5lciEsIENMQVNTX09QRU4pXG5cbiAgICBuYXZTZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICB0YXJnZXRzOiBuYXZTZWN0aW9uLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9CT0RZX0RVUkFUSU9OLFxuICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICBoZWlnaHQ6IGFuaW1hdGVDb250YWluZXIgPyBuYXZDb250YWluZXIuc2Nyb2xsSGVpZ2h0IDogbmF2U2VjdGlvbi5zY3JvbGxIZWlnaHQsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBEb20uYWRkQ2xhc3MobmF2U2VjdGlvbiEsIENMQVNTX09QRU4pXG4gICAgICAgIG5ldyBEb21FbGVtZW50KG5hdlNlY3Rpb24hKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAobmF2Rm9vdGVyKSB7XG4gICAgICBjb25zdCBuYXZJdGVtcyA9IG5hdkZvb3Rlci5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9DT0xVTU4pXG4gICAgICBmb3IgKGxldCBpdGVtIG9mIG5hdkl0ZW1zKSB7XG4gICAgICAgIERvbS5hZGRDbGFzcyhpdGVtLCBDTEFTU19BQ1RJVkUpXG4gICAgICB9XG5cbiAgICAgIG5hdkZvb3Rlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IG5hdkZvb3RlcixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04sXG4gICAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgICBoZWlnaHQ6IG5hdkZvb3Rlci5zY3JvbGxIZWlnaHQsXG4gICAgICAgIG9mZnNldDogYC09JHtBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OfWAsXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgRG9tLmFkZENsYXNzKG5hdkZvb3RlciEsIENMQVNTX09QRU4pXG4gICAgICAgICAgbmV3IERvbUVsZW1lbnQobmF2Rm9vdGVyISkuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZUNvbHVtbnMgPT09IHRydWUpIHtcbiAgICAgIGxldCBkZWxheSA9IEFOSU1BVElPTl9TVEFSVF9ERUxBWVxuXG4gICAgICBmb3IgKGxldCBpdGVtIG9mIGFjdGl2ZUl0ZW1zKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICAgICAgdGFyZ2V0czogaXRlbSxcbiAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICBvZmZzZXQ6IGRlbGF5LFxuICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBEb20uYWRkQ2xhc3MoaXRlbSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZGVsYXkgKz0gQU5JTUFUSU9OX09GRlNFVFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2VTZWN0aW9uKFxuICAgIG5hdkNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICAgIG5hdlNlY3Rpb24/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZGb290ZXI/OiBIVE1MRWxlbWVudCxcbiAgICBhbmltYXRlQ29sdW1ucyA9IHRydWUsXG4gICAgYW5pbWF0ZUNvbnRhaW5lciA9IGZhbHNlXG4gICkge1xuICAgIGlmICghbmF2U2VjdGlvbiB8fCAhbmF2Q29udGFpbmVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgYWN0aXZlSXRlbXMgPSBuYXZTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfTkFWX0NPTFVNTl9BQ1RJVkUpXG5cbiAgICBpZiAoYW5pbWF0ZUNvbnRhaW5lciA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IG5hdkNvbnRhaW5lclxuICAgICAgbmF2Q29udGFpbmVyID0gbmF2U2VjdGlvblxuICAgICAgbmF2U2VjdGlvbiA9IGNvbnRhaW5lclxuICAgIH1cblxuICAgIGlmIChhbmltYXRlQ29sdW1ucyA9PT0gdHJ1ZSkge1xuICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGFjdGl2ZUl0ZW1zKSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhhY3RpdmUsIENMQVNTX0FDVElWRSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgdGFyZ2V0czogbmF2U2VjdGlvbixcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fQk9EWV9EVVJBVElPTixcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgRG9tLnJlbW92ZUNsYXNzKG5hdkNvbnRhaW5lciEsIENMQVNTX09QRU4pXG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZTZWN0aW9uISwgQ0xBU1NfT1BFTilcbiAgICAgICAgbmF2U2VjdGlvbiEuc3R5bGUuaGVpZ2h0ID0gXCJcIlxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAobmF2Rm9vdGVyKSB7XG4gICAgICBmb3IgKGxldCBhY3RpdmUgb2YgbmF2Rm9vdGVyLnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfTkFWX0NPTFVNTl9BQ1RJVkUpKSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhhY3RpdmUsIENMQVNTX0FDVElWRSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgICAgdGFyZ2V0czogbmF2Rm9vdGVyLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTixcbiAgICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZGb290ZXIhLCBDTEFTU19PUEVOKVxuICAgICAgICAgIG5hdkZvb3RlciEuc3R5bGUuaGVpZ2h0ID0gXCJcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlU2VhcmNoQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuX3NlYXJjaERlc2t0b3ApIHtcbiAgICAgIHRoaXMuX3NlYXJjaERlc2t0b3Aub3BlbigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBuYXZpZ2F0aW9uIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICBmb3IgKGxldCBuYXZMaW5rIG9mIHRoaXMuX25hdkxldmVsMC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9MRVZFTDBfTElOSykpIHtcbiAgICAgIG5hdkxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2xldmVsMENsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBuYXZMaW5rIG9mIHRoaXMuX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9MRVZFTDFfTElOSykpIHtcbiAgICAgIG5hdkxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2xldmVsMUNsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9sZXZlbDFDbGlja0hhbmRsZXIpXG5cbiAgICAvLyBEZXNrdG9wIHNlYXJjaCBpY29uXG4gICAgbGV0IHNlYXJjaEljb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TRUFSQ0hfSUNPTilcbiAgICBpZiAoc2VhcmNoSWNvbikge1xuICAgICAgc2VhcmNoSWNvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fc2VhcmNoQ2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgIGZvciAobGV0IHNlYXJjaCBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9TRUFSQ0hfRklFTEQpKSB7XG4gICAgICBsZXQgc2VhcmNoQ29tcG9uZW50ID0gbmV3IFNlYXJjaElucHV0KHNlYXJjaCBhcyBIVE1MRWxlbWVudClcblxuICAgICAgaWYgKERvbS5oYXNDbGFzcyhzZWFyY2gsIENMQVNTX1NFQVJDSF9ERVNLVE9QKSB8fCBEb20uaGFzQ2xhc3Moc2VhcmNoLnBhcmVudEVsZW1lbnQhLCBDTEFTU19TRUFSQ0hfREVTS1RPUCkpIHtcbiAgICAgICAgdGhpcy5fc2VhcmNoRGVza3RvcCA9IHNlYXJjaENvbXBvbmVudFxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZWFyY2hDb21wb25lbnRzLnB1c2goc2VhcmNoQ29tcG9uZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG5hdmlnYXRpb24uXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgbGV0IGlzTW9ibGUgPSB0aGlzLl9pc01vYmlsZSgpXG5cbiAgICBsZXQgbGV2ZWwxID0gdGhpcy5fbmF2TGV2ZWwxLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKSBhcyBIVE1MRWxlbWVudFxuICAgIGxldCBsZXZlbDAgPSB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfTElOS19BQ1RJVkUpIGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAoIWxldmVsMSAmJiBpc01vYmxlICYmIERvbS5oYXNDbGFzcyh0aGlzLl9oYW1idXJnZXJFbGVtZW50LCBDTEFTU19BQ1RJVkUpKSB7XG4gICAgICBsZXZlbDEgPSB0aGlzLl9oYW1idXJnZXJFbGVtZW50XG4gICAgfVxuXG4gICAgbGV0IG5hdkl0ZW1zXG5cbiAgICBpZiAobGV2ZWwxKSB7XG4gICAgICBuYXZJdGVtcyA9IG5ldyBOYXZpZ2F0aW9uSXRlbXModGhpcykuZnJvbUxldmVsMShsZXZlbDEpXG4gICAgfSBlbHNlIGlmIChsZXZlbDApIHtcbiAgICAgIG5hdkl0ZW1zID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzKS5mcm9tTGV2ZWwwKGxldmVsMClcbiAgICB9XG5cbiAgICBpZiAobmF2SXRlbXMpIHtcbiAgICAgIHRoaXMuX3Jlc2V0TWFpblRpbWVsaW5lKG5hdkl0ZW1zLmNvbnRhaW5lciEsIG5hdkl0ZW1zLnNlY3Rpb24hLCBuYXZJdGVtcy5mb290ZXIhKVxuICAgICAgRG9tLnJlbW92ZUNsYXNzKG5hdkl0ZW1zLmxpbmssIENMQVNTX0FDVElWRSlcbiAgICAgIHRoaXMuX29uTmF2aWdhdGlvbkNsb3NlZCgpXG4gICAgICB0aGlzLl9jbG9zZVNlY3Rpb24obmF2SXRlbXMuY29udGFpbmVyISwgbmF2SXRlbXMuc2VjdGlvbiEsIG5hdkl0ZW1zLmZvb3RlciwgIWlzTW9ibGUsIGZhbHNlKVxuICAgIH1cblxuICB9XG59XG5cbmNsYXNzIE5hdmlnYXRpb25JdGVtcyB7XG4gIHByaXZhdGUgX25hdmlnYXRpb246IE5hdmlnYXRpb25cbiAgcHJpdmF0ZSBfbGluayE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2NvbnRhaW5lcj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3NlY3Rpb24/OiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9mb290ZXI/OiBIVE1MRWxlbWVudFxuICBjb25zdHJ1Y3RvcihuYXY6IE5hdmlnYXRpb24pIHtcbiAgICB0aGlzLl9uYXZpZ2F0aW9uID0gbmF2XG4gIH1cblxuICBnZXQgbGluaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlua1xuICB9XG5cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyXG4gIH1cblxuICBnZXQgc2VjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VjdGlvblxuICB9XG5cbiAgZ2V0IGZvb3RlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9vdGVyXG4gIH1cblxuICBwdWJsaWMgZnJvbUxldmVsMChuYXZMaW5rOiBIVE1MRWxlbWVudCkge1xuICAgIHdoaWxlICghRG9tLmhhc0NsYXNzKG5hdkxpbmssIENMQVNTX05BVl9MSU5LKSAmJiBuYXZMaW5rLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIG5hdkxpbmsgPSBuYXZMaW5rLnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICB0aGlzLl9saW5rID0gbmF2TGlua1xuXG4gICAgbGV0IHRvZ2dsZUlkID0gbmF2TGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvZ2dsZVwiKVxuICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMEJvZHlcbiAgICB0aGlzLl9zZWN0aW9uID0gdGhpcy5fbmF2aWdhdGlvbi5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3IoYCMke3RvZ2dsZUlkfWApISBhcyBIVE1MRWxlbWVudFxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBmcm9tTGV2ZWwxKG5hdkxpbms6IEhUTUxFbGVtZW50KSB7XG4gICAgd2hpbGUgKG5hdkxpbmsucGFyZW50RWxlbWVudCkge1xuICAgICAgaWYgKChuYXZMaW5rID09PSB0aGlzLl9uYXZpZ2F0aW9uLl9oYW1idXJnZXJFbGVtZW50KSB8fCBEb20uaGFzQ2xhc3MobmF2TGluaywgQ0xBU1NfTkFWX0xJTkspKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIG5hdkxpbmsgPSBuYXZMaW5rLnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICB0aGlzLl9saW5rID0gbmF2TGlua1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IG5hdkxpbmsucGFyZW50RWxlbWVudCEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9zZWN0aW9uID0gdGhpcy5fY29udGFpbmVyIS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9CT0RZKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9mb290ZXIgPSB0aGlzLl9jb250YWluZXIhLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0ZPT1RFUikhIGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAobmF2TGluayA9PT0gdGhpcy5fbmF2aWdhdGlvbi5faGFtYnVyZ2VyRWxlbWVudCkge1xuICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fbmF2aWdhdGlvbi5fbmF2TGV2ZWwxXG4gICAgICB0aGlzLl9zZWN0aW9uID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0hCX0JPRFkpISBhcyBIVE1MRWxlbWVudFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgcHJldmlvdXNMZXZlbDEoKSB7XG4gICAgbGV0IHByZXYgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMuX25hdmlnYXRpb24pXG5cbiAgICBwcmV2Ll9saW5rID0gdGhpcy5fbmF2aWdhdGlvbi5fbmF2TGV2ZWwxLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKSEgYXMgSFRNTEVsZW1lbnRcbiAgICBwcmV2Ll9jb250YWluZXIgPSBwcmV2Ll9saW5rID8gcHJldi5fbGluay5wYXJlbnRFbGVtZW50ISA6IHVuZGVmaW5lZFxuICAgIHByZXYuX3NlY3Rpb24gPSBwcmV2Ll9jb250YWluZXIgPyBwcmV2Ll9jb250YWluZXIucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfQk9EWSkhIGFzIEhUTUxFbGVtZW50IDogdW5kZWZpbmVkXG4gICAgcHJldi5fZm9vdGVyID0gcHJldi5fY29udGFpbmVyID8gcHJldi5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0ZPT1RFUikhIGFzIEhUTUxFbGVtZW50IDogdW5kZWZpbmVkXG5cbiAgICByZXR1cm4gcHJldlxuICB9XG5cbiAgcHVibGljIGlzSGFtYnVyZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5rID09PSB0aGlzLl9uYXZpZ2F0aW9uLl9oYW1idXJnZXJFbGVtZW50XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIubmF2XCIsIChlKSA9PiB7XG4gICAgbmV3IE5hdmlnYXRpb24oZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdGlvblxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcbmltcG9ydCB7IGhhc0NsYXNzLCBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcImlzLWFjdGl2ZVwiXG5cbmNvbnN0IFFVRVJZX1NJVEVfV1JBUFBFUiA9IFwiLmpzLXNpdGUtd3JhcHBlclwiXG5jb25zdCBRVUVSWV9OQVZfSEFNQlVSR0VSID0gXCIuanMtc2l0ZS13cmFwcGVyIC5qcy1oYW1idXJnZXJcIlxuXG5jb25zdCBRVUVSWV9OQVZfSVRFTSA9IFwiLmpzLW5hdi1pdGVtXCJcblxuY29uc3QgTkFWX0xJTktfSU5JVElBTF9TQ0FMRSA9IDAuOVxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OX0xJTktTID0gMTAwXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT05fTkFWID0gMzAwXG5cbmNvbnN0IEFOSU1BVElPTl9TVEFHR0VSX0RFTEFZID0gNTBcblxuLyoqXG4gKiBUaGUgbmF2aWdhdGlvbiBzaWRlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBOYXZpZ2F0aW9uU2lkZSBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfc2l0ZVdyYXBwZXI6IEVsZW1lbnRcbiAgcHJpdmF0ZSBfaGFtYnVyZ2VyRWxlbWVudDogRWxlbWVudFxuICBwcml2YXRlIF9uYXZJdGVtczogTm9kZUxpc3RPZjxFbGVtZW50PlxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX3NpdGVXcmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TSVRFX1dSQVBQRVIpIVxuICAgIHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9IQU1CVVJHRVIpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICB0aGlzLl9uYXZJdGVtcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9JVEVNKSFcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIHRoaXMudG9nZ2xlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBFbGVtZW50XG5cbiAgICB3aGlsZSAodGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgc2lkZSBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgc2xpZGUgbmF2aWdhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBvcGVuKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB9LCA1MClcblxuICAgIGFkZENsYXNzKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIENMQVNTX0FDVElWRSlcbiAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG4gICAgYWRkQ2xhc3ModGhpcy5fc2l0ZVdyYXBwZXIsIENMQVNTX09QRU4pXG5cbiAgICBjb25zdCB4ID0gYW5pbWUudGltZWxpbmUoKVxuICAgIGxldCBvZmYgPSBBTklNQVRJT05fRFVSQVRJT05fTkFWXG4gICAgdGhpcy5fbmF2SXRlbXMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgZWwgPSBlbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gXCIwXCJcbiAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke05BVl9MSU5LX0lOSVRJQUxfU0NBTEV9KWBcbiAgICAgIHguYWRkKHtcbiAgICAgICAgdGFyZ2V0czogZWwsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT05fTElOS1MsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBlYXNpbmc6IFwibGluZWFyXCIsXG4gICAgICAgIG9mZnNldDogb2ZmXG4gICAgICB9KVxuICAgICAgb2ZmICs9IEFOSU1BVElPTl9TVEFHR0VSX0RFTEFZXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHNpZGUgbmF2aWdhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHJlbW92ZUNsYXNzKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIENMQVNTX0FDVElWRSlcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5fc2l0ZVdyYXBwZXIsIENMQVNTX09QRU4pXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnRcbiAgICogc3Vic2NyaXB0aW9ucyBhbmQgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKTtcblxuICAgICh0aGlzIGFzIGFueSkuX3dpbmRvd0NsaWNrSGFuZGxlciA9IG51bGw7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9jbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3NpdGVXcmFwcGVyID0gbnVsbDtcblxuICAgICh0aGlzIGFzIGFueSkuX2hhbWJ1cmdlckVsZW1lbnQgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX25hdkl0ZW1zID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLm5hdi1zaWRlXCIsIChlKSA9PiB7XG4gICAgbmV3IE5hdmlnYXRpb25TaWRlKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRpb25TaWRlXG4iLCJpbXBvcnQgeyBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX05PVElGSUNBVElPTiA9IFwibm90aWZpY2F0aW9uLWhlYWRlclwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcIm5vdGlmaWNhdGlvbi0tb3BlblwiXG5jb25zdCBDTEFTU19CVVRUT05fQ0xPU0UgPSBcIm5vdGlmaWNhdGlvbl9fY2xvc2VcIlxuXG4vKipcbiAqIE5vdGlmaWNhdGlvbiBjb21wb25lbnQuXG4gKiBAbmFtZXNwYWNlIE5vdGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogVGhlIG1lc3NhZ2UgY2xpY2sgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAbWVtYmVyb2YgTm90aWZpY2F0aW9uXG4gKiBAY2FsbGJhY2sgTm90aWZpY2F0aW9ufkNsaWNrXG4gKiBAcHJvcGVydHkge05vdGlmaWNhdGlvbkhlYWRlcn0gaXRlbSAtIFRoZSBjdXJyZW50IG5vdGlmaWNhdGlvbiBoZWFkZXIgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIHRydWUgaWYgdGhlIG5vdGlmaWNhdGlvbiBzaG91bGQgYmUgY2xvc2VkOyByZXR1cm4gZmFsc2UgaWYgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uIHNob3VsZCByZW1haW4gb3Blbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQ2xpY2tDYWxsYmFjayB7XG4gIChoZWFkZXI6IE5vdGlmaWNhdGlvbkhlYWRlcik6IGJvb2xlYW4gfCB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBUaGUgY2FuY2VsIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQG1lbWJlcm9mIE5vdGlmaWNhdGlvblxuICogQGNhbGxiYWNrIE5vdGlmaWNhdGlvbn5DYW5jZWxcbiAqIEBwcm9wZXJ0eSB7Tm90aWZpY2F0aW9uSGVhZGVyfSBpdGVtIC0gVGhlIGN1cnJlbnQgbm90aWZpY2F0aW9uIGhlYWRlciBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxDYWxsYmFjayB7XG4gIChoZWFkZXI6IE5vdGlmaWNhdGlvbkhlYWRlcik6IHZvaWRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBzaG93cyBhIG5vdGlmaWNhdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZS5cbiAqIEBtZW1iZXJvZiBOb3RpZmljYXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250YWluZXJJZCAtIFRoZSBpZCBvZiB0aGUgY29udGFpbmVyIG9uIHdoZXJlIHRvIHNob3cgdGhlIG5vdGlmaWNhdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gc2hvdy5cbiAqIEBwYXJhbSB7Tm90aWZpY2F0aW9ufkNsaWNrfSBtZXNzYWdlQ2xpY2tDYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZSB0ZXh0LlxuICogQHBhcmFtIHtOb3RpZmljYXRpb25+Q2FuY2VsfSBjYW5jZWxDYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgbm90aWZpY2F0aW9uIGJ5IGNsb3NpbmcgaXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJDbGFzcyAtIFRoZSBjc3MgbW9kaWZpZXIgY2xhc3MgZm9yIHRoZSBub3RpZmljYXRpb247IHRoaXMgaXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyXG4gKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9uSGVhZGVyfSBUaGUgbm90aWZpY2F0aW9uIGhlYWRlciBpdGVtIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvd09uSGVhZGVyKFxuICBjb250YWluZXJJZDogc3RyaW5nLFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIG1lc3NhZ2VDbGlja0NhbGxiYWNrPzogTWVzc2FnZUNsaWNrQ2FsbGJhY2ssXG4gIGNhbmNlbENhbGxiYWNrPzogQ2FuY2VsQ2FsbGJhY2ssXG4gIG1vZGlmaWVyQ2xhc3M/OiBzdHJpbmdcbikge1xuXG4gIGNvbnN0IGNvbnRhaW5lckUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtjb250YWluZXJJZH1gKVxuICBpZiAoIWNvbnRhaW5lckUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHRoZSBjb250YWluZXIgd2l0aCBpZCAke2NvbnRhaW5lcklkfWApXG4gIH1cblxuICBjb25zdCBjb250YWluZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoY29udGFpbmVyRSlcbiAgY29uc3Qgbm90aWZpY2F0aW9uRWxlbWVudCA9IG5ldyBOb3RpZmljYXRpb25IZWFkZXIoKVxuXG4gIGlmIChtb2RpZmllckNsYXNzKSB7XG4gICAgbm90aWZpY2F0aW9uRWxlbWVudC5hZGRDbGFzcyhtb2RpZmllckNsYXNzKVxuICB9XG5cbiAgbm90aWZpY2F0aW9uRWxlbWVudC5tZXNzYWdlID0gbWVzc2FnZVxuICBub3RpZmljYXRpb25FbGVtZW50Lm1lc3NhZ2VDbGlja0NhbGxiYWNrID0gbWVzc2FnZUNsaWNrQ2FsbGJhY2tcbiAgbm90aWZpY2F0aW9uRWxlbWVudC5jYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrXG5cbiAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChub3RpZmljYXRpb25FbGVtZW50KVxuICBub3RpZmljYXRpb25FbGVtZW50Ll9vcGVuKClcblxuICByZXR1cm4gbm90aWZpY2F0aW9uRWxlbWVudFxufVxuXG4vKipcbiAqIEEgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIG5vdGlmaWNhdGlvbnMgb24gdGhlIHBhZ2UtaGVhZGVyLlxuICogQGlubmVyXG4gKiBAbWVtYmVyb2YgTm90aWZpY2F0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb25IZWFkZXIgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfY2xvc2VIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2NsaWNrSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2NhbGxiYWNrPzogTWVzc2FnZUNsaWNrQ2FsbGJhY2tcbiAgcHJpdmF0ZSBfY2FuY2VsQ2FsbGJhY2s/OiBDYW5jZWxDYWxsYmFja1xuXG4gIHByaXZhdGUgX2Nsb3NlQnV0dG9uITogRG9tRWxlbWVudDxFbGVtZW50PlxuICBwcml2YXRlIF9ub3RpZmljYXRpb25Cb2R5ITogRG9tRWxlbWVudDxFbGVtZW50PlxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiZGl2XCIpXG5cbiAgICB0aGlzLl9jbG9zZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHJhbmdlIG1vZGFsIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX05PVElGSUNBVElPTilcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX09QRU4pXG5cbiAgICBjb25zdCBub3RpZmljYXRpb25Db250ZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhcIm5vdGlmaWNhdGlvbl9fY29udGVudFwiKVxuXG4gICAgdGhpcy5hcHBlbmRDaGlsZChub3RpZmljYXRpb25Db250ZW50KVxuXG4gICAgdGhpcy5fbm90aWZpY2F0aW9uQm9keSA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoXCJub3RpZmljYXRpb25fX2JvZHlcIilcblxuICAgIG5vdGlmaWNhdGlvbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5fbm90aWZpY2F0aW9uQm9keSlcblxuICAgIHRoaXMuX2Nsb3NlQnV0dG9uID0gbmV3IERvbUVsZW1lbnQoXCJidXR0b25cIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19CVVRUT05fQ0xPU0UpXG4gICAgICAuYWRkQ2xhc3MoXCJub3RpZmljYXRpb24tY2FuY2VsXCIpXG4gICAgICAuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIkNsb3NlXCIpXG5cbiAgICBjb25zdCBjbG9zZUljb24gPSBuZXcgRG9tRWxlbWVudChcImlcIilcbiAgICAgIC5hZGRDbGFzcyhcImljb25cIilcbiAgICAgIC5hZGRDbGFzcyhcImljb24tMDIyLWNsb3NlXCIpXG4gICAgICAuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpXG5cbiAgICB0aGlzLl9jbG9zZUJ1dHRvbi5hcHBlbmRDaGlsZChjbG9zZUljb24pXG4gICAgbm90aWZpY2F0aW9uQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLl9jbG9zZUJ1dHRvbilcblxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcblxuICAgIGxldCBjbG9zZU5vdGlmaWNhdGlvbiA9IHRydWVcbiAgICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICAgIGlmICh0aGlzLl9jYWxsYmFjayh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY2xvc2VOb3RpZmljYXRpb24gPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbG9zZU5vdGlmaWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbG9zZShldmVudDogRXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKHRoaXMuX2NhbmNlbENhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9jYW5jZWxDYWxsYmFjayh0aGlzKVxuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9zZSgpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG4gICAgdGhpcy5fY2xvc2VCdXR0b24uZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xvc2VIYW5kbGVyKVxuXG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBkb21cbiAgICAgIGlmIChlbCAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWwpXG4gICAgICB9XG4gICAgfSwgMzAwKVxuICB9XG5cbiAgLy8gY2FsbGVkIGJ5IHNob3dPbkhlYWRlclxuICBwdWJsaWMgX29wZW4oKSB7XG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuXG4gICAgdGhpcy5fY2xvc2VCdXR0b24uZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xvc2VIYW5kbGVyKVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcIm9wZW5lZFwiKVxuICB9XG5cbiAgc2V0IG1lc3NhZ2VDbGlja0NhbGxiYWNrKGNhbGxiYWNrOiBNZXNzYWdlQ2xpY2tDYWxsYmFjayB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjYW5jZWwgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAqL1xuICBzZXQgY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2s6IENhbmNlbENhbGxiYWNrIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fY2FuY2VsQ2FsbGJhY2sgPSBjYWxsYmFja1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vdGlmaWNhdGlvbiBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gLSBUaGUgbWVzc2FnZSB0byBzZXQuXG4gICAqL1xuICBzZXQgbWVzc2FnZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fbm90aWZpY2F0aW9uQm9keS5zZXRIdG1sKHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbm90aWZpY2F0aW9uLlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMuX2Nsb3NlKClcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjbG9zZWRcIilcbiAgfVxufVxuIiwiaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIGNsYW1wLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX0hFQURFUiA9IFwiLnByb2dyZXNzLWZ1bGxfX2JhclwiXG5jb25zdCBDTEFTU19TRUNUSU9OUyA9IFwiLnByb2dyZXNzLWZ1bGxfX3NlY3Rpb25zID4gc3BhblwiXG5jb25zdCBDTEFTU19TRUNUSU9OX0FDVElWRSA9IFwic2VjdGlvbi0tYWN0aXZlXCJcblxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SID0gXCJpbmRpY2F0b3JcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQgPSBcImluZGljYXRvci0tY3VycmVudFwiXG5jb25zdCBDTEFTU19JTkRJQ0FUT1JfQ09NUExFVEVEID0gXCJpbmRpY2F0b3ItLWNvbXBsZXRlZFwiXG5cbi8qKlxuICogRnVsbCBwcm9ncmVzcyBiYXIgY29tcG9uZW50XG4gKi9cbmNsYXNzIFByb2dyZXNzRnVsbCBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9idXR0b25DbGlja0hhbmRsZXIhOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXIhOiAoZTogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9oZWFkZXJFbGVtZW50ITogRG9tRWxlbWVudDxFbGVtZW50PlxuICBwcml2YXRlIF9wYWdlcyE6IE5vZGVMaXN0T2Y8RWxlbWVudD5cblxuICBwcml2YXRlIF9taW5WYWx1ZSE6IG51bWJlclxuICBwcml2YXRlIF92YWx1ZSE6IG51bWJlclxuICBwcml2YXRlIF90b3RhbCE6IG51bWJlclxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgUHJvZ3Jlc3NGdWxsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIFByb2dyZXNzRnVsbCBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbG9hZGVyIGJhciBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQnV0dG9uQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9oZWFkZXJFbGVtZW50ID0gdGhpcy5maW5kKENMQVNTX0hFQURFUikhXG5cbiAgICB0aGlzLl9wYWdlcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX1NFQ1RJT05TKVxuXG4gICAgdGhpcy5fbWluVmFsdWUgPSAxXG4gICAgdGhpcy5fdmFsdWUgPSAxXG4gICAgdGhpcy5fdG90YWwgPSB0aGlzLl9wYWdlcy5sZW5ndGhcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9wYWdlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmICh0aGlzLl9wYWdlc1tpbmRleF0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX1NFQ1RJT05fQUNUSVZFKSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGluZGV4ICsgMVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2FkZEluY2ljYXRvcnMoKVxuICAgIHRoaXMuX3VwZGF0ZSgtMSwgdGhpcy5fdmFsdWUsIGZhbHNlKVxuXG4gICAgLy8gQXBwbHkgdGhlIHRhYiBpbmRleFxuICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKVxuICAgIGlmICh0YWJJbmRleCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIlwiKVxuICAgICAgdGhpcy5faGVhZGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCB0YWJJbmRleClcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFkZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgICB0aGlzLl9oZWFkZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZEluY2ljYXRvcnMoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX3BhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgaW5kaWNhdG9yRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiYnV0dG9uXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1IpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIGAke2kgKyAxfWApXG4gICAgICAgIC5zZXRIdG1sKChpICsgMSkudG9TdHJpbmcoKSlcblxuICAgICAgdGhpcy5faGVhZGVyRWxlbWVudC5wcmVwZW5kQ2hpbGQoaW5kaWNhdG9yRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZShvbGRWYWx1ZTogbnVtYmVyLCBuZXdWYWx1ZTogbnVtYmVyLCBhbmltYXRlID0gdHJ1ZSkge1xuICAgIGxldCBpbmRpY2F0b3JzID0gdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmNoaWxkTm9kZXNcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpbmRpY2F0b3JzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgbGV0IGluZGljYXRvckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChpbmRpY2F0b3JzW2luZGV4XSBhcyBFbGVtZW50KVxuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgaW5kaWNhdG9yRWxlbWVudFxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19JTkRJQ0FUT1JfQ1VSUkVOVClcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRClcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICsgMSA9PT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgaW5kaWNhdG9yRWxlbWVudFxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19JTkRJQ0FUT1JfQ09NUExFVEVEKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfQ1VSUkVOVClcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICsgMSA+IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIGluZGljYXRvckVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRClcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgbGV0IGRpcmVjdGlvbiA9IE1hdGguc2lnbihvbGRWYWx1ZSAtIG5ld1ZhbHVlKVxuXG4gICAgICBpZiAob2xkVmFsdWUgPiAwICYmIG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgb2xkU2VjdGlvbiA9IG5ldyBEb21FbGVtZW50KHRoaXMuX3BhZ2VzW29sZFZhbHVlIC0gMV0pXG5cbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICBhbmltZSh7XG4gICAgICAgICAgICB0YXJnZXRzOiBvbGRTZWN0aW9uLmVsZW1lbnQsXG4gICAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgbGVmdDogMTAwICogZGlyZWN0aW9uLFxuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgb2xkU2VjdGlvbi5yZW1vdmVDbGFzcyhDTEFTU19TRUNUSU9OX0FDVElWRSlcbiAgICAgICAgICAgICAgb2xkU2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkU2VjdGlvbi5yZW1vdmVDbGFzcyhDTEFTU19TRUNUSU9OX0FDVElWRSlcbiAgICAgICAgICBvbGRTZWN0aW9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IG5ld1NlY3Rpb24gPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9wYWdlc1tuZXdWYWx1ZSAtIDFdKVxuXG4gICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICBjb25zdCBlbCA9IG5ld1NlY3Rpb24uZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gYCR7LTEwMCAqIGRpcmVjdGlvbn1weGBcbiAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IFwiMFwiXG4gICAgICAgIG5ld1NlY3Rpb24uYWRkQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgIGFuaW1lKHtcbiAgICAgICAgICB0YXJnZXRzOiBuZXdTZWN0aW9uLmVsZW1lbnQsXG4gICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIG5ld1NlY3Rpb24uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdTZWN0aW9uLmFkZENsYXNzKENMQVNTX1NFQ1RJT05fQUNUSVZFKVxuICAgICAgICBuZXdTZWN0aW9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVCdXR0b25DbGljayhldmVudDogRXZlbnQpIHtcbiAgICBsZXQgZWxlbWVudCA9IG5ldyBEb21FbGVtZW50KGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KVxuICAgIGlmICghZWxlbWVudC5oYXNDbGFzcyhDTEFTU19JTkRJQ0FUT1IpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIilcbiAgICB0aGlzLnZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSEpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEV2ZW50KSB7XG4gICAgY29uc3Qga2V5Ym9hcmRFdmVudCA9IGV2ZW50IGFzIEtleWJvYXJkRXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGtleWJvYXJkRXZlbnQud2hpY2ggfHwga2V5Ym9hcmRFdmVudC5rZXlDb2RlXG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19SSUdIVCkge1xuICAgICAgdGhpcy52YWx1ZSsrXG5cbiAgICAgIHByZXZlbnREZWZhdWx0KGtleWJvYXJkRXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19MRUZUKSB7XG4gICAgICB0aGlzLnZhbHVlLS1cblxuICAgICAgcHJldmVudERlZmF1bHQoa2V5Ym9hcmRFdmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChrZXljb2RlID49IElucHV0cy5LRVlfTlJfMCAmJiBrZXljb2RlIDw9IElucHV0cy5LRVlfTlJfOSkge1xuICAgICAgdGhpcy52YWx1ZSA9IGtleWNvZGUgLSBJbnB1dHMuS0VZX05SXzBcbiAgICAgIHByZXZlbnREZWZhdWx0KGtleWJvYXJkRXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBwcm9ncmVzcyB2YWx1ZSBpbiB0aGUgcmFuZ2Ugb2YgMS4udG90YWwuXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBwcm9ncmVzcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IC0gVGhlIHByb2dyZXNzIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIHNldCB2YWx1ZSh2YWw6IG51bWJlcikge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fdmFsdWVcblxuICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAodmFsLCB0aGlzLl9taW5WYWx1ZSwgdGhpcy5fdG90YWwpXG4gICAgdGhpcy5fdXBkYXRlKG9sZFZhbHVlLCB0aGlzLl92YWx1ZSwgdHJ1ZSlcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZWRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0b3RhbCBwcm9ncmVzcyB2YWx1ZS5cbiAgICovXG4gIGdldCB0b3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5wcm9ncmVzcy1mdWxsXCIsIChlKSA9PiB7XG4gICAgbmV3IFByb2dyZXNzRnVsbChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm9ncmVzc0Z1bGxcbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBjbGFtcCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX0JBUiA9IFwiLnByb2dyZXNzLWxpZ2h0X19iYXJcIlxuY29uc3QgQ0xBU1NfUFJPR1JFU1MgPSBcIi5iYXJfX3Byb2dyZXNzXCJcbmNvbnN0IENMQVNTX1BST0dSRVNTX0NPTVBMRVRFRCA9IFwiYmFyX19wcm9ncmVzcy0tY29tcGxldGVcIlxuY29uc3QgQ0xBU1NfVElDSyA9IFwiYmFyX190aWNrXCJcbmNvbnN0IENMQVNTX1BBR0VfQ1VSUkVOVCA9IFwiLmRldGFpbF9fY3VycmVudHBhZ2VcIlxuY29uc3QgQ0xBU1NfUEFHRV9UT1RBTCA9IFwiLmRldGFpbF9fdG90YWxwYWdlXCJcblxuY29uc3QgQ0xBU1NfRElTQUJMRUQgPSBcImFycm93LS1kaXNhYmxlZFwiXG5jb25zdCBDTEFTU19CVVRUT05fTEVGVCA9IFwiLmFycm93LS1sZWZ0XCJcbmNvbnN0IENMQVNTX0JVVFRPTl9SSUdIVCA9IFwiLmFycm93LS1yaWdodFwiXG5cbi8qKlxuICogTGlnaHQgcHJvZ3Jlc3MgYmFyIGNvbXBvbmVudFxuICovXG5jbGFzcyBQcm9ncmVzc0xpZ2h0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2J1dHRvbkNsaWNrSGFuZGxlciE6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYW5pbWF0aW9uQ29tcGxldGVkSGFuZGxlciE6IChldmVudDogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9iYXJFbGVtZW50ITogRG9tRWxlbWVudDxFbGVtZW50PlxuICBwcml2YXRlIF9wcm9ncmVzc0VsZW1lbnQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX3BhZ2VDdXJyZW50RWxlbWVudCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfcGFnZVRvdGFsRWxlbWVudCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfYnV0dG9uTGVmdCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfYnV0dG9uUmlnaHQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG5cbiAgcHJpdmF0ZSBfbWluVmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdG90YWwhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdmFsdWUhOiBudW1iZXJcblxuICBwcml2YXRlIF9pdGVtV2lkdGg/OiBudW1iZXJcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIFByb2dyZXNzTGlnaHQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgUHJvZ3Jlc3NMaWdodCBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbG9hZGVyIGJhciBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG5cbiAgICB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVCdXR0b25DbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fYW5pbWF0aW9uQ29tcGxldGVkSGFuZGxlciA9IHRoaXMuX2hhbmRsZUFuaW1hdGlvbkNvbXBsZXRlZC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9iYXJFbGVtZW50ID0gdGhpcy5maW5kKENMQVNTX0JBUikhXG4gICAgdGhpcy5fcHJvZ3Jlc3NFbGVtZW50ID0gdGhpcy5maW5kKENMQVNTX1BST0dSRVNTKSFcbiAgICB0aGlzLl9wYWdlQ3VycmVudEVsZW1lbnQgPSB0aGlzLmZpbmQoQ0xBU1NfUEFHRV9DVVJSRU5UKSFcbiAgICB0aGlzLl9wYWdlVG90YWxFbGVtZW50ID0gdGhpcy5maW5kKENMQVNTX1BBR0VfVE9UQUwpIVxuICAgIHRoaXMuX2J1dHRvbkxlZnQgPSB0aGlzLmZpbmQoQ0xBU1NfQlVUVE9OX0xFRlQpIVxuICAgIHRoaXMuX2J1dHRvblJpZ2h0ID0gdGhpcy5maW5kKENMQVNTX0JVVFRPTl9SSUdIVCkhXG5cbiAgICB0aGlzLl9taW5WYWx1ZSA9IDFcbiAgICB0aGlzLl90b3RhbCA9IE1hdGgubWF4KHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKFwidG90YWxcIikgfHwgXCIxMDBcIiwgMTApLCB0aGlzLl9taW5WYWx1ZSlcbiAgICB0aGlzLl92YWx1ZSA9IGNsYW1wKHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCIxXCIsIDEwKSwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX3RvdGFsKVxuXG4gICAgdGhpcy5fbGF5b3V0KClcblxuICAgIHRoaXMuX2FkZFRpY2tzKClcbiAgICB0aGlzLl91cGRhdGUoZmFsc2UpXG5cbiAgICB0aGlzLmVuYWJsZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZFRpY2tzKCkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fdG90YWw7IGkrKykge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9pdGVtV2lkdGghICogaVxuXG4gICAgICBsZXQgdGlja0VsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVElDSylcbiAgICAgICAgLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBsZWZ0OiAke3Bvc2l0aW9ufSVgKVxuXG4gICAgICB0aGlzLl9iYXJFbGVtZW50LnByZXBlbmRDaGlsZCh0aWNrRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZShhbmltYXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuX3BhZ2VDdXJyZW50RWxlbWVudC5zZXRIdG1sKHRoaXMuX3ZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdGhpcy5fcGFnZVRvdGFsRWxlbWVudC5zZXRIdG1sKHRoaXMuX3RvdGFsLnRvU3RyaW5nKCkpXG5cbiAgICBsZXQgcG9zaXRpb24gPSB0aGlzLl92YWx1ZSAqIHRoaXMuX2l0ZW1XaWR0aCFcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIHdpZHRoIHRvIHRoZSBsYXN0IGVsZW1lbnQgdG8gbWFrZSBzdXJlXG4gICAgLy8gdGhlIHJvdW5kZWQgYm9yZGVyIG9uIHRoZSBsZWZ0IGlzIGZpbGxlZCBhcyB3ZWxsXG4gICAgaWYgKHRoaXMuX3ZhbHVlID09PSB0aGlzLl90b3RhbCkge1xuICAgICAgcG9zaXRpb24gKz0gNVxuICAgIH1cblxuICAgIGlmICh0aGlzLl92YWx1ZSA+PSB0aGlzLl90b3RhbCkge1xuICAgICAgdGhpcy5fYnV0dG9uUmlnaHQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1dHRvblJpZ2h0LnJlbW92ZUNsYXNzKENMQVNTX0RJU0FCTEVEKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl92YWx1ZSA8PSB0aGlzLl9taW5WYWx1ZSkge1xuICAgICAgdGhpcy5fYnV0dG9uTGVmdC5hZGRDbGFzcyhDTEFTU19ESVNBQkxFRClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnV0dG9uTGVmdC5yZW1vdmVDbGFzcyhDTEFTU19ESVNBQkxFRClcbiAgICB9XG5cbiAgICBjb25zdCBlbCA9IHRoaXMuX3Byb2dyZXNzRWxlbWVudC5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgIGFuaW1lKHtcbiAgICAgICAgdGFyZ2V0czogdGhpcy5fcHJvZ3Jlc3NFbGVtZW50LmVsZW1lbnQsXG4gICAgICAgIGR1cmF0aW9uOiAyMDAsXG4gICAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgICB3aWR0aDogdGhpcy5fYmFyRWxlbWVudC5lbGVtZW50LmNsaWVudFdpZHRoICogcG9zaXRpb24gLyAxMDAsXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBgJHtwb3NpdGlvbn0lYFxuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbXBsZXRlZEhhbmRsZXIoPEV2ZW50Pnt9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS53aWR0aCA9IGAke3Bvc2l0aW9ufSVgXG4gICAgICB0aGlzLl9hbmltYXRpb25Db21wbGV0ZWRIYW5kbGVyKDxFdmVudD57fSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2xheW91dCgpIHtcbiAgICB0aGlzLl9pdGVtV2lkdGggPSBNYXRoLmZsb29yKDEwMCAvIHRoaXMuX3RvdGFsKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVCdXR0b25DbGljayhldmVudDogRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9idXR0b25MZWZ0LmVsZW1lbnQpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl92YWx1ZSAtIDFcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fYnV0dG9uUmlnaHQuZWxlbWVudCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX3ZhbHVlICsgMVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQW5pbWF0aW9uQ29tcGxldGVkKCkge1xuICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gdGhpcy5fdG90YWwpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzRWxlbWVudC5hZGRDbGFzcyhDTEFTU19QUk9HUkVTU19DT01QTEVURUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19QUk9HUkVTU19DT01QTEVURUQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgdmFsdWUgaW4gdGhlIHJhbmdlIG9mIDEuLnRvdGFsLlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAtIFRoZSBwcm9ncmVzcyBpbiB0aGUgcmFuZ2Ugb2YgMS4udG90YWwuXG4gICAqL1xuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBjbGFtcCh2YWwsIHRoaXMuX21pblZhbHVlLCB0aGlzLl90b3RhbClcbiAgICB0aGlzLl91cGRhdGUodHJ1ZSlcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZWRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0b3RhbCBwcm9ncmVzcyB2YWx1ZS5cbiAgICovXG4gIGdldCB0b3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0b3RhbCBwcm9ncmVzcyB2YWx1ZSBhbmQgdXBkYXRlcyB0aGUgVUkgYWNjb3JkaW5nbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAtIFRoZSB0b3RhbCBwcm9ncmVzcyBwb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlLlxuICAgKi9cbiAgc2V0IHRvdGFsKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3RvdGFsID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fdG90YWwgPSBNYXRoLm1heCh2YWx1ZSwgdGhpcy5fbWluVmFsdWUpXG4gICAgdGhpcy5fdmFsdWUgPSBjbGFtcCh0aGlzLl92YWx1ZSwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX3RvdGFsKVxuXG4gICAgLy8gQ2xlYXIgdGhlIHRpY2tzXG4gICAgZm9yIChsZXQgdGljayBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVElDS31gKSkge1xuICAgICAgdGhpcy5fYmFyRWxlbWVudC5lbGVtZW50LnJlbW92ZUNoaWxkKHRpY2spXG4gICAgfVxuXG4gICAgdGhpcy5fbGF5b3V0KClcbiAgICB0aGlzLl9hZGRUaWNrcygpXG5cbiAgICB0aGlzLl91cGRhdGUoZmFsc2UpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJ0b3RhbGNoYW5nZWRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBwdWJsaWMgZW5hYmxlKCkge1xuICAgIHRoaXMuX2J1dHRvbkxlZnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyKVxuICAgIHRoaXMuX2J1dHRvblJpZ2h0LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgcHVibGljIGRpc2FibGUoKSB7XG4gICAgdGhpcy5fYnV0dG9uTGVmdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gICAgdGhpcy5fYnV0dG9uUmlnaHQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLnByb2dyZXNzLWxpZ2h0XCIsIChlKSA9PiB7XG4gICAgbmV3IFByb2dyZXNzTGlnaHQoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvZ3Jlc3NMaWdodFxuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vVXRpbHNcIlxuXG5pbXBvcnQgTG9hZGVyQmFyLCB7IGluaXQgYXMgaW5pdExvYWRlckJhciB9IGZyb20gXCIuL2xvYWRlci9Mb2FkZXJCYXJcIlxuXG4vKiBGb3JtIENvbXBvbmVudHMgKi9cbmltcG9ydCBJbnB1dEZpZWxkLCB7IGluaXQgYXMgaW5pdElucHV0RmllbGQgfSBmcm9tIFwiLi9mb3JtL0lucHV0RmllbGRcIlxuaW1wb3J0IFRleHRhcmVhLCB7IGluaXQgYXMgaW5pdFRleHRhcmVhIH0gZnJvbSBcIi4vZm9ybS9UZXh0YXJlYVwiXG5pbXBvcnQgU2VsZWN0LCB7IGluaXQgYXMgaW5pdFNlbGVjdCB9IGZyb20gXCIuL2Zvcm0vU2VsZWN0XCJcbmltcG9ydCBSYW5nZSwgeyBpbml0IGFzIGluaXRSYW5nZSB9IGZyb20gXCIuL2Zvcm0vUmFuZ2VcIlxuaW1wb3J0IEF1dG9jb21wbGV0ZSwgeyBpbml0IGFzIGluaXRBdXRvY29tcGxldGUgfSBmcm9tIFwiLi9mb3JtL0F1dG9jb21wbGV0ZVwiXG5cbmltcG9ydCBQcm9ncmVzc0xpZ2h0LCB7IGluaXQgYXMgaW5pdFByb2dyZXNzTGlnaHQgfSBmcm9tIFwiLi9wcm9ncmVzcy9Qcm9ncmVzc0xpZ2h0XCJcbmltcG9ydCBQcm9ncmVzc0Z1bGwsIHsgaW5pdCBhcyBpbml0UHJvZ3Jlc3NGdWxsIH0gZnJvbSBcIi4vcHJvZ3Jlc3MvUHJvZ3Jlc3NGdWxsXCJcblxuaW1wb3J0IE1vZGFsLCB7IGluaXQgYXMgaW5pdE1vZGFsIH0gZnJvbSBcIi4vbW9kYWwvTW9kYWxcIlxuaW1wb3J0IFRvb2xiYXIgZnJvbSBcIi4vdG9vbGJhci9Ub29sYmFyXCJcblxuaW1wb3J0ICogYXMgTm90aWZpY2F0aW9uIGZyb20gXCIuL25vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb25cIlxuXG5pbXBvcnQgQ29sbGFwc2UsIHsgaW5pdCBhcyBpbml0Q29sbGFwc2UgfSBmcm9tIFwiLi9jb2xsYXBzZS9Db2xsYXBzZVwiXG5pbXBvcnQgQWNjb3JkaW9uLCB7IGluaXQgYXMgaW5pdEFjY29yZGlvbiB9IGZyb20gXCIuL2FjY29yZGlvbi9BY2NvcmRpb25cIlxuaW1wb3J0IE1lbnVGbHlvdXQsIHsgaW5pdCBhcyBpbml0TWVudUZseW91dCB9IGZyb20gXCIuL21lbnUvTWVudUZseW91dFwiXG5cbmltcG9ydCBOYXZpZ2F0aW9uLCB7IGluaXQgYXMgaW5pdE5hdmlnYXRpb24gfSBmcm9tIFwiLi9uYXZpZ2F0aW9uL05hdmlnYXRpb25cIlxuaW1wb3J0IE5hdmlnYXRpb25TaWRlLCB7IGluaXQgYXMgaW5pdE5hdmlnYXRpb25TaWRlIH0gZnJvbSBcIi4vbmF2aWdhdGlvbi9OYXZpZ2F0aW9uU2lkZVwiXG5pbXBvcnQgU2VhcmNoSW5wdXQsIHsgaW5pdCBhcyBpbml0U2VhcmNoSW5wdXQgfSBmcm9tIFwiLi9zZWFyY2gvU2VhcmNoSW5wdXRcIlxuaW1wb3J0IEVtcHR5U3RhdGUsIHsgaW5pdCBhcyBpbml0RW1wdHlTdGF0ZSB9IGZyb20gXCIuL2VtcHR5LXN0YXRlcy9FbXB0eVN0YXRlXCJcbmltcG9ydCBDYXJvdXNlbCwgeyBpbml0IGFzIGluaXRDYXJvdXNlbCB9IGZyb20gXCIuL2Nhcm91c2VsL0Nhcm91c2VsXCJcblxuaW1wb3J0IFRhYmxlLCB7IGluaXQgYXMgaW5pdFRhYmxlIH0gZnJvbSBcIi4vdGFibGUvVGFibGVcIlxuXG5pbXBvcnQgUGllQ2hhcnQsIHsgaW5pdCBhcyBpbml0UGllQ2hhcnQgfSBmcm9tIFwiLi9jaGFydHMvUGllQ2hhcnRcIlxuaW1wb3J0IEJhckNoYXJ0SG9yaXpvbnRhbCwgeyBpbml0IGFzIGluaXRCYXJDaGFydEhvcml6b250YWwgfSBmcm9tIFwiLi9jaGFydHMvQmFyQ2hhcnRIb3Jpem9udGFsXCJcbmltcG9ydCBCYXJDaGFydFZlcnRpY2FsLCB7IGluaXQgYXMgaW5pdEJhckNoYXJ0VmVydGljYWwgfSBmcm9tIFwiLi9jaGFydHMvQmFyQ2hhcnRWZXJ0aWNhbFwiXG5cbmV4cG9ydCB7XG4gIHV0aWxzLFxuICBMb2FkZXJCYXIsIGluaXRMb2FkZXJCYXIsXG4gIElucHV0RmllbGQsIGluaXRJbnB1dEZpZWxkLFxuICBUZXh0YXJlYSwgaW5pdFRleHRhcmVhLFxuICBTZWxlY3QsIGluaXRTZWxlY3QsXG4gIFJhbmdlLCBpbml0UmFuZ2UsXG4gIEF1dG9jb21wbGV0ZSwgaW5pdEF1dG9jb21wbGV0ZSxcbiAgUHJvZ3Jlc3NMaWdodCwgaW5pdFByb2dyZXNzTGlnaHQsXG4gIFByb2dyZXNzRnVsbCwgaW5pdFByb2dyZXNzRnVsbCxcbiAgTW9kYWwsIGluaXRNb2RhbCxcbiAgVG9vbGJhcixcbiAgTm90aWZpY2F0aW9uLFxuICBDb2xsYXBzZSwgaW5pdENvbGxhcHNlLFxuICBBY2NvcmRpb24sIGluaXRBY2NvcmRpb24sXG4gIE1lbnVGbHlvdXQsIGluaXRNZW51Rmx5b3V0LFxuICBOYXZpZ2F0aW9uLCBpbml0TmF2aWdhdGlvbixcbiAgTmF2aWdhdGlvblNpZGUsIGluaXROYXZpZ2F0aW9uU2lkZSxcbiAgU2VhcmNoSW5wdXQsIGluaXRTZWFyY2hJbnB1dCxcbiAgRW1wdHlTdGF0ZSwgaW5pdEVtcHR5U3RhdGUsXG4gIENhcm91c2VsLCBpbml0Q2Fyb3VzZWwsXG4gIFRhYmxlLCBpbml0VGFibGUsXG4gIFBpZUNoYXJ0LCBpbml0UGllQ2hhcnQsXG4gIEJhckNoYXJ0SG9yaXpvbnRhbCwgaW5pdEJhckNoYXJ0SG9yaXpvbnRhbCxcbiAgQmFyQ2hhcnRWZXJ0aWNhbCwgaW5pdEJhckNoYXJ0VmVydGljYWxcbn1cbiIsImltcG9ydCBhbmltZSwgeyBBbmltZVRpbWVsaW5lSW5zdGFuY2UgfSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBwcmV2ZW50RGVmYXVsdCwgaW50ZXJuZXRFeHBsb3Jlck9yRWRnZVZlcnNpb24gfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IHsgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UsIHBhcmVudFdpdGhDbGFzcyB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9TRUFSQ0hfSU5QVVQgPSBcImlucHV0LnNlYXJjaF9fZmllbGRcIlxuY29uc3QgUVVFUllfQlROX0NMT1NFID0gXCIuc2VhcmNoX19pY29uLWNsb3NlXCJcblxuY29uc3QgUVVFUllfTElWRV9TVUdFU1RJT05TID0gXCIuanMtc3VnZ2VzdGlvbnNcIlxuY29uc3QgUVVFUllfTElWRV9GT09URVIgPSBcIi5qcy1mb290ZXJcIlxuXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcImlzLWFjdGl2ZVwiXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcblxuY29uc3QgQ0xBU1NfU0VBUkNIID0gXCJzZWFyY2hcIlxuXG5jb25zdCBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04gPSAzMDBcbmNvbnN0IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04gPSAxMDBcbmNvbnN0IEFOSU1BVElPTl9GT09URVJfREVMQVkgPSBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04gLSBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OXG5cbi8qKlxuICogVGhlIHNlYXJjaCBpbnB1dCBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgU2VhcmNoSW5wdXQgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnRcbiAgcHJpdmF0ZSBfZm9ybTogSFRNTEZvcm1FbGVtZW50XG4gIHByaXZhdGUgX2J0bkNsb3NlOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9saXZlU3VnZ2VzdGlvbnM/OiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9saXZlRm9vdGVyPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGl2ZUNvbnRhaW5lcj86IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfZm9jdXNIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYmx1ckhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9jbG9zZUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF93aW5kb3dDbGlja0hhbmRsZXI6IChlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9rZXlkb3duSGFuZGxlcjogKGU6IEtleWJvYXJkRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfcmVzaXplSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfaXNPcGVuOiBib29sZWFuID0gZmFsc2VcbiAgcHJpdmF0ZSBhbmltYXRpb24hOiBBbmltZVRpbWVsaW5lSW5zdGFuY2VcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9pbnB1dCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX1NFQVJDSF9JTlBVVCkgYXMgSFRNTElucHV0RWxlbWVudFxuICAgIHRoaXMuX2Zvcm0gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcImZvcm1cIikhXG4gICAgdGhpcy5fYnRuQ2xvc2UgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9CVE5fQ0xPU0UpIGFzIEhUTUxFbGVtZW50XG5cbiAgICBsZXQgbGl2ZVNlYXJjaCA9IGdldEF0dHJpYnV0ZVJlZmVyZW5jZSh0aGlzLmVsZW1lbnQsIFwiZGF0YS1saXZlXCIpXG4gICAgaWYgKGxpdmVTZWFyY2gpIHtcbiAgICAgIHRoaXMuX2xpdmVTdWdnZXN0aW9ucyA9IGxpdmVTZWFyY2gucXVlcnlTZWxlY3RvcihRVUVSWV9MSVZFX1NVR0VTVElPTlMpIGFzIEhUTUxFbGVtZW50IHx8IHVuZGVmaW5lZFxuICAgICAgdGhpcy5fbGl2ZUZvb3RlciA9IGxpdmVTZWFyY2gucXVlcnlTZWxlY3RvcihRVUVSWV9MSVZFX0ZPT1RFUikgYXMgSFRNTEVsZW1lbnQgfHwgdW5kZWZpbmVkXG5cbiAgICAgIGlmICh0aGlzLl9saXZlU3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbGl2ZUNvbnRhaW5lciA9IHRoaXMuX2xpdmVTdWdnZXN0aW9ucy5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2ZvY3VzSGFuZGxlciA9IHRoaXMuX2hhbmRsZUlucHV0Rm9jdXMuYmluZCh0aGlzKVxuICAgIHRoaXMuX2JsdXJIYW5kbGVyID0gdGhpcy5faGFuZGxlSW5wdXRCbHVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9jbG9zZUhhbmRsZXIgPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gdGhpcy5faGFuZGxlUmVzaXplLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG5cbiAgICBpZiAoaW50ZXJuZXRFeHBsb3Jlck9yRWRnZVZlcnNpb24oKSA+IDApIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBJRSBicm93c2VycyB3aGVyZSBhIGZvY3VzZWRcbiAgICAgIC8vIGlucHV0J3MgY3Vyc29yIGJsZWVkcyB0cm91Z2ggZXZlbiBpZiBoaWRkZW5cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYnRuQ2xvc2UpIHtcbiAgICAgIHRoaXMuX2J0bkNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbG9zZUhhbmRsZXIpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVJbnB1dEZvY3VzKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVJbnB1dEJsdXIoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19BQ1RJVkUpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkge1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgIGlmICghcGFyZW50V2l0aENsYXNzKHRhcmdldCwgQ0xBU1NfU0VBUkNIKSkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGtleWNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FU0NBUEUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVSZXNpemUoKSB7XG4gICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50KVxuICAgIGlmIChzdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgdGhpcy5faW5wdXQuYmx1cigpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9yZXNldE1haW5UaW1lbGluZSgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uLnBhdXNlKClcbiAgICB9XG4gICAgYW5pbWUucmVtb3ZlKHRoaXMuX2xpdmVTdWdnZXN0aW9ucyEpXG4gICAgYW5pbWUucmVtb3ZlKHRoaXMuX2xpdmVGb290ZXIhKVxuXG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltZS50aW1lbGluZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2VhcmNoIGlucHV0IHRleHQgY29udGVudC5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGlucHV0IHRleHQuXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMvYWN0aXZhdGVzIHRoZSBzZWFyY2ggaW5wdXQuXG4gICAqL1xuICBwdWJsaWMgb3BlbigpIHtcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX09QRU4pXG4gICAgdGhpcy5faW5wdXQuZm9jdXMoKVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIH0sIDUwKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3Nlcy9kZWFjdGl2YXRlcyB0aGUgc2VhcmNoIGlucHV0LlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMuX2Zvcm0ucmVzZXQoKVxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcblxuICAgIHRoaXMuY2xvc2VMaXZlU2VhcmNoKClcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbGl2ZSBzZWFyY2ggc3VnZ2VzdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgb3BlbkxpdmVTZWFyY2goKSB7XG4gICAgaWYgKCF0aGlzLl9saXZlU3VnZ2VzdGlvbnMgfHwgdGhpcy5faXNPcGVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc09wZW4gPSB0cnVlXG4gICAgYWRkQ2xhc3ModGhpcy5fbGl2ZUNvbnRhaW5lciEsIENMQVNTX09QRU4pXG5cbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG5cbiAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgIHRhcmdldHM6IHRoaXMuX2xpdmVTdWdnZXN0aW9ucyxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04sXG4gICAgICBoZWlnaHQ6IHRoaXMuX2xpdmVTdWdnZXN0aW9ucy5zY3JvbGxIZWlnaHQgKyBcInB4XCIsXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbUVsID0gbmV3IERvbUVsZW1lbnQodGhpcy5fbGl2ZVN1Z2dlc3Rpb25zISlcbiAgICAgICAgZG9tRWwuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuX2xpdmVGb290ZXIpIHtcbiAgICAgIHRoaXMuX2xpdmVGb290ZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICB0YXJnZXRzOiB0aGlzLl9saXZlRm9vdGVyLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTixcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9saXZlRm9vdGVyLnNjcm9sbEhlaWdodCArIFwicHhcIixcbiAgICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICAgIG9mZnNldDogQU5JTUFUSU9OX0ZPT1RFUl9ERUxBWSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkb21FbCA9IG5ldyBEb21FbGVtZW50KHRoaXMuX2xpdmVGb290ZXIhKVxuICAgICAgICAgIGRvbUVsLmFkZENsYXNzKENMQVNTX09QRU4pXG4gICAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBsaXZlIHNlYXJjaCBzdWdnZXN0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBjbG9zZUxpdmVTZWFyY2goKSB7XG4gICAgaWYgKCF0aGlzLl9saXZlU3VnZ2VzdGlvbnMgfHwgIXRoaXMuaXNPcGVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc09wZW4gPSBmYWxzZVxuICAgIHRoaXMuX3Jlc2V0TWFpblRpbWVsaW5lKClcblxuICAgIHRoaXMuX2xpdmVTdWdnZXN0aW9ucy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG5cbiAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgdGFyZ2V0czogdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9TVUdHRVNUSU9OU19EVVJBVElPTixcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9saXZlU3VnZ2VzdGlvbnMhKVxuICAgICAgICBkb21FbC5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICBkb21FbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLl9saXZlQ29udGFpbmVyISwgQ0xBU1NfT1BFTilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuX2xpdmVGb290ZXIpIHtcbiAgICAgIHRoaXMuX2xpdmVGb290ZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICB0YXJnZXRzOiB0aGlzLl9saXZlRm9vdGVyLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTixcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRvbUVsID0gbmV3IERvbUVsZW1lbnQodGhpcy5fbGl2ZUZvb3RlciEpXG4gICAgICAgICAgZG9tRWwucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgICAgICBkb21FbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBjbGVhcnMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG5cbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5fYnRuQ2xvc2UpIHtcbiAgICAgIHRoaXMuX2J0bkNsb3NlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbG9zZUhhbmRsZXIpXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5faW5wdXQgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2Zvcm0gPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2J0bkNsb3NlID0gbnVsbDtcblxuICAgICh0aGlzIGFzIGFueSkuX2ZvY3VzSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYmx1ckhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2Nsb3NlSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fd2luZG93Q2xpY2tIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9rZXlkb3duSGFuZGxlciA9IG51bGw7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9saXZlU3VnZ2VzdGlvbnMgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2xpdmVGb290ZXIgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgU2VhcmNoSW5wdXQgaXMgb3Blbi92aXNpYmxlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAtIFRydWUgaWYgb3Blbjsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgcHVibGljIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNDbGFzcyhDTEFTU19PUEVOKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxFbGVtZW50PihcIi5zZWFyY2guc2VhcmNoX19pbnB1dFwiLCAoZSkgPT4ge1xuICAgIG5ldyBTZWFyY2hJbnB1dChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWFyY2hJbnB1dFxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IFFVRVJZX0hFQURFUiA9IFwidGhlYWQgdGhcIlxuXG5jb25zdCBDTEFTU19TT1JURURfQVNDRU5ESU5HID0gXCJqcy1hc2NlbmRpbmdcIlxuY29uc3QgQ0xBU1NfU09SVEVEX0RFU0NFTkRJTkcgPSBcImpzLWRlc2NlbmRpbmdcIlxuY29uc3QgQ0xBU1NfQVJST1cgPSBcImFycm93LWljb25cIlxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBhcmVyPFQgPSBhbnk+IHtcbiAgKGl0ZW0xOiBULCBpdGVtMjogVCk6IG51bWJlclxufVxuXG4vKipcbiAqIFRoZSBUYWJsZSBjb21wb25lbnQuIEFkZHMgYWRkaXRpb25hbCBjYXBhYmlsaXRpZXMgdG8gc3RhbmRhcmQgSFRNTCA1IHRhYmxlcy5cbiAqL1xuY2xhc3MgVGFibGUgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfaGVhZGVyQ2xpY2tIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYm9keTogSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnRcbiAgcHJpdmF0ZSBfcm93czogSFRNTENvbGxlY3Rpb25PZjxIVE1MVGFibGVSb3dFbGVtZW50PlxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB0YWJsZSBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MVGFibGVFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUhlYWRlckNsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2JvZHkgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcInRib2R5XCIpIGFzIEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50XG4gICAgdGhpcy5fcm93cyA9IHRoaXMuX2JvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0clwiKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgZm9yIChsZXQgaGVhZGVyIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0hFQURFUikpIHtcbiAgICAgIGlmIChoZWFkZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpKSB7XG4gICAgICAgIGhlYWRlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGVhZGVyQ2xpY2tIYW5kbGVyKVxuXG4gICAgICAgIGxldCBhcnJvd0VsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19BUlJPVylcbiAgICAgICAgICAuZWxlbWVudFxuXG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChhcnJvd0VsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVIZWFkZXJDbGljayhlOiBFdmVudCkge1xuICAgIGNvbnN0IHRoID0gZS50YXJnZXQgYXMgSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnRcbiAgICB0aGlzLnNvcnQodGgpXG4gIH1cblxuICAvKipcbiAgICogU29ydHMgdGhlIHRhYmxlIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHRhYmxlIGhlYWRlciBlbGVtZW50LlxuICAgKiBUaGUgY29sdW1uIGlzIHNvcnRlZCBhc2NlbmRpbmcgYnkgZGVmYXVsdCBpZiBubyBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkIGFuZCBub1xuICAgKiBleGlzdGluZyBzb3J0IG9yZGVyIGNsYXNzIGlzIGZvdW5kIGluIHRoZSBtYXJrdXAuXG4gICAqXG4gICAqIElmIHRoZSBkaXNwbGF5ZWQgZGF0YSBpcyBub3Qgc3VpdGFibGUgZm9yIHNvcnRpbmcgYDx0ZC8+YCBlbGVtZW50cyBjYW4gZGVmaW5lIGEgYGRhdGEtdmFsdWVgIGF0dHJpYnV0ZVxuICAgKiB3aGljaCBpcyB0aGVuIHVzZWQgZm9yIHRoZSBkYXRhLXNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtUYWJsZUhlYWRlcn0gdGFibGVIZWFkZXIgVGhlIGhlYWRlciBlbGVtZW50IG9mIHRoZSByb3cgdG8gc29ydCBieS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRvIHNvcnQsIGAxYCBmb3IgYXNjZW5kaW5nLCBgLTFgIGZvciBkZXNjZW5kaW5nIG9yZGVyLiBUaGlzIHBhcmFtZXRlciBpcyBvcHRpb25hbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXF1YWxpdHlDb21wYXJlciBUaGUgZXF1aWFsaXR5IGNvbXBhcmVyIGZ1bmN0aW9uIHRvIGNvbXBhcmUgaW5kaXZpZHVhbCBjZWxsIHZhbHVlcy5cbiAgICovXG4gIHB1YmxpYyBzb3J0KFxuICAgIHRhYmxlSGVhZGVyOiBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudCxcbiAgICBkaXJlY3Rpb24/OiAtMSB8IDEsXG4gICAgZXF1YWxpdHlDb21wYXJlcj86IENvbXBhcmVyXG4gICkge1xuICAgIGlmICghdGFibGVIZWFkZXIgfHwgdGFibGVIZWFkZXIudGFnTmFtZSAhPT0gXCJUSFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFyYW1ldGVyICd0YWJsZUhlYWRlcicgbXVzdCBiZSBhIHZhbGlkIGNvbHVtbiBoZWFkZXIgbm9kZVwiKVxuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gIT09IDEgJiYgZGlyZWN0aW9uICE9PSAtMSAmJiBkaXJlY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIG91dCBvZiByYW5nZSwgcGFyYW1ldGVyICdkaXJlY3Rpb24nIHdpdGggdmFsdWUgJyR7ZGlyZWN0aW9ufScgbXVzdCBiZSBlaXRoZXIgLTEsIDEgb3IgdW5kZWZpbmVkYClcbiAgICB9XG5cbiAgICBjb25zdCBjb2x1bW5JbmRleCA9IHRhYmxlSGVhZGVyLmNlbGxJbmRleFxuXG4gICAgaWYgKCFlcXVhbGl0eUNvbXBhcmVyKSB7XG4gICAgICBsZXQgZGF0YVR5cGUgPSB0YWJsZUhlYWRlci5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR5cGVcIilcbiAgICAgIGVxdWFsaXR5Q29tcGFyZXIgPSB0aGlzLl9nZXRDb21wYXJlcihkYXRhVHlwZSEpXG4gICAgfVxuXG4gICAgaWYgKGNvbHVtbkluZGV4ID49IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0hFQURFUikubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2x1bW4gb3V0IG9mIHJhbmdlXCIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaGVhZGVyIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0hFQURFUikpIHtcbiAgICAgIGlmIChoZWFkZXIgIT09IHRhYmxlSGVhZGVyKSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhoZWFkZXIsIENMQVNTX1NPUlRFRF9BU0NFTkRJTkcpXG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhoZWFkZXIsIENMQVNTX1NPUlRFRF9ERVNDRU5ESU5HKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChEb20uaGFzQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9BU0NFTkRJTkcpKSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9BU0NFTkRJTkcpXG4gICAgICBEb20uYWRkQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9ERVNDRU5ESU5HKVxuXG4gICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgLTFcbiAgICB9IGVsc2Uge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfREVTQ0VORElORylcbiAgICAgIERvbS5hZGRDbGFzcyh0YWJsZUhlYWRlciwgQ0xBU1NfU09SVEVEX0FTQ0VORElORylcbiAgICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAxXG4gICAgfVxuXG4gICAgdGhpcy5fcXVpY2tzb3J0KGNvbHVtbkluZGV4LCAwLCB0aGlzLl9yb3dzLmxlbmd0aCAtIDEsIGRpcmVjdGlvbiwgZXF1YWxpdHlDb21wYXJlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0Q2VsbChjb2x1bW46IG51bWJlciwgcm93OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcm93c1tyb3ddLmNlbGxzW2NvbHVtbl1cbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0Um93KHJvdzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd3Nbcm93XVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRDb21wYXJlcihkYXRhVHlwZTogc3RyaW5nKTogQ29tcGFyZXI8c3RyaW5nPiB7XG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSBcIm51bWJlclwiOiB7XG4gICAgICAgIC8vIHBhcnNlIHRoZSBzdHJpbmcgYXMgYSBudW1iZXJcbiAgICAgICAgcmV0dXJuIChhLCBiKSA9PiBwYXJzZUZsb2F0KGEpIC0gcGFyc2VGbG9hdChiKVxuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICAvLyBjb21wYXJlIHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIChhLCBiKSA9PiB7XG4gICAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3F1aWNrc29ydChcbiAgICBjb2x1bW46IG51bWJlcixcbiAgICBsZWZ0OiBudW1iZXIsXG4gICAgcmlnaHQ6IG51bWJlcixcbiAgICBkaXJlY3Rpb246IC0xIHwgMSA9IDEsXG4gICAgZXF1YWxpdHlDb21wYXJlcjogQ29tcGFyZXI8c3RyaW5nPlxuICApIHtcbiAgICBpZiAocmlnaHQgLSBsZWZ0ID4gMCkge1xuXG4gICAgICBsZXQgcGFydGl0aW9uID0gdGhpcy5fcGFydGl0aW9uKGNvbHVtbiwgbGVmdCwgcmlnaHQsIGRpcmVjdGlvbiwgZXF1YWxpdHlDb21wYXJlcilcblxuICAgICAgaWYgKGxlZnQgPCBwYXJ0aXRpb24gLSAxKSB7XG4gICAgICAgIHRoaXMuX3F1aWNrc29ydChjb2x1bW4sIGxlZnQsIHBhcnRpdGlvbiAtIDEsIGRpcmVjdGlvbiwgZXF1YWxpdHlDb21wYXJlcilcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnRpdGlvbiA8IHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3F1aWNrc29ydChjb2x1bW4sIHBhcnRpdGlvbiwgcmlnaHQsIGRpcmVjdGlvbiwgZXF1YWxpdHlDb21wYXJlcilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3BhcnRpdGlvbihcbiAgICBjb2x1bW46IG51bWJlcixcbiAgICBsZWZ0OiBudW1iZXIsXG4gICAgcmlnaHQ6IG51bWJlcixcbiAgICBkaXJlY3Rpb246IC0xIHwgMSA9IDEsXG4gICAgZXF1YWxpdHlDb21wYXJlcjogQ29tcGFyZXI8c3RyaW5nPlxuICApIHtcbiAgICBsZXQgcGl2b3QgPSB0aGlzLl9nZXRDZWxsKGNvbHVtbiwgTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpKVxuICAgIGxldCBpID0gbGVmdFxuICAgIGxldCBqID0gcmlnaHRcblxuICAgIHdoaWxlIChpIDw9IGopIHtcbiAgICAgIHdoaWxlICh0aGlzLl9lcXVhbHModGhpcy5fZ2V0Q2VsbChjb2x1bW4sIGkpLCBwaXZvdCwgZXF1YWxpdHlDb21wYXJlcikgKiBkaXJlY3Rpb24gPCAwKSB7XG4gICAgICAgIGkrK1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodGhpcy5fZXF1YWxzKHRoaXMuX2dldENlbGwoY29sdW1uLCBqKSwgcGl2b3QsIGVxdWFsaXR5Q29tcGFyZXIpICogZGlyZWN0aW9uID4gMCkge1xuICAgICAgICBqLS1cbiAgICAgIH1cblxuICAgICAgaWYgKGkgPD0gaikge1xuICAgICAgICB0aGlzLl9zd2FwKGksIGopXG4gICAgICAgIGkrK1xuICAgICAgICBqLS1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaVxuICB9XG5cbiAgcHJvdGVjdGVkIF9lcXVhbHMoXG4gICAgYTogSFRNTEVsZW1lbnQsXG4gICAgYjogSFRNTEVsZW1lbnQsXG4gICAgZXF1YWxpdHlDb21wYXJlcjogQ29tcGFyZXI8c3RyaW5nPlxuICApIHtcbiAgICBsZXQgZGF0YUEgPSBhLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIilcbiAgICBsZXQgZGF0YUIgPSBiLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIilcblxuICAgIGRhdGFBID0gZGF0YUEgfHwgYS50ZXh0Q29udGVudCB8fCBhLmlubmVyVGV4dFxuICAgIGRhdGFCID0gZGF0YUIgfHwgYi50ZXh0Q29udGVudCB8fCBiLmlubmVyVGV4dFxuXG4gICAgcmV0dXJuIGVxdWFsaXR5Q29tcGFyZXIoZGF0YUEsIGRhdGFCKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zd2FwKGk6IG51bWJlciwgajogbnVtYmVyKSB7XG4gICAgbGV0IHRtcE5vZGUgPSB0aGlzLl9ib2R5LnJlcGxhY2VDaGlsZCh0aGlzLl9nZXRSb3coaSksIHRoaXMuX2dldFJvdyhqKSlcbiAgICBjb25zdCByZWZlcmVuY2VSb3cgPSB0aGlzLl9nZXRSb3coaSlcblxuICAgIGlmICghcmVmZXJlbmNlUm93KSB7XG4gICAgICB0aGlzLl9ib2R5LmFwcGVuZENoaWxkKHRtcE5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHkuaW5zZXJ0QmVmb3JlKHRtcE5vZGUsIHJlZmVyZW5jZVJvdylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgY2xlYXJzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgaGVhZGVyIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0hFQURFUikpIHtcbiAgICAgIGhlYWRlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGVhZGVyQ2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX2hlYWRlckNsaWNrSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYm9keSA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fcm93cyA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcInRhYmxlXCIsIChlKSA9PiB7XG4gICAgbmV3IFRhYmxlKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRhYmxlXG4iLCJpbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19JVEVNUyA9IFwiLnRvb2xiYXJfX2l0ZW1cIlxuY29uc3QgQ0xBU1NfU0hPVyA9IFwiaXRlbS0tc2hvd1wiXG5cbmNvbnN0IEFOSU1BVElPTl9TVEFSVF9ERUxBWSA9IDEwMFxuY29uc3QgQU5JTUFUSU9OX09GRlNFVCA9IDUwXG5cbi8qKlxuICogVG9vbGJhciBjb21wb25lbnQuIFVzZSB0aGlzIGNvbXBvbmVudCB0byBzaG93IGFuZCBoaWRlIHRoZVxuICogaW5kaXZpZHVhbCB0b29sYmFyIGl0ZW1zLlxuICovXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIE1ha2VzIHRoZSB0b29sYmFyIGl0ZW1zIHZpc2libGUuXG4gICAqL1xuICBwdWJsaWMgc2hvdygpIHtcbiAgICBsZXQgZGVsYXkgPSBBTklNQVRJT05fU1RBUlRfREVMQVlcbiAgICBsZXQgaXRlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19JVEVNUylcblxuICAgIGxldCB0aW1lbGluZSA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB0aW1lbGluZS5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBpdGVtc1tpbmRleF0sXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICBvZmZzZXQ6IGRlbGF5LFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIGl0ZW1zW2luZGV4XS5jbGFzc0xpc3QuYWRkKENMQVNTX1NIT1cpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBkZWxheSArPSBBTklNQVRJT05fT0ZGU0VUXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSB0b29sYmFyIGl0ZW1zLlxuICAgKi9cbiAgcHVibGljIGhpZGUoKSB7XG4gICAgbGV0IGRlbGF5ID0gQU5JTUFUSU9OX1NUQVJUX0RFTEFZXG4gICAgbGV0IGl0ZW1zID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoQ0xBU1NfSVRFTVMpXG5cbiAgICBsZXQgdGltZWxpbmUgPSBhbmltZS50aW1lbGluZSgpXG4gICAgZm9yIChsZXQgaW5kZXggPSBpdGVtcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICB0aW1lbGluZS5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBpdGVtc1tpbmRleF0sXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICBvZmZzZXQ6IGRlbGF5LFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIGl0ZW1zW2luZGV4XS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX1NIT1cpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBkZWxheSArPSBBTklNQVRJT05fT0ZGU0VUXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHRvb2xiYXIgaXRlbXMgdmlzaWJpbGl0eS5cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19TSE9XfWApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zaG93KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJhclxuIiwiLyohXG4gKiBtb2Rlcm5penIgdjMuOC4wXG4gKiBCdWlsZCBodHRwczovL21vZGVybml6ci5jb20vZG93bmxvYWQ/LWhpZGRlbnNjcm9sbC10b3VjaGV2ZW50cy1zZXRjbGFzc2VzLWRvbnRtaW5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpXG4gKiAgRmFydWsgQXRlc1xuICogIFBhdWwgSXJpc2hcbiAqICBBbGV4IFNleHRvblxuICogIFJ5YW4gU2VkZG9uXG4gKiAgUGF0cmljayBLZXR0bmVyXG4gKiAgU3R1IENveFxuICogIFJpY2hhcmQgSGVycmVyYVxuICogIFZlZWNrXG5cbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxuLypcbiAqIE1vZGVybml6ciB0ZXN0cyB3aGljaCBuYXRpdmUgQ1NTMyBhbmQgSFRNTDUgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGVcbiAqIGN1cnJlbnQgVUEgYW5kIG1ha2VzIHRoZSByZXN1bHRzIGF2YWlsYWJsZSB0byB5b3UgaW4gdHdvIHdheXM6IGFzIHByb3BlcnRpZXMgb25cbiAqIGEgZ2xvYmFsIGBNb2Rlcm5penJgIG9iamVjdCwgYW5kIGFzIGNsYXNzZXMgb24gdGhlIGA8aHRtbD5gIGVsZW1lbnQuIFRoaXNcbiAqIGluZm9ybWF0aW9uIGFsbG93cyB5b3UgdG8gcHJvZ3Jlc3NpdmVseSBlbmhhbmNlIHlvdXIgcGFnZXMgd2l0aCBhIGdyYW51bGFyIGxldmVsXG4gKiBvZiBjb250cm9sIG92ZXIgdGhlIGV4cGVyaWVuY2UuXG4qL1xuXG47KGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCl7XG5cbiAgdmFyIHRlc3RzID0gW107XG4gIFxuXG4gIC8qKlxuICAgKiBNb2Rlcm5penJQcm90byBpcyB0aGUgY29uc3RydWN0b3IgZm9yIE1vZGVybml6clxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFjY2VzcyBwdWJsaWNcbiAgICovXG4gIHZhciBNb2Rlcm5penJQcm90byA9IHtcbiAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uLCBkdW1teVxuICAgIF92ZXJzaW9uOiAnMy44LjAnLFxuXG4gICAgLy8gQW55IHNldHRpbmdzIHRoYXQgZG9uJ3Qgd29yayBhcyBzZXBhcmF0ZSBtb2R1bGVzXG4gICAgLy8gY2FuIGdvIGluIGhlcmUgYXMgY29uZmlndXJhdGlvbi5cbiAgICBfY29uZmlnOiB7XG4gICAgICAnY2xhc3NQcmVmaXgnOiAnJyxcbiAgICAgICdlbmFibGVDbGFzc2VzJzogdHJ1ZSxcbiAgICAgICdlbmFibGVKU0NsYXNzJzogdHJ1ZSxcbiAgICAgICd1c2VQcmVmaXhlcyc6IHRydWVcbiAgICB9LFxuXG4gICAgLy8gUXVldWUgb2YgdGVzdHNcbiAgICBfcTogW10sXG5cbiAgICAvLyBTdHViIHRoZXNlIGZvciBwZW9wbGUgd2hvIGFyZSBsaXN0ZW5pbmdcbiAgICBvbjogZnVuY3Rpb24odGVzdCwgY2IpIHtcbiAgICAgIC8vIEkgZG9uJ3QgcmVhbGx5IHRoaW5rIHBlb3BsZSBzaG91bGQgZG8gdGhpcywgYnV0IHdlIGNhblxuICAgICAgLy8gc2FmZSBndWFyZCBpdCBhIGJpdC5cbiAgICAgIC8vIC0tIE5PVEU6OiB0aGlzIGdldHMgV0FZIG92ZXJyaWRkZW4gaW4gc3JjL2FkZFRlc3QgZm9yIGFjdHVhbCBhc3luYyB0ZXN0cy5cbiAgICAgIC8vIFRoaXMgaXMgaW4gY2FzZSBwZW9wbGUgbGlzdGVuIHRvIHN5bmNocm9ub3VzIHRlc3RzLiBJIHdvdWxkIGxlYXZlIGl0IG91dCxcbiAgICAgIC8vIGJ1dCB0aGUgY29kZSB0byAqZGlzYWxsb3cqIHN5bmMgdGVzdHMgaW4gdGhlIHJlYWwgdmVyc2lvbiBvZiB0aGlzXG4gICAgICAvLyBmdW5jdGlvbiBpcyBhY3R1YWxseSBsYXJnZXIgdGhhbiB0aGlzLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioc2VsZlt0ZXN0XSk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVGVzdDogZnVuY3Rpb24obmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgIHRlc3RzLnB1c2goe25hbWU6IG5hbWUsIGZuOiBmbiwgb3B0aW9uczogb3B0aW9uc30pO1xuICAgIH0sXG5cbiAgICBhZGRBc3luY1Rlc3Q6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB0ZXN0cy5wdXNoKHtuYW1lOiBudWxsLCBmbjogZm59KTtcbiAgICB9XG4gIH07XG5cbiAgXG5cbiAgLy8gRmFrZSBzb21lIG9mIE9iamVjdC5jcmVhdGUgc28gd2UgY2FuIGZvcmNlIG5vbiB0ZXN0IHJlc3VsdHMgdG8gYmUgbm9uIFwib3duXCIgcHJvcGVydGllcy5cbiAgdmFyIE1vZGVybml6ciA9IGZ1bmN0aW9uKCkge307XG4gIE1vZGVybml6ci5wcm90b3R5cGUgPSBNb2Rlcm5penJQcm90bztcblxuICAvLyBMZWFrIG1vZGVybml6ciBnbG9iYWxseSB3aGVuIHlvdSBgcmVxdWlyZWAgaXQgcmF0aGVyIHRoYW4gZm9yY2UgaXQgaGVyZS5cbiAgLy8gT3ZlcndyaXRlIG5hbWUgc28gY29uc3RydWN0b3IgbmFtZSBpcyBuaWNlciA6RFxuICBNb2Rlcm5penIgPSBuZXcgTW9kZXJuaXpyKCk7XG5cbiAgXG5cbiAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgXG5cbiAgLyoqXG4gICAqIGlzIHJldHVybnMgYSBib29sZWFuIGlmIHRoZSB0eXBlb2YgYW4gb2JqIGlzIGV4YWN0bHkgdHlwZS5cbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBpc1xuICAgKiBAcGFyYW0geyp9IG9iaiAtIEEgdGhpbmcgd2Ugd2FudCB0byBjaGVjayB0aGUgdHlwZSBvZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEEgc3RyaW5nIHRvIGNvbXBhcmUgdGhlIHR5cGVvZiBhZ2FpbnN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0eXBlb2YgdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBmdW5jdGlvbiBpcyhvYmosIHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gdHlwZTtcbiAgfVxuXG4gIDtcblxuICAvKipcbiAgICogUnVuIHRocm91Z2ggYWxsIHRlc3RzIGFuZCBkZXRlY3QgdGhlaXIgc3VwcG9ydCBpbiB0aGUgY3VycmVudCBVQS5cbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gdGVzdFJ1bm5lcigpIHtcbiAgICB2YXIgZmVhdHVyZU5hbWVzO1xuICAgIHZhciBmZWF0dXJlO1xuICAgIHZhciBhbGlhc0lkeDtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBmZWF0dXJlTmFtZTtcbiAgICB2YXIgZmVhdHVyZU5hbWVTcGxpdDtcblxuICAgIGZvciAodmFyIGZlYXR1cmVJZHggaW4gdGVzdHMpIHtcbiAgICAgIGlmICh0ZXN0cy5oYXNPd25Qcm9wZXJ0eShmZWF0dXJlSWR4KSkge1xuICAgICAgICBmZWF0dXJlTmFtZXMgPSBbXTtcbiAgICAgICAgZmVhdHVyZSA9IHRlc3RzW2ZlYXR1cmVJZHhdO1xuICAgICAgICAvLyBydW4gdGhlIHRlc3QsIHRocm93IHRoZSByZXR1cm4gdmFsdWUgaW50byB0aGUgTW9kZXJuaXpyLFxuICAgICAgICAvLyB0aGVuIGJhc2VkIG9uIHRoYXQgYm9vbGVhbiwgZGVmaW5lIGFuIGFwcHJvcHJpYXRlIGNsYXNzTmFtZVxuICAgICAgICAvLyBhbmQgcHVzaCBpdCBpbnRvIGFuIGFycmF5IG9mIGNsYXNzZXMgd2UnbGwgam9pbiBsYXRlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbmFtZSwgaXQncyBhbiAnYXN5bmMnIHRlc3QgdGhhdCBpcyBydW4sXG4gICAgICAgIC8vIGJ1dCBub3QgZGlyZWN0bHkgYWRkZWQgdG8gdGhlIG9iamVjdC4gVGhhdCBzaG91bGRcbiAgICAgICAgLy8gYmUgZG9uZSB3aXRoIGEgcG9zdC1ydW4gYWRkVGVzdCBjYWxsLlxuICAgICAgICBpZiAoZmVhdHVyZS5uYW1lKSB7XG4gICAgICAgICAgZmVhdHVyZU5hbWVzLnB1c2goZmVhdHVyZS5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgaWYgKGZlYXR1cmUub3B0aW9ucyAmJiBmZWF0dXJlLm9wdGlvbnMuYWxpYXNlcyAmJiBmZWF0dXJlLm9wdGlvbnMuYWxpYXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhbGwgdGhlIGFsaWFzZXMgaW50byB0aGUgbmFtZXMgbGlzdFxuICAgICAgICAgICAgZm9yIChhbGlhc0lkeCA9IDA7IGFsaWFzSWR4IDwgZmVhdHVyZS5vcHRpb25zLmFsaWFzZXMubGVuZ3RoOyBhbGlhc0lkeCsrKSB7XG4gICAgICAgICAgICAgIGZlYXR1cmVOYW1lcy5wdXNoKGZlYXR1cmUub3B0aW9ucy5hbGlhc2VzW2FsaWFzSWR4XS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdW4gdGhlIHRlc3QsIG9yIHVzZSB0aGUgcmF3IHZhbHVlIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb25cbiAgICAgICAgcmVzdWx0ID0gaXMoZmVhdHVyZS5mbiwgJ2Z1bmN0aW9uJykgPyBmZWF0dXJlLmZuKCkgOiBmZWF0dXJlLmZuO1xuXG4gICAgICAgIC8vIFNldCBlYWNoIG9mIHRoZSBuYW1lcyBvbiB0aGUgTW9kZXJuaXpyIG9iamVjdFxuICAgICAgICBmb3IgKG5hbWVJZHggPSAwOyBuYW1lSWR4IDwgZmVhdHVyZU5hbWVzLmxlbmd0aDsgbmFtZUlkeCsrKSB7XG4gICAgICAgICAgZmVhdHVyZU5hbWUgPSBmZWF0dXJlTmFtZXNbbmFtZUlkeF07XG4gICAgICAgICAgLy8gU3VwcG9ydCBkb3QgcHJvcGVydGllcyBhcyBzdWIgdGVzdHMuIFdlIGRvbid0IGRvIGNoZWNraW5nIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGltcGxpZWQgcGFyZW50IHRlc3RzIGhhdmUgYmVlbiBhZGRlZC4gWW91IG11c3QgY2FsbCB0aGVtIGluXG4gICAgICAgICAgLy8gb3JkZXIgKGVpdGhlciBpbiB0aGUgdGVzdCwgb3IgbWFrZSB0aGUgcGFyZW50IHRlc3QgYSBkZXBlbmRlbmN5KS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIENhcCBpdCB0byBUV08gdG8gbWFrZSB0aGUgbG9naWMgc2ltcGxlIGFuZCBiZWNhdXNlIHdobyBuZWVkcyB0aGF0IGtpbmQgb2Ygc3VidGVzdGluZ1xuICAgICAgICAgIC8vIGhhc2h0YWcgZmFtb3VzIGxhc3Qgd29yZHNcbiAgICAgICAgICBmZWF0dXJlTmFtZVNwbGl0ID0gZmVhdHVyZU5hbWUuc3BsaXQoJy4nKTtcblxuICAgICAgICAgIGlmIChmZWF0dXJlTmFtZVNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgTW9kZXJuaXpyW2ZlYXR1cmVOYW1lU3BsaXRbMF1dID0gcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjYXN0IHRvIGEgQm9vbGVhbiwgaWYgbm90IG9uZSBhbHJlYWR5IG9yIGlmIGl0IGRvZXNudCBleGlzdCB5ZXQgKGxpa2UgaW5wdXR0eXBlcylcbiAgICAgICAgICAgIGlmICghTW9kZXJuaXpyW2ZlYXR1cmVOYW1lU3BsaXRbMF1dIHx8IE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSAmJiAhKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSBpbnN0YW5jZW9mIEJvb2xlYW4pKSB7XG4gICAgICAgICAgICAgIE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSA9IG5ldyBCb29sZWFuKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXVtmZWF0dXJlTmFtZVNwbGl0WzFdXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGFzc2VzLnB1c2goKHJlc3VsdCA/ICcnIDogJ25vLScpICsgZmVhdHVyZU5hbWVTcGxpdC5qb2luKCctJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIDtcblxuICAvKipcbiAgICogZG9jRWxlbWVudCBpcyBhIGNvbnZlbmllbmNlIHdyYXBwZXIgdG8gZ3JhYiB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IFRoZSByb290IGVsZW1lbnQgb2YgdGhlIGRvY3VtZW50XG4gICAqL1xuICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgaGVscGVyIHRvIGNoZWNrIGlmIHRoZSBkb2N1bWVudCB3ZSBhcmUgcnVubmluZyBpbiBpcyBhbiBTVkcgZG9jdW1lbnRcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmFyIGlzU1ZHID0gZG9jRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJztcblxuICBcblxuICAvKipcbiAgICogc2V0Q2xhc3NlcyB0YWtlcyBhbiBhcnJheSBvZiBjbGFzcyBuYW1lcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSByb290IGVsZW1lbnRcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBzZXRDbGFzc2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNsYXNzZXMgLSBBcnJheSBvZiBjbGFzcyBuYW1lc1xuICAgKi9cbiAgLy8gUGFzcyBpbiBhbiBhbmQgYXJyYXkgb2YgY2xhc3MgbmFtZXMsIGUuZy46XG4gIC8vICBbJ25vLXdlYnAnLCAnYm9yZGVycmFkaXVzJywgLi4uXVxuICBmdW5jdGlvbiBzZXRDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gZG9jRWxlbWVudC5jbGFzc05hbWU7XG4gICAgdmFyIGNsYXNzUHJlZml4ID0gTW9kZXJuaXpyLl9jb25maWcuY2xhc3NQcmVmaXggfHwgJyc7XG5cbiAgICBpZiAoaXNTVkcpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5iYXNlVmFsO1xuICAgIH1cblxuICAgIC8vIENoYW5nZSBgbm8tanNgIHRvIGBqc2AgKGluZGVwZW5kZW50bHkgb2YgdGhlIGBlbmFibGVDbGFzc2VzYCBvcHRpb24pXG4gICAgLy8gSGFuZGxlIGNsYXNzUHJlZml4IG9uIHRoaXMgdG9vXG4gICAgaWYgKE1vZGVybml6ci5fY29uZmlnLmVuYWJsZUpTQ2xhc3MpIHtcbiAgICAgIHZhciByZUpTID0gbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzUHJlZml4ICsgJ25vLWpzKFxcXFxzfCQpJyk7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZShyZUpTLCAnJDEnICsgY2xhc3NQcmVmaXggKyAnanMkMicpO1xuICAgIH1cblxuICAgIGlmIChNb2Rlcm5penIuX2NvbmZpZy5lbmFibGVDbGFzc2VzKSB7XG4gICAgICAvLyBBZGQgdGhlIG5ldyBjbGFzc2VzXG4gICAgICBpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBjbGFzc1ByZWZpeCArIGNsYXNzZXMuam9pbignICcgKyBjbGFzc1ByZWZpeCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgZG9jRWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCA9IGNsYXNzTmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY0VsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIDtcblxuICAvKipcbiAgICogY3JlYXRlRWxlbWVudCBpcyBhIGNvbnZlbmllbmNlIHdyYXBwZXIgYXJvdW5kIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuIFNpbmNlIHdlXG4gICAqIHVzZSBjcmVhdGVFbGVtZW50IGFsbCBvdmVyIHRoZSBwbGFjZSwgdGhpcyBhbGxvd3MgZm9yIChzbGlnaHRseSkgc21hbGxlciBjb2RlXG4gICAqIGFzIHdlbGwgYXMgYWJzdHJhY3RpbmcgYXdheSBpc3N1ZXMgd2l0aCBjcmVhdGluZyBlbGVtZW50cyBpbiBjb250ZXh0cyBvdGhlciB0aGFuXG4gICAqIEhUTUwgZG9jdW1lbnRzIChlLmcuIFNWRyBkb2N1bWVudHMpLlxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IEFuIEhUTUwgb3IgU1ZHIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIGluIElFNywgd2hlcmUgdGhlIHR5cGUgb2YgY3JlYXRlRWxlbWVudCBpcyBcIm9iamVjdFwiLlxuICAgICAgLy8gRm9yIHRoaXMgcmVhc29uLCB3ZSBjYW5ub3QgY2FsbCBhcHBseSgpIGFzIE9iamVjdCBpcyBub3QgYSBGdW5jdGlvbi5cbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFyZ3VtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmIChpc1NWRykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUy5jYWxsKGRvY3VtZW50LCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBhcmd1bWVudHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIGdldEJvZHkgcmV0dXJucyB0aGUgYm9keSBvZiBhIGRvY3VtZW50LCBvciBhbiBlbGVtZW50IHRoYXQgY2FuIHN0YW5kIGluIGZvclxuICAgKiB0aGUgYm9keSBpZiBhIHJlYWwgYm9keSBkb2VzIG5vdCBleGlzdFxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIGdldEJvZHlcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IFJldHVybnMgdGhlIHJlYWwgYm9keSBvZiBhIGRvY3VtZW50LCBvciBhblxuICAgKiBhcnRpZmljaWFsbHkgY3JlYXRlZCBlbGVtZW50IHRoYXQgc3RhbmRzIGluIGZvciB0aGUgYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAvLyBBZnRlciBwYWdlIGxvYWQgaW5qZWN0aW5nIGEgZmFrZSBib2R5IGRvZXNuJ3Qgd29yayBzbyBjaGVjayBpZiBib2R5IGV4aXN0c1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICAgIGlmICghYm9keSkge1xuICAgICAgLy8gQ2FuJ3QgdXNlIHRoZSByZWFsIGJvZHkgY3JlYXRlIGEgZmFrZSBvbmUuXG4gICAgICBib2R5ID0gY3JlYXRlRWxlbWVudChpc1NWRyA/ICdzdmcnIDogJ2JvZHknKTtcbiAgICAgIGJvZHkuZmFrZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIGluamVjdEVsZW1lbnRXaXRoU3R5bGVzIGluamVjdHMgYW4gZWxlbWVudCB3aXRoIHN0eWxlIGVsZW1lbnQgYW5kIHNvbWUgQ1NTIHJ1bGVzXG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gaW5qZWN0RWxlbWVudFdpdGhTdHlsZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBTdHJpbmcgcmVwcmVzZW50aW5nIGEgY3NzIHJ1bGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byB0ZXN0IHRoZSBpbmplY3RlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbm9kZXNdIC0gQW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG5vZGVzIHlvdSB3YW50IGluamVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFt0ZXN0bmFtZXNdIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGFyZSB1c2VkIGFzIGlkcyBmb3IgdGhlIGFkZGl0aW9uYWwgbm9kZXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIHNwZWNpZmllZCBjYWxsYmFjayB0ZXN0XG4gICAqL1xuICBmdW5jdGlvbiBpbmplY3RFbGVtZW50V2l0aFN0eWxlcyhydWxlLCBjYWxsYmFjaywgbm9kZXMsIHRlc3RuYW1lcykge1xuICAgIHZhciBtb2QgPSAnbW9kZXJuaXpyJztcbiAgICB2YXIgc3R5bGU7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgZG9jT3ZlcmZsb3c7XG4gICAgdmFyIGRpdiA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBib2R5ID0gZ2V0Qm9keSgpO1xuXG4gICAgaWYgKHBhcnNlSW50KG5vZGVzLCAxMCkpIHtcbiAgICAgIC8vIEluIG9yZGVyIG5vdCB0byBnaXZlIGZhbHNlIHBvc2l0aXZlcyB3ZSBjcmVhdGUgYSBub2RlIGZvciBlYWNoIHRlc3RcbiAgICAgIC8vIFRoaXMgYWxzbyBhbGxvd3MgdGhlIG1ldGhvZCB0byBzY2FsZSBmb3IgdW5zcGVjaWZpZWQgdXNlc1xuICAgICAgd2hpbGUgKG5vZGVzLS0pIHtcbiAgICAgICAgbm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBub2RlLmlkID0gdGVzdG5hbWVzID8gdGVzdG5hbWVzW25vZGVzXSA6IG1vZCArIChub2RlcyArIDEpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3R5bGUgPSBjcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIHN0eWxlLmlkID0gJ3MnICsgbW9kO1xuXG4gICAgLy8gSUU2IHdpbGwgZmFsc2UgcG9zaXRpdmUgb24gc29tZSB0ZXN0cyBkdWUgdG8gdGhlIHN0eWxlIGVsZW1lbnQgaW5zaWRlIHRoZSB0ZXN0IGRpdiBzb21laG93IGludGVyZmVyaW5nIG9mZnNldEhlaWdodCwgc28gaW5zZXJ0IGl0IGludG8gYm9keSBvciBmYWtlYm9keS5cbiAgICAvLyBPcGVyYSB3aWxsIGFjdCBhbGwgcXVpcmt5IHdoZW4gaW5qZWN0aW5nIGVsZW1lbnRzIGluIGRvY3VtZW50RWxlbWVudCB3aGVuIHBhZ2UgaXMgc2VydmVkIGFzIHhtbCwgbmVlZHMgZmFrZWJvZHkgdG9vLiAjMjcwXG4gICAgKCFib2R5LmZha2UgPyBkaXYgOiBib2R5KS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJ1bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJ1bGUpKTtcbiAgICB9XG4gICAgZGl2LmlkID0gbW9kO1xuXG4gICAgaWYgKGJvZHkuZmFrZSkge1xuICAgICAgLy9hdm9pZCBjcmFzaGluZyBJRTgsIGlmIGJhY2tncm91bmQgaW1hZ2UgaXMgdXNlZFxuICAgICAgYm9keS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gICAgICAvL1NhZmFyaSA1LjEzLzUuMS40IE9TWCBzdG9wcyBsb2FkaW5nIGlmIDo6LXdlYmtpdC1zY3JvbGxiYXIgaXMgdXNlZCBhbmQgc2Nyb2xsYmFycyBhcmUgdmlzaWJsZVxuICAgICAgYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgZG9jT3ZlcmZsb3cgPSBkb2NFbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuICAgICAgZG9jRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgZG9jRWxlbWVudC5hcHBlbmRDaGlsZChib2R5KTtcbiAgICB9XG5cbiAgICByZXQgPSBjYWxsYmFjayhkaXYsIHJ1bGUpO1xuICAgIC8vIElmIHRoaXMgaXMgZG9uZSBhZnRlciBwYWdlIGxvYWQgd2UgZG9uJ3Qgd2FudCB0byByZW1vdmUgdGhlIGJvZHkgc28gY2hlY2sgaWYgYm9keSBleGlzdHNcbiAgICBpZiAoYm9keS5mYWtlKSB7XG4gICAgICBib2R5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYm9keSk7XG4gICAgICBkb2NFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gZG9jT3ZlcmZsb3c7XG4gICAgICAvLyBUcmlnZ2VyIGxheW91dCBzbyBraW5ldGljIHNjcm9sbGluZyBpc24ndCBkaXNhYmxlZCBpbiBpT1M2K1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBkb2NFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gISFyZXQ7XG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIHRlc3RTdHlsZXMgaW5qZWN0cyBhbiBlbGVtZW50IHdpdGggc3R5bGUgZWxlbWVudCBhbmQgc29tZSBDU1MgcnVsZXNcbiAgICpcbiAgICogQG1lbWJlck9mIE1vZGVybml6clxuICAgKiBAbmFtZSBNb2Rlcm5penIudGVzdFN0eWxlc1xuICAgKiBAb3B0aW9uTmFtZSBNb2Rlcm5penIudGVzdFN0eWxlcygpXG4gICAqIEBvcHRpb25Qcm9wIHRlc3RTdHlsZXNcbiAgICogQGFjY2VzcyBwdWJsaWNcbiAgICogQGZ1bmN0aW9uIHRlc3RTdHlsZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBTdHJpbmcgcmVwcmVzZW50aW5nIGEgY3NzIHJ1bGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byB0ZXN0IHRoZSBpbmplY3RlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbm9kZXNdIC0gQW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG5vZGVzIHlvdSB3YW50IGluamVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFt0ZXN0bmFtZXNdIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGFyZSB1c2VkIGFzIGlkcyBmb3IgdGhlIGFkZGl0aW9uYWwgbm9kZXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBNb2Rlcm5penIudGVzdFN0eWxlc2AgdGFrZXMgYSBDU1MgcnVsZSBhbmQgaW5qZWN0cyBpdCBvbnRvIHRoZSBjdXJyZW50IHBhZ2VcbiAgICogYWxvbmcgd2l0aCAocG9zc2libHkgbXVsdGlwbGUpIERPTSBlbGVtZW50cy4gVGhpcyBsZXRzIHlvdSBjaGVjayBmb3IgZmVhdHVyZXNcbiAgICogdGhhdCBjYW4gbm90IGJlIGRldGVjdGVkIGJ5IHNpbXBseSBjaGVja2luZyB0aGUgW0lETF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL0RldmVsb3Blcl9ndWlkZS9JbnRlcmZhY2VfZGV2ZWxvcG1lbnRfZ3VpZGUvSURMX2ludGVyZmFjZV9ydWxlcykuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIE1vZGVybml6ci50ZXN0U3R5bGVzKCcjbW9kZXJuaXpyIHsgd2lkdGg6IDlweDsgY29sb3I6IHBhcGF5YXdoaXA7IH0nLCBmdW5jdGlvbihlbGVtLCBydWxlKSB7XG4gICAqICAgLy8gZWxlbSBpcyB0aGUgZmlyc3QgRE9NIG5vZGUgaW4gdGhlIHBhZ2UgKGJ5IGRlZmF1bHQgI21vZGVybml6cilcbiAgICogICAvLyBydWxlIGlzIHRoZSBmaXJzdCBhcmd1bWVudCB5b3Ugc3VwcGxpZWQgLSB0aGUgQ1NTIHJ1bGUgaW4gc3RyaW5nIGZvcm1cbiAgICpcbiAgICogICBhZGRUZXN0KCd3aWR0aHdvcmtzJywgZWxlbS5zdHlsZS53aWR0aCA9PT0gJzlweCcpXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91ciB0ZXN0IHJlcXVpcmVzIG11bHRpcGxlIG5vZGVzLCB5b3UgY2FuIGluY2x1ZGUgYSB0aGlyZCBhcmd1bWVudFxuICAgKiBpbmRpY2F0aW5nIGhvdyBtYW55IGFkZGl0aW9uYWwgZGl2IGVsZW1lbnRzIHRvIGluY2x1ZGUgb24gdGhlIHBhZ2UuIFRoZVxuICAgKiBhZGRpdGlvbmFsIG5vZGVzIGFyZSBpbmplY3RlZCBhcyBjaGlsZHJlbiBvZiB0aGUgYGVsZW1gIHRoYXQgaXMgcmV0dXJuZWQgYXNcbiAgICogdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogYGBganNcbiAgICogTW9kZXJuaXpyLnRlc3RTdHlsZXMoJyNtb2Rlcm5penIge3dpZHRoOiAxcHh9OyAjbW9kZXJuaXpyMiB7d2lkdGg6IDJweH0nLCBmdW5jdGlvbihlbGVtKSB7XG4gICAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGVybml6cicpLnN0eWxlLndpZHRoID09PSAnMXB4JzsgLy8gdHJ1ZVxuICAgKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2Rlcm5penIyJykuc3R5bGUud2lkdGggPT09ICcycHgnOyAvLyB0cnVlXG4gICAqICAgZWxlbS5maXJzdENoaWxkID09PSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZXJuaXpyMicpOyAvLyB0cnVlXG4gICAqIH0sIDEpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYWxsIG9mIHRoZSBhZGRpdGlvbmFsIGVsZW1lbnRzIGhhdmUgYW4gSUQgb2YgYG1vZGVybml6cltuXWAsIHdoZXJlXG4gICAqIGBuYCBpcyBpdHMgaW5kZXggKGUuZy4gdGhlIGZpcnN0IGFkZGl0aW9uYWwsIHNlY29uZCBvdmVyYWxsIGlzIGAjbW9kZXJuaXpyMmAsXG4gICAqIHRoZSBzZWNvbmQgYWRkaXRpb25hbCBpcyBgI21vZGVybml6cjNgLCBldGMuKS5cbiAgICogSWYgeW91IHdhbnQgdG8gaGF2ZSBtb3JlIG1lYW5pbmdmdWwgSURzIGZvciB5b3VyIGZ1bmN0aW9uLCB5b3UgY2FuIHByb3ZpZGVcbiAgICogdGhlbSBhcyB0aGUgZm91cnRoIGFyZ3VtZW50LCBhcyBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIE1vZGVybml6ci50ZXN0U3R5bGVzKCcjZm9vIHt3aWR0aDogMTBweH07ICNiYXIge2hlaWdodDogMjBweH0nLCBmdW5jdGlvbihlbGVtKSB7XG4gICAqICAgZWxlbS5maXJzdENoaWxkID09PSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vJyk7IC8vIHRydWVcbiAgICogICBlbGVtLmxhc3RDaGlsZCA9PT0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhcicpOyAvLyB0cnVlXG4gICAqIH0sIDIsIFsnZm9vJywgJ2JhciddKTtcbiAgICogYGBgXG4gICAqL1xuICB2YXIgdGVzdFN0eWxlcyA9IE1vZGVybml6clByb3RvLnRlc3RTdHlsZXMgPSBpbmplY3RFbGVtZW50V2l0aFN0eWxlcztcbiAgXG4vKiFcbntcbiAgXCJuYW1lXCI6IFwiSGlkZGVuIFNjcm9sbGJhclwiLFxuICBcInByb3BlcnR5XCI6IFwiaGlkZGVuc2Nyb2xsXCIsXG4gIFwiYXV0aG9yc1wiOiBbXCJPbGVnIEtvcnN1bnNreVwiXSxcbiAgXCJ0YWdzXCI6IFtcIm92ZXJsYXlcIl0sXG4gIFwibm90ZXNcIjogW3tcbiAgICBcIm5hbWVcIjogXCJPdmVybGF5IFNjcm9sbGJhciBkZXNjcmlwdGlvblwiLFxuICAgIFwiaHJlZlwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L21hYy9yZWxlYXNlbm90ZXMvTWFjT1NYL1doYXRzTmV3SW5PU1gvQXJ0aWNsZXMvTWFjT1NYMTBfNy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAxMDM1NS1TVzM5XCJcbiAgfSx7XG4gICAgXCJuYW1lXCI6IFwiVmlkZW8gZXhhbXBsZSBvZiBvdmVybGF5IHNjcm9sbGJhcnNcIixcbiAgICBcImhyZWZcIjogXCJodHRwczovL2dmeWNhdC5jb20vRm9vbGlzaE1lYXNseUF0bGFudGljc2hhcnBub3NlcHVmZmVyXCJcbiAgfV1cbn1cbiEqL1xuLyogRE9DXG5EZXRlY3RzIG92ZXJsYXkgc2Nyb2xsYmFycyAod2hlbiBzY3JvbGxiYXJzIG9uIG92ZXJmbG93ZWQgYmxvY2tzIGFyZSB2aXNpYmxlKS4gVGhpcyBpcyBmb3VuZCBtb3N0IGNvbW1vbmx5IG9uIG1vYmlsZSBhbmQgT1MgWC5cbiovXG5cbiAgTW9kZXJuaXpyLmFkZFRlc3QoJ2hpZGRlbnNjcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0ZXN0U3R5bGVzKCcjbW9kZXJuaXpyIHt3aWR0aDoxMDBweDtoZWlnaHQ6MTAwcHg7b3ZlcmZsb3c6c2Nyb2xsfScsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtLm9mZnNldFdpZHRoID09PSBlbGVtLmNsaWVudFdpZHRoO1xuICAgIH0pO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBzZXQgZm9yIGNzcyB0ZXN0cy4gU2VlIHRpY2tldCAjMjFcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21vZGVybml6ci9tb2Rlcm5penIvaXNzdWVzLzIxXG4gICAqXG4gICAqIEBtZW1iZXJPZiBNb2Rlcm5penJcbiAgICogQG5hbWUgTW9kZXJuaXpyLl9wcmVmaXhlc1xuICAgKiBAb3B0aW9uTmFtZSBNb2Rlcm5penIuX3ByZWZpeGVzXG4gICAqIEBvcHRpb25Qcm9wIHByZWZpeGVzXG4gICAqIEBhY2Nlc3MgcHVibGljXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIE1vZGVybml6ci5fcHJlZml4ZXMgaXMgdGhlIGludGVybmFsIGxpc3Qgb2YgcHJlZml4ZXMgdGhhdCB3ZSB0ZXN0IGFnYWluc3RcbiAgICogaW5zaWRlIG9mIHRoaW5ncyBsaWtlIFtwcmVmaXhlZF0oI21vZGVybml6ci1wcmVmaXhlZCkgYW5kIFtwcmVmaXhlZENTU10oIy1jb2RlLW1vZGVybml6ci1wcmVmaXhlZGNzcykuIEl0IGlzIHNpbXBseVxuICAgKiBhbiBhcnJheSBvZiBrZWJhYi1jYXNlIHZlbmRvciBwcmVmaXhlcyB5b3UgY2FuIHVzZSB3aXRoaW4geW91ciBjb2RlLlxuICAgKlxuICAgKiBTb21lIGNvbW1vbiB1c2UgY2FzZXMgaW5jbHVkZVxuICAgKlxuICAgKiBHZW5lcmF0aW5nIGFsbCBwb3NzaWJsZSBwcmVmaXhlZCB2ZXJzaW9uIG9mIGEgQ1NTIHByb3BlcnR5XG4gICAqIGBgYGpzXG4gICAqIHZhciBydWxlID0gTW9kZXJuaXpyLl9wcmVmaXhlcy5qb2luKCd0cmFuc2Zvcm06IHJvdGF0ZSgyMGRlZyk7ICcpO1xuICAgKlxuICAgKiBydWxlID09PSAndHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOyB3ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOyBtb3otdHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOyBvLXRyYW5zZm9ybTogcm90YXRlKDIwZGVnKTsgbXMtdHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOydcbiAgICogYGBgXG4gICAqXG4gICAqIEdlbmVyYXRpbmcgYWxsIHBvc3NpYmxlIHByZWZpeGVkIHZlcnNpb24gb2YgYSBDU1MgdmFsdWVcbiAgICogYGBganNcbiAgICogcnVsZSA9ICdkaXNwbGF5OicgKyAgTW9kZXJuaXpyLl9wcmVmaXhlcy5qb2luKCdmbGV4OyBkaXNwbGF5OicpICsgJ2ZsZXgnO1xuICAgKlxuICAgKiBydWxlID09PSAnZGlzcGxheTpmbGV4OyBkaXNwbGF5Oi13ZWJraXQtZmxleDsgZGlzcGxheTotbW96LWZsZXg7IGRpc3BsYXk6LW8tZmxleDsgZGlzcGxheTotbXMtZmxleDsgZGlzcGxheTpmbGV4J1xuICAgKiBgYGBcbiAgICovXG4gIC8vIHdlIHVzZSBbJycsJyddIHJhdGhlciB0aGFuIGFuIGVtcHR5IGFycmF5IGluIG9yZGVyIHRvIGFsbG93IGEgcGF0dGVybiBvZiAuYGpvaW4oKWBpbmcgcHJlZml4ZXMgdG8gdGVzdFxuICAvLyB2YWx1ZXMgaW4gZmVhdHVyZSBkZXRlY3RzIHRvIGNvbnRpbnVlIHRvIHdvcmtcbiAgdmFyIHByZWZpeGVzID0gKE1vZGVybml6clByb3RvLl9jb25maWcudXNlUHJlZml4ZXMgPyAnIC13ZWJraXQtIC1tb3otIC1vLSAtbXMtICcuc3BsaXQoJyAnKSA6IFsnJywnJ10pO1xuXG4gIC8vIGV4cG9zZSB0aGVzZSBmb3IgdGhlIHBsdWdpbiBBUEkuIExvb2sgaW4gdGhlIHNvdXJjZSBmb3IgaG93IHRvIGpvaW4oKSB0aGVtIGFnYWluc3QgeW91ciBpbnB1dFxuICBNb2Rlcm5penJQcm90by5fcHJlZml4ZXMgPSBwcmVmaXhlcztcblxuICBcblxuICAvKipcbiAgICogTW9kZXJuaXpyLm1xIHRlc3RzIGEgZ2l2ZW4gbWVkaWEgcXVlcnksIGxpdmUgYWdhaW5zdCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgd2luZG93XG4gICAqIGFkYXB0ZWQgZnJvbSBtYXRjaE1lZGlhIHBvbHlmaWxsIGJ5IFNjb3R0IEplaGwgYW5kIFBhdWwgSXJpc2hcbiAgICogZ2lzdC5naXRodWIuY29tLzc4Njc2OFxuICAgKlxuICAgKiBAbWVtYmVyT2YgTW9kZXJuaXpyXG4gICAqIEBuYW1lIE1vZGVybml6ci5tcVxuICAgKiBAb3B0aW9uTmFtZSBNb2Rlcm5penIubXEoKVxuICAgKiBAb3B0aW9uUHJvcCBtcVxuICAgKiBAYWNjZXNzIHB1YmxpY1xuICAgKiBAZnVuY3Rpb24gbXFcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1xIC0gU3RyaW5nIG9mIHRoZSBtZWRpYSBxdWVyeSB3ZSB3YW50IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIE1vZGVybml6ci5tcSBhbGxvd3MgZm9yIHlvdSB0byBwcm9ncmFtbWF0aWNhbGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50IGJyb3dzZXJcbiAgICogd2luZG93IHN0YXRlIG1hdGNoZXMgYSBtZWRpYSBxdWVyeS5cbiAgICpcbiAgICogYGBganNcbiAgICogIHZhciBxdWVyeSA9IE1vZGVybml6ci5tcSgnKG1pbi13aWR0aDogOTAwcHgpJyk7XG4gICAqXG4gICAqICBpZiAocXVlcnkpIHtcbiAgICogICAgLy8gdGhlIGJyb3dzZXIgd2luZG93IGlzIGxhcmdlciB0aGFuIDkwMHB4XG4gICAqICB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBPbmx5IHZhbGlkIG1lZGlhIHF1ZXJpZXMgYXJlIHN1cHBvcnRlZCwgdGhlcmVmb3JlIHlvdSBtdXN0IGFsd2F5cyBpbmNsdWRlIHZhbHVlc1xuICAgKiB3aXRoIHlvdXIgbWVkaWEgcXVlcnlcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gZ29vZFxuICAgKiAgTW9kZXJuaXpyLm1xKCcobWluLXdpZHRoOiA5MDBweCknKTtcbiAgICpcbiAgICogLy8gYmFkXG4gICAqICBNb2Rlcm5penIubXEoJ21pbi13aWR0aCcpO1xuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91IHdvdWxkIGp1c3QgbGlrZSB0byB0ZXN0IHRoYXQgbWVkaWEgcXVlcmllcyBhcmUgc3VwcG9ydGVkIGluIGdlbmVyYWwsIHVzZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAgTW9kZXJuaXpyLm1xKCdvbmx5IGFsbCcpOyAvLyB0cnVlIGlmIE1RIGFyZSBzdXBwb3J0ZWQsIGZhbHNlIGlmIG5vdFxuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbWVkaWEgcXVlcmllcyAoZS5nLiBvbGQgSUUpIG1xIHdpbGxcbiAgICogYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICovXG4gIHZhciBtcSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0Y2hNZWRpYSA9IHdpbmRvdy5tYXRjaE1lZGlhIHx8IHdpbmRvdy5tc01hdGNoTWVkaWE7XG4gICAgaWYgKG1hdGNoTWVkaWEpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihtcSkge1xuICAgICAgICB2YXIgbXFsID0gbWF0Y2hNZWRpYShtcSk7XG4gICAgICAgIHJldHVybiBtcWwgJiYgbXFsLm1hdGNoZXMgfHwgZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihtcSkge1xuICAgICAgdmFyIGJvb2wgPSBmYWxzZTtcblxuICAgICAgaW5qZWN0RWxlbWVudFdpdGhTdHlsZXMoJ0BtZWRpYSAnICsgbXEgKyAnIHsgI21vZGVybml6ciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgfSB9JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBib29sID0gKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID9cbiAgICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKSA6XG4gICAgICAgICAgbm9kZS5jdXJyZW50U3R5bGUpLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBib29sO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgTW9kZXJuaXpyUHJvdG8ubXEgPSBtcTtcblxuICBcbi8qIVxue1xuICBcIm5hbWVcIjogXCJUb3VjaCBFdmVudHNcIixcbiAgXCJwcm9wZXJ0eVwiOiBcInRvdWNoZXZlbnRzXCIsXG4gIFwiY2FuaXVzZVwiOiBcInRvdWNoXCIsXG4gIFwidGFnc1wiOiBbXCJtZWRpYVwiLCBcImF0dHJpYnV0ZVwiXSxcbiAgXCJub3Rlc1wiOiBbe1xuICAgIFwibmFtZVwiOiBcIlRvdWNoIEV2ZW50cyBzcGVjXCIsXG4gICAgXCJocmVmXCI6IFwiaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtdG91Y2gtZXZlbnRzLTIwMTMwMTI0L1wiXG4gIH1dLFxuICBcIndhcm5pbmdzXCI6IFtcbiAgICBcIioqIERFUFJFQ0FURUQgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL3B1bGwvMjQzMiAqKlwiLFxuICAgIFwiSW5kaWNhdGVzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBUb3VjaCBFdmVudHMgc3BlYywgYW5kIGRvZXMgbm90IG5lY2Vzc2FyaWx5IHJlZmxlY3QgYSB0b3VjaHNjcmVlbiBkZXZpY2VcIlxuICBdLFxuICBcImtub3duQnVnc1wiOiBbXG4gICAgXCJGYWxzZS1wb3NpdGl2ZSBvbiBzb21lIGNvbmZpZ3VyYXRpb25zIG9mIE5va2lhIE45MDBcIixcbiAgICBcIkZhbHNlLXBvc2l0aXZlIG9uIHNvbWUgQmxhY2tCZXJyeSA2LjAgYnVpbGRzIOKAkyBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9pc3N1ZXMvMzcyI2lzc3VlY29tbWVudC0zMTEyNjk1XCJcbiAgXVxufVxuISovXG4vKiBET0NcbkluZGljYXRlcyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgVzNDIFRvdWNoIEV2ZW50cyBBUEkuXG5cblRoaXMgKmRvZXMgbm90KiBuZWNlc3NhcmlseSByZWZsZWN0IGEgdG91Y2hzY3JlZW4gZGV2aWNlOlxuXG4qIE9sZGVyIHRvdWNoc2NyZWVuIGRldmljZXMgb25seSBlbXVsYXRlIG1vdXNlIGV2ZW50c1xuKiBNb2Rlcm4gSUUgdG91Y2ggZGV2aWNlcyBpbXBsZW1lbnQgdGhlIFBvaW50ZXIgRXZlbnRzIEFQSSBpbnN0ZWFkOiB1c2UgYE1vZGVybml6ci5wb2ludGVyZXZlbnRzYCB0byBkZXRlY3Qgc3VwcG9ydCBmb3IgdGhhdFxuKiBTb21lIGJyb3dzZXJzICYgT1Mgc2V0dXBzIG1heSBlbmFibGUgdG91Y2ggQVBJcyB3aGVuIG5vIHRvdWNoc2NyZWVuIGlzIGNvbm5lY3RlZFxuKiBGdXR1cmUgYnJvd3NlcnMgbWF5IGltcGxlbWVudCBvdGhlciBldmVudCBtb2RlbHMgZm9yIHRvdWNoIGludGVyYWN0aW9uc1xuXG5TZWUgdGhpcyBhcnRpY2xlOiBbWW91IENhbid0IERldGVjdCBBIFRvdWNoc2NyZWVuXShodHRwOi8vd3d3LnN0dWNveC5jb20vYmxvZy95b3UtY2FudC1kZXRlY3QtYS10b3VjaHNjcmVlbi8pLlxuXG5JdCdzIHJlY29tbWVuZGVkIHRvIGJpbmQgYm90aCBtb3VzZSBhbmQgdG91Y2gvcG9pbnRlciBldmVudHMgc2ltdWx0YW5lb3VzbHkg4oCTIHNlZSBbdGhpcyBIVE1MNSBSb2NrcyB0dXRvcmlhbF0oaHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vbW9iaWxlL3RvdWNoYW5kbW91c2UvKS5cblxuVGhpcyB0ZXN0IHdpbGwgYWxzbyByZXR1cm4gYHRydWVgIGZvciBGaXJlZm94IDQgTXVsdGl0b3VjaCBzdXBwb3J0LlxuKi9cblxuICAvLyBDaHJvbWUgKGRlc2t0b3ApIHVzZWQgdG8gbGllIGFib3V0IGl0cyBzdXBwb3J0IG9uIHRoaXMsIGJ1dCB0aGF0IGhhcyBzaW5jZSBiZWVuIHJlY3RpZmllZDogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzY0MTVcbiAgLy8gQ2hyb21lIGFsc28gY2hhbmdlZCBpdHMgYmVoYXZpb3VyIHNpbmNlIHY3MCBhbmQgcmVjb21tZW5kcyB0aGUgVG91Y2hFdmVudCBvYmplY3QgZm9yIGRldGVjdGlvbjogaHR0cHM6Ly93d3cuY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlLzQ3NjQyMjUzNDgwNDI3NTJcbiAgTW9kZXJuaXpyLmFkZFRlc3QoJ3RvdWNoZXZlbnRzJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Ub3VjaEV2ZW50IHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gaW5jbHVkZSB0aGUgJ2hlYXJ0eicgYXMgYSB3YXkgdG8gaGF2ZSBhIG5vbiBtYXRjaGluZyBNUSB0byBoZWxwIHRlcm1pbmF0ZSB0aGUgam9pblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2lzc3Vlcy8xODE0XG4gICAgdmFyIHF1ZXJ5ID0gWycoJywgcHJlZml4ZXMuam9pbigndG91Y2gtZW5hYmxlZCksKCcpLCAnaGVhcnR6JywgJyknXS5qb2luKCcnKTtcbiAgICByZXR1cm4gbXEocXVlcnkpO1xuICB9KTtcblxuXG4gIC8vIFJ1biBlYWNoIHRlc3RcbiAgdGVzdFJ1bm5lcigpO1xuXG4gIC8vIFJlbW92ZSB0aGUgXCJuby1qc1wiIGNsYXNzIGlmIGl0IGV4aXN0c1xuICBzZXRDbGFzc2VzKGNsYXNzZXMpO1xuXG4gIGRlbGV0ZSBNb2Rlcm5penJQcm90by5hZGRUZXN0O1xuICBkZWxldGUgTW9kZXJuaXpyUHJvdG8uYWRkQXN5bmNUZXN0O1xuXG4gIC8vIFJ1biB0aGUgdGhpbmdzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIHJ1biBhZnRlciB0aGUgdGVzdHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNb2Rlcm5penIuX3EubGVuZ3RoOyBpKyspIHtcbiAgICBNb2Rlcm5penIuX3FbaV0oKTtcbiAgfVxuXG4gIC8vIExlYWsgTW9kZXJuaXpyIG5hbWVzcGFjZVxuICB3aW5kb3cuTW9kZXJuaXpyID0gTW9kZXJuaXpyO1xuXG5cbjtcblxufSkod2luZG93LCBkb2N1bWVudCk7XG4iLCIvKlxuICogYW5pbWUuanMgdjMuMS4wXG4gKiAoYykgMjAxOSBKdWxpYW4gR2FybmllclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBhbmltZWpzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gRGVmYXVsdHNcblxudmFyIGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzID0ge1xuICB1cGRhdGU6IG51bGwsXG4gIGJlZ2luOiBudWxsLFxuICBsb29wQmVnaW46IG51bGwsXG4gIGNoYW5nZUJlZ2luOiBudWxsLFxuICBjaGFuZ2U6IG51bGwsXG4gIGNoYW5nZUNvbXBsZXRlOiBudWxsLFxuICBsb29wQ29tcGxldGU6IG51bGwsXG4gIGNvbXBsZXRlOiBudWxsLFxuICBsb29wOiAxLFxuICBkaXJlY3Rpb246ICdub3JtYWwnLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgdGltZWxpbmVPZmZzZXQ6IDBcbn07XG5cbnZhciBkZWZhdWx0VHdlZW5TZXR0aW5ncyA9IHtcbiAgZHVyYXRpb246IDEwMDAsXG4gIGRlbGF5OiAwLFxuICBlbmREZWxheTogMCxcbiAgZWFzaW5nOiAnZWFzZU91dEVsYXN0aWMoMSwgLjUpJyxcbiAgcm91bmQ6IDBcbn07XG5cbnZhciB2YWxpZFRyYW5zZm9ybXMgPSBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJywgJ3JvdGF0ZScsICdyb3RhdGVYJywgJ3JvdGF0ZVknLCAncm90YXRlWicsICdzY2FsZScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ3NjYWxlWicsICdza2V3JywgJ3NrZXdYJywgJ3NrZXdZJywgJ3BlcnNwZWN0aXZlJ107XG5cbi8vIENhY2hpbmdcblxudmFyIGNhY2hlID0ge1xuICBDU1M6IHt9LFxuICBzcHJpbmdzOiB7fVxufTtcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gbWluTWF4KHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nQ29udGFpbnMoc3RyLCB0ZXh0KSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZih0ZXh0KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBhcHBseUFyZ3VtZW50cyhmdW5jLCBhcmdzKSB7XG4gIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG52YXIgaXMgPSB7XG4gIGFycjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSk7IH0sXG4gIG9iajogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHN0cmluZ0NvbnRhaW5zKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSwgJ09iamVjdCcpOyB9LFxuICBwdGg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBpcy5vYmooYSkgJiYgYS5oYXNPd25Qcm9wZXJ0eSgndG90YWxMZW5ndGgnKTsgfSxcbiAgc3ZnOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7IH0sXG4gIGlucDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50OyB9LFxuICBkb206IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5vZGVUeXBlIHx8IGlzLnN2ZyhhKTsgfSxcbiAgc3RyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdzdHJpbmcnOyB9LFxuICBmbmM6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgdW5kOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnOyB9LFxuICBoZXg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChhKTsgfSxcbiAgcmdiOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15yZ2IvLnRlc3QoYSk7IH0sXG4gIGhzbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9eaHNsLy50ZXN0KGEpOyB9LFxuICBjb2w6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAoaXMuaGV4KGEpIHx8IGlzLnJnYihhKSB8fCBpcy5oc2woYSkpOyB9LFxuICBrZXk6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAhZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgIWRlZmF1bHRUd2VlblNldHRpbmdzLmhhc093blByb3BlcnR5KGEpICYmIGEgIT09ICd0YXJnZXRzJyAmJiBhICE9PSAna2V5ZnJhbWVzJzsgfVxufTtcblxuLy8gRWFzaW5nc1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IC9cXCgoW14pXSspXFwpLy5leGVjKHN0cmluZyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXJzZUZsb2F0KHApOyB9KSA6IFtdO1xufVxuXG4vLyBTcHJpbmcgc29sdmVyIGluc3BpcmVkIGJ5IFdlYmtpdCBDb3B5cmlnaHQgwqkgMjAxNiBBcHBsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG5cbmZ1bmN0aW9uIHNwcmluZyhzdHJpbmcsIGR1cmF0aW9uKSB7XG5cbiAgdmFyIHBhcmFtcyA9IHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpO1xuICB2YXIgbWFzcyA9IG1pbk1heChpcy51bmQocGFyYW1zWzBdKSA/IDEgOiBwYXJhbXNbMF0sIC4xLCAxMDApO1xuICB2YXIgc3RpZmZuZXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMV0pID8gMTAwIDogcGFyYW1zWzFdLCAuMSwgMTAwKTtcbiAgdmFyIGRhbXBpbmcgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1syXSkgPyAxMCA6IHBhcmFtc1syXSwgLjEsIDEwMCk7XG4gIHZhciB2ZWxvY2l0eSA9ICBtaW5NYXgoaXMudW5kKHBhcmFtc1szXSkgPyAwIDogcGFyYW1zWzNdLCAuMSwgMTAwKTtcbiAgdmFyIHcwID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpO1xuICB2YXIgemV0YSA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gIHZhciB3ZCA9IHpldGEgPCAxID8gdzAgKiBNYXRoLnNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSB6ZXRhIDwgMSA/ICh6ZXRhICogdzAgKyAtdmVsb2NpdHkpIC8gd2QgOiAtdmVsb2NpdHkgKyB3MDtcblxuICBmdW5jdGlvbiBzb2x2ZXIodCkge1xuICAgIHZhciBwcm9ncmVzcyA9IGR1cmF0aW9uID8gKGR1cmF0aW9uICogdCkgLyAxMDAwIDogdDtcbiAgICBpZiAoemV0YSA8IDEpIHtcbiAgICAgIHByb2dyZXNzID0gTWF0aC5leHAoLXByb2dyZXNzICogemV0YSAqIHcwKSAqIChhICogTWF0aC5jb3Mod2QgKiBwcm9ncmVzcykgKyBiICogTWF0aC5zaW4od2QgKiBwcm9ncmVzcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmVzcyA9IChhICsgYiAqIHByb2dyZXNzKSAqIE1hdGguZXhwKC1wcm9ncmVzcyAqIHcwKTtcbiAgICB9XG4gICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkgeyByZXR1cm4gdDsgfVxuICAgIHJldHVybiAxIC0gcHJvZ3Jlc3M7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuc3ByaW5nc1tzdHJpbmddO1xuICAgIGlmIChjYWNoZWQpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICAgIHZhciBmcmFtZSA9IDEvNjtcbiAgICB2YXIgZWxhcHNlZCA9IDA7XG4gICAgdmFyIHJlc3QgPSAwO1xuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGVsYXBzZWQgKz0gZnJhbWU7XG4gICAgICBpZiAoc29sdmVyKGVsYXBzZWQpID09PSAxKSB7XG4gICAgICAgIHJlc3QrKztcbiAgICAgICAgaWYgKHJlc3QgPj0gMTYpIHsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3QgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZHVyYXRpb24gPSBlbGFwc2VkICogZnJhbWUgKiAxMDAwO1xuICAgIGNhY2hlLnNwcmluZ3Nbc3RyaW5nXSA9IGR1cmF0aW9uO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbiA/IHNvbHZlciA6IGdldER1cmF0aW9uO1xuXG59XG5cbi8vIEJhc2ljIHN0ZXBzIGVhc2luZyBpbXBsZW1lbnRhdGlvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9mci9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cblxuZnVuY3Rpb24gc3RlcHMoc3RlcHMpIHtcbiAgaWYgKCBzdGVwcyA9PT0gdm9pZCAwICkgc3RlcHMgPSAxMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucm91bmQodCAqIHN0ZXBzKSAqICgxIC8gc3RlcHMpOyB9O1xufVxuXG4vLyBCZXppZXJFYXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nXG5cbnZhciBiZXppZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gIHZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5cbiAgZnVuY3Rpb24gQShhQTEsIGFBMikgeyByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExIH1cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikgeyByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExIH1cbiAgZnVuY3Rpb24gQyhhQTEpICAgICAgeyByZXR1cm4gMy4wICogYUExIH1cblxuICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikgeyByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQgfVxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSkgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7IGFCID0gY3VycmVudFQ7IH0gZWxzZSB7IGFBID0gY3VycmVudFQ7IH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiAwLjAwMDAwMDEgJiYgKytpIDwgMTApO1xuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7IHJldHVybiBhR3Vlc3NUOyB9XG4gICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cblxuICBmdW5jdGlvbiBiZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG5cbiAgICBpZiAoISgwIDw9IG1YMSAmJiBtWDEgPD0gMSAmJiAwIDw9IG1YMiAmJiBtWDIgPD0gMSkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cbiAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG5cbiAgICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgfVxuXG4gICAgICAtLWN1cnJlbnRTYW1wbGU7XG5cbiAgICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSAwLjAwMSkge1xuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHsgcmV0dXJuIHg7IH1cbiAgICAgIGlmICh4ID09PSAwIHx8IHggPT09IDEpIHsgcmV0dXJuIHg7IH1cbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gYmV6aWVyO1xuXG59KSgpO1xuXG52YXIgcGVubmVyID0gKGZ1bmN0aW9uICgpIHtcblxuICAvLyBCYXNlZCBvbiBqUXVlcnkgVUkncyBpbXBsZW1lbmF0aW9uIG9mIGVhc2luZyBlcXVhdGlvbnMgZnJvbSBSb2JlcnQgUGVubmVyIChodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nKVxuXG4gIHZhciBlYXNlcyA9IHsgbGluZWFyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfTsgfSB9O1xuXG4gIHZhciBmdW5jdGlvbkVhc2luZ3MgPSB7XG4gICAgU2luZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpOyB9OyB9LFxuICAgIENpcmM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7IH07IH0sXG4gICAgQmFjazogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogKDMgKiB0IC0gMik7IH07IH0sXG4gICAgQm91bmNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIHBvdzIsIGIgPSA0O1xuICAgICAgd2hpbGUgKHQgPCAoKCBwb3cyID0gTWF0aC5wb3coMiwgLS1iKSkgLSAxKSAvIDExKSB7fVxuICAgICAgcmV0dXJuIDEgLyBNYXRoLnBvdyg0LCAzIC0gYikgLSA3LjU2MjUgKiBNYXRoLnBvdygoIHBvdzIgKiAzIC0gMiApIC8gMjIgLSB0LCAyKVxuICAgIH07IH0sXG4gICAgRWxhc3RpYzogZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgICBpZiAoIGFtcGxpdHVkZSA9PT0gdm9pZCAwICkgYW1wbGl0dWRlID0gMTtcbiAgICAgIGlmICggcGVyaW9kID09PSB2b2lkIDAgKSBwZXJpb2QgPSAuNTtcblxuICAgICAgdmFyIGEgPSBtaW5NYXgoYW1wbGl0dWRlLCAxLCAxMCk7XG4gICAgICB2YXIgcCA9IG1pbk1heChwZXJpb2QsIC4xLCAyKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyB0IDogXG4gICAgICAgICAgLWEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICogTWF0aC5zaW4oKCgodCAtIDEpIC0gKHAgLyAoTWF0aC5QSSAqIDIpICogTWF0aC5hc2luKDEgLyBhKSkpICogKE1hdGguUEkgKiAyKSkgLyBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGJhc2VFYXNpbmdzID0gWydRdWFkJywgJ0N1YmljJywgJ1F1YXJ0JywgJ1F1aW50JywgJ0V4cG8nXTtcblxuICBiYXNlRWFzaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgZnVuY3Rpb25FYXNpbmdzW25hbWVdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucG93KHQsIGkgKyAyKTsgfTsgfTtcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZnVuY3Rpb25FYXNpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGVhc2VJbiA9IGZ1bmN0aW9uRWFzaW5nc1tuYW1lXTtcbiAgICBlYXNlc1snZWFzZUluJyArIG5hbWVdID0gZWFzZUluO1xuICAgIGVhc2VzWydlYXNlT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gZWFzZUluKGEsIGIpKDEgLSB0KTsgfTsgfTtcbiAgICBlYXNlc1snZWFzZUluT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgMC41ID8gZWFzZUluKGEsIGIpKHQgKiAyKSAvIDIgOiBcbiAgICAgIDEgLSBlYXNlSW4oYSwgYikodCAqIC0yICsgMikgLyAyOyB9OyB9O1xuICB9KTtcblxuICByZXR1cm4gZWFzZXM7XG5cbn0pKCk7XG5cbmZ1bmN0aW9uIHBhcnNlRWFzaW5ncyhlYXNpbmcsIGR1cmF0aW9uKSB7XG4gIGlmIChpcy5mbmMoZWFzaW5nKSkgeyByZXR1cm4gZWFzaW5nOyB9XG4gIHZhciBuYW1lID0gZWFzaW5nLnNwbGl0KCcoJylbMF07XG4gIHZhciBlYXNlID0gcGVubmVyW25hbWVdO1xuICB2YXIgYXJncyA9IHBhcnNlRWFzaW5nUGFyYW1ldGVycyhlYXNpbmcpO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzcHJpbmcnIDogcmV0dXJuIHNwcmluZyhlYXNpbmcsIGR1cmF0aW9uKTtcbiAgICBjYXNlICdjdWJpY0JlemllcicgOiByZXR1cm4gYXBwbHlBcmd1bWVudHMoYmV6aWVyLCBhcmdzKTtcbiAgICBjYXNlICdzdGVwcycgOiByZXR1cm4gYXBwbHlBcmd1bWVudHMoc3RlcHMsIGFyZ3MpO1xuICAgIGRlZmF1bHQgOiByZXR1cm4gYXBwbHlBcmd1bWVudHMoZWFzZSwgYXJncyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nc1xuXG5mdW5jdGlvbiBzZWxlY3RTdHJpbmcoc3RyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzdHIpO1xuICAgIHJldHVybiBub2RlcztcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cbi8vIEFycmF5c1xuXG5mdW5jdGlvbiBmaWx0ZXJBcnJheShhcnIsIGNhbGxiYWNrKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGkgaW4gYXJyKSB7XG4gICAgICB2YXIgdmFsID0gYXJyW2ldO1xuICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsLCBpLCBhcnIpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheShhcnIpIHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGlzLmFycihiKSA/IGZsYXR0ZW5BcnJheShiKSA6IGIpOyB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkobykge1xuICBpZiAoaXMuYXJyKG8pKSB7IHJldHVybiBvOyB9XG4gIGlmIChpcy5zdHIobykpIHsgbyA9IHNlbGVjdFN0cmluZyhvKSB8fCBvOyB9XG4gIGlmIChvIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgbyBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uKSB7IHJldHVybiBbXS5zbGljZS5jYWxsKG8pOyB9XG4gIHJldHVybiBbb107XG59XG5cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnMoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5zb21lKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhID09PSB2YWw7IH0pO1xufVxuXG4vLyBPYmplY3RzXG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KG8pIHtcbiAgdmFyIGNsb25lID0ge307XG4gIGZvciAodmFyIHAgaW4gbykgeyBjbG9uZVtwXSA9IG9bcF07IH1cbiAgcmV0dXJuIGNsb25lO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlT2JqZWN0UHJvcHMobzEsIG8yKSB7XG4gIHZhciBvID0gY2xvbmVPYmplY3QobzEpO1xuICBmb3IgKHZhciBwIGluIG8xKSB7IG9bcF0gPSBvMi5oYXNPd25Qcm9wZXJ0eShwKSA/IG8yW3BdIDogbzFbcF07IH1cbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvMSwgbzIpIHtcbiAgdmFyIG8gPSBjbG9uZU9iamVjdChvMSk7XG4gIGZvciAodmFyIHAgaW4gbzIpIHsgb1twXSA9IGlzLnVuZChvMVtwXSkgPyBvMltwXSA6IG8xW3BdOyB9XG4gIHJldHVybiBvO1xufVxuXG4vLyBDb2xvcnNcblxuZnVuY3Rpb24gcmdiVG9SZ2JhKHJnYlZhbHVlKSB7XG4gIHZhciByZ2IgPSAvcmdiXFwoKFxcZCssXFxzKltcXGRdKyxcXHMqW1xcZF0rKVxcKS9nLmV4ZWMocmdiVmFsdWUpO1xuICByZXR1cm4gcmdiID8gKFwicmdiYShcIiArIChyZ2JbMV0pICsgXCIsMSlcIikgOiByZ2JWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleFZhbHVlKSB7XG4gIHZhciByZ3ggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICB2YXIgaGV4ID0gaGV4VmFsdWUucmVwbGFjZShyZ3gsIGZ1bmN0aW9uIChtLCByLCBnLCBiKSB7IHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7IH0gKTtcbiAgdmFyIHJnYiA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuICB2YXIgciA9IHBhcnNlSW50KHJnYlsxXSwgMTYpO1xuICB2YXIgZyA9IHBhcnNlSW50KHJnYlsyXSwgMTYpO1xuICB2YXIgYiA9IHBhcnNlSW50KHJnYlszXSwgMTYpO1xuICByZXR1cm4gKFwicmdiYShcIiArIHIgKyBcIixcIiArIGcgKyBcIixcIiArIGIgKyBcIiwxKVwiKTtcbn1cblxuZnVuY3Rpb24gaHNsVG9SZ2JhKGhzbFZhbHVlKSB7XG4gIHZhciBoc2wgPSAvaHNsXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklXFwpL2cuZXhlYyhoc2xWYWx1ZSkgfHwgL2hzbGFcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKVxcKS9nLmV4ZWMoaHNsVmFsdWUpO1xuICB2YXIgaCA9IHBhcnNlSW50KGhzbFsxXSwgMTApIC8gMzYwO1xuICB2YXIgcyA9IHBhcnNlSW50KGhzbFsyXSwgMTApIC8gMTAwO1xuICB2YXIgbCA9IHBhcnNlSW50KGhzbFszXSwgMTApIC8gMTAwO1xuICB2YXIgYSA9IGhzbFs0XSB8fCAxO1xuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHsgdCArPSAxOyB9XG4gICAgaWYgKHQgPiAxKSB7IHQgLT0gMTsgfVxuICAgIGlmICh0IDwgMS82KSB7IHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0OyB9XG4gICAgaWYgKHQgPCAxLzIpIHsgcmV0dXJuIHE7IH1cbiAgICBpZiAodCA8IDIvMykgeyByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2OyB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgdmFyIHIsIGcsIGI7XG4gIGlmIChzID09IDApIHtcbiAgICByID0gZyA9IGIgPSBsO1xuICB9IGVsc2Uge1xuICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcbiAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMS8zKTtcbiAgfVxuICByZXR1cm4gKFwicmdiYShcIiArIChyICogMjU1KSArIFwiLFwiICsgKGcgKiAyNTUpICsgXCIsXCIgKyAoYiAqIDI1NSkgKyBcIixcIiArIGEgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIGNvbG9yVG9SZ2IodmFsKSB7XG4gIGlmIChpcy5yZ2IodmFsKSkgeyByZXR1cm4gcmdiVG9SZ2JhKHZhbCk7IH1cbiAgaWYgKGlzLmhleCh2YWwpKSB7IHJldHVybiBoZXhUb1JnYmEodmFsKTsgfVxuICBpZiAoaXMuaHNsKHZhbCkpIHsgcmV0dXJuIGhzbFRvUmdiYSh2YWwpOyB9XG59XG5cbi8vIFVuaXRzXG5cbmZ1bmN0aW9uIGdldFVuaXQodmFsKSB7XG4gIHZhciBzcGxpdCA9IC9bKy1dP1xcZCpcXC4/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPyglfHB4fHB0fGVtfHJlbXxpbnxjbXxtbXxleHxjaHxwY3x2d3x2aHx2bWlufHZtYXh8ZGVnfHJhZHx0dXJuKT8kLy5leGVjKHZhbCk7XG4gIGlmIChzcGxpdCkgeyByZXR1cm4gc3BsaXRbMV07IH1cbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSkge1xuICBpZiAoc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICd0cmFuc2xhdGUnKSB8fCBwcm9wTmFtZSA9PT0gJ3BlcnNwZWN0aXZlJykgeyByZXR1cm4gJ3B4JzsgfVxuICBpZiAoc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdyb3RhdGUnKSB8fCBzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3NrZXcnKSkgeyByZXR1cm4gJ2RlZyc7IH1cbn1cblxuLy8gVmFsdWVzXG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVmFsdWUodmFsLCBhbmltYXRhYmxlKSB7XG4gIGlmICghaXMuZm5jKHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICByZXR1cm4gdmFsKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltYXRhYmxlLmlkLCBhbmltYXRhYmxlLnRvdGFsKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBwcm9wKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUocHJvcCk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIHZhbHVlVW5pdCA9IGdldFVuaXQodmFsdWUpO1xuICBpZiAoYXJyYXlDb250YWlucyhbdW5pdCwgJ2RlZycsICdyYWQnLCAndHVybiddLCB2YWx1ZVVuaXQpKSB7IHJldHVybiB2YWx1ZTsgfVxuICB2YXIgY2FjaGVkID0gY2FjaGUuQ1NTW3ZhbHVlICsgdW5pdF07XG4gIGlmICghaXMudW5kKGNhY2hlZCkpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICB2YXIgYmFzZWxpbmUgPSAxMDA7XG4gIHZhciB0ZW1wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsLnRhZ05hbWUpO1xuICB2YXIgcGFyZW50RWwgPSAoZWwucGFyZW50Tm9kZSAmJiAoZWwucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQpKSA/IGVsLnBhcmVudE5vZGUgOiBkb2N1bWVudC5ib2R5O1xuICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0ZW1wRWwpO1xuICB0ZW1wRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0ZW1wRWwuc3R5bGUud2lkdGggPSBiYXNlbGluZSArIHVuaXQ7XG4gIHZhciBmYWN0b3IgPSBiYXNlbGluZSAvIHRlbXBFbC5vZmZzZXRXaWR0aDtcbiAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEVsKTtcbiAgdmFyIGNvbnZlcnRlZFVuaXQgPSBmYWN0b3IgKiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgY2FjaGUuQ1NTW3ZhbHVlICsgdW5pdF0gPSBjb252ZXJ0ZWRVbml0O1xuICByZXR1cm4gY29udmVydGVkVW5pdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q1NTVmFsdWUoZWwsIHByb3AsIHVuaXQpIHtcbiAgaWYgKHByb3AgaW4gZWwuc3R5bGUpIHtcbiAgICB2YXIgdXBwZXJjYXNlUHJvcE5hbWUgPSBwcm9wLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gZWwuc3R5bGVbcHJvcF0gfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSh1cHBlcmNhc2VQcm9wTmFtZSkgfHwgJzAnO1xuICAgIHJldHVybiB1bml0ID8gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkgOiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25UeXBlKGVsLCBwcm9wKSB7XG4gIGlmIChpcy5kb20oZWwpICYmICFpcy5pbnAoZWwpICYmIChnZXRBdHRyaWJ1dGUoZWwsIHByb3ApIHx8IChpcy5zdmcoZWwpICYmIGVsW3Byb3BdKSkpIHsgcmV0dXJuICdhdHRyaWJ1dGUnOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIGFycmF5Q29udGFpbnModmFsaWRUcmFuc2Zvcm1zLCBwcm9wKSkgeyByZXR1cm4gJ3RyYW5zZm9ybSc7IH1cbiAgaWYgKGlzLmRvbShlbCkgJiYgKHByb3AgIT09ICd0cmFuc2Zvcm0nICYmIGdldENTU1ZhbHVlKGVsLCBwcm9wKSkpIHsgcmV0dXJuICdjc3MnOyB9XG4gIGlmIChlbFtwcm9wXSAhPSBudWxsKSB7IHJldHVybiAnb2JqZWN0JzsgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50VHJhbnNmb3JtcyhlbCkge1xuICBpZiAoIWlzLmRvbShlbCkpIHsgcmV0dXJuOyB9XG4gIHZhciBzdHIgPSBlbC5zdHlsZS50cmFuc2Zvcm0gfHwgJyc7XG4gIHZhciByZWcgID0gLyhcXHcrKVxcKChbXildKilcXCkvZztcbiAgdmFyIHRyYW5zZm9ybXMgPSBuZXcgTWFwKCk7XG4gIHZhciBtOyB3aGlsZSAobSA9IHJlZy5leGVjKHN0cikpIHsgdHJhbnNmb3Jtcy5zZXQobVsxXSwgbVsyXSk7IH1cbiAgcmV0dXJuIHRyYW5zZm9ybXM7XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlKGVsLCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCkge1xuICB2YXIgZGVmYXVsdFZhbCA9IHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAnc2NhbGUnKSA/IDEgOiAwICsgZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSk7XG4gIHZhciB2YWx1ZSA9IGdldEVsZW1lbnRUcmFuc2Zvcm1zKGVsKS5nZXQocHJvcE5hbWUpIHx8IGRlZmF1bHRWYWw7XG4gIGlmIChhbmltYXRhYmxlKSB7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLmxpc3Quc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zWydsYXN0J10gPSBwcm9wTmFtZTtcbiAgfVxuICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCwgYW5pbWF0YWJsZSkge1xuICBzd2l0Y2ggKGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wTmFtZSkpIHtcbiAgICBjYXNlICd0cmFuc2Zvcm0nOiByZXR1cm4gZ2V0VHJhbnNmb3JtVmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCk7XG4gICAgY2FzZSAnY3NzJzogcmV0dXJuIGdldENTU1ZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHVuaXQpO1xuICAgIGNhc2UgJ2F0dHJpYnV0ZSc6IHJldHVybiBnZXRBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHRhcmdldFtwcm9wTmFtZV0gfHwgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSB7XG4gIHZhciBvcGVyYXRvciA9IC9eKFxcKj18XFwrPXwtPSkvLmV4ZWModG8pO1xuICBpZiAoIW9wZXJhdG9yKSB7IHJldHVybiB0bzsgfVxuICB2YXIgdSA9IGdldFVuaXQodG8pIHx8IDA7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChmcm9tKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHRvLnJlcGxhY2Uob3BlcmF0b3JbMF0sICcnKSk7XG4gIHN3aXRjaCAob3BlcmF0b3JbMF1bMF0pIHtcbiAgICBjYXNlICcrJzogcmV0dXJuIHggKyB5ICsgdTtcbiAgICBjYXNlICctJzogcmV0dXJuIHggLSB5ICsgdTtcbiAgICBjYXNlICcqJzogcmV0dXJuIHggKiB5ICsgdTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbCwgdW5pdCkge1xuICBpZiAoaXMuY29sKHZhbCkpIHsgcmV0dXJuIGNvbG9yVG9SZ2IodmFsKTsgfVxuICBpZiAoL1xccy9nLnRlc3QodmFsKSkgeyByZXR1cm4gdmFsOyB9XG4gIHZhciBvcmlnaW5hbFVuaXQgPSBnZXRVbml0KHZhbCk7XG4gIHZhciB1bml0TGVzcyA9IG9yaWdpbmFsVW5pdCA/IHZhbC5zdWJzdHIoMCwgdmFsLmxlbmd0aCAtIG9yaWdpbmFsVW5pdC5sZW5ndGgpIDogdmFsO1xuICBpZiAodW5pdCkgeyByZXR1cm4gdW5pdExlc3MgKyB1bml0OyB9XG4gIHJldHVybiB1bml0TGVzcztcbn1cblxuLy8gZ2V0VG90YWxMZW5ndGgoKSBlcXVpdmFsZW50IGZvciBjaXJjbGUsIHJlY3QsIHBvbHlsaW5lLCBwb2x5Z29uIGFuZCBsaW5lIHNoYXBlc1xuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1NlYkxhbWJsYS8zZTA1NTBjNDk2YzIzNjcwOTc0NFxuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMi54IC0gcDEueCwgMikgKyBNYXRoLnBvdyhwMi55IC0gcDEueSwgMikpO1xufVxuXG5mdW5jdGlvbiBnZXRDaXJjbGVMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIE1hdGguUEkgKiAyICogZ2V0QXR0cmlidXRlKGVsLCAncicpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0TGVuZ3RoKGVsKSB7XG4gIHJldHVybiAoZ2V0QXR0cmlidXRlKGVsLCAnd2lkdGgnKSAqIDIpICsgKGdldEF0dHJpYnV0ZShlbCwgJ2hlaWdodCcpICogMik7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKFxuICAgIHt4OiBnZXRBdHRyaWJ1dGUoZWwsICd4MScpLCB5OiBnZXRBdHRyaWJ1dGUoZWwsICd5MScpfSwgXG4gICAge3g6IGdldEF0dHJpYnV0ZShlbCwgJ3gyJyksIHk6IGdldEF0dHJpYnV0ZShlbCwgJ3kyJyl9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFBvbHlsaW5lTGVuZ3RoKGVsKSB7XG4gIHZhciBwb2ludHMgPSBlbC5wb2ludHM7XG4gIHZhciB0b3RhbExlbmd0aCA9IDA7XG4gIHZhciBwcmV2aW91c1BvcztcbiAgZm9yICh2YXIgaSA9IDAgOyBpIDwgcG9pbnRzLm51bWJlck9mSXRlbXM7IGkrKykge1xuICAgIHZhciBjdXJyZW50UG9zID0gcG9pbnRzLmdldEl0ZW0oaSk7XG4gICAgaWYgKGkgPiAwKSB7IHRvdGFsTGVuZ3RoICs9IGdldERpc3RhbmNlKHByZXZpb3VzUG9zLCBjdXJyZW50UG9zKTsgfVxuICAgIHByZXZpb3VzUG9zID0gY3VycmVudFBvcztcbiAgfVxuICByZXR1cm4gdG90YWxMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldFBvbHlnb25MZW5ndGgoZWwpIHtcbiAgdmFyIHBvaW50cyA9IGVsLnBvaW50cztcbiAgcmV0dXJuIGdldFBvbHlsaW5lTGVuZ3RoKGVsKSArIGdldERpc3RhbmNlKHBvaW50cy5nZXRJdGVtKHBvaW50cy5udW1iZXJPZkl0ZW1zIC0gMSksIHBvaW50cy5nZXRJdGVtKDApKTtcbn1cblxuLy8gUGF0aCBhbmltYXRpb25cblxuZnVuY3Rpb24gZ2V0VG90YWxMZW5ndGgoZWwpIHtcbiAgaWYgKGVsLmdldFRvdGFsTGVuZ3RoKSB7IHJldHVybiBlbC5nZXRUb3RhbExlbmd0aCgpOyB9XG4gIHN3aXRjaChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdjaXJjbGUnOiByZXR1cm4gZ2V0Q2lyY2xlTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdyZWN0JzogcmV0dXJuIGdldFJlY3RMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ2xpbmUnOiByZXR1cm4gZ2V0TGluZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncG9seWxpbmUnOiByZXR1cm4gZ2V0UG9seWxpbmVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3BvbHlnb24nOiByZXR1cm4gZ2V0UG9seWdvbkxlbmd0aChlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RGFzaG9mZnNldChlbCkge1xuICB2YXIgcGF0aExlbmd0aCA9IGdldFRvdGFsTGVuZ3RoKGVsKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgcGF0aExlbmd0aCk7XG4gIHJldHVybiBwYXRoTGVuZ3RoO1xufVxuXG4vLyBNb3Rpb24gcGF0aFxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdmdFbChlbCkge1xuICB2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnROb2RlO1xuICB3aGlsZSAoaXMuc3ZnKHBhcmVudEVsKSkge1xuICAgIGlmICghaXMuc3ZnKHBhcmVudEVsLnBhcmVudE5vZGUpKSB7IGJyZWFrOyB9XG4gICAgcGFyZW50RWwgPSBwYXJlbnRFbC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBwYXJlbnRFbDtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50U3ZnKHBhdGhFbCwgc3ZnRGF0YSkge1xuICB2YXIgc3ZnID0gc3ZnRGF0YSB8fCB7fTtcbiAgdmFyIHBhcmVudFN2Z0VsID0gc3ZnLmVsIHx8IGdldFBhcmVudFN2Z0VsKHBhdGhFbCk7XG4gIHZhciByZWN0ID0gcGFyZW50U3ZnRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB2aWV3Qm94QXR0ciA9IGdldEF0dHJpYnV0ZShwYXJlbnRTdmdFbCwgJ3ZpZXdCb3gnKTtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgdmlld0JveCA9IHN2Zy52aWV3Qm94IHx8ICh2aWV3Qm94QXR0ciA/IHZpZXdCb3hBdHRyLnNwbGl0KCcgJykgOiBbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICByZXR1cm4ge1xuICAgIGVsOiBwYXJlbnRTdmdFbCxcbiAgICB2aWV3Qm94OiB2aWV3Qm94LFxuICAgIHg6IHZpZXdCb3hbMF0gLyAxLFxuICAgIHk6IHZpZXdCb3hbMV0gLyAxLFxuICAgIHc6IHdpZHRoIC8gdmlld0JveFsyXSxcbiAgICBoOiBoZWlnaHQgLyB2aWV3Qm94WzNdXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGF0aChwYXRoLCBwZXJjZW50KSB7XG4gIHZhciBwYXRoRWwgPSBpcy5zdHIocGF0aCkgPyBzZWxlY3RTdHJpbmcocGF0aClbMF0gOiBwYXRoO1xuICB2YXIgcCA9IHBlcmNlbnQgfHwgMTAwO1xuICByZXR1cm4gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgZWw6IHBhdGhFbCxcbiAgICAgIHN2ZzogZ2V0UGFyZW50U3ZnKHBhdGhFbCksXG4gICAgICB0b3RhbExlbmd0aDogZ2V0VG90YWxMZW5ndGgocGF0aEVsKSAqIChwIC8gMTAwKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoUHJvZ3Jlc3MocGF0aCwgcHJvZ3Jlc3MpIHtcbiAgZnVuY3Rpb24gcG9pbnQob2Zmc2V0KSB7XG4gICAgaWYgKCBvZmZzZXQgPT09IHZvaWQgMCApIG9mZnNldCA9IDA7XG5cbiAgICB2YXIgbCA9IHByb2dyZXNzICsgb2Zmc2V0ID49IDEgPyBwcm9ncmVzcyArIG9mZnNldCA6IDA7XG4gICAgcmV0dXJuIHBhdGguZWwuZ2V0UG9pbnRBdExlbmd0aChsKTtcbiAgfVxuICB2YXIgc3ZnID0gZ2V0UGFyZW50U3ZnKHBhdGguZWwsIHBhdGguc3ZnKTtcbiAgdmFyIHAgPSBwb2ludCgpO1xuICB2YXIgcDAgPSBwb2ludCgtMSk7XG4gIHZhciBwMSA9IHBvaW50KCsxKTtcbiAgc3dpdGNoIChwYXRoLnByb3BlcnR5KSB7XG4gICAgY2FzZSAneCc6IHJldHVybiAocC54IC0gc3ZnLngpICogc3ZnLnc7XG4gICAgY2FzZSAneSc6IHJldHVybiAocC55IC0gc3ZnLnkpICogc3ZnLmg7XG4gICAgY2FzZSAnYW5nbGUnOiByZXR1cm4gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxufVxuXG4vLyBEZWNvbXBvc2UgdmFsdWVcblxuZnVuY3Rpb24gZGVjb21wb3NlVmFsdWUodmFsLCB1bml0KSB7XG4gIC8vIGNvbnN0IHJneCA9IC8tP1xcZCpcXC4/XFxkKy9nOyAvLyBoYW5kbGVzIGJhc2ljIG51bWJlcnNcbiAgLy8gY29uc3Qgcmd4ID0gL1srLV0/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPy9nOyAvLyBoYW5kbGVzIGV4cG9uZW50cyBub3RhdGlvblxuICB2YXIgcmd4ID0gL1srLV0/XFxkKlxcLj9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/L2c7IC8vIGhhbmRsZXMgZXhwb25lbnRzIG5vdGF0aW9uXG4gIHZhciB2YWx1ZSA9IHZhbGlkYXRlVmFsdWUoKGlzLnB0aCh2YWwpID8gdmFsLnRvdGFsTGVuZ3RoIDogdmFsKSwgdW5pdCkgKyAnJztcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgbnVtYmVyczogdmFsdWUubWF0Y2gocmd4KSA/IHZhbHVlLm1hdGNoKHJneCkubWFwKE51bWJlcikgOiBbMF0sXG4gICAgc3RyaW5nczogKGlzLnN0cih2YWwpIHx8IHVuaXQpID8gdmFsdWUuc3BsaXQocmd4KSA6IFtdXG4gIH1cbn1cblxuLy8gQW5pbWF0YWJsZXNcblxuZnVuY3Rpb24gcGFyc2VUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldHNBcnJheSA9IHRhcmdldHMgPyAoZmxhdHRlbkFycmF5KGlzLmFycih0YXJnZXRzKSA/IHRhcmdldHMubWFwKHRvQXJyYXkpIDogdG9BcnJheSh0YXJnZXRzKSkpIDogW107XG4gIHJldHVybiBmaWx0ZXJBcnJheSh0YXJnZXRzQXJyYXksIGZ1bmN0aW9uIChpdGVtLCBwb3MsIHNlbGYpIHsgcmV0dXJuIHNlbGYuaW5kZXhPZihpdGVtKSA9PT0gcG9zOyB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cykge1xuICB2YXIgcGFyc2VkID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICByZXR1cm4gcGFyc2VkLm1hcChmdW5jdGlvbiAodCwgaSkge1xuICAgIHJldHVybiB7dGFyZ2V0OiB0LCBpZDogaSwgdG90YWw6IHBhcnNlZC5sZW5ndGgsIHRyYW5zZm9ybXM6IHsgbGlzdDogZ2V0RWxlbWVudFRyYW5zZm9ybXModCkgfSB9O1xuICB9KTtcbn1cblxuLy8gUHJvcGVydGllc1xuXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwcm9wLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBzZXR0aW5ncyA9IGNsb25lT2JqZWN0KHR3ZWVuU2V0dGluZ3MpO1xuICAvLyBPdmVycmlkZSBkdXJhdGlvbiBpZiBlYXNpbmcgaXMgYSBzcHJpbmdcbiAgaWYgKC9ec3ByaW5nLy50ZXN0KHNldHRpbmdzLmVhc2luZykpIHsgc2V0dGluZ3MuZHVyYXRpb24gPSBzcHJpbmcoc2V0dGluZ3MuZWFzaW5nKTsgfVxuICBpZiAoaXMuYXJyKHByb3ApKSB7XG4gICAgdmFyIGwgPSBwcm9wLmxlbmd0aDtcbiAgICB2YXIgaXNGcm9tVG8gPSAobCA9PT0gMiAmJiAhaXMub2JqKHByb3BbMF0pKTtcbiAgICBpZiAoIWlzRnJvbVRvKSB7XG4gICAgICAvLyBEdXJhdGlvbiBkaXZpZGVkIGJ5IHRoZSBudW1iZXIgb2YgdHdlZW5zXG4gICAgICBpZiAoIWlzLmZuYyh0d2VlblNldHRpbmdzLmR1cmF0aW9uKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24gLyBsOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYW5zZm9ybSBbZnJvbSwgdG9dIHZhbHVlcyBzaG9ydGhhbmQgdG8gYSB2YWxpZCB0d2VlbiB2YWx1ZVxuICAgICAgcHJvcCA9IHt2YWx1ZTogcHJvcH07XG4gICAgfVxuICB9XG4gIHZhciBwcm9wQXJyYXkgPSBpcy5hcnIocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICByZXR1cm4gcHJvcEFycmF5Lm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHZhciBvYmogPSAoaXMub2JqKHYpICYmICFpcy5wdGgodikpID8gdiA6IHt2YWx1ZTogdn07XG4gICAgLy8gRGVmYXVsdCBkZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBmaXJzdCB0d2VlblxuICAgIGlmIChpcy51bmQob2JqLmRlbGF5KSkgeyBvYmouZGVsYXkgPSAhaSA/IHR3ZWVuU2V0dGluZ3MuZGVsYXkgOiAwOyB9XG4gICAgLy8gRGVmYXVsdCBlbmREZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBsYXN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZW5kRGVsYXkpKSB7IG9iai5lbmREZWxheSA9IGkgPT09IHByb3BBcnJheS5sZW5ndGggLSAxID8gdHdlZW5TZXR0aW5ncy5lbmREZWxheSA6IDA7IH1cbiAgICByZXR1cm4gb2JqO1xuICB9KS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIG1lcmdlT2JqZWN0cyhrLCBzZXR0aW5ncyk7IH0pO1xufVxuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5LZXlmcmFtZXMoa2V5ZnJhbWVzKSB7XG4gIHZhciBwcm9wZXJ0eU5hbWVzID0gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gT2JqZWN0LmtleXMoa2V5KTsgfSkpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gaXMua2V5KHApOyB9KVxuICAucmVkdWNlKGZ1bmN0aW9uIChhLGIpIHsgaWYgKGEuaW5kZXhPZihiKSA8IDApIHsgYS5wdXNoKGIpOyB9IHJldHVybiBhOyB9LCBbXSk7XG4gIHZhciBwcm9wZXJ0aWVzID0ge307XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBrZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBuZXdLZXkgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4ga2V5KSB7XG4gICAgICAgIGlmIChpcy5rZXkocCkpIHtcbiAgICAgICAgICBpZiAocCA9PSBwcm9wTmFtZSkgeyBuZXdLZXkudmFsdWUgPSBrZXlbcF07IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdLZXlbcF0gPSBrZXlbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcykge1xuICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICB2YXIga2V5ZnJhbWVzID0gcGFyYW1zLmtleWZyYW1lcztcbiAgaWYgKGtleWZyYW1lcykgeyBwYXJhbXMgPSBtZXJnZU9iamVjdHMoZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpLCBwYXJhbXMpOyB9XG4gIGZvciAodmFyIHAgaW4gcGFyYW1zKSB7XG4gICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogcCxcbiAgICAgICAgdHdlZW5zOiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwYXJhbXNbcF0sIHR3ZWVuU2V0dGluZ3MpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbi8vIFR3ZWVuc1xuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlblZhbHVlcyh0d2VlbiwgYW5pbWF0YWJsZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHR3ZWVuKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZSh0d2VlbltwXSwgYW5pbWF0YWJsZSk7XG4gICAgaWYgKGlzLmFycih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBnZXRGdW5jdGlvblZhbHVlKHYsIGFuaW1hdGFibGUpOyB9KTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHsgdmFsdWUgPSB2YWx1ZVswXTsgfVxuICAgIH1cbiAgICB0W3BdID0gdmFsdWU7XG4gIH1cbiAgdC5kdXJhdGlvbiA9IHBhcnNlRmxvYXQodC5kdXJhdGlvbik7XG4gIHQuZGVsYXkgPSBwYXJzZUZsb2F0KHQuZGVsYXkpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVHdlZW5zKHByb3AsIGFuaW1hdGFibGUpIHtcbiAgdmFyIHByZXZpb3VzVHdlZW47XG4gIHJldHVybiBwcm9wLnR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgdHdlZW4gPSBub3JtYWxpemVUd2VlblZhbHVlcyh0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgdHdlZW5WYWx1ZSA9IHR3ZWVuLnZhbHVlO1xuICAgIHZhciB0byA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMV0gOiB0d2VlblZhbHVlO1xuICAgIHZhciB0b1VuaXQgPSBnZXRVbml0KHRvKTtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSwgdG9Vbml0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLnRvLm9yaWdpbmFsIDogb3JpZ2luYWxWYWx1ZTtcbiAgICB2YXIgZnJvbSA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMF0gOiBwcmV2aW91c1ZhbHVlO1xuICAgIHZhciBmcm9tVW5pdCA9IGdldFVuaXQoZnJvbSkgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICB2YXIgdW5pdCA9IHRvVW5pdCB8fCBmcm9tVW5pdDtcbiAgICBpZiAoaXMudW5kKHRvKSkgeyB0byA9IHByZXZpb3VzVmFsdWU7IH1cbiAgICB0d2Vlbi5mcm9tID0gZGVjb21wb3NlVmFsdWUoZnJvbSwgdW5pdCk7XG4gICAgdHdlZW4udG8gPSBkZWNvbXBvc2VWYWx1ZShnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSwgdW5pdCk7XG4gICAgdHdlZW4uc3RhcnQgPSBwcmV2aW91c1R3ZWVuID8gcHJldmlvdXNUd2Vlbi5lbmQgOiAwO1xuICAgIHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0ICsgdHdlZW4uZGVsYXkgKyB0d2Vlbi5kdXJhdGlvbiArIHR3ZWVuLmVuZERlbGF5O1xuICAgIHR3ZWVuLmVhc2luZyA9IHBhcnNlRWFzaW5ncyh0d2Vlbi5lYXNpbmcsIHR3ZWVuLmR1cmF0aW9uKTtcbiAgICB0d2Vlbi5pc1BhdGggPSBpcy5wdGgodHdlZW5WYWx1ZSk7XG4gICAgdHdlZW4uaXNDb2xvciA9IGlzLmNvbCh0d2Vlbi5mcm9tLm9yaWdpbmFsKTtcbiAgICBpZiAodHdlZW4uaXNDb2xvcikgeyB0d2Vlbi5yb3VuZCA9IDE7IH1cbiAgICBwcmV2aW91c1R3ZWVuID0gdHdlZW47XG4gICAgcmV0dXJuIHR3ZWVuO1xuICB9KTtcbn1cblxuLy8gVHdlZW4gcHJvZ3Jlc3NcblxudmFyIHNldFByb2dyZXNzVmFsdWUgPSB7XG4gIGNzczogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc3R5bGVbcF0gPSB2OyB9LFxuICBhdHRyaWJ1dGU6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0LnNldEF0dHJpYnV0ZShwLCB2KTsgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdFtwXSA9IHY7IH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKHQsIHAsIHYsIHRyYW5zZm9ybXMsIG1hbnVhbCkge1xuICAgIHRyYW5zZm9ybXMubGlzdC5zZXQocCwgdik7XG4gICAgaWYgKHAgPT09IHRyYW5zZm9ybXMubGFzdCB8fCBtYW51YWwpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHRyYW5zZm9ybXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcHJvcCkgeyBzdHIgKz0gcHJvcCArIFwiKFwiICsgdmFsdWUgKyBcIikgXCI7IH0pO1xuICAgICAgdC5zdHlsZS50cmFuc2Zvcm0gPSBzdHI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBTZXQgVmFsdWUgaGVscGVyXG5cbmZ1bmN0aW9uIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHRhcmdldHMpO1xuICBhbmltYXRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZShwcm9wZXJ0aWVzW3Byb3BlcnR5XSwgYW5pbWF0YWJsZSk7XG4gICAgICB2YXIgdGFyZ2V0ID0gYW5pbWF0YWJsZS50YXJnZXQ7XG4gICAgICB2YXIgdmFsdWVVbml0ID0gZ2V0VW5pdCh2YWx1ZSk7XG4gICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWVVbml0LCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB1bml0ID0gdmFsdWVVbml0IHx8IGdldFVuaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgICB2YXIgdG8gPSBnZXRSZWxhdGl2ZVZhbHVlKHZhbGlkYXRlVmFsdWUodmFsdWUsIHVuaXQpLCBvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBzZXRQcm9ncmVzc1ZhbHVlW2FuaW1UeXBlXSh0YXJnZXQsIHByb3BlcnR5LCB0bywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBBbmltYXRpb25zXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKSB7XG4gIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSk7XG4gIGlmIChhbmltVHlwZSkge1xuICAgIHZhciB0d2VlbnMgPSBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIGxhc3RUd2VlbiA9IHR3ZWVuc1t0d2VlbnMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFuaW1UeXBlLFxuICAgICAgcHJvcGVydHk6IHByb3AubmFtZSxcbiAgICAgIGFuaW1hdGFibGU6IGFuaW1hdGFibGUsXG4gICAgICB0d2VlbnM6IHR3ZWVucyxcbiAgICAgIGR1cmF0aW9uOiBsYXN0VHdlZW4uZW5kLFxuICAgICAgZGVsYXk6IHR3ZWVuc1swXS5kZWxheSxcbiAgICAgIGVuZERlbGF5OiBsYXN0VHdlZW4uZW5kRGVsYXlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcykge1xuICByZXR1cm4gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGFuaW1hdGFibGVzLm1hcChmdW5jdGlvbiAoYW5pbWF0YWJsZSkge1xuICAgIHJldHVybiBwcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKTtcbiAgICB9KTtcbiAgfSkpLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWlzLnVuZChhKTsgfSk7XG59XG5cbi8vIENyZWF0ZSBJbnN0YW5jZVxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncykge1xuICB2YXIgYW5pbUxlbmd0aCA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuICB2YXIgZ2V0VGxPZmZzZXQgPSBmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gYW5pbS50aW1lbGluZU9mZnNldCA/IGFuaW0udGltZWxpbmVPZmZzZXQgOiAwOyB9O1xuICB2YXIgdGltaW5ncyA9IHt9O1xuICB0aW1pbmdzLmR1cmF0aW9uID0gYW5pbUxlbmd0aCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZHVyYXRpb247IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb247XG4gIHRpbWluZ3MuZGVsYXkgPSBhbmltTGVuZ3RoID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5kZWxheTtcbiAgdGltaW5ncy5lbmREZWxheSA9IGFuaW1MZW5ndGggPyB0aW1pbmdzLmR1cmF0aW9uIC0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbiAtIGFuaW0uZW5kRGVsYXk7IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZW5kRGVsYXk7XG4gIHJldHVybiB0aW1pbmdzO1xufVxuXG52YXIgaW5zdGFuY2VJRCA9IDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcykge1xuICB2YXIgaW5zdGFuY2VTZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHR3ZWVuU2V0dGluZ3MgPSByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyhwYXJhbXMudGFyZ2V0cyk7XG4gIHZhciBhbmltYXRpb25zID0gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcyk7XG4gIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGFuaW1hdGlvbnMsIHR3ZWVuU2V0dGluZ3MpO1xuICB2YXIgaWQgPSBpbnN0YW5jZUlEO1xuICBpbnN0YW5jZUlEKys7XG4gIHJldHVybiBtZXJnZU9iamVjdHMoaW5zdGFuY2VTZXR0aW5ncywge1xuICAgIGlkOiBpZCxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYW5pbWF0YWJsZXM6IGFuaW1hdGFibGVzLFxuICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgZHVyYXRpb246IHRpbWluZ3MuZHVyYXRpb24sXG4gICAgZGVsYXk6IHRpbWluZ3MuZGVsYXksXG4gICAgZW5kRGVsYXk6IHRpbWluZ3MuZW5kRGVsYXlcbiAgfSk7XG59XG5cbi8vIENvcmVcblxudmFyIGFjdGl2ZUluc3RhbmNlcyA9IFtdO1xudmFyIHBhdXNlZEluc3RhbmNlcyA9IFtdO1xudmFyIHJhZjtcblxudmFyIGVuZ2luZSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHBsYXkoKSB7IFxuICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgfVxuICBmdW5jdGlvbiBzdGVwKHQpIHtcbiAgICB2YXIgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDtcbiAgICBpZiAoYWN0aXZlSW5zdGFuY2VzTGVuZ3RoKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGFjdGl2ZUluc3RhbmNlc0xlbmd0aCkge1xuICAgICAgICB2YXIgYWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZXNbaV07XG4gICAgICAgIGlmICghYWN0aXZlSW5zdGFuY2UucGF1c2VkKSB7XG4gICAgICAgICAgYWN0aXZlSW5zdGFuY2UudGljayh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2VJbmRleCA9IGFjdGl2ZUluc3RhbmNlcy5pbmRleE9mKGFjdGl2ZUluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2VJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKGluc3RhbmNlSW5kZXgsIDEpO1xuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgcGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYWYgPSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGxheTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICBhY3RpdmVJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zKSB7IHJldHVybiBpbnMucGF1c2UoKTsgfSk7XG4gICAgcGF1c2VkSW5zdGFuY2VzID0gYWN0aXZlSW5zdGFuY2VzLnNsaWNlKDApO1xuICAgIGFuaW1lLnJ1bm5pbmcgPSBhY3RpdmVJbnN0YW5jZXMgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICBwYXVzZWRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zKSB7IHJldHVybiBpbnMucGxheSgpOyB9KTtcbiAgfVxufVxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG59XG5cbi8vIFB1YmxpYyBJbnN0YW5jZVxuXG5mdW5jdGlvbiBhbmltZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IDAsIGxhc3RUaW1lID0gMCwgbm93ID0gMDtcbiAgdmFyIGNoaWxkcmVuLCBjaGlsZHJlbkxlbmd0aCA9IDA7XG4gIHZhciByZXNvbHZlID0gbnVsbDtcblxuICBmdW5jdGlvbiBtYWtlUHJvbWlzZShpbnN0YW5jZSkge1xuICAgIHZhciBwcm9taXNlID0gd2luZG93LlByb21pc2UgJiYgbmV3IFByb21pc2UoZnVuY3Rpb24gKF9yZXNvbHZlKSB7IHJldHVybiByZXNvbHZlID0gX3Jlc29sdmU7IH0pO1xuICAgIGluc3RhbmNlLmZpbmlzaGVkID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcyk7XG4gIHZhciBwcm9taXNlID0gbWFrZVByb21pc2UoaW5zdGFuY2UpO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnN0YW5jZS5kaXJlY3Rpb247XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgIGluc3RhbmNlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbiAhPT0gJ25vcm1hbCcgPyAnbm9ybWFsJyA6ICdyZXZlcnNlJztcbiAgICB9XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSAhaW5zdGFuY2UucmV2ZXJzZWQ7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnJldmVyc2VkID0gaW5zdGFuY2UucmV2ZXJzZWQ7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRqdXN0VGltZSh0aW1lKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VGltZSgpIHtcbiAgICBzdGFydFRpbWUgPSAwO1xuICAgIGxhc3RUaW1lID0gYWRqdXN0VGltZShpbnN0YW5jZS5jdXJyZW50VGltZSkgKiAoMSAvIGFuaW1lLnNwZWVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlZWtDaGlsZCh0aW1lLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCkgeyBjaGlsZC5zZWVrKHRpbWUgLSBjaGlsZC50aW1lbGluZU9mZnNldCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNJbnN0YW5jZUNoaWxkcmVuKHRpbWUpIHtcbiAgICBpZiAoIWluc3RhbmNlLnJldmVyc2VQbGF5YmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7IHNlZWtDaGlsZCh0aW1lLCBjaGlsZHJlbltpXSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSQxID0gY2hpbGRyZW5MZW5ndGg7IGkkMS0tOykgeyBzZWVrQ2hpbGQodGltZSwgY2hpbGRyZW5baSQxXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zVGltZSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gICAgdmFyIGFuaW1hdGlvbnNMZW5ndGggPSBhbmltYXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGFuaW1hdGlvbnNMZW5ndGgpIHtcbiAgICAgIHZhciBhbmltID0gYW5pbWF0aW9uc1tpXTtcbiAgICAgIHZhciBhbmltYXRhYmxlID0gYW5pbS5hbmltYXRhYmxlO1xuICAgICAgdmFyIHR3ZWVucyA9IGFuaW0udHdlZW5zO1xuICAgICAgdmFyIHR3ZWVuTGVuZ3RoID0gdHdlZW5zLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgdHdlZW4gPSB0d2VlbnNbdHdlZW5MZW5ndGhdO1xuICAgICAgLy8gT25seSBjaGVjayBmb3Iga2V5ZnJhbWVzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgdHdlZW5cbiAgICAgIGlmICh0d2Vlbkxlbmd0aCkgeyB0d2VlbiA9IGZpbHRlckFycmF5KHR3ZWVucywgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChpbnNUaW1lIDwgdC5lbmQpOyB9KVswXSB8fCB0d2VlbjsgfVxuICAgICAgdmFyIGVsYXBzZWQgPSBtaW5NYXgoaW5zVGltZSAtIHR3ZWVuLnN0YXJ0IC0gdHdlZW4uZGVsYXksIDAsIHR3ZWVuLmR1cmF0aW9uKSAvIHR3ZWVuLmR1cmF0aW9uO1xuICAgICAgdmFyIGVhc2VkID0gaXNOYU4oZWxhcHNlZCkgPyAxIDogdHdlZW4uZWFzaW5nKGVsYXBzZWQpO1xuICAgICAgdmFyIHN0cmluZ3MgPSB0d2Vlbi50by5zdHJpbmdzO1xuICAgICAgdmFyIHJvdW5kID0gdHdlZW4ucm91bmQ7XG4gICAgICB2YXIgbnVtYmVycyA9IFtdO1xuICAgICAgdmFyIHRvTnVtYmVyc0xlbmd0aCA9IHR3ZWVuLnRvLm51bWJlcnMubGVuZ3RoO1xuICAgICAgdmFyIHByb2dyZXNzID0gKHZvaWQgMCk7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRvTnVtYmVyc0xlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgdG9OdW1iZXIgPSB0d2Vlbi50by5udW1iZXJzW25dO1xuICAgICAgICB2YXIgZnJvbU51bWJlciA9IHR3ZWVuLmZyb20ubnVtYmVyc1tuXSB8fCAwO1xuICAgICAgICBpZiAoIXR3ZWVuLmlzUGF0aCkge1xuICAgICAgICAgIHZhbHVlID0gZnJvbU51bWJlciArIChlYXNlZCAqICh0b051bWJlciAtIGZyb21OdW1iZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldFBhdGhQcm9ncmVzcyh0d2Vlbi52YWx1ZSwgZWFzZWQgKiB0b051bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdW5kKSB7XG4gICAgICAgICAgaWYgKCEodHdlZW4uaXNDb2xvciAmJiBuID4gMikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIHJvdW5kKSAvIHJvdW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gTWFudWFsIEFycmF5LnJlZHVjZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlc1xuICAgICAgdmFyIHN0cmluZ3NMZW5ndGggPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgIGlmICghc3RyaW5nc0xlbmd0aCkge1xuICAgICAgICBwcm9ncmVzcyA9IG51bWJlcnNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmVzcyA9IHN0cmluZ3NbMF07XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3RyaW5nc0xlbmd0aDsgcysrKSB7XG4gICAgICAgICAgdmFyIGEgPSBzdHJpbmdzW3NdO1xuICAgICAgICAgIHZhciBiID0gc3RyaW5nc1tzICsgMV07XG4gICAgICAgICAgdmFyIG4kMSA9IG51bWJlcnNbc107XG4gICAgICAgICAgaWYgKCFpc05hTihuJDEpKSB7XG4gICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MgKz0gbiQxICsgJyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MgKz0gbiQxICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFByb2dyZXNzVmFsdWVbYW5pbS50eXBlXShhbmltYXRhYmxlLnRhcmdldCwgYW5pbS5wcm9wZXJ0eSwgcHJvZ3Jlc3MsIGFuaW1hdGFibGUudHJhbnNmb3Jtcyk7XG4gICAgICBhbmltLmN1cnJlbnRWYWx1ZSA9IHByb2dyZXNzO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhbGxiYWNrKGNiKSB7XG4gICAgaWYgKGluc3RhbmNlW2NiXSAmJiAhaW5zdGFuY2UucGFzc1Rocm91Z2gpIHsgaW5zdGFuY2VbY2JdKGluc3RhbmNlKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gY291bnRJdGVyYXRpb24oKSB7XG4gICAgaWYgKGluc3RhbmNlLnJlbWFpbmluZyAmJiBpbnN0YW5jZS5yZW1haW5pbmcgIT09IHRydWUpIHtcbiAgICAgIGluc3RhbmNlLnJlbWFpbmluZy0tO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluc3RhbmNlUHJvZ3Jlc3MoZW5naW5lVGltZSkge1xuICAgIHZhciBpbnNEdXJhdGlvbiA9IGluc3RhbmNlLmR1cmF0aW9uO1xuICAgIHZhciBpbnNEZWxheSA9IGluc3RhbmNlLmRlbGF5O1xuICAgIHZhciBpbnNFbmREZWxheSA9IGluc0R1cmF0aW9uIC0gaW5zdGFuY2UuZW5kRGVsYXk7XG4gICAgdmFyIGluc1RpbWUgPSBhZGp1c3RUaW1lKGVuZ2luZVRpbWUpO1xuICAgIGluc3RhbmNlLnByb2dyZXNzID0gbWluTWF4KChpbnNUaW1lIC8gaW5zRHVyYXRpb24pICogMTAwLCAwLCAxMDApO1xuICAgIGluc3RhbmNlLnJldmVyc2VQbGF5YmFjayA9IGluc1RpbWUgPCBpbnN0YW5jZS5jdXJyZW50VGltZTtcbiAgICBpZiAoY2hpbGRyZW4pIHsgc3luY0luc3RhbmNlQ2hpbGRyZW4oaW5zVGltZSk7IH1cbiAgICBpZiAoIWluc3RhbmNlLmJlZ2FuICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgaW5zdGFuY2UuYmVnYW4gPSB0cnVlO1xuICAgICAgc2V0Q2FsbGJhY2soJ2JlZ2luJyk7XG4gICAgfVxuICAgIGlmICghaW5zdGFuY2UubG9vcEJlZ2FuICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gdHJ1ZTtcbiAgICAgIHNldENhbGxiYWNrKCdsb29wQmVnaW4nKTtcbiAgICB9XG4gICAgaWYgKGluc1RpbWUgPD0gaW5zRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IDApIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcygwKTtcbiAgICB9XG4gICAgaWYgKChpbnNUaW1lID49IGluc0VuZERlbGF5ICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lICE9PSBpbnNEdXJhdGlvbikgfHwgIWluc0R1cmF0aW9uKSB7XG4gICAgICBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zRHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA+IGluc0RlbGF5ICYmIGluc1RpbWUgPCBpbnNFbmREZWxheSkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5jaGFuZ2VCZWdhbikge1xuICAgICAgICBpbnN0YW5jZS5jaGFuZ2VCZWdhbiA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICBzZXRDYWxsYmFjaygnY2hhbmdlQmVnaW4nKTtcbiAgICAgIH1cbiAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2UnKTtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VDb21wbGV0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5jdXJyZW50VGltZSA9IG1pbk1heChpbnNUaW1lLCAwLCBpbnNEdXJhdGlvbik7XG4gICAgaWYgKGluc3RhbmNlLmJlZ2FuKSB7IHNldENhbGxiYWNrKCd1cGRhdGUnKTsgfVxuICAgIGlmIChlbmdpbmVUaW1lID49IGluc0R1cmF0aW9uKSB7XG4gICAgICBsYXN0VGltZSA9IDA7XG4gICAgICBjb3VudEl0ZXJhdGlvbigpO1xuICAgICAgaWYgKCFpbnN0YW5jZS5yZW1haW5pbmcpIHtcbiAgICAgICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5jb21wbGV0ZWQpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNldENhbGxiYWNrKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgICBzZXRDYWxsYmFjaygnY29tcGxldGUnKTtcbiAgICAgICAgICBpZiAoIWluc3RhbmNlLnBhc3NUaHJvdWdoICYmICdQcm9taXNlJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHByb21pc2UgPSBtYWtlUHJvbWlzZShpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFRpbWUgPSBub3c7XG4gICAgICAgIHNldENhbGxiYWNrKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnN0YW5jZS5kaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnKSB7XG4gICAgICAgICAgdG9nZ2xlSW5zdGFuY2VEaXJlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGluc3RhbmNlLmRpcmVjdGlvbjtcbiAgICBpbnN0YW5jZS5wYXNzVGhyb3VnaCA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gMDtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IDA7XG4gICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS5iZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmxvb3BCZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSBkaXJlY3Rpb24gPT09ICdyZXZlcnNlJztcbiAgICBpbnN0YW5jZS5yZW1haW5pbmcgPSBpbnN0YW5jZS5sb29wO1xuICAgIGNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW47XG4gICAgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuTGVuZ3RoOyBpLS07KSB7IGluc3RhbmNlLmNoaWxkcmVuW2ldLnJlc2V0KCk7IH1cbiAgICBpZiAoaW5zdGFuY2UucmV2ZXJzZWQgJiYgaW5zdGFuY2UubG9vcCAhPT0gdHJ1ZSB8fCAoZGlyZWN0aW9uID09PSAnYWx0ZXJuYXRlJyAmJiBpbnN0YW5jZS5sb29wID09PSAxKSkgeyBpbnN0YW5jZS5yZW1haW5pbmcrKzsgfVxuICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnN0YW5jZS5yZXZlcnNlZCA/IGluc3RhbmNlLmR1cmF0aW9uIDogMCk7XG4gIH07XG5cbiAgLy8gU2V0IFZhbHVlIGhlbHBlclxuXG4gIGluc3RhbmNlLnNldCA9IGZ1bmN0aW9uKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgICBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGluc3RhbmNlLnRpY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgbm93ID0gdDtcbiAgICBpZiAoIXN0YXJ0VGltZSkgeyBzdGFydFRpbWUgPSBub3c7IH1cbiAgICBzZXRJbnN0YW5jZVByb2dyZXNzKChub3cgKyAobGFzdFRpbWUgLSBzdGFydFRpbWUpKSAqIGFuaW1lLnNwZWVkKTtcbiAgfTtcblxuICBpbnN0YW5jZS5zZWVrID0gZnVuY3Rpb24odGltZSkge1xuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoYWRqdXN0VGltZSh0aW1lKSk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWluc3RhbmNlLnBhdXNlZCkgeyByZXR1cm47IH1cbiAgICBpZiAoaW5zdGFuY2UuY29tcGxldGVkKSB7IGluc3RhbmNlLnJlc2V0KCk7IH1cbiAgICBpbnN0YW5jZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBhY3RpdmVJbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgcmVzZXRUaW1lKCk7XG4gICAgaWYgKCFyYWYpIHsgZW5naW5lKCk7IH1cbiAgfTtcblxuICBpbnN0YW5jZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdG9nZ2xlSW5zdGFuY2VEaXJlY3Rpb24oKTtcbiAgICByZXNldFRpbWUoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaW5zdGFuY2UucmVzZXQoKTtcbiAgICBpbnN0YW5jZS5wbGF5KCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzZXQoKTtcblxuICBpZiAoaW5zdGFuY2UuYXV0b3BsYXkpIHsgaW5zdGFuY2UucGxheSgpOyB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xuXG59XG5cbi8vIFJlbW92ZSB0YXJnZXRzIGZyb20gYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnMpIHtcbiAgZm9yICh2YXIgYSA9IGFuaW1hdGlvbnMubGVuZ3RoOyBhLS07KSB7XG4gICAgaWYgKGFycmF5Q29udGFpbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zW2FdLmFuaW1hdGFibGUudGFyZ2V0KSkge1xuICAgICAgYW5pbWF0aW9ucy5zcGxpY2UoYSwgMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICBmb3IgKHZhciBpID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBpbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gICAgdmFyIGNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW47XG4gICAgcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9ucyk7XG4gICAgZm9yICh2YXIgYyA9IGNoaWxkcmVuLmxlbmd0aDsgYy0tOykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bY107XG4gICAgICB2YXIgY2hpbGRBbmltYXRpb25zID0gY2hpbGQuYW5pbWF0aW9ucztcbiAgICAgIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGNoaWxkQW5pbWF0aW9ucyk7XG4gICAgICBpZiAoIWNoaWxkQW5pbWF0aW9ucy5sZW5ndGggJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aCkgeyBjaGlsZHJlbi5zcGxpY2UoYywgMSk7IH1cbiAgICB9XG4gICAgaWYgKCFhbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGRyZW4ubGVuZ3RoKSB7IGluc3RhbmNlLnBhdXNlKCk7IH1cbiAgfVxufVxuXG4vLyBTdGFnZ2VyIGhlbHBlcnNcblxuZnVuY3Rpb24gc3RhZ2dlcih2YWwsIHBhcmFtcykge1xuICBpZiAoIHBhcmFtcyA9PT0gdm9pZCAwICkgcGFyYW1zID0ge307XG5cbiAgdmFyIGRpcmVjdGlvbiA9IHBhcmFtcy5kaXJlY3Rpb24gfHwgJ25vcm1hbCc7XG4gIHZhciBlYXNpbmcgPSBwYXJhbXMuZWFzaW5nID8gcGFyc2VFYXNpbmdzKHBhcmFtcy5lYXNpbmcpIDogbnVsbDtcbiAgdmFyIGdyaWQgPSBwYXJhbXMuZ3JpZDtcbiAgdmFyIGF4aXMgPSBwYXJhbXMuYXhpcztcbiAgdmFyIGZyb21JbmRleCA9IHBhcmFtcy5mcm9tIHx8IDA7XG4gIHZhciBmcm9tRmlyc3QgPSBmcm9tSW5kZXggPT09ICdmaXJzdCc7XG4gIHZhciBmcm9tQ2VudGVyID0gZnJvbUluZGV4ID09PSAnY2VudGVyJztcbiAgdmFyIGZyb21MYXN0ID0gZnJvbUluZGV4ID09PSAnbGFzdCc7XG4gIHZhciBpc1JhbmdlID0gaXMuYXJyKHZhbCk7XG4gIHZhciB2YWwxID0gaXNSYW5nZSA/IHBhcnNlRmxvYXQodmFsWzBdKSA6IHBhcnNlRmxvYXQodmFsKTtcbiAgdmFyIHZhbDIgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMV0pIDogMDtcbiAgdmFyIHVuaXQgPSBnZXRVbml0KGlzUmFuZ2UgPyB2YWxbMV0gOiB2YWwpIHx8IDA7XG4gIHZhciBzdGFydCA9IHBhcmFtcy5zdGFydCB8fCAwICsgKGlzUmFuZ2UgPyB2YWwxIDogMCk7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIG1heFZhbHVlID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbCwgaSwgdCkge1xuICAgIGlmIChmcm9tRmlyc3QpIHsgZnJvbUluZGV4ID0gMDsgfVxuICAgIGlmIChmcm9tQ2VudGVyKSB7IGZyb21JbmRleCA9ICh0IC0gMSkgLyAyOyB9XG4gICAgaWYgKGZyb21MYXN0KSB7IGZyb21JbmRleCA9IHQgLSAxOyB9XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoIWdyaWQpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChNYXRoLmFicyhmcm9tSW5kZXggLSBpbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmcm9tWCA9ICFmcm9tQ2VudGVyID8gZnJvbUluZGV4JWdyaWRbMF0gOiAoZ3JpZFswXS0xKS8yO1xuICAgICAgICAgIHZhciBmcm9tWSA9ICFmcm9tQ2VudGVyID8gTWF0aC5mbG9vcihmcm9tSW5kZXgvZ3JpZFswXSkgOiAoZ3JpZFsxXS0xKS8yO1xuICAgICAgICAgIHZhciB0b1ggPSBpbmRleCVncmlkWzBdO1xuICAgICAgICAgIHZhciB0b1kgPSBNYXRoLmZsb29yKGluZGV4L2dyaWRbMF0pO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBmcm9tWCAtIHRvWDtcbiAgICAgICAgICB2YXIgZGlzdGFuY2VZID0gZnJvbVkgLSB0b1k7XG4gICAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5zcXJ0KGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWSk7XG4gICAgICAgICAgaWYgKGF4aXMgPT09ICd4JykgeyB2YWx1ZSA9IC1kaXN0YW5jZVg7IH1cbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3knKSB7IHZhbHVlID0gLWRpc3RhbmNlWTsgfVxuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoZWFzaW5nKSB7IHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gZWFzaW5nKHZhbCAvIG1heFZhbHVlKSAqIG1heFZhbHVlOyB9KTsgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnKSB7IHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gYXhpcyA/ICh2YWwgPCAwKSA/IHZhbCAqIC0xIDogLXZhbCA6IE1hdGguYWJzKG1heFZhbHVlIC0gdmFsKTsgfSk7IH1cbiAgICB9XG4gICAgdmFyIHNwYWNpbmcgPSBpc1JhbmdlID8gKHZhbDIgLSB2YWwxKSAvIG1heFZhbHVlIDogdmFsMTtcbiAgICByZXR1cm4gc3RhcnQgKyAoc3BhY2luZyAqIChNYXRoLnJvdW5kKHZhbHVlc1tpXSAqIDEwMCkgLyAxMDApKSArIHVuaXQ7XG4gIH1cbn1cblxuLy8gVGltZWxpbmVcblxuZnVuY3Rpb24gdGltZWxpbmUocGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgdGwgPSBhbmltZShwYXJhbXMpO1xuICB0bC5kdXJhdGlvbiA9IDA7XG4gIHRsLmFkZCA9IGZ1bmN0aW9uKGluc3RhbmNlUGFyYW1zLCB0aW1lbGluZU9mZnNldCkge1xuICAgIHZhciB0bEluZGV4ID0gYWN0aXZlSW5zdGFuY2VzLmluZGV4T2YodGwpO1xuICAgIHZhciBjaGlsZHJlbiA9IHRsLmNoaWxkcmVuO1xuICAgIGlmICh0bEluZGV4ID4gLTEpIHsgYWN0aXZlSW5zdGFuY2VzLnNwbGljZSh0bEluZGV4LCAxKTsgfVxuICAgIGZ1bmN0aW9uIHBhc3NUaHJvdWdoKGlucykgeyBpbnMucGFzc1Rocm91Z2ggPSB0cnVlOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykgeyBwYXNzVGhyb3VnaChjaGlsZHJlbltpXSk7IH1cbiAgICB2YXIgaW5zUGFyYW1zID0gbWVyZ2VPYmplY3RzKGluc3RhbmNlUGFyYW1zLCByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcykpO1xuICAgIGluc1BhcmFtcy50YXJnZXRzID0gaW5zUGFyYW1zLnRhcmdldHMgfHwgcGFyYW1zLnRhcmdldHM7XG4gICAgdmFyIHRsRHVyYXRpb24gPSB0bC5kdXJhdGlvbjtcbiAgICBpbnNQYXJhbXMuYXV0b3BsYXkgPSBmYWxzZTtcbiAgICBpbnNQYXJhbXMuZGlyZWN0aW9uID0gdGwuZGlyZWN0aW9uO1xuICAgIGluc1BhcmFtcy50aW1lbGluZU9mZnNldCA9IGlzLnVuZCh0aW1lbGluZU9mZnNldCkgPyB0bER1cmF0aW9uIDogZ2V0UmVsYXRpdmVWYWx1ZSh0aW1lbGluZU9mZnNldCwgdGxEdXJhdGlvbik7XG4gICAgcGFzc1Rocm91Z2godGwpO1xuICAgIHRsLnNlZWsoaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0KTtcbiAgICB2YXIgaW5zID0gYW5pbWUoaW5zUGFyYW1zKTtcbiAgICBwYXNzVGhyb3VnaChpbnMpO1xuICAgIGNoaWxkcmVuLnB1c2goaW5zKTtcbiAgICB2YXIgdGltaW5ncyA9IGdldEluc3RhbmNlVGltaW5ncyhjaGlsZHJlbiwgcGFyYW1zKTtcbiAgICB0bC5kZWxheSA9IHRpbWluZ3MuZGVsYXk7XG4gICAgdGwuZW5kRGVsYXkgPSB0aW1pbmdzLmVuZERlbGF5O1xuICAgIHRsLmR1cmF0aW9uID0gdGltaW5ncy5kdXJhdGlvbjtcbiAgICB0bC5zZWVrKDApO1xuICAgIHRsLnJlc2V0KCk7XG4gICAgaWYgKHRsLmF1dG9wbGF5KSB7IHRsLnBsYXkoKTsgfVxuICAgIHJldHVybiB0bDtcbiAgfTtcbiAgcmV0dXJuIHRsO1xufVxuXG5hbmltZS52ZXJzaW9uID0gJzMuMS4wJztcbmFuaW1lLnNwZWVkID0gMTtcbmFuaW1lLnJ1bm5pbmcgPSBhY3RpdmVJbnN0YW5jZXM7XG5hbmltZS5yZW1vdmUgPSByZW1vdmVUYXJnZXRzO1xuYW5pbWUuZ2V0ID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZTtcbmFuaW1lLnNldCA9IHNldFRhcmdldHNWYWx1ZTtcbmFuaW1lLmNvbnZlcnRQeCA9IGNvbnZlcnRQeFRvVW5pdDtcbmFuaW1lLnBhdGggPSBnZXRQYXRoO1xuYW5pbWUuc2V0RGFzaG9mZnNldCA9IHNldERhc2hvZmZzZXQ7XG5hbmltZS5zdGFnZ2VyID0gc3RhZ2dlcjtcbmFuaW1lLnRpbWVsaW5lID0gdGltZWxpbmU7XG5hbmltZS5lYXNpbmcgPSBwYXJzZUVhc2luZ3M7XG5hbmltZS5wZW5uZXIgPSBwZW5uZXI7XG5hbmltZS5yYW5kb20gPSBmdW5jdGlvbiAobWluLCBtYXgpIHsgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47IH07XG5cbm1vZHVsZS5leHBvcnRzID0gYW5pbWU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXRoL3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbWF0aC90cnVuY1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvaXMtbmFuXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9tYXgtc2FmZS1pbnRlZ2VyXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59OyIsIiFmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW1wiZXhwb3J0c1wiXSx0KTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzKXQoZXhwb3J0cyk7ZWxzZXt2YXIgbz17fTt0KG8pLGUuYm9keVNjcm9sbExvY2s9b319KHRoaXMsZnVuY3Rpb24oZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxvPUFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylvW3RdPWVbdF07cmV0dXJuIG99cmV0dXJuIEFycmF5LmZyb20oZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9ITE7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl7dmFyIGU9e2dldCBwYXNzaXZlKCl7bD0hMH19O3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIixudWxsLGUpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIixudWxsLGUpfXZhciBkPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5uYXZpZ2F0b3ImJndpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0mJi9pUChhZHxob25lfG9kKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSxjPVtdLHU9ITEsYT0tMSxzPXZvaWQgMCx2PXZvaWQgMCxmPWZ1bmN0aW9uKHQpe3JldHVybiBjLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuISghZS5vcHRpb25zLmFsbG93VG91Y2hNb3ZlfHwhZS5vcHRpb25zLmFsbG93VG91Y2hNb3ZlKHQpKX0pfSxtPWZ1bmN0aW9uKGUpe3ZhciB0PWV8fHdpbmRvdy5ldmVudDtyZXR1cm4hIWYodC50YXJnZXQpfHwoMTx0LnRvdWNoZXMubGVuZ3RofHwodC5wcmV2ZW50RGVmYXVsdCYmdC5wcmV2ZW50RGVmYXVsdCgpLCExKSl9LG89ZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dm9pZCAwIT09diYmKGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0PXYsdj12b2lkIDApLHZvaWQgMCE9PXMmJihkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93PXMscz12b2lkIDApfSl9O2V4cG9ydHMuZGlzYWJsZUJvZHlTY3JvbGw9ZnVuY3Rpb24oaSxlKXtpZihkKXtpZighaSlyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiZGlzYWJsZUJvZHlTY3JvbGwgdW5zdWNjZXNzZnVsIC0gdGFyZ2V0RWxlbWVudCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY2FsbGluZyBkaXNhYmxlQm9keVNjcm9sbCBvbiBJT1MgZGV2aWNlcy5cIik7aWYoaSYmIWMuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZS50YXJnZXRFbGVtZW50PT09aX0pKXt2YXIgdD17dGFyZ2V0RWxlbWVudDppLG9wdGlvbnM6ZXx8e319O2M9W10uY29uY2F0KHIoYyksW3RdKSxpLm9udG91Y2hzdGFydD1mdW5jdGlvbihlKXsxPT09ZS50YXJnZXRUb3VjaGVzLmxlbmd0aCYmKGE9ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkpfSxpLm9udG91Y2htb3ZlPWZ1bmN0aW9uKGUpe3ZhciB0LG8sbixyOzE9PT1lLnRhcmdldFRvdWNoZXMubGVuZ3RoJiYobz1pLHI9KHQ9ZSkudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLWEsIWYodC50YXJnZXQpJiYobyYmMD09PW8uc2Nyb2xsVG9wJiYwPHI/bSh0KToobj1vKSYmbi5zY3JvbGxIZWlnaHQtbi5zY3JvbGxUb3A8PW4uY2xpZW50SGVpZ2h0JiZyPDA/bSh0KTp0LnN0b3BQcm9wYWdhdGlvbigpKSl9LHV8fChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsbSxsP3twYXNzaXZlOiExfTp2b2lkIDApLHU9ITApfX1lbHNle249ZSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYodm9pZCAwPT09dil7dmFyIGU9ISFuJiYhMD09PW4ucmVzZXJ2ZVNjcm9sbEJhckdhcCx0PXdpbmRvdy5pbm5lcldpZHRoLWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtlJiYwPHQmJih2PWRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0LGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0PXQrXCJweFwiKX12b2lkIDA9PT1zJiYocz1kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93LGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIil9KTt2YXIgbz17dGFyZ2V0RWxlbWVudDppLG9wdGlvbnM6ZXx8e319O2M9W10uY29uY2F0KHIoYyksW29dKX12YXIgbn0sZXhwb3J0cy5jbGVhckFsbEJvZHlTY3JvbGxMb2Nrcz1mdW5jdGlvbigpe2Q/KGMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnRhcmdldEVsZW1lbnQub250b3VjaHN0YXJ0PW51bGwsZS50YXJnZXRFbGVtZW50Lm9udG91Y2htb3ZlPW51bGx9KSx1JiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLG0sbD97cGFzc2l2ZTohMX06dm9pZCAwKSx1PSExKSxjPVtdLGE9LTEpOihvKCksYz1bXSl9LGV4cG9ydHMuZW5hYmxlQm9keVNjcm9sbD1mdW5jdGlvbih0KXtpZihkKXtpZighdClyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiZW5hYmxlQm9keVNjcm9sbCB1bnN1Y2Nlc3NmdWwgLSB0YXJnZXRFbGVtZW50IG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjYWxsaW5nIGVuYWJsZUJvZHlTY3JvbGwgb24gSU9TIGRldmljZXMuXCIpO3Qub250b3VjaHN0YXJ0PW51bGwsdC5vbnRvdWNobW92ZT1udWxsLGM9Yy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUudGFyZ2V0RWxlbWVudCE9PXR9KSx1JiYwPT09Yy5sZW5ndGgmJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsbSxsP3twYXNzaXZlOiExfTp2b2lkIDApLHU9ITEpfWVsc2UgMT09PWMubGVuZ3RoJiZjWzBdLnRhcmdldEVsZW1lbnQ9PT10PyhvKCksYz1bXSk6Yz1jLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50YXJnZXRFbGVtZW50IT09dH0pfX0pO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5NYXRoLnNpZ247XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5NYXRoLnRydW5jO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTnVtYmVyLmlzTmFOO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbm1vZHVsZS5leHBvcnRzID0gMHgxZmZmZmZmZmZmZmZmZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMTEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBpc0VudW0uY2FsbChTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJykgfSk7XG4iLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpIHtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsIiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkR09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAhISRHT1BTLmY7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICRHT1BTLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gJGZhaWxzKGZ1bmN0aW9uICgpIHsgJEdPUFMuZigxKTsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogRkFJTFNfT05fUFJJTUlUSVZFUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gJEdPUFMuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cbiIsIi8qIGZsYXRwaWNrciB2NC41LjcsIEBsaWNlbnNlIE1JVCAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5mbGF0cGlja3IgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxuICAgIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgICBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuICAgIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICAgIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICAgIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbiAgICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuICAgIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gICAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbiAgICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xuXG4gICAgdmFyIEhPT0tTID0gW1xuICAgICAgICBcIm9uQ2hhbmdlXCIsXG4gICAgICAgIFwib25DbG9zZVwiLFxuICAgICAgICBcIm9uRGF5Q3JlYXRlXCIsXG4gICAgICAgIFwib25EZXN0cm95XCIsXG4gICAgICAgIFwib25LZXlEb3duXCIsXG4gICAgICAgIFwib25Nb250aENoYW5nZVwiLFxuICAgICAgICBcIm9uT3BlblwiLFxuICAgICAgICBcIm9uUGFyc2VDb25maWdcIixcbiAgICAgICAgXCJvblJlYWR5XCIsXG4gICAgICAgIFwib25WYWx1ZVVwZGF0ZVwiLFxuICAgICAgICBcIm9uWWVhckNoYW5nZVwiLFxuICAgICAgICBcIm9uUHJlQ2FsZW5kYXJQb3NpdGlvblwiLFxuICAgIF07XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBfZGlzYWJsZTogW10sXG4gICAgICAgIF9lbmFibGU6IFtdLFxuICAgICAgICBhbGxvd0lucHV0OiBmYWxzZSxcbiAgICAgICAgYWx0Rm9ybWF0OiBcIkYgaiwgWVwiLFxuICAgICAgICBhbHRJbnB1dDogZmFsc2UsXG4gICAgICAgIGFsdElucHV0Q2xhc3M6IFwiZm9ybS1jb250cm9sIGlucHV0XCIsXG4gICAgICAgIGFuaW1hdGU6IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID09PSAtMSxcbiAgICAgICAgYXJpYURhdGVGb3JtYXQ6IFwiRiBqLCBZXCIsXG4gICAgICAgIGNsaWNrT3BlbnM6IHRydWUsXG4gICAgICAgIGNsb3NlT25TZWxlY3Q6IHRydWUsXG4gICAgICAgIGNvbmp1bmN0aW9uOiBcIiwgXCIsXG4gICAgICAgIGRhdGVGb3JtYXQ6IFwiWS1tLWRcIixcbiAgICAgICAgZGVmYXVsdEhvdXI6IDEyLFxuICAgICAgICBkZWZhdWx0TWludXRlOiAwLFxuICAgICAgICBkZWZhdWx0U2Vjb25kczogMCxcbiAgICAgICAgZGlzYWJsZTogW10sXG4gICAgICAgIGRpc2FibGVNb2JpbGU6IGZhbHNlLFxuICAgICAgICBlbmFibGU6IFtdLFxuICAgICAgICBlbmFibGVTZWNvbmRzOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlVGltZTogZmFsc2UsXG4gICAgICAgIGVycm9ySGFuZGxlcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXZWVrOiBmdW5jdGlvbiAoZ2l2ZW5EYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGdpdmVuRGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIC8vIFRodXJzZGF5IGluIGN1cnJlbnQgd2VlayBkZWNpZGVzIHRoZSB5ZWFyLlxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMyAtICgoZGF0ZS5nZXREYXkoKSArIDYpICUgNykpO1xuICAgICAgICAgICAgLy8gSmFudWFyeSA0IGlzIGFsd2F5cyBpbiB3ZWVrIDEuXG4gICAgICAgICAgICB2YXIgd2VlazEgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDQpO1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRvIFRodXJzZGF5IGluIHdlZWsgMSBhbmQgY291bnQgbnVtYmVyIG9mIHdlZWtzIGZyb20gZGF0ZSB0byB3ZWVrMS5cbiAgICAgICAgICAgIHJldHVybiAoMSArXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoKGRhdGUuZ2V0VGltZSgpIC0gd2VlazEuZ2V0VGltZSgpKSAvIDg2NDAwMDAwIC1cbiAgICAgICAgICAgICAgICAgICAgMyArXG4gICAgICAgICAgICAgICAgICAgICgod2VlazEuZ2V0RGF5KCkgKyA2KSAlIDcpKSAvXG4gICAgICAgICAgICAgICAgICAgIDcpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaG91ckluY3JlbWVudDogMSxcbiAgICAgICAgaWdub3JlZEZvY3VzRWxlbWVudHM6IFtdLFxuICAgICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAgICBsb2NhbGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBtaW51dGVJbmNyZW1lbnQ6IDUsXG4gICAgICAgIG1vZGU6IFwic2luZ2xlXCIsXG4gICAgICAgIG5leHRBcnJvdzogXCI8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgdmlld0JveD0nMCAwIDE3IDE3Jz48Zz48L2c+PHBhdGggZD0nTTEzLjIwNyA4LjQ3MmwtNy44NTQgNy44NTQtMC43MDctMC43MDcgNy4xNDYtNy4xNDYtNy4xNDYtNy4xNDggMC43MDctMC43MDcgNy44NTQgNy44NTR6JyAvPjwvc3ZnPlwiLFxuICAgICAgICBub0NhbGVuZGFyOiBmYWxzZSxcbiAgICAgICAgbm93OiBuZXcgRGF0ZSgpLFxuICAgICAgICBvbkNoYW5nZTogW10sXG4gICAgICAgIG9uQ2xvc2U6IFtdLFxuICAgICAgICBvbkRheUNyZWF0ZTogW10sXG4gICAgICAgIG9uRGVzdHJveTogW10sXG4gICAgICAgIG9uS2V5RG93bjogW10sXG4gICAgICAgIG9uTW9udGhDaGFuZ2U6IFtdLFxuICAgICAgICBvbk9wZW46IFtdLFxuICAgICAgICBvblBhcnNlQ29uZmlnOiBbXSxcbiAgICAgICAgb25SZWFkeTogW10sXG4gICAgICAgIG9uVmFsdWVVcGRhdGU6IFtdLFxuICAgICAgICBvblllYXJDaGFuZ2U6IFtdLFxuICAgICAgICBvblByZUNhbGVuZGFyUG9zaXRpb246IFtdLFxuICAgICAgICBwbHVnaW5zOiBbXSxcbiAgICAgICAgcG9zaXRpb246IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbkVsZW1lbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJldkFycm93OiBcIjxzdmcgdmVyc2lvbj0nMS4xJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB2aWV3Qm94PScwIDAgMTcgMTcnPjxnPjwvZz48cGF0aCBkPSdNNS4yMDcgOC40NzFsNy4xNDYgNy4xNDctMC43MDcgMC43MDctNy44NTMtNy44NTQgNy44NTQtNy44NTMgMC43MDcgMC43MDctNy4xNDcgNy4xNDZ6JyAvPjwvc3ZnPlwiLFxuICAgICAgICBzaG9ydGhhbmRDdXJyZW50TW9udGg6IGZhbHNlLFxuICAgICAgICBzaG93TW9udGhzOiAxLFxuICAgICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgICB0aW1lXzI0aHI6IGZhbHNlLFxuICAgICAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgICAgIHdyYXA6IGZhbHNlXG4gICAgfTtcblxuICAgIHZhciBlbmdsaXNoID0ge1xuICAgICAgICB3ZWVrZGF5czoge1xuICAgICAgICAgICAgc2hvcnRoYW5kOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICAgIFwiU3VuZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJNb25kYXlcIixcbiAgICAgICAgICAgICAgICBcIlR1ZXNkYXlcIixcbiAgICAgICAgICAgICAgICBcIldlZG5lc2RheVwiLFxuICAgICAgICAgICAgICAgIFwiVGh1cnNkYXlcIixcbiAgICAgICAgICAgICAgICBcIkZyaWRheVwiLFxuICAgICAgICAgICAgICAgIFwiU2F0dXJkYXlcIixcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgbW9udGhzOiB7XG4gICAgICAgICAgICBzaG9ydGhhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIkphblwiLFxuICAgICAgICAgICAgICAgIFwiRmViXCIsXG4gICAgICAgICAgICAgICAgXCJNYXJcIixcbiAgICAgICAgICAgICAgICBcIkFwclwiLFxuICAgICAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICAgICAgXCJKdW5cIixcbiAgICAgICAgICAgICAgICBcIkp1bFwiLFxuICAgICAgICAgICAgICAgIFwiQXVnXCIsXG4gICAgICAgICAgICAgICAgXCJTZXBcIixcbiAgICAgICAgICAgICAgICBcIk9jdFwiLFxuICAgICAgICAgICAgICAgIFwiTm92XCIsXG4gICAgICAgICAgICAgICAgXCJEZWNcIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICAgIFwiSmFudWFyeVwiLFxuICAgICAgICAgICAgICAgIFwiRmVicnVhcnlcIixcbiAgICAgICAgICAgICAgICBcIk1hcmNoXCIsXG4gICAgICAgICAgICAgICAgXCJBcHJpbFwiLFxuICAgICAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICAgICAgXCJKdW5lXCIsXG4gICAgICAgICAgICAgICAgXCJKdWx5XCIsXG4gICAgICAgICAgICAgICAgXCJBdWd1c3RcIixcbiAgICAgICAgICAgICAgICBcIlNlcHRlbWJlclwiLFxuICAgICAgICAgICAgICAgIFwiT2N0b2JlclwiLFxuICAgICAgICAgICAgICAgIFwiTm92ZW1iZXJcIixcbiAgICAgICAgICAgICAgICBcIkRlY2VtYmVyXCIsXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGRheXNJbk1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrOiAwLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnRoKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG50aCAlIDEwMDtcbiAgICAgICAgICAgIGlmIChzID4gMyAmJiBzIDwgMjEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidGhcIjtcbiAgICAgICAgICAgIHN3aXRjaCAocyAlIDEwKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJkXCI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIHRvIFwiLFxuICAgICAgICB3ZWVrQWJicmV2aWF0aW9uOiBcIldrXCIsXG4gICAgICAgIHNjcm9sbFRpdGxlOiBcIlNjcm9sbCB0byBpbmNyZW1lbnRcIixcbiAgICAgICAgdG9nZ2xlVGl0bGU6IFwiQ2xpY2sgdG8gdG9nZ2xlXCIsXG4gICAgICAgIGFtUE06IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgICAgIHllYXJBcmlhTGFiZWw6IFwiWWVhclwiXG4gICAgfTtcblxuICAgIHZhciBwYWQgPSBmdW5jdGlvbiAobnVtYmVyKSB7IHJldHVybiAoXCIwXCIgKyBudW1iZXIpLnNsaWNlKC0yKTsgfTtcbiAgICB2YXIgaW50ID0gZnVuY3Rpb24gKGJvb2wpIHsgcmV0dXJuIChib29sID09PSB0cnVlID8gMSA6IDApOyB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkgeyBpbW1lZGlhdGUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgdGltZW91dDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRpbWVvdXQgIT09IG51bGwgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSlcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIHdhaXQpO1xuICAgICAgICAgICAgaWYgKGltbWVkaWF0ZSAmJiAhdGltZW91dClcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgYXJyYXlpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6IFtvYmpdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtLCBjbGFzc05hbWUsIGJvb2wpIHtcbiAgICAgICAgaWYgKGJvb2wgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgY2xhc3NOYW1lLCBjb250ZW50KSB7XG4gICAgICAgIHZhciBlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IFwiXCI7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50IHx8IFwiXCI7XG4gICAgICAgIGUuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhck5vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kUGFyZW50KG5vZGUsIGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmaW5kUGFyZW50KG5vZGUucGFyZW50Tm9kZSwgY29uZGl0aW9uKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gbm90aGluZyBmb3VuZFxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOdW1iZXJJbnB1dChpbnB1dENsYXNzTmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJudW1JbnB1dFdyYXBwZXJcIiksIG51bUlucHV0ID0gY3JlYXRlRWxlbWVudChcImlucHV0XCIsIFwibnVtSW5wdXQgXCIgKyBpbnB1dENsYXNzTmFtZSksIGFycm93VXAgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImFycm93VXBcIiksIGFycm93RG93biA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiYXJyb3dEb3duXCIpO1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRSA5LjBcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBudW1JbnB1dC50eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG51bUlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIG51bUlucHV0LnBhdHRlcm4gPSBcIlxcXFxkKlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0cylcbiAgICAgICAgICAgICAgICBudW1JbnB1dC5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRzW2tleV0pO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKG51bUlucHV0KTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChhcnJvd1VwKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChhcnJvd0Rvd24pO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudC5jb21wb3NlZFBhdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvX25vdGhpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgdmFyIG1vbnRoVG9TdHIgPSBmdW5jdGlvbiAobW9udGhOdW1iZXIsIHNob3J0aGFuZCwgbG9jYWxlKSB7IHJldHVybiBsb2NhbGUubW9udGhzW3Nob3J0aGFuZCA/IFwic2hvcnRoYW5kXCIgOiBcImxvbmdoYW5kXCJdW21vbnRoTnVtYmVyXTsgfTtcbiAgICB2YXIgcmV2Rm9ybWF0ID0ge1xuICAgICAgICBEOiBkb19ub3RoaW5nLFxuICAgICAgICBGOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbW9udGhOYW1lLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgobG9jYWxlLm1vbnRocy5sb25naGFuZC5pbmRleE9mKG1vbnRoTmFtZSkpO1xuICAgICAgICB9LFxuICAgICAgICBHOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgSDogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIEo6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBLOiBmdW5jdGlvbiAoZGF0ZU9iaiwgYW1QTSwgbG9jYWxlKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKChkYXRlT2JqLmdldEhvdXJzKCkgJSAxMikgK1xuICAgICAgICAgICAgICAgIDEyICogaW50KG5ldyBSZWdFeHAobG9jYWxlLmFtUE1bMV0sIFwiaVwiKS50ZXN0KGFtUE0pKSk7XG4gICAgICAgIH0sXG4gICAgICAgIE06IGZ1bmN0aW9uIChkYXRlT2JqLCBzaG9ydE1vbnRoLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgobG9jYWxlLm1vbnRocy5zaG9ydGhhbmQuaW5kZXhPZihzaG9ydE1vbnRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFM6IGZ1bmN0aW9uIChkYXRlT2JqLCBzZWNvbmRzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldFNlY29uZHMocGFyc2VGbG9hdChzZWNvbmRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFU6IGZ1bmN0aW9uIChfLCB1bml4U2Vjb25kcykgeyByZXR1cm4gbmV3IERhdGUocGFyc2VGbG9hdCh1bml4U2Vjb25kcykgKiAxMDAwKTsgfSxcbiAgICAgICAgVzogZnVuY3Rpb24gKGRhdGVPYmosIHdlZWtOdW0pIHtcbiAgICAgICAgICAgIHZhciB3ZWVrTnVtYmVyID0gcGFyc2VJbnQod2Vla051bSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZU9iai5nZXRGdWxsWWVhcigpLCAwLCAyICsgKHdlZWtOdW1iZXIgLSAxKSAqIDcsIDAsIDAsIDAsIDApO1xuICAgICAgICB9LFxuICAgICAgICBZOiBmdW5jdGlvbiAoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcihwYXJzZUZsb2F0KHllYXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgWjogZnVuY3Rpb24gKF8sIElTT0RhdGUpIHsgcmV0dXJuIG5ldyBEYXRlKElTT0RhdGUpOyB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGk6IGZ1bmN0aW9uIChkYXRlT2JqLCBtaW51dGVzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1pbnV0ZXMocGFyc2VGbG9hdChtaW51dGVzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGo6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBsOiBkb19ub3RoaW5nLFxuICAgICAgICBtOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbW9udGgpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgocGFyc2VGbG9hdChtb250aCkgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgbjogZnVuY3Rpb24gKGRhdGVPYmosIG1vbnRoKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1vbnRoKHBhcnNlRmxvYXQobW9udGgpIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIHM6IGZ1bmN0aW9uIChkYXRlT2JqLCBzZWNvbmRzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldFNlY29uZHMocGFyc2VGbG9hdChzZWNvbmRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHU6IGZ1bmN0aW9uIChfLCB1bml4TWlsbFNlY29uZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZUZsb2F0KHVuaXhNaWxsU2Vjb25kcykpO1xuICAgICAgICB9LFxuICAgICAgICB3OiBkb19ub3RoaW5nLFxuICAgICAgICB5OiBmdW5jdGlvbiAoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcigyMDAwICsgcGFyc2VGbG9hdCh5ZWFyKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0b2tlblJlZ2V4ID0ge1xuICAgICAgICBEOiBcIihcXFxcdyspXCIsXG4gICAgICAgIEY6IFwiKFxcXFx3KylcIixcbiAgICAgICAgRzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgSDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgSjogXCIoXFxcXGRcXFxcZHxcXFxcZClcXFxcdytcIixcbiAgICAgICAgSzogXCJcIixcbiAgICAgICAgTTogXCIoXFxcXHcrKVwiLFxuICAgICAgICBTOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBVOiBcIiguKylcIixcbiAgICAgICAgVzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgWTogXCIoXFxcXGR7NH0pXCIsXG4gICAgICAgIFo6IFwiKC4rKVwiLFxuICAgICAgICBkOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBoOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBpOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBqOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBsOiBcIihcXFxcdyspXCIsXG4gICAgICAgIG06IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIG46IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIHM6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIHU6IFwiKC4rKVwiLFxuICAgICAgICB3OiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICB5OiBcIihcXFxcZHsyfSlcIlxuICAgIH07XG4gICAgdmFyIGZvcm1hdHMgPSB7XG4gICAgICAgIC8vIGdldCB0aGUgZGF0ZSBpbiBVVENcbiAgICAgICAgWjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTsgfSxcbiAgICAgICAgLy8gd2Vla2RheSBuYW1lLCBzaG9ydCwgZS5nLiBUaHVcbiAgICAgICAgRDogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5cy5zaG9ydGhhbmRbZm9ybWF0cy53KGRhdGUsIGxvY2FsZSwgb3B0aW9ucyldO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmdWxsIG1vbnRoIG5hbWUgZS5nLiBKYW51YXJ5XG4gICAgICAgIEY6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aFRvU3RyKGZvcm1hdHMubihkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIC0gMSwgZmFsc2UsIGxvY2FsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHBhZGRlZCBob3VyIDEtMTJcbiAgICAgICAgRzogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHBhZChmb3JtYXRzLmgoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGhvdXJzIHdpdGggbGVhZGluZyB6ZXJvIGUuZy4gMDNcbiAgICAgICAgSDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldEhvdXJzKCkpOyB9LFxuICAgICAgICAvLyBkYXkgKDEtMzApIHdpdGggb3JkaW5hbCBzdWZmaXggZS5nLiAxc3QsIDJuZFxuICAgICAgICBKOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm9yZGluYWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZGF0ZS5nZXREYXRlKCkgKyBsb2NhbGUub3JkaW5hbChkYXRlLmdldERhdGUoKSlcbiAgICAgICAgICAgICAgICA6IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBTS9QTVxuICAgICAgICBLOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7IHJldHVybiBsb2NhbGUuYW1QTVtpbnQoZGF0ZS5nZXRIb3VycygpID4gMTEpXTsgfSxcbiAgICAgICAgLy8gc2hvcnRoYW5kIG1vbnRoIGUuZy4gSmFuLCBTZXAsIE9jdCwgZXRjXG4gICAgICAgIE06IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aFRvU3RyKGRhdGUuZ2V0TW9udGgoKSwgdHJ1ZSwgbG9jYWxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gc2Vjb25kcyAwMC01OVxuICAgICAgICBTOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0U2Vjb25kcygpKTsgfSxcbiAgICAgICAgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgICAgVTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMDsgfSxcbiAgICAgICAgVzogZnVuY3Rpb24gKGRhdGUsIF8sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmdldFdlZWsoZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZ1bGwgeWVhciBlLmcuIDIwMTZcbiAgICAgICAgWTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTsgfSxcbiAgICAgICAgLy8gZGF5IGluIG1vbnRoLCBwYWRkZWQgKDAxLTMwKVxuICAgICAgICBkOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0RGF0ZSgpKTsgfSxcbiAgICAgICAgLy8gaG91ciBmcm9tIDEtMTIgKGFtL3BtKVxuICAgICAgICBoOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGRhdGUuZ2V0SG91cnMoKSAlIDEyID8gZGF0ZS5nZXRIb3VycygpICUgMTIgOiAxMik7IH0sXG4gICAgICAgIC8vIG1pbnV0ZXMsIHBhZGRlZCB3aXRoIGxlYWRpbmcgemVybyBlLmcuIDA5XG4gICAgICAgIGk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRNaW51dGVzKCkpOyB9LFxuICAgICAgICAvLyBkYXkgaW4gbW9udGggKDEtMzApXG4gICAgICAgIGo6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldERhdGUoKTsgfSxcbiAgICAgICAgLy8gd2Vla2RheSBuYW1lLCBmdWxsLCBlLmcuIFRodXJzZGF5XG4gICAgICAgIGw6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXMubG9uZ2hhbmRbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHBhZGRlZCBtb250aCBudW1iZXIgKDAxLTEyKVxuICAgICAgICBtOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0TW9udGgoKSArIDEpOyB9LFxuICAgICAgICAvLyB0aGUgbW9udGggbnVtYmVyICgxLTEyKVxuICAgICAgICBuOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgMTsgfSxcbiAgICAgICAgLy8gc2Vjb25kcyAwLTU5XG4gICAgICAgIHM6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFNlY29uZHMoKTsgfSxcbiAgICAgICAgLy8gVW5peCBNaWxsaXNlY29uZHNcbiAgICAgICAgdTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpOyB9LFxuICAgICAgICAvLyBudW1iZXIgb2YgdGhlIGRheSBvZiB0aGUgd2Vla1xuICAgICAgICB3OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXREYXkoKTsgfSxcbiAgICAgICAgLy8gbGFzdCB0d28gZGlnaXRzIG9mIHllYXIgZS5nLiAxNiBmb3IgMjAxNlxuICAgICAgICB5OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gU3RyaW5nKGRhdGUuZ2V0RnVsbFllYXIoKSkuc3Vic3RyaW5nKDIpOyB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEYXRlRm9ybWF0dGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLmNvbmZpZywgY29uZmlnID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRzIDogX2IsIF9jID0gX2EubDEwbiwgbDEwbiA9IF9jID09PSB2b2lkIDAgPyBlbmdsaXNoIDogX2M7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZU9iaiwgZnJtdCwgb3ZlcnJpZGVMb2NhbGUpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBvdmVycmlkZUxvY2FsZSB8fCBsMTBuO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5mb3JtYXREYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLmZvcm1hdERhdGUoZGF0ZU9iaiwgZnJtdCwgbG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcm10XG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiXCIpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYywgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHNbY10gJiYgYXJyW2kgLSAxXSAhPT0gXCJcXFxcXCJcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2NdKGRhdGVPYmosIGxvY2FsZSwgY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICA6IGMgIT09IFwiXFxcXFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlRGF0ZVBhcnNlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5jb25maWcsIGNvbmZpZyA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyA6IF9iLCBfYyA9IF9hLmwxMG4sIGwxMG4gPSBfYyA9PT0gdm9pZCAwID8gZW5nbGlzaCA6IF9jO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGdpdmVuRm9ybWF0LCB0aW1lbGVzcywgY3VzdG9tTG9jYWxlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSAhPT0gMCAmJiAhZGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGN1c3RvbUxvY2FsZSB8fCBsMTBuO1xuICAgICAgICAgICAgdmFyIHBhcnNlZERhdGU7XG4gICAgICAgICAgICB2YXIgZGF0ZV9vcmlnID0gZGF0ZTtcbiAgICAgICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGUgIT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRlLnRvRml4ZWQgIT09IHVuZGVmaW5lZCAvLyB0aW1lc3RhbXBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb3B5XG4gICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkYXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBnaXZlbkZvcm1hdCB8fCAoY29uZmlnIHx8IGRlZmF1bHRzKS5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgICAgIHZhciBkYXRlc3RyID0gU3RyaW5nKGRhdGUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXN0ciA9PT0gXCJ0b2RheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9aJC8udGVzdChkYXRlc3RyKSB8fFxuICAgICAgICAgICAgICAgICAgICAvR01UJC8udGVzdChkYXRlc3RyKSAvLyBkYXRlc3RyaW5ncyB3LyB0aW1lem9uZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZyAmJiBjb25maWcucGFyc2VEYXRlKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gY29uZmlnLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICFjb25maWcgfHwgIWNvbmZpZy5ub0NhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIDAsIDEsIDAsIDAsIDAsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSB2b2lkIDAsIG9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF0Y2hJbmRleCA9IDAsIHJlZ2V4U3RyID0gXCJcIjsgaSA8IGZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuXzEgPSBmb3JtYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNCYWNrU2xhc2ggPSB0b2tlbl8xID09PSBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkID0gZm9ybWF0W2kgLSAxXSA9PT0gXCJcXFxcXCIgfHwgaXNCYWNrU2xhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWdleFt0b2tlbl8xXSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4U3RyICs9IHRva2VuUmVnZXhbdG9rZW5fMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbmV3IFJlZ0V4cChyZWdleFN0cikuZXhlYyhkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoZWQgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHNbdG9rZW5fMSAhPT0gXCJZXCIgPyBcInB1c2hcIiA6IFwidW5zaGlmdFwiXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogcmV2Rm9ybWF0W3Rva2VuXzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiBtYXRjaFsrK21hdGNoSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JhY2tTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleFN0ciArPSBcIi5cIjsgLy8gZG9uJ3QgcmVhbGx5IGNhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IF9hLmZuLCB2YWwgPSBfYS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZWREYXRlID0gZm4ocGFyc2VkRGF0ZSwgdmFsLCBsb2NhbGUpIHx8IHBhcnNlZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG1hdGNoZWQgPyBwYXJzZWREYXRlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIShwYXJzZWREYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ocGFyc2VkRGF0ZS5nZXRUaW1lKCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHByb3ZpZGVkOiBcIiArIGRhdGVfb3JpZykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZWxlc3MgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcGFyc2VkRGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWREYXRlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZGlmZmVyZW5jZSBpbiBkYXRlcywgbWVhc3VyZWQgaW4gbXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlRGF0ZXMoZGF0ZTEsIGRhdGUyLCB0aW1lbGVzcykge1xuICAgICAgICBpZiAodGltZWxlc3MgPT09IHZvaWQgMCkgeyB0aW1lbGVzcyA9IHRydWU7IH1cbiAgICAgICAgaWYgKHRpbWVsZXNzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgRGF0ZShkYXRlMS5nZXRUaW1lKCkpLnNldEhvdXJzKDAsIDAsIDAsIDApIC1cbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShkYXRlMi5nZXRUaW1lKCkpLnNldEhvdXJzKDAsIDAsIDAsIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTEuZ2V0VGltZSgpIC0gZGF0ZTIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICB2YXIgaXNCZXR3ZWVuID0gZnVuY3Rpb24gKHRzLCB0czEsIHRzMikge1xuICAgICAgICByZXR1cm4gdHMgPiBNYXRoLm1pbih0czEsIHRzMikgJiYgdHMgPCBNYXRoLm1heCh0czEsIHRzMik7XG4gICAgfTtcbiAgICB2YXIgZHVyYXRpb24gPSB7XG4gICAgICAgIERBWTogODY0MDAwMDBcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgYXJnc18xID0gYXJnczsgX2EgPCBhcmdzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NfMVtfYV07XG4gICAgICAgICAgICAgICAgX2xvb3BfMShzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgREVCT1VOQ0VEX0NIQU5HRV9NUyA9IDMwMDtcbiAgICBmdW5jdGlvbiBGbGF0cGlja3JJbnN0YW5jZShlbGVtZW50LCBpbnN0YW5jZUNvbmZpZykge1xuICAgICAgICB2YXIgc2VsZiA9IHtcbiAgICAgICAgICAgIGNvbmZpZzogX19hc3NpZ24oe30sIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnKSxcbiAgICAgICAgICAgIGwxMG46IGVuZ2xpc2hcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHsgY29uZmlnOiBzZWxmLmNvbmZpZywgbDEwbjogc2VsZi5sMTBuIH0pO1xuICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICBzZWxmLl9iaW5kID0gYmluZDtcbiAgICAgICAgc2VsZi5fc2V0SG91cnNGcm9tRGF0ZSA9IHNldEhvdXJzRnJvbURhdGU7XG4gICAgICAgIHNlbGYuX3Bvc2l0aW9uQ2FsZW5kYXIgPSBwb3NpdGlvbkNhbGVuZGFyO1xuICAgICAgICBzZWxmLmNoYW5nZU1vbnRoID0gY2hhbmdlTW9udGg7XG4gICAgICAgIHNlbGYuY2hhbmdlWWVhciA9IGNoYW5nZVllYXI7XG4gICAgICAgIHNlbGYuY2xlYXIgPSBjbGVhcjtcbiAgICAgICAgc2VsZi5jbG9zZSA9IGNsb3NlO1xuICAgICAgICBzZWxmLl9jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbiAgICAgICAgc2VsZi5kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG4gICAgICAgIHNlbGYuanVtcFRvRGF0ZSA9IGp1bXBUb0RhdGU7XG4gICAgICAgIHNlbGYub3BlbiA9IG9wZW47XG4gICAgICAgIHNlbGYucmVkcmF3ID0gcmVkcmF3O1xuICAgICAgICBzZWxmLnNldCA9IHNldDtcbiAgICAgICAgc2VsZi5zZXREYXRlID0gc2V0RGF0ZTtcbiAgICAgICAgc2VsZi50b2dnbGUgPSB0b2dnbGU7XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwSGVscGVyRnVuY3Rpb25zKCkge1xuICAgICAgICAgICAgc2VsZi51dGlscyA9IHtcbiAgICAgICAgICAgICAgICBnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKG1vbnRoLCB5cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IHNlbGYuY3VycmVudE1vbnRoOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ciA9PT0gdm9pZCAwKSB7IHlyID0gc2VsZi5jdXJyZW50WWVhcjsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IDEgJiYgKCh5ciAlIDQgPT09IDAgJiYgeXIgJSAxMDAgIT09IDApIHx8IHlyICUgNDAwID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubDEwbi5kYXlzSW5Nb250aFttb250aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgc2VsZi5lbGVtZW50ID0gc2VsZi5pbnB1dCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyc2VDb25maWcoKTtcbiAgICAgICAgICAgIHNldHVwTG9jYWxlKCk7XG4gICAgICAgICAgICBzZXR1cElucHV0cygpO1xuICAgICAgICAgICAgc2V0dXBEYXRlcygpO1xuICAgICAgICAgICAgc2V0dXBIZWxwZXJGdW5jdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICBidWlsZCgpO1xuICAgICAgICAgICAgYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoc2VsZi5jb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiB8fCBzZWxmLmNvbmZpZy5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENhbGVuZGFyV2lkdGgoKTtcbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDAgfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcjtcbiAgICAgICAgICAgIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICAvKiBUT0RPOiBpbnZlc3RpZ2F0ZSB0aGlzIGZ1cnRoZXJcbiAgICAgICAgXG4gICAgICAgICAgICAgIEN1cnJlbnRseSwgdGhlcmUgaXMgd2VpcmQgcG9zaXRpb25pbmcgYmVoYXZpb3IgaW4gc2FmYXJpIGNhdXNpbmcgcGFnZXNcbiAgICAgICAgICAgICAgdG8gc2Nyb2xsIHVwLiBodHRwczovL2dpdGh1Yi5jb20vY2htbG4vZmxhdHBpY2tyL2lzc3Vlcy81NjNcbiAgICAgICAgXG4gICAgICAgICAgICAgIEhvd2V2ZXIsIG1vc3QgYnJvd3NlcnMgYXJlIG5vdCBTYWZhcmkgYW5kIHBvc2l0aW9uaW5nIGlzIGV4cGVuc2l2ZSB3aGVuIHVzZWRcbiAgICAgICAgICAgICAgaW4gc2NhbGUuIGh0dHBzOi8vZ2l0aHViLmNvbS9jaG1sbi9mbGF0cGlja3IvaXNzdWVzLzEwOTZcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUgJiYgaXNTYWZhcmkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblJlYWR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRUb0luc3RhbmNlKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZChzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRDYWxlbmRhcldpZHRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuY29uZmlnO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWVrTnVtYmVycyA9PT0gZmFsc2UgJiYgY29uZmlnLnNob3dNb250aHMgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLm5vQ2FsZW5kYXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXlzV2lkdGggPSAoc2VsZi5kYXlzLm9mZnNldFdpZHRoICsgMSkgKiBjb25maWcuc2hvd01vbnRocztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IGRheXNXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheXNXaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZWxmLndlZWtXcmFwcGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi53ZWVrV3JhcHBlci5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ2aXNpYmlsaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhhbmRsZXIgZm9yIGFsbCBldmVudHMgdGFyZ2V0aW5nIHRoZSB0aW1lIGlucHV0c1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGltZShlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNldERlZmF1bHRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gdW5kZWZpbmVkICYmIGUudHlwZSAhPT0gXCJibHVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aW1lV3JhcHBlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBzZWxmLl9pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dC52YWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYW1wbTJtaWxpdGFyeShob3VyLCBhbVBNKSB7XG4gICAgICAgICAgICByZXR1cm4gKGhvdXIgJSAxMikgKyAxMiAqIGludChhbVBNID09PSBzZWxmLmwxMG4uYW1QTVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWlsaXRhcnkyYW1wbShob3VyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGhvdXIgJSAyNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgJSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGhlIHNlbGVjdGVkIGRhdGUgb2JqZWN0IHRpbWUgd2l0aCB1c2VyJ3MgdGltZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnNGcm9tSW5wdXRzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCBzZWxmLm1pbnV0ZUVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG91cnMgPSAocGFyc2VJbnQoc2VsZi5ob3VyRWxlbWVudC52YWx1ZS5zbGljZSgtMiksIDEwKSB8fCAwKSAlIDI0LCBtaW51dGVzID0gKHBhcnNlSW50KHNlbGYubWludXRlRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjAsIHNlY29uZHMgPSBzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gKHBhcnNlSW50KHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjBcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBob3VycyA9IGFtcG0ybWlsaXRhcnkoaG91cnMsIHNlbGYuYW1QTS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGltaXRNaW5Ib3VycyA9IHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5taW5EYXRlLCB0cnVlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgdmFyIGxpbWl0TWF4SG91cnMgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5jb25maWcubWF4RGF0ZSwgdHJ1ZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIGlmIChsaW1pdE1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFRpbWUgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhUaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWluKGhvdXJzLCBtYXhUaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4VGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5taW4obWludXRlcywgbWF4VGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtYXhUaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWluKHNlY29uZHMsIG1heFRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdE1pbkhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblRpbWUgPSBzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5taW5UaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWluRGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5UaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluVGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5tYXgobWludXRlcywgbWluVGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtaW5UaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWF4KHNlY29uZHMsIG1pblRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGltZSBpbnB1dCB2YWx1ZXMgd2l0aCBhIGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEhvdXJzRnJvbURhdGUoZGF0ZU9iaikge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBkYXRlT2JqIHx8IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqO1xuICAgICAgICAgICAgaWYgKGRhdGUpXG4gICAgICAgICAgICAgICAgc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldERlZmF1bHRIb3VycygpIHtcbiAgICAgICAgICAgIHZhciBob3VycyA9IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0TWludXRlO1xuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0U2Vjb25kcztcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluX2hyID0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgIHZhciBtaW5fbWludXRlcyA9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5tYXgoaG91cnMsIG1pbl9ocik7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5faHIpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1heChtaW5fbWludXRlcywgbWludXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5faHIgJiYgbWludXRlcyA9PT0gbWluX21pbnV0ZXMpXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4X2hyID0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgIHZhciBtYXhfbWludXRlcyA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5taW4oaG91cnMsIG1heF9ocik7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhfaHIpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1pbihtYXhfbWludXRlcywgbWludXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhfaHIgJiYgbWludXRlcyA9PT0gbWF4X21pbnV0ZXMpXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaG91cnMsIG1pbnV0ZXMsIGFuZCBvcHRpb25hbGx5IHNlY29uZHNcbiAgICAgICAgICogb2YgdGhlIGxhdGVzdCBzZWxlY3RlZCBkYXRlIG9iamVjdCBhbmQgdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgdGltZSBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXJzIHRoZSBob3VyLiB3aGV0aGVyIGl0cyBtaWxpdGFyeVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgb3IgYW0tcG0gZ2V0cyBpbmZlcnJlZCBmcm9tIGNvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWludXRlcyB0aGUgbWludXRlc1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyB0aGUgc2Vjb25kcyAob3B0aW9uYWwpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZXRIb3Vycyhob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICAgICAgICAgICAgaWYgKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5zZXRIb3Vycyhob3VycyAlIDI0LCBtaW51dGVzLCBzZWNvbmRzIHx8IDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmhvdXJFbGVtZW50IHx8ICFzZWxmLm1pbnV0ZUVsZW1lbnQgfHwgc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnZhbHVlID0gcGFkKCFzZWxmLmNvbmZpZy50aW1lXzI0aHJcbiAgICAgICAgICAgICAgICA/ICgoMTIgKyBob3VycykgJSAxMikgKyAxMiAqIGludChob3VycyAlIDEyID09PSAwKVxuICAgICAgICAgICAgICAgIDogaG91cnMpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnZhbHVlID0gcGFkKG1pbnV0ZXMpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IHNlbGYubDEwbi5hbVBNW2ludChob3VycyA+PSAxMildO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSA9IHBhZChzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyB0aGUgeWVhciBpbnB1dCBhbmQgaW5jcmVtZW50aW5nIGV2ZW50c1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUga2V5dXAgb3IgaW5jcmVtZW50IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBvblllYXJJbnB1dChldmVudCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludChldmVudC50YXJnZXQudmFsdWUpICsgKGV2ZW50LmRlbHRhIHx8IDApO1xuICAgICAgICAgICAgaWYgKHllYXIgLyAxMDAwID4gMSB8fFxuICAgICAgICAgICAgICAgIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhL1teXFxkXS8udGVzdCh5ZWFyLnRvU3RyaW5nKCkpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoeWVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVzc2VudGlhbGx5IGFkZEV2ZW50TGlzdGVuZXIgKyB0cmFja2luZ1xuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gYWRkRXZlbnRMaXN0ZW5lciB0b1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgdGhlIGV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGV2KSB7IHJldHVybiBiaW5kKGVsZW1lbnQsIGV2LCBoYW5kbGVyLCBvcHRpb25zKTsgfSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBiaW5kKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7IH0pO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHNlbGYuX2hhbmRsZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbW91c2Vkb3duIGhhbmRsZXIgd2hpY2ggbWltaWNzIGNsaWNrLlxuICAgICAgICAgKiBNaW5pbWl6ZXMgbGF0ZW5jeSwgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB3YWl0IGZvciBtb3VzZXVwIGluIG1vc3QgY2FzZXMuXG4gICAgICAgICAqIEFsc28sIGF2b2lkcyBoYW5kbGluZyByaWdodCBjbGlja3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG9uQ2xpY2soaGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBldnQud2hpY2ggPT09IDEgJiYgaGFuZGxlcihldnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlKCkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLndyYXApIHtcbiAgICAgICAgICAgICAgICBbXCJvcGVuXCIsIFwiY2xvc2VcIiwgXCJ0b2dnbGVcIiwgXCJjbGVhclwiXS5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzZWxmLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLVwiICsgZXZ0ICsgXCJdXCIpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKGVsLCBcImNsaWNrXCIsIHNlbGZbZXZ0XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaXNNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICBzZXR1cE1vYmlsZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZWJvdW5jZWRSZXNpemUgPSBkZWJvdW5jZShvblJlc2l6ZSwgNTApO1xuICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlID0gZGVib3VuY2UodHJpZ2dlckNoYW5nZSwgREVCT1VOQ0VEX0NIQU5HRV9NUyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICYmICEvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG4gICAgICAgICAgICAgICAgYmluZChzZWxmLmRheXNDb250YWluZXIsIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlT3ZlcihlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudC5ib2R5LCBcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljKVxuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5pbmxpbmUgJiYgIXNlbGYuY29uZmlnLnN0YXRpYylcbiAgICAgICAgICAgICAgICBiaW5kKHdpbmRvdywgXCJyZXNpemVcIiwgZGVib3VuY2VkUmVzaXplKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cub250b3VjaHN0YXJ0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwiY2xpY2tcIiwgZG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soZG9jdW1lbnRDbGljaykpO1xuICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwiZm9jdXNcIiwgZG9jdW1lbnRDbGljaywgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNsaWNrT3BlbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuX2lucHV0LCBcImZvY3VzXCIsIHNlbGYub3Blbik7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJtb3VzZWRvd25cIiwgb25DbGljayhzZWxmLm9wZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5tb250aE5hdiwgXCJtb3VzZWRvd25cIiwgb25DbGljayhvbk1vbnRoTmF2Q2xpY2spKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYubW9udGhOYXYsIFtcImtleXVwXCIsIFwiaW5jcmVtZW50XCJdLCBvblllYXJJbnB1dCk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLmRheXNDb250YWluZXIsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soc2VsZWN0RGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYudGltZUNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsVGV4dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRhcmdldC5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBbXCJpbmNyZW1lbnRcIl0sIHVwZGF0ZVRpbWUpO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBcImJsdXJcIiwgdXBkYXRlVGltZSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHRpbWVJbmNyZW1lbnQpKTtcbiAgICAgICAgICAgICAgICBiaW5kKFtzZWxmLmhvdXJFbGVtZW50LCBzZWxmLm1pbnV0ZUVsZW1lbnRdLCBbXCJmb2N1c1wiLCBcImNsaWNrXCJdLCBzZWxUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWNvbmRFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5zZWNvbmRFbGVtZW50LCBcImZvY3VzXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuc2Vjb25kRWxlbWVudCAmJiBzZWxmLnNlY29uZEVsZW1lbnQuc2VsZWN0KCk7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kKHNlbGYuYW1QTSwgXCJtb3VzZWRvd25cIiwgb25DbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGltZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjYWxlbmRhciB2aWV3IHRvIGEgcGFydGljdWxhciBkYXRlLlxuICAgICAgICAgKiBAcGFyYW0ge0RhdGV9IGp1bXBEYXRlIHRoZSBkYXRlIHRvIHNldCB0aGUgdmlldyB0b1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24ganVtcFRvRGF0ZShqdW1wRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGp1bXBUbyA9IGp1bXBEYXRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHNlbGYucGFyc2VEYXRlKGp1bXBEYXRlKVxuICAgICAgICAgICAgICAgIDogc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgc2VsZi5jb25maWcubWluRGF0ZSA+IHNlbGYubm93XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJiBzZWxmLmNvbmZpZy5tYXhEYXRlIDwgc2VsZi5ub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYubm93KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1bXBUbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBqdW1wVG8uZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBqdW1wVG8uZ2V0TW9udGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gXCJJbnZhbGlkIGRhdGUgc3VwcGxpZWQ6IFwiICsganVtcFRvO1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cC9kb3duIGFycm93IGhhbmRsZXIgZm9yIHRpbWUgaW5wdXRzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGNsaWNrIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0aW1lSW5jcmVtZW50KGUpIHtcbiAgICAgICAgICAgIGlmICh+ZS50YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoXCJhcnJvd1wiKSlcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnROdW1JbnB1dChlLCBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcnJvd1VwXCIpID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5jcmVtZW50cy9kZWNyZW1lbnRzIHRoZSB2YWx1ZSBvZiBpbnB1dCBhc3NvY2ktXG4gICAgICAgICAqIGF0ZWQgd2l0aCB0aGUgdXAvZG93biBhcnJvdyBieSBkaXNwYXRjaGluZyBhblxuICAgICAgICAgKiBcImluY3JlbWVudFwiIGV2ZW50IG9uIHRoZSBpbnB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIHRoZSBkaWZmICh1c3VhbGx5IDEgb3IgLTEpXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gaW5wdXRFbGVtIHRoZSBpbnB1dCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpbmNyZW1lbnROdW1JbnB1dChlLCBkZWx0YSwgaW5wdXRFbGVtKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZSAmJiBlLnRhcmdldDtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0RWxlbSB8fFxuICAgICAgICAgICAgICAgICh0YXJnZXQgJiYgdGFyZ2V0LnBhcmVudE5vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVFdmVudChcImluY3JlbWVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmRlbHRhID0gZGVsdGE7XG4gICAgICAgICAgICBpbnB1dCAmJiBpbnB1dC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1jYWxlbmRhclwiKTtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcubm9DYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGJ1aWxkTW9udGhOYXYoKSk7XG4gICAgICAgICAgICAgICAgc2VsZi5pbm5lckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItaW5uZXJDb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLndlZWtOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGJ1aWxkV2Vla3MoKSwgd2Vla1dyYXBwZXIgPSBfYS53ZWVrV3JhcHBlciwgd2Vla051bWJlcnMgPSBfYS53ZWVrTnVtYmVycztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZCh3ZWVrV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYud2Vla051bWJlcnMgPSB3ZWVrTnVtYmVycztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53ZWVrV3JhcHBlciA9IHdlZWtXcmFwcGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXJDb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5yQ29udGFpbmVyLmFwcGVuZENoaWxkKGJ1aWxkV2Vla2RheXMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmRheXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1kYXlzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5yQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuZGF5c0NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgc2VsZi5pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLnJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHNlbGYuaW5uZXJDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChidWlsZFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInJhbmdlTW9kZVwiLCBzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhbmltYXRlXCIsIHNlbGYuY29uZmlnLmFuaW1hdGUgPT09IHRydWUpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJtdWx0aU1vbnRoXCIsIHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxKTtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUFwcGVuZCA9IHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hcHBlbmRUby5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSB8fCBzZWxmLmNvbmZpZy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoc2VsZi5jb25maWcuaW5saW5lID8gXCJpbmxpbmVcIiA6IFwic3RhdGljXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b21BcHBlbmQgJiYgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgc2VsZi5faW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuYXBwZW5kVG8uYXBwZW5kQ2hpbGQoc2VsZi5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdyYXBwZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBzZWxmLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmFsdElucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLnN0YXRpYyAmJiAhc2VsZi5jb25maWcuaW5saW5lKVxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuYXBwZW5kVG9cbiAgICAgICAgICAgICAgICAgICAgOiB3aW5kb3cuZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2VsZi5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGF5KGNsYXNzTmFtZSwgZGF0ZSwgZGF5TnVtYmVyLCBpKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUlzRW5hYmxlZCA9IGlzRW5hYmxlZChkYXRlLCB0cnVlKSwgZGF5RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWRheSBcIiArIGNsYXNzTmFtZSwgZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBkYXlFbGVtZW50LmRhdGVPYmogPSBkYXRlO1xuICAgICAgICAgICAgZGF5RWxlbWVudC4kaSA9IGk7XG4gICAgICAgICAgICBkYXlFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc2VsZi5mb3JtYXREYXRlKGRhdGUsIHNlbGYuY29uZmlnLmFyaWFEYXRlRm9ybWF0KSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYubm93KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYudG9kYXlEYXRlRWxlbSA9IGRheUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwidG9kYXlcIik7XG4gICAgICAgICAgICAgICAgZGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJkYXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVJc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZVNlbGVjdGVkKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gPSBkYXlFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhkYXlFbGVtZW50LCBcInN0YXJ0UmFuZ2VcIiwgc2VsZi5zZWxlY3RlZERhdGVzWzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdHJ1ZSkgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZGF5RWxlbWVudCwgXCJlbmRSYW5nZVwiLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzFdLCB0cnVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09PSBcIm5leHRNb250aERheVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlSW5SYW5nZShkYXRlKSAmJiAhaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycyAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgIT09IFwicHJldk1vbnRoRGF5XCIgJiZcbiAgICAgICAgICAgICAgICBkYXlOdW1iZXIgJSA3ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCI8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLWRheSc+XCIgKyBzZWxmLmNvbmZpZy5nZXRXZWVrKGRhdGUpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25EYXlDcmVhdGVcIiwgZGF5RWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb2N1c09uRGF5RWxlbSh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZpcnN0QXZhaWxhYmxlRGF5KGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRNb250aCA9IGRlbHRhID4gMCA/IDAgOiBzZWxmLmNvbmZpZy5zaG93TW9udGhzIC0gMTtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBzdGFydE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gZGVsdGEgPiAwID8gMCA6IG1vbnRoLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gZGVsdGEgPiAwID8gbW9udGguY2hpbGRyZW4ubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgKz0gZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtb250aC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmIGlzRW5hYmxlZChjLmRhdGVPYmopKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0QXZhaWxhYmxlRGF5KGN1cnJlbnQsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZ2l2ZW5Nb250aCA9IGN1cnJlbnQuY2xhc3NOYW1lLmluZGV4T2YoXCJNb250aFwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQuZGF0ZU9iai5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIHZhciBsb29wRGVsdGEgPSBkZWx0YSA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gZ2l2ZW5Nb250aCAtIHNlbGYuY3VycmVudE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGdpdmVuTW9udGggLSBzZWxmLmN1cnJlbnRNb250aCA9PT0gbVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQuJGkgKyBkZWx0YVxuICAgICAgICAgICAgICAgICAgICA6IGRlbHRhIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtb250aC5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIG51bU1vbnRoRGF5cyA9IG1vbnRoLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA+PSAwICYmIGkgPCBudW1Nb250aERheXMgJiYgaSAhPSAoZGVsdGEgPiAwID8gbnVtTW9udGhEYXlzIDogLTEpOyBpICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1vbnRoLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5hYmxlZChjLmRhdGVPYmopICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhjdXJyZW50LiRpIC0gaSkgPj0gTWF0aC5hYnMoZGVsdGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY2hhbmdlTW9udGgobG9vcERlbHRhKTtcbiAgICAgICAgICAgIGZvY3VzT25EYXkoZ2V0Rmlyc3RBdmFpbGFibGVEYXkobG9vcERlbHRhKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzT25EYXkoY3VycmVudCwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgZGF5Rm9jdXNlZCA9IGlzSW5WaWV3KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbGVtID0gY3VycmVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50XG4gICAgICAgICAgICAgICAgOiBkYXlGb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYuc2VsZWN0ZWREYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5zZWxlY3RlZERhdGVFbGVtXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYudG9kYXlEYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYudG9kYXlEYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYudG9kYXlEYXRlRWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0Rmlyc3RBdmFpbGFibGVEYXkob2Zmc2V0ID4gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRFbGVtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoIWRheUZvY3VzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKHN0YXJ0RWxlbSk7XG4gICAgICAgICAgICBnZXROZXh0QXZhaWxhYmxlRGF5KHN0YXJ0RWxlbSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoRGF5cyh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0T2ZNb250aCA9IChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0RGF5KCkgLSBzZWxmLmwxMG4uZmlyc3REYXlPZldlZWsgKyA3KSAlIDc7XG4gICAgICAgICAgICB2YXIgcHJldk1vbnRoRGF5cyA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgoKG1vbnRoIC0gMSArIDEyKSAlIDEyKTtcbiAgICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgobW9udGgpLCBkYXlzID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgaXNNdWx0aU1vbnRoID0gc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEsIHByZXZNb250aERheUNsYXNzID0gaXNNdWx0aU1vbnRoID8gXCJwcmV2TW9udGhEYXkgaGlkZGVuXCIgOiBcInByZXZNb250aERheVwiLCBuZXh0TW9udGhEYXlDbGFzcyA9IGlzTXVsdGlNb250aCA/IFwibmV4dE1vbnRoRGF5IGhpZGRlblwiIDogXCJuZXh0TW9udGhEYXlcIjtcbiAgICAgICAgICAgIHZhciBkYXlOdW1iZXIgPSBwcmV2TW9udGhEYXlzICsgMSAtIGZpcnN0T2ZNb250aCwgZGF5SW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gcHJlcGVuZCBkYXlzIGZyb20gdGhlIGVuZGluZyBvZiBwcmV2aW91cyBtb250aFxuICAgICAgICAgICAgZm9yICg7IGRheU51bWJlciA8PSBwcmV2TW9udGhEYXlzOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KHByZXZNb250aERheUNsYXNzLCBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGF0IDEgc2luY2UgdGhlcmUgaXMgbm8gMHRoIGRheVxuICAgICAgICAgICAgZm9yIChkYXlOdW1iZXIgPSAxOyBkYXlOdW1iZXIgPD0gZGF5c0luTW9udGg7IGRheU51bWJlcisrLCBkYXlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkoXCJcIiwgbmV3IERhdGUoeWVhciwgbW9udGgsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCBkYXlzIGZyb20gdGhlIG5leHQgbW9udGhcbiAgICAgICAgICAgIGZvciAodmFyIGRheU51bSA9IGRheXNJbk1vbnRoICsgMTsgZGF5TnVtIDw9IDQyIC0gZmlyc3RPZk1vbnRoICYmXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgfHwgZGF5SW5kZXggJSA3ICE9PSAwKTsgZGF5TnVtKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShuZXh0TW9udGhEYXlDbGFzcywgbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCBkYXlOdW0gJSBkYXlzSW5Nb250aCksIGRheU51bSwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgdmFyIGRheUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJkYXlDb250YWluZXJcIik7XG4gICAgICAgICAgICBkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkRGF5cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICAgICAgLy8gVE9ETzogd2VlayBudW1iZXJzIGZvciBlYWNoIG1vbnRoXG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycylcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrTnVtYmVycyk7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgMSk7XG4gICAgICAgICAgICAgICAgZC5zZXRNb250aChzZWxmLmN1cnJlbnRNb250aCArIGkpO1xuICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoYnVpbGRNb250aERheXMoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgIHNlbGYuZGF5cyA9IHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJiBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItbW9udGhcIik7XG4gICAgICAgICAgICB2YXIgbW9udGhOYXZGcmFnbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB2YXIgbW9udGhFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJjdXItbW9udGhcIik7XG4gICAgICAgICAgICB2YXIgeWVhcklucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJjdXIteWVhclwiLCB7IHRhYmluZGV4OiBcIi0xXCIgfSk7XG4gICAgICAgICAgICB2YXIgeWVhckVsZW1lbnQgPSB5ZWFySW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc2VsZi5sMTBuLnllYXJBcmlhTGFiZWwpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtaW5cIiwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUpIHtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LmRpc2FibGVkID1cbiAgICAgICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50TW9udGggPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWN1cnJlbnQtbW9udGhcIik7XG4gICAgICAgICAgICBjdXJyZW50TW9udGguYXBwZW5kQ2hpbGQobW9udGhFbGVtZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRNb250aC5hcHBlbmRDaGlsZCh5ZWFySW5wdXQpO1xuICAgICAgICAgICAgbW9udGhOYXZGcmFnbWVudC5hcHBlbmRDaGlsZChjdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1vbnRoTmF2RnJhZ21lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudDogeWVhckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbW9udGhFbGVtZW50OiBtb250aEVsZW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aHMoKSB7XG4gICAgICAgICAgICBjbGVhck5vZGUoc2VsZi5tb250aE5hdik7XG4gICAgICAgICAgICBzZWxmLm1vbnRoTmF2LmFwcGVuZENoaWxkKHNlbGYucHJldk1vbnRoTmF2KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zaG93TW9udGhzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBtLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gYnVpbGRNb250aCgpO1xuICAgICAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzLnB1c2gobW9udGgueWVhckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50cy5wdXNoKG1vbnRoLm1vbnRoRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChtb250aC5jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChzZWxmLm5leHRNb250aE5hdik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aE5hdigpIHtcbiAgICAgICAgICAgIHNlbGYubW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLW1vbnRoc1wiKTtcbiAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzID0gW107XG4gICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYucHJldk1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItcHJldi1tb250aFwiKTtcbiAgICAgICAgICAgIHNlbGYucHJldk1vbnRoTmF2LmlubmVySFRNTCA9IHNlbGYuY29uZmlnLnByZXZBcnJvdztcbiAgICAgICAgICAgIHNlbGYubmV4dE1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItbmV4dC1tb250aFwiKTtcbiAgICAgICAgICAgIHNlbGYubmV4dE1vbnRoTmF2LmlubmVySFRNTCA9IHNlbGYuY29uZmlnLm5leHRBcnJvdztcbiAgICAgICAgICAgIGJ1aWxkTW9udGhzKCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJfaGlkZVByZXZNb250aEFycm93XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3c7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdyAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5wcmV2TW9udGhOYXYsIFwiZGlzYWJsZWRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9faGlkZVByZXZNb250aEFycm93ID0gYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLl9faGlkZU5leHRNb250aEFycm93OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3cgIT09IGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYubmV4dE1vbnRoTmF2LCBcImRpc2FibGVkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdyA9IGJvb2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50ID0gc2VsZi55ZWFyRWxlbWVudHNbMF07XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5tb250aE5hdjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFRpbWUoKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNUaW1lXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9DYWxlbmRhclwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItdGltZVwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKTtcbiAgICAgICAgICAgIHZhciBob3VySW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1ob3VyXCIpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCA9IGhvdXJJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZUlucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3ItbWludXRlXCIpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50ID0gbWludXRlSW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudGFiSW5kZXggPSBzZWxmLm1pbnV0ZUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldEhvdXJzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLnRpbWVfMjRoclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyXG4gICAgICAgICAgICAgICAgICAgIDogbWlsaXRhcnkyYW1wbShzZWxmLmNvbmZpZy5kZWZhdWx0SG91cikpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRNaW51dGVzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRlZmF1bHRNaW51dGUpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYuY29uZmlnLmhvdXJJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3RlcFwiLCBzZWxmLmNvbmZpZy5taW51dGVJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyBcIjBcIiA6IFwiMVwiKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMjNcIiA6IFwiMTJcIik7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCI1OVwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChob3VySW5wdXQpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQobWludXRlSW5wdXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRpbWVfMjRocilcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRpbWUyNGhyXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1NlY29uZHNcIik7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZElucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3Itc2Vjb25kXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudCA9IHNlY29uZElucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0U2Vjb25kcygpXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHMpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYubWludXRlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIFwiNTlcIik7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKSk7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlY29uZElucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcudGltZV8yNGhyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHNlbGYuYW1QTSBpZiBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgIHNlbGYuYW1QTSA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWFtLXBtXCIsIHNlbGYubDEwbi5hbVBNW2ludCgoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmhvdXJFbGVtZW50LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdEhvdXIpID4gMTEpXSk7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRpdGxlID0gc2VsZi5sMTBuLnRvZ2dsZVRpdGxlO1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmFtUE0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYudGltZUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFdlZWtkYXlzKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLndlZWtkYXlDb250YWluZXIpXG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5c1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrZGF5Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla2RheWNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVdlZWtkYXlzKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi53ZWVrZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdlZWtkYXlzKCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gc2VsZi5sMTBuLmZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICAgICAgdmFyIHdlZWtkYXlzID0gc2VsZi5sMTBuLndlZWtkYXlzLnNob3J0aGFuZC5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0RGF5T2ZXZWVrID4gMCAmJiBmaXJzdERheU9mV2VlayA8IHdlZWtkYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlzID0gd2Vla2RheXMuc3BsaWNlKGZpcnN0RGF5T2ZXZWVrLCB3ZWVrZGF5cy5sZW5ndGgpLmNvbmNhdCh3ZWVrZGF5cy5zcGxpY2UoMCwgZmlyc3REYXlPZldlZWspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyLmNoaWxkcmVuW2ldLmlubmVySFRNTCA9IFwiXFxuICAgICAgPHNwYW4gY2xhc3M9J2ZsYXRwaWNrci13ZWVrZGF5Jz5cXG4gICAgICAgIFwiICsgd2Vla2RheXMuam9pbihcIjwvc3Bhbj48c3BhbiBjbGFzcz0nZmxhdHBpY2tyLXdlZWtkYXknPlwiKSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICAgIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkV2Vla3MoKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNXZWVrc1wiKTtcbiAgICAgICAgICAgIHZhciB3ZWVrV3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla3dyYXBwZXJcIik7XG4gICAgICAgICAgICB3ZWVrV3JhcHBlci5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci13ZWVrZGF5XCIsIHNlbGYubDEwbi53ZWVrQWJicmV2aWF0aW9uKSk7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlcnMgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtzXCIpO1xuICAgICAgICAgICAgd2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQod2Vla051bWJlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3ZWVrV3JhcHBlcjogd2Vla1dyYXBwZXIsXG4gICAgICAgICAgICAgICAgd2Vla051bWJlcnM6IHdlZWtOdW1iZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZU1vbnRoKHZhbHVlLCBpc19vZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChpc19vZmZzZXQgPT09IHZvaWQgMCkgeyBpc19vZmZzZXQgPSB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBpc19vZmZzZXQgPyB2YWx1ZSA6IHZhbHVlIC0gc2VsZi5jdXJyZW50TW9udGg7XG4gICAgICAgICAgICBpZiAoKGRlbHRhIDwgMCAmJiBzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgPT09IHRydWUpIHx8XG4gICAgICAgICAgICAgICAgKGRlbHRhID4gMCAmJiBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPT09IHRydWUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoICs9IGRlbHRhO1xuICAgICAgICAgICAgaWYgKHNlbGYuY3VycmVudE1vbnRoIDwgMCB8fCBzZWxmLmN1cnJlbnRNb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciArPSBzZWxmLmN1cnJlbnRNb250aCA+IDExID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gKHNlbGYuY3VycmVudE1vbnRoICsgMTIpICUgMTI7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyKHRyaWdnZXJDaGFuZ2VFdmVudCwgdG9Jbml0aWFsKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50ID09PSB2b2lkIDApIHsgdHJpZ2dlckNoYW5nZUV2ZW50ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRvSW5pdGlhbCA9PT0gdm9pZCAwKSB7IHRvSW5pdGlhbCA9IHRydWU7IH1cbiAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRvSW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gc2VsZi5faW5pdGlhbERhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZXREZWZhdWx0SG91cnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KVxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJDaGFuZ2VFdmVudCBpcyB0cnVlIChkZWZhdWx0KSBvciBhbiBFdmVudFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkRlc3Ryb3lcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5faGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBzZWxmLl9oYW5kbGVyc1tpXTtcbiAgICAgICAgICAgICAgICBoLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoLmV2ZW50LCBoLmhhbmRsZXIsIGgub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5tb2JpbGVJbnB1dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgJiYgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYyAmJiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIubGFzdENoaWxkICYmIHdyYXBwZXIucmVtb3ZlQ2hpbGQod3JhcHBlci5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlci5maXJzdENoaWxkLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmFsdElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBzZWxmLmlucHV0Ll90eXBlO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiX3Nob3dUaW1lSW5wdXRcIixcbiAgICAgICAgICAgICAgICBcImxhdGVzdFNlbGVjdGVkRGF0ZU9ialwiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX19oaWRlTmV4dE1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcIl9faGlkZVByZXZNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJpc01vYmlsZVwiLFxuICAgICAgICAgICAgICAgIFwiaXNPcGVuXCIsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RlZERhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJtaW5EYXRlSGFzVGltZVwiLFxuICAgICAgICAgICAgICAgIFwibWF4RGF0ZUhhc1RpbWVcIixcbiAgICAgICAgICAgICAgICBcImRheXNcIixcbiAgICAgICAgICAgICAgICBcImRheXNDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIl9pbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwiX3Bvc2l0aW9uRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwiaW5uZXJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcInJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIm1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJ0b2RheURhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJjYWxlbmRhckNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwid2Vla2RheUNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwicHJldk1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0TW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRNb250aEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRZZWFyRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwibmF2aWdhdGlvbkN1cnJlbnRNb250aFwiLFxuICAgICAgICAgICAgICAgIFwic2VsZWN0ZWREYXRlRWxlbVwiLFxuICAgICAgICAgICAgICAgIFwiY29uZmlnXCIsXG4gICAgICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZltrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNDYWxlbmRhckVsZW0oZWxlbSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFwcGVuZFRvICYmIHNlbGYuY29uZmlnLmFwcGVuZFRvLmNvbnRhaW5zKGVsZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY29udGFpbnMoZWxlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRDbGljayhlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc09wZW4gJiYgIXNlbGYuY29uZmlnLmlubGluZSkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFRhcmdldF8xID0gZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ2FsZW5kYXJFbGVtZW50ID0gaXNDYWxlbmRhckVsZW0oZXZlbnRUYXJnZXRfMSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5wdXQgPSBldmVudFRhcmdldF8xID09PSBzZWxmLmlucHV0IHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0XzEgPT09IHNlbGYuYWx0SW5wdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LmNvbnRhaW5zKGV2ZW50VGFyZ2V0XzEpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlYiBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGUucGF0aCBpcyBub3QgcHJlc2VudCBpbiBhbGwgYnJvd3NlcnMuIGNpcmN1bXZlbnRpbmcgdHlwZWNoZWNrc1xuICAgICAgICAgICAgICAgICAgICAoZS5wYXRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnBhdGguaW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKH5lLnBhdGguaW5kZXhPZihzZWxmLmlucHV0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5lLnBhdGguaW5kZXhPZihzZWxmLmFsdElucHV0KSkpO1xuICAgICAgICAgICAgICAgIHZhciBsb3N0Rm9jdXMgPSBlLnR5cGUgPT09IFwiYmx1clwiXG4gICAgICAgICAgICAgICAgICAgID8gaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICA6ICFpc0lucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc0NhbGVuZGFyRWxlbShlLnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpc0lnbm9yZWQgPSAhc2VsZi5jb25maWcuaWdub3JlZEZvY3VzRWxlbWVudHMuc29tZShmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5jb250YWlucyhldmVudFRhcmdldF8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobG9zdEZvY3VzICYmIGlzSWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIgJiYgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZVllYXIobmV3WWVhcikge1xuICAgICAgICAgICAgaWYgKCFuZXdZZWFyIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgbmV3WWVhciA8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSkgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJiBuZXdZZWFyID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbmV3WWVhck51bSA9IG5ld1llYXIsIGlzTmV3WWVhciA9IHNlbGYuY3VycmVudFllYXIgIT09IG5ld1llYXJOdW07XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0gbmV3WWVhck51bSB8fCBzZWxmLmN1cnJlbnRZZWFyO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IE1hdGgubWluKHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKSwgc2VsZi5jdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gTWF0aC5tYXgoc2VsZi5jb25maWcubWluRGF0ZS5nZXRNb250aCgpLCBzZWxmLmN1cnJlbnRNb250aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZXdZZWFyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKGRhdGUsIHRpbWVsZXNzKSB7XG4gICAgICAgICAgICBpZiAodGltZWxlc3MgPT09IHZvaWQgMCkgeyB0aW1lbGVzcyA9IHRydWU7IH1cbiAgICAgICAgICAgIHZhciBkYXRlVG9DaGVjayA9IHNlbGYucGFyc2VEYXRlKGRhdGUsIHVuZGVmaW5lZCwgdGltZWxlc3MpOyAvLyB0aW1lbGVzc1xuICAgICAgICAgICAgaWYgKChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2sgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZVRvQ2hlY2ssIHNlbGYuY29uZmlnLm1pbkRhdGUsIHRpbWVsZXNzICE9PSB1bmRlZmluZWQgPyB0aW1lbGVzcyA6ICFzZWxmLm1pbkRhdGVIYXNUaW1lKSA8IDApIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGVUb0NoZWNrLCBzZWxmLmNvbmZpZy5tYXhEYXRlLCB0aW1lbGVzcyAhPT0gdW5kZWZpbmVkID8gdGltZWxlc3MgOiAhc2VsZi5tYXhEYXRlSGFzVGltZSkgPiAwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlLmxlbmd0aCA9PT0gMCAmJiBzZWxmLmNvbmZpZy5kaXNhYmxlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkYXRlVG9DaGVjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBib29sID0gc2VsZi5jb25maWcuZW5hYmxlLmxlbmd0aCA+IDAsIGFycmF5ID0gYm9vbCA/IHNlbGYuY29uZmlnLmVuYWJsZSA6IHNlbGYuY29uZmlnLmRpc2FibGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZCA9IHZvaWQgMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZCA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIGQoZGF0ZVRvQ2hlY2spIC8vIGRpc2FibGVkIGJ5IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0VGltZSgpID09PSBkYXRlVG9DaGVjay5nZXRUaW1lKCkpXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIGJ5IGRhdGVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09IFwic3RyaW5nXCIgJiYgZGF0ZVRvQ2hlY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCBieSBkYXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gc2VsZi5wYXJzZURhdGUoZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZCAmJiBwYXJzZWQuZ2V0VGltZSgpID09PSBkYXRlVG9DaGVjay5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYm9vbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAhYm9vbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnkgcmFuZ2VcbiAgICAgICAgICAgICAgICB0eXBlb2YgZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGQuZnJvbSAmJlxuICAgICAgICAgICAgICAgICAgICBkLnRvICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrLmdldFRpbWUoKSA+PSBkLmZyb20uZ2V0VGltZSgpICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrLmdldFRpbWUoKSA8PSBkLnRvLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIWJvb2w7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNJblZpZXcoZWxlbSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAoZWxlbS5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLmNvbnRhaW5zKGVsZW0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgICAgICAgLy8gZS5rZXkgICAgICAgICAgICAgICAgICAgICAgZS5rZXlDb2RlXG4gICAgICAgICAgICAvLyBcIkJhY2tzcGFjZVwiICAgICAgICAgICAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgLy8gXCJUYWJcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDlcbiAgICAgICAgICAgIC8vIFwiRW50ZXJcIiAgICAgICAgICAgICAgICAgICAgICAgICAgIDEzXG4gICAgICAgICAgICAvLyBcIkVzY2FwZVwiICAgICAoSUUgXCJFc2NcIikgICAgICAgICAgIDI3XG4gICAgICAgICAgICAvLyBcIkFycm93TGVmdFwiICAoSUUgXCJMZWZ0XCIpICAgICAgICAgIDM3XG4gICAgICAgICAgICAvLyBcIkFycm93VXBcIiAgICAoSUUgXCJVcFwiKSAgICAgICAgICAgIDM4XG4gICAgICAgICAgICAvLyBcIkFycm93UmlnaHRcIiAoSUUgXCJSaWdodFwiKSAgICAgICAgIDM5XG4gICAgICAgICAgICAvLyBcIkFycm93RG93blwiICAoSUUgXCJEb3duXCIpICAgICAgICAgIDQwXG4gICAgICAgICAgICAvLyBcIkRlbGV0ZVwiICAgICAoSUUgXCJEZWxcIikgICAgICAgICAgIDQ2XG4gICAgICAgICAgICB2YXIgaXNJbnB1dCA9IGUudGFyZ2V0ID09PSBzZWxmLl9pbnB1dDtcbiAgICAgICAgICAgIHZhciBhbGxvd0lucHV0ID0gc2VsZi5jb25maWcuYWxsb3dJbnB1dDtcbiAgICAgICAgICAgIHZhciBhbGxvd0tleWRvd24gPSBzZWxmLmlzT3BlbiAmJiAoIWFsbG93SW5wdXQgfHwgIWlzSW5wdXQpO1xuICAgICAgICAgICAgdmFyIGFsbG93SW5saW5lS2V5ZG93biA9IHNlbGYuY29uZmlnLmlubGluZSAmJiBpc0lucHV0ICYmICFhbGxvd0lucHV0O1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShzZWxmLl9pbnB1dC52YWx1ZSwgdHJ1ZSwgZS50YXJnZXQgPT09IHNlbGYuYWx0SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuYWx0Rm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50YXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDYWxlbmRhckVsZW0oZS50YXJnZXQpIHx8XG4gICAgICAgICAgICAgICAgYWxsb3dLZXlkb3duIHx8XG4gICAgICAgICAgICAgICAgYWxsb3dJbmxpbmVLZXlkb3duKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVGltZU9iaiA9ICEhc2VsZi50aW1lQ29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdERhdGUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5wdXQgJiYgIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93SW5wdXQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBpc0luVmlldyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YV8xID0gZS5rZXlDb2RlID09PSAzOSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmN0cmxLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KHVuZGVmaW5lZCwgZGVsdGFfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZU1vbnRoKGRlbHRhXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmhvdXJFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZS5rZXlDb2RlID09PSA0MCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2VsZi5kYXlzQ29udGFpbmVyICYmIGUudGFyZ2V0LiRpICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgPT09IHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciAtIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1RpbWVPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkodW5kZWZpbmVkLCBkZWx0YSAqIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lT2JqICYmIHNlbGYuaG91ckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZWxlbXMuaW5kZXhPZihlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlbGVtc1tpICsgKGUuc2hpZnRLZXkgPyAtMSA6IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQgJiYgZS50YXJnZXQgPT09IHNlbGYuYW1QTSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVswXS5jaGFyQXQoMCk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMF0uY2hhckF0KDApLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzFdLmNoYXJBdCgwKTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IHNlbGYubDEwbi5hbVBNWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25LZXlEb3duXCIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VPdmVyKGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgKGVsZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgKCFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG92ZXJEYXRlID0gZWxlbVxuICAgICAgICAgICAgICAgID8gZWxlbS5kYXRlT2JqLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgIDogc2VsZi5kYXlzLmZpcnN0RWxlbWVudENoaWxkLmRhdGVPYmouZ2V0VGltZSgpLCBpbml0aWFsRGF0ZSA9IHNlbGYucGFyc2VEYXRlKHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdW5kZWZpbmVkLCB0cnVlKS5nZXRUaW1lKCksIHJhbmdlU3RhcnREYXRlID0gTWF0aC5taW4oaG92ZXJEYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKSwgcmFuZ2VFbmREYXRlID0gTWF0aC5tYXgoaG92ZXJEYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKSwgbGFzdERhdGUgPSBzZWxmLmRheXNDb250YWluZXIubGFzdENoaWxkXG4gICAgICAgICAgICAgICAgLmxhc3RDaGlsZC5kYXRlT2JqLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBjb250YWluc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbWluUmFuZ2UgPSAwLCBtYXhSYW5nZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gcmFuZ2VTdGFydERhdGU7IHQgPCBsYXN0RGF0ZTsgdCArPSBkdXJhdGlvbi5EQVkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW5hYmxlZChuZXcgRGF0ZSh0KSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc0Rpc2FibGVkIHx8ICh0ID4gcmFuZ2VTdGFydERhdGUgJiYgdCA8IHJhbmdlRW5kRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgaW5pdGlhbERhdGUgJiYgKCFtaW5SYW5nZSB8fCB0ID4gbWluUmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluUmFuZ2UgPSB0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID4gaW5pdGlhbERhdGUgJiYgKCFtYXhSYW5nZSB8fCB0IDwgbWF4UmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UmFuZ2UgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgbSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2TW9udGggPSBzZWxmLmRheXNDb250YWluZXIuY2hpbGRyZW5bbSAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGksIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRheUVsZW0gPSBtb250aC5jaGlsZHJlbltpXSwgZGF0ZSA9IGRheUVsZW0uZGF0ZU9iajtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0T2ZSYW5nZSA9IChtaW5SYW5nZSA+IDAgJiYgdGltZXN0YW1wIDwgbWluUmFuZ2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobWF4UmFuZ2UgPiAwICYmIHRpbWVzdGFtcCA+IG1heFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dE9mUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcIm5vdEFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJpblJhbmdlXCIsIFwic3RhcnRSYW5nZVwiLCBcImVuZFJhbmdlXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnNEaXNhYmxlZCAmJiAhb3V0T2ZSYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIFtcInN0YXJ0UmFuZ2VcIiwgXCJpblJhbmdlXCIsIFwiZW5kUmFuZ2VcIiwgXCJub3RBbGxvd2VkXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChob3ZlckRhdGUgPCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInN0YXJ0UmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJlbmRSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb250aC5jb250YWlucyhlbGVtKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEobSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldk1vbnRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZNb250aC5sYXN0Q2hpbGQuZGF0ZU9iai5nZXRUaW1lKCkgPj0gdGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRGF0ZSA8IGhvdmVyRGF0ZSAmJiB0aW1lc3RhbXAgPT09IGluaXRpYWxEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJzdGFydFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluaXRpYWxEYXRlID4gaG92ZXJEYXRlICYmIHRpbWVzdGFtcCA9PT0gaW5pdGlhbERhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImVuZFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbWluUmFuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1heFJhbmdlID09PSAwIHx8IHRpbWVzdGFtcCA8PSBtYXhSYW5nZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNCZXR3ZWVuKHRpbWVzdGFtcCwgaW5pdGlhbERhdGUsIGhvdmVyRGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbW9udGguY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoaSwgbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgIXNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0RGVmYXVsdFRpbWUoKSB7XG4gICAgICAgICAgICBzZWxmLnNldERhdGUoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShzZWxmLmNvbmZpZy5taW5EYXRlLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKCksIGZhbHNlKTtcbiAgICAgICAgICAgIHNldERlZmF1bHRIb3VycygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvcGVuKGUsIHBvc2l0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uRWxlbWVudCA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uRWxlbWVudCA9IHNlbGYuX3Bvc2l0aW9uRWxlbWVudDsgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaXNNb2JpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0ICYmIGUudGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25PcGVuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dC5kaXNhYmxlZCB8fCBzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHdhc09wZW4gPSBzZWxmLmlzT3BlbjtcbiAgICAgICAgICAgIHNlbGYuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghd2FzT3Blbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk9wZW5cIik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25DYWxlbmRhcihwb3NpdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUgJiYgc2VsZi5jb25maWcubm9DYWxlbmRhciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERlZmF1bHRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbGxvd0lucHV0ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAoZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5ob3VyRWxlbWVudC5zZWxlY3QoKTsgfSwgNTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtaW5NYXhEYXRlU2V0dGVyKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlT2JqID0gKHNlbGYuY29uZmlnW1wiX1wiICsgdHlwZSArIFwiRGF0ZVwiXSA9IHNlbGYucGFyc2VEYXRlKGRhdGUsIHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpKTtcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJzZURhdGVPYmogPSBzZWxmLmNvbmZpZ1tcIl9cIiArICh0eXBlID09PSBcIm1pblwiID8gXCJtYXhcIiA6IFwibWluXCIpICsgXCJEYXRlXCJdO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZlt0eXBlID09PSBcIm1pblwiID8gXCJtaW5EYXRlSGFzVGltZVwiIDogXCJtYXhEYXRlSGFzVGltZVwiXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iai5nZXRNaW51dGVzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iai5nZXRTZWNvbmRzKCkgPiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IHNlbGYuc2VsZWN0ZWREYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGlzRW5hYmxlZChkKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCAmJiB0eXBlID09PSBcIm1pblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tRGF0ZShkYXRlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVPYmogIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50W3R5cGVdID0gZGF0ZU9iai5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQuZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgISFpbnZlcnNlRGF0ZU9iaiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmogIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVyc2VEYXRlT2JqLmdldEZ1bGxZZWFyKCkgPT09IGRhdGVPYmouZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlQ29uZmlnKCkge1xuICAgICAgICAgICAgdmFyIGJvb2xPcHRzID0gW1xuICAgICAgICAgICAgICAgIFwid3JhcFwiLFxuICAgICAgICAgICAgICAgIFwid2Vla051bWJlcnNcIixcbiAgICAgICAgICAgICAgICBcImFsbG93SW5wdXRcIixcbiAgICAgICAgICAgICAgICBcImNsaWNrT3BlbnNcIixcbiAgICAgICAgICAgICAgICBcInRpbWVfMjRoclwiLFxuICAgICAgICAgICAgICAgIFwiZW5hYmxlVGltZVwiLFxuICAgICAgICAgICAgICAgIFwibm9DYWxlbmRhclwiLFxuICAgICAgICAgICAgICAgIFwiYWx0SW5wdXRcIixcbiAgICAgICAgICAgICAgICBcInNob3J0aGFuZEN1cnJlbnRNb250aFwiLFxuICAgICAgICAgICAgICAgIFwiaW5saW5lXCIsXG4gICAgICAgICAgICAgICAgXCJzdGF0aWNcIixcbiAgICAgICAgICAgICAgICBcImVuYWJsZVNlY29uZHNcIixcbiAgICAgICAgICAgICAgICBcImRpc2FibGVNb2JpbGVcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgdXNlckNvbmZpZyA9IF9fYXNzaWduKHt9LCBpbnN0YW5jZUNvbmZpZywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbGVtZW50LmRhdGFzZXQgfHwge30pKSk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0cyA9IHt9O1xuICAgICAgICAgICAgc2VsZi5jb25maWcucGFyc2VEYXRlID0gdXNlckNvbmZpZy5wYXJzZURhdGU7XG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5mb3JtYXREYXRlID0gdXNlckNvbmZpZy5mb3JtYXREYXRlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcImVuYWJsZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fZW5hYmxlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLl9lbmFibGUgPSBwYXJzZURhdGVSdWxlcyhkYXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwiZGlzYWJsZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fZGlzYWJsZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5fZGlzYWJsZSA9IHBhcnNlRGF0ZVJ1bGVzKGRhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB0aW1lTW9kZSA9IHVzZXJDb25maWcubW9kZSA9PT0gXCJ0aW1lXCI7XG4gICAgICAgICAgICBpZiAoIXVzZXJDb25maWcuZGF0ZUZvcm1hdCAmJiAodXNlckNvbmZpZy5lbmFibGVUaW1lIHx8IHRpbWVNb2RlKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMuZGF0ZUZvcm1hdCA9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWcubm9DYWxlbmRhciB8fCB0aW1lTW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLmRhdGVGb3JtYXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIEg6aVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5hbHRJbnB1dCAmJlxuICAgICAgICAgICAgICAgICh1c2VyQ29uZmlnLmVuYWJsZVRpbWUgfHwgdGltZU1vZGUpICYmXG4gICAgICAgICAgICAgICAgIXVzZXJDb25maWcuYWx0Rm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0cy5hbHRGb3JtYXQgPVxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlnLm5vQ2FsZW5kYXIgfHwgdGltZU1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJoOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTIEtcIiA6IFwiIEtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmxhdHBpY2tyLmRlZmF1bHRDb25maWcuYWx0Rm9ybWF0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCIgaDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIikgKyBcIiBLXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1pbkRhdGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21pbkRhdGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhEYXRlU2V0dGVyKFwibWluXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtYXhEYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9tYXhEYXRlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4RGF0ZVNldHRlcihcIm1heFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWluTWF4VGltZVNldHRlciA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWdbdHlwZSA9PT0gXCJtaW5cIiA/IFwiX21pblRpbWVcIiA6IFwiX21heFRpbWVcIl0gPSBzZWxmLnBhcnNlRGF0ZSh2YWwsIFwiSDppXCIpO1xuICAgICAgICAgICAgfTsgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtaW5UaW1lXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9taW5UaW1lOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4VGltZVNldHRlcihcIm1pblwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWF4VGltZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWF4VGltZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heFRpbWVTZXR0ZXIoXCJtYXhcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcubW9kZSA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lbmFibGVUaW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIGZvcm1hdHMsIHVzZXJDb25maWcpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sT3B0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tib29sT3B0c1tpXV0gPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tib29sT3B0c1tpXV0gPT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICBIT09LUy5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIHNlbGYuY29uZmlnW2hvb2tdICE9PSB1bmRlZmluZWQ7IH0pLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tob29rXSA9IGFycmF5aWZ5KHNlbGYuY29uZmlnW2hvb2tdIHx8IFtdKS5tYXAoYmluZFRvSW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmlzTW9iaWxlID1cbiAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZGlzYWJsZU1vYmlsZSAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuaW5saW5lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy53ZWVrTnVtYmVycyAmJlxuICAgICAgICAgICAgICAgICAgICAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGx1Z2luQ29uZiA9IHNlbGYuY29uZmlnLnBsdWdpbnNbaV0oc2VsZikgfHwge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBsdWdpbkNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEhPT0tTLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1trZXldID0gYXJyYXlpZnkocGx1Z2luQ29uZltrZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYmluZFRvSW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChzZWxmLmNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdXNlckNvbmZpZ1trZXldID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdba2V5XSA9IHBsdWdpbkNvbmZba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblBhcnNlQ29uZmlnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwTG9jYWxlKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvbmZpZy5sb2NhbGUgIT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZmxhdHBpY2tyLmwxMG5zW3NlbGYuY29uZmlnLmxvY2FsZV0gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcImZsYXRwaWNrcjogaW52YWxpZCBsb2NhbGUgXCIgKyBzZWxmLmNvbmZpZy5sb2NhbGUpKTtcbiAgICAgICAgICAgIHNlbGYubDEwbiA9IF9fYXNzaWduKHt9LCBmbGF0cGlja3IubDEwbnNbXCJkZWZhdWx0XCJdLCAodHlwZW9mIHNlbGYuY29uZmlnLmxvY2FsZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubG9jYWxlXG4gICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5sb2NhbGUgIT09IFwiZGVmYXVsdFwiXG4gICAgICAgICAgICAgICAgICAgID8gZmxhdHBpY2tyLmwxMG5zW3NlbGYuY29uZmlnLmxvY2FsZV1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIHRva2VuUmVnZXguSyA9IFwiKFwiICsgc2VsZi5sMTBuLmFtUE1bMF0gKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzFdICsgXCJ8XCIgKyBzZWxmLmwxMG4uYW1QTVswXS50b0xvd2VyQ2FzZSgpICsgXCJ8XCIgKyBzZWxmLmwxMG4uYW1QTVsxXS50b0xvd2VyQ2FzZSgpICsgXCIpXCI7XG4gICAgICAgICAgICBzZWxmLmZvcm1hdERhdGUgPSBjcmVhdGVEYXRlRm9ybWF0dGVyKHNlbGYpO1xuICAgICAgICAgICAgc2VsZi5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHsgY29uZmlnOiBzZWxmLmNvbmZpZywgbDEwbjogc2VsZi5sMTBuIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uQ2FsZW5kYXIoY3VzdG9tUG9zaXRpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uUHJlQ2FsZW5kYXJQb3NpdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkVsZW1lbnQgPSBjdXN0b21Qb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5fcG9zaXRpb25FbGVtZW50O1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFySGVpZ2h0ID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2hpbGRyZW4sIChmdW5jdGlvbiAoYWNjLCBjaGlsZCkgeyByZXR1cm4gYWNjICsgY2hpbGQub2Zmc2V0SGVpZ2h0OyB9KSwgMCksIGNhbGVuZGFyV2lkdGggPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLm9mZnNldFdpZHRoLCBjb25maWdQb3MgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbi5zcGxpdChcIiBcIiksIGNvbmZpZ1Bvc1ZlcnRpY2FsID0gY29uZmlnUG9zWzBdLCBjb25maWdQb3NIb3Jpem9udGFsID0gY29uZmlnUG9zLmxlbmd0aCA+IDEgPyBjb25maWdQb3NbMV0gOiBudWxsLCBpbnB1dEJvdW5kcyA9IHBvc2l0aW9uRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZGlzdGFuY2VGcm9tQm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0IC0gaW5wdXRCb3VuZHMuYm90dG9tLCBzaG93T25Ub3AgPSBjb25maWdQb3NWZXJ0aWNhbCA9PT0gXCJhYm92ZVwiIHx8XG4gICAgICAgICAgICAgICAgKGNvbmZpZ1Bvc1ZlcnRpY2FsICE9PSBcImJlbG93XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VGcm9tQm90dG9tIDwgY2FsZW5kYXJIZWlnaHQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRCb3VuZHMudG9wID4gY2FsZW5kYXJIZWlnaHQpO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCArXG4gICAgICAgICAgICAgICAgaW5wdXRCb3VuZHMudG9wICtcbiAgICAgICAgICAgICAgICAoIXNob3dPblRvcCA/IHBvc2l0aW9uRWxlbWVudC5vZmZzZXRIZWlnaHQgKyAyIDogLWNhbGVuZGFySGVpZ2h0IC0gMik7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFycm93VG9wXCIsICFzaG93T25Ub3ApO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd0JvdHRvbVwiLCBzaG93T25Ub3ApO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCArXG4gICAgICAgICAgICAgICAgaW5wdXRCb3VuZHMubGVmdCAtXG4gICAgICAgICAgICAgICAgKGNvbmZpZ1Bvc0hvcml6b250YWwgIT0gbnVsbCAmJiBjb25maWdQb3NIb3Jpem9udGFsID09PSBcImNlbnRlclwiXG4gICAgICAgICAgICAgICAgICAgID8gKGNhbGVuZGFyV2lkdGggLSBpbnB1dEJvdW5kcy53aWR0aCkgLyAyXG4gICAgICAgICAgICAgICAgICAgIDogMCk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAtIGlucHV0Qm91bmRzLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIHJpZ2h0TW9zdCA9IGxlZnQgKyBjYWxlbmRhcldpZHRoID4gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgY2VudGVyTW9zdCA9IHJpZ2h0ICsgY2FsZW5kYXJXaWR0aCA+IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyaWdodE1vc3RcIiwgcmlnaHRNb3N0KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zdGF0aWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgICBpZiAoIXJpZ2h0TW9zdCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNlbnRlck1vc3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0ID0gcmlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbMF07XG4gICAgICAgICAgICAgICAgLy8gc29tZSB0ZXN0aW5nIGVudmlyb25tZW50cyBkb24ndCBoYXZlIGNzcyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgaWYgKGRvYyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlXaWR0aCA9IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJMZWZ0ID0gTWF0aC5tYXgoMCwgYm9keVdpZHRoIC8gMiAtIGNhbGVuZGFyV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyQmVmb3JlID0gXCIuZmxhdHBpY2tyLWNhbGVuZGFyLmNlbnRlck1vc3Q6YmVmb3JlXCI7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckFmdGVyID0gXCIuZmxhdHBpY2tyLWNhbGVuZGFyLmNlbnRlck1vc3Q6YWZ0ZXJcIjtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVySW5kZXggPSBkb2MuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJTdHlsZSA9IFwie2xlZnQ6XCIgKyBpbnB1dEJvdW5kcy5sZWZ0ICsgXCJweDtyaWdodDphdXRvO31cIjtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInJpZ2h0TW9zdFwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJjZW50ZXJNb3N0XCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvYy5pbnNlcnRSdWxlKGNlbnRlckJlZm9yZSArIFwiLFwiICsgY2VudGVyQWZ0ZXIgKyBjZW50ZXJTdHlsZSwgY2VudGVySW5kZXgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IGNlbnRlckxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyIHx8IHNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9jdXNBbmRDbG9zZSgpIHtcbiAgICAgICAgICAgIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGhhY2sgLSBidWdzIGluIHRoZSB3YXkgSUUgaGFuZGxlcyBmb2N1cyBrZWVwcyB0aGUgY2FsZW5kYXIgb3BlblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc2VsZi5jbG9zZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2VsZWN0RGF0ZShlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF5LmNsYXNzTGlzdCAmJlxuICAgICAgICAgICAgICAgICAgICBkYXkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyLWRheVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZGF5LmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICFkYXkuY2xhc3NMaXN0LmNvbnRhaW5zKFwibm90QWxsb3dlZFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdCA9IGZpbmRQYXJlbnQoZS50YXJnZXQsIGlzU2VsZWN0YWJsZSk7XG4gICAgICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGF0ZSA9IChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IG5ldyBEYXRlKHRhcmdldC5kYXRlT2JqLmdldFRpbWUoKSkpO1xuICAgICAgICAgICAgdmFyIHNob3VsZENoYW5nZU1vbnRoID0gKHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpIDwgc2VsZi5jdXJyZW50TW9udGggfHxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGUuZ2V0TW9udGgoKSA+XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoICsgc2VsZi5jb25maWcuc2hvd01vbnRocyAtIDEpICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gW3NlbGVjdGVkRGF0ZV07XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcIm11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IGlzRGF0ZVNlbGVjdGVkKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zcGxpY2UocGFyc2VJbnQoc2VsZWN0ZWRJbmRleCksIDEpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnB1c2goc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxlY3RlZERhdGU7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnB1c2goc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3Mgc2VsZWN0aW5nIHNhbWUgZGF0ZSB0d2ljZSwgc29ydCBhc2NlbmRpbmdseVxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRGF0ZXMoc2VsZWN0ZWREYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHRydWUpICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDaGFuZ2VNb250aCkge1xuICAgICAgICAgICAgICAgIHZhciBpc05ld1llYXIgPSBzZWxmLmN1cnJlbnRZZWFyICE9PSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxlY3RlZERhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXdZZWFyKVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25Nb250aENoYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gKHNlbGYuc2hvd1RpbWVJbnB1dCA9IHRydWUpOyB9LCA1MCk7XG4gICAgICAgICAgICAvLyBtYWludGFpbiBmb2N1c1xuICAgICAgICAgICAgaWYgKCFzaG91bGRDaGFuZ2VNb250aCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIiAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEpXG4gICAgICAgICAgICAgICAgZm9jdXNPbkRheUVsZW0odGFyZ2V0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtICYmIHNlbGYuc2VsZWN0ZWREYXRlRWxlbS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaG91ckVsZW1lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgc2VsZi5ob3VyRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNsb3NlT25TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlID0gc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIiAmJiAhc2VsZi5jb25maWcuZW5hYmxlVGltZTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZW5hYmxlVGltZTtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlIHx8IHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIENBTExCQUNLUyA9IHtcbiAgICAgICAgICAgIGxvY2FsZTogW3NldHVwTG9jYWxlLCB1cGRhdGVXZWVrZGF5c10sXG4gICAgICAgICAgICBzaG93TW9udGhzOiBbYnVpbGRNb250aHMsIHNldENhbGVuZGFyV2lkdGgsIGJ1aWxkV2Vla2RheXNdXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldChvcHRpb24sIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb24gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywgb3B0aW9uKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW29wdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoQ0FMTEJBQ0tTW29wdGlvbl0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgQ0FMTEJBQ0tTW29wdGlvbl0uZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCgpOyB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChIT09LUy5pbmRleE9mKG9wdGlvbikgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdbb3B0aW9uXSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0U2VsZWN0ZWREYXRlKGlucHV0RGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChpbnB1dERhdGUgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHNlbGYucGFyc2VEYXRlKGQsIGZvcm1hdCk7IH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXREYXRlIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgaW5wdXREYXRlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIGRhdGVzID0gW3NlbGYucGFyc2VEYXRlKGlucHV0RGF0ZSwgZm9ybWF0KV07XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXREYXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZWxmLmNvbmZpZy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzaW5nbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzID0gW3NlbGYucGFyc2VEYXRlKGlucHV0RGF0ZSwgZm9ybWF0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChzZWxmLmNvbmZpZy5jb25qdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBzZWxmLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmFuZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzID0gaW5wdXREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KHNlbGYubDEwbi5yYW5nZVNlcGFyYXRvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBzZWxmLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgc3VwcGxpZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXREYXRlKSkpO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkIGluc3RhbmNlb2YgRGF0ZSAmJiBpc0VuYWJsZWQoZCwgZmFsc2UpOyB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldERhdGUoZGF0ZSwgdHJpZ2dlckNoYW5nZSwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2UgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7IGZvcm1hdCA9IHNlbGYuY29uZmlnLmRhdGVGb3JtYXQ7IH1cbiAgICAgICAgICAgIGlmICgoZGF0ZSAhPT0gMCAmJiAhZGF0ZSkgfHwgKGRhdGUgaW5zdGFuY2VvZiBBcnJheSAmJiBkYXRlLmxlbmd0aCA9PT0gMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2xlYXIodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZERhdGUoZGF0ZSwgZm9ybWF0KTtcbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF07XG4gICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAganVtcFRvRGF0ZSgpO1xuICAgICAgICAgICAgc2V0SG91cnNGcm9tRGF0ZSgpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSlcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwYXJzZURhdGVSdWxlcyhhcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJcbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJ1bGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgcnVsZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyc2VEYXRlKHJ1bGUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJ1bGUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5mcm9tICYmXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBzZWxmLnBhcnNlRGF0ZShydWxlLmZyb20sIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogc2VsZi5wYXJzZURhdGUocnVsZS50bywgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTsgLy8gcmVtb3ZlIGZhbHN5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwRGF0ZXMoKSB7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubm93ID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubm93KSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBJRTExIHNldHRpbmcgcGxhY2Vob2xkZXIgYXMgdGhlIGlucHV0J3MgdmFsdWVcbiAgICAgICAgICAgIHZhciBwcmVsb2FkZWREYXRlID0gc2VsZi5jb25maWcuZGVmYXVsdERhdGUgfHxcbiAgICAgICAgICAgICAgICAoKHNlbGYuaW5wdXQubm9kZU5hbWUgPT09IFwiSU5QVVRcIiB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0Lm5vZGVOYW1lID09PSBcIlRFWFRBUkVBXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGxhY2Vob2xkZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9PT0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmVsb2FkZWREYXRlKVxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRGF0ZShwcmVsb2FkZWREYXRlLCBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgIHNlbGYuX2luaXRpYWxEYXRlID1cbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuc2VsZWN0ZWREYXRlc1swXVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0VGltZSgpID4gc2VsZi5ub3cuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0VGltZSgpIDwgc2VsZi5ub3cuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhEYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLm5vdztcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZi5zZWxlY3RlZERhdGVzWzBdO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5UaW1lID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubWluVGltZSwgXCJIOmlcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4VGltZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heFRpbWUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5tYXhUaW1lLCBcIkg6aVwiKTtcbiAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgPVxuICAgICAgICAgICAgICAgICEhc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWluRGF0ZS5nZXRIb3VycygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRNaW51dGVzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKSA+IDApO1xuICAgICAgICAgICAgc2VsZi5tYXhEYXRlSGFzVGltZSA9XG4gICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0U2Vjb25kcygpID4gMCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJzaG93VGltZUlucHV0XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX3Nob3dUaW1lSW5wdXQ7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zaG93VGltZUlucHV0ID0gYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInNob3dUaW1lSW5wdXRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaXNPcGVuICYmIHBvc2l0aW9uQ2FsZW5kYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cElucHV0cygpIHtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQgPSBzZWxmLmNvbmZpZy53cmFwXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1pbnB1dF1cIilcbiAgICAgICAgICAgICAgICA6IGVsZW1lbnQ7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgZWxlbWVudCBzcGVjaWZpZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhY2s6IHN0b3JlIHByZXZpb3VzIHR5cGUgdG8gcmVzdG9yZSBpdCBhZnRlciBkZXN0cm95KClcbiAgICAgICAgICAgIHNlbGYuaW5wdXQuX3R5cGUgPSBzZWxmLmlucHV0LnR5cGU7XG4gICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LmFkZChcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgIHNlbGYuX2lucHV0ID0gc2VsZi5pbnB1dDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbHRJbnB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxpY2F0ZSBzZWxmLmVsZW1lbnRcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0ID0gY3JlYXRlRWxlbWVudChzZWxmLmlucHV0Lm5vZGVOYW1lLCBzZWxmLmlucHV0LmNsYXNzTmFtZSArIFwiIFwiICsgc2VsZi5jb25maWcuYWx0SW5wdXRDbGFzcyk7XG4gICAgICAgICAgICAgICAgc2VsZi5faW5wdXQgPSBzZWxmLmFsdElucHV0O1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQucGxhY2Vob2xkZXIgPSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQuZGlzYWJsZWQgPSBzZWxmLmlucHV0LmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQucmVxdWlyZWQgPSBzZWxmLmlucHV0LnJlcXVpcmVkO1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudGFiSW5kZXggPSBzZWxmLmlucHV0LnRhYkluZGV4O1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLnN0YXRpYyAmJiBzZWxmLmlucHV0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2VsZi5hbHRJbnB1dCwgc2VsZi5pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpXG4gICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICAgIHNlbGYuX3Bvc2l0aW9uRWxlbWVudCA9IHNlbGYuY29uZmlnLnBvc2l0aW9uRWxlbWVudCB8fCBzZWxmLl9pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cE1vYmlsZSgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFR5cGUgPSBzZWxmLmNvbmZpZy5lbmFibGVUaW1lXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgID8gXCJ0aW1lXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImRhdGV0aW1lLWxvY2FsXCJcbiAgICAgICAgICAgICAgICA6IFwiZGF0ZVwiO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCA9IGNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBzZWxmLmlucHV0LmNsYXNzTmFtZSArIFwiIGZsYXRwaWNrci1tb2JpbGVcIik7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnN0ZXAgPSBzZWxmLmlucHV0LmdldEF0dHJpYnV0ZShcInN0ZXBcIikgfHwgXCJhbnlcIjtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudGFiSW5kZXggPSAxO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC50eXBlID0gaW5wdXRUeXBlO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5kaXNhYmxlZCA9IHNlbGYuaW5wdXQuZGlzYWJsZWQ7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnJlcXVpcmVkID0gc2VsZi5pbnB1dC5yZXF1aXJlZDtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQucGxhY2Vob2xkZXIgPSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVGb3JtYXRTdHIgPVxuICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9PT0gXCJkYXRldGltZS1sb2NhbFwiXG4gICAgICAgICAgICAgICAgICAgID8gXCJZLW0tZFxcXFxUSDppOlNcIlxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0VHlwZSA9PT0gXCJkYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJZLW0tZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiSDppOlNcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZGVmYXVsdFZhbHVlID0gc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHNlbGYubW9iaWxlRm9ybWF0U3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQubWluID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuY29uZmlnLm1pbkRhdGUsIFwiWS1tLWRcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSlcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0Lm1heCA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLmNvbmZpZy5tYXhEYXRlLCBcIlktbS1kXCIpO1xuICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLm1vYmlsZUlucHV0LCBzZWxmLmlucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICBiaW5kKHNlbGYubW9iaWxlSW5wdXQsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKGUudGFyZ2V0LnZhbHVlLCBmYWxzZSwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2xvc2VcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICBzZWxmLm9wZW4oZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFscmVhZHksIGFsbCBob29rcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGhvb2tzID0gc2VsZi5jb25maWdbZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGhvb2tzICE9PSB1bmRlZmluZWQgJiYgaG9va3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBob29rc1tpXSAmJiBpIDwgaG9va3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzW2ldKHNlbGYuc2VsZWN0ZWREYXRlcywgc2VsZi5pbnB1dC52YWx1ZSwgc2VsZiwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IFwib25DaGFuZ2VcIikge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChcImNoYW5nZVwiKSk7XG4gICAgICAgICAgICAgICAgLy8gbWFueSBmcm9udC1lbmQgZnJhbWV3b3JrcyBiaW5kIHRvIHRoZSBpbnB1dCBldmVudFxuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChcImlucHV0XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgICAgICAgICBlLmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGVkKGRhdGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhzZWxmLnNlbGVjdGVkRGF0ZXNbaV0sIGRhdGUpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNEYXRlSW5SYW5nZShkYXRlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiIHx8IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAoY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSkgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0pIDw9IDApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhciB8fCBzZWxmLmlzTW9iaWxlIHx8ICFzZWxmLm1vbnRoTmF2KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHllYXJFbGVtZW50LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgMSk7XG4gICAgICAgICAgICAgICAgZC5zZXRNb250aChzZWxmLmN1cnJlbnRNb250aCArIGkpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50c1tpXS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoVG9TdHIoZC5nZXRNb250aCgpLCBzZWxmLmNvbmZpZy5zaG9ydGhhbmRDdXJyZW50TW9udGgsIHNlbGYubDEwbikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCI7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQudmFsdWUgPSBkLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5faGlkZVByZXZNb250aEFycm93ID1cbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmN1cnJlbnRNb250aCA8PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jdXJyZW50WWVhciA8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgICAgICBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY3VycmVudE1vbnRoICsgMSA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRZZWFyID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREYXRlU3RyKGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2VsZWN0ZWREYXRlc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRPYmopIHsgcmV0dXJuIHNlbGYuZm9ybWF0RGF0ZShkT2JqLCBmb3JtYXQpOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZW5hYmxlVGltZSB8fFxuICAgICAgICAgICAgICAgICAgICBhcnIuaW5kZXhPZihkKSA9PT0gaTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5jb25qdW5jdGlvblxuICAgICAgICAgICAgICAgIDogc2VsZi5sMTBuLnJhbmdlU2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIGlucHV0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGNhbGVuZGFyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2UgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbGVhcih0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQgJiYgc2VsZi5tb2JpbGVGb3JtYXRTdHIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmZvcm1hdERhdGUoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYubW9iaWxlRm9ybWF0U3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IGdldERhdGVTdHIoc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC52YWx1ZSA9IGdldERhdGVTdHIoc2VsZi5jb25maWcuYWx0Rm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblZhbHVlVXBkYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uTW9udGhOYXZDbGljayhlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgaXNQcmV2TW9udGggPSBzZWxmLnByZXZNb250aE5hdi5jb250YWlucyhlLnRhcmdldCk7XG4gICAgICAgICAgICB2YXIgaXNOZXh0TW9udGggPSBzZWxmLm5leHRNb250aE5hdi5jb250YWlucyhlLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoaXNQcmV2TW9udGggfHwgaXNOZXh0TW9udGgpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VNb250aChpc1ByZXZNb250aCA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLnllYXJFbGVtZW50cy5pbmRleE9mKGUudGFyZ2V0KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcnJvd1VwXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93RG93blwiKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGltZVdyYXBwZXIoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGlzS2V5RG93biA9IGUudHlwZSA9PT0gXCJrZXlkb3duXCIsIGlucHV0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQgJiYgZS50YXJnZXQgPT09IHNlbGYuYW1QTSkge1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubDEwbi5hbVBNW2ludChzZWxmLmFtUE0udGV4dENvbnRlbnQgPT09IHNlbGYubDEwbi5hbVBNWzBdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluID0gcGFyc2VGbG9hdChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJtaW5cIikpLCBtYXggPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcIm1heFwiKSksIHN0ZXAgPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcInN0ZXBcIikpLCBjdXJWYWx1ZSA9IHBhcnNlSW50KGlucHV0LnZhbHVlLCAxMCksIGRlbHRhID0gZS5kZWx0YSB8fFxuICAgICAgICAgICAgICAgIChpc0tleURvd24gPyAoZS53aGljaCA9PT0gMzggPyAxIDogLTEpIDogMCk7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXJWYWx1ZSArIHN0ZXAgKiBkZWx0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQudmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSG91ckVsZW0gPSBpbnB1dCA9PT0gc2VsZi5ob3VyRWxlbWVudCwgaXNNaW51dGVFbGVtID0gaW5wdXQgPT09IHNlbGYubWludXRlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50KCFpc0hvdXJFbGVtKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGludChpc0hvdXJFbGVtKSAmJiBpbnQoIXNlbGYuYW1QTSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaW51dGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50TnVtSW5wdXQodW5kZWZpbmVkLCAtMSwgc2VsZi5ob3VyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID09PSBzZWxmLmhvdXJFbGVtZW50ID8gbmV3VmFsdWUgLSBtYXggLSBpbnQoIXNlbGYuYW1QTSkgOiBtaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pbnV0ZUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnROdW1JbnB1dCh1bmRlZmluZWQsIDEsIHNlbGYuaG91ckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbVBNICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSG91ckVsZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0ZXAgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUgKyBjdXJWYWx1ZSA9PT0gMjNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5hYnMobmV3VmFsdWUgLSBjdXJWYWx1ZSkgPiBzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sMTBuLmFtUE1baW50KHNlbGYuYW1QTS50ZXh0Q29udGVudCA9PT0gc2VsZi5sMTBuLmFtUE1bMF0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBwYWQobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gX2ZsYXRwaWNrcihub2RlTGlzdCwgY29uZmlnKSB7XG4gICAgICAgIC8vIHN0YXRpYyBsaXN0XG4gICAgICAgIHZhciBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgICAgLmNhbGwobm9kZUxpc3QpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7IH0pO1xuICAgICAgICB2YXIgaW5zdGFuY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZnAtb21pdFwiKSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuX2ZsYXRwaWNrciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyID0gRmxhdHBpY2tySW5zdGFuY2Uobm9kZSwgY29uZmlnIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXMucHVzaChub2RlLl9mbGF0cGlja3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXMubGVuZ3RoID09PSAxID8gaW5zdGFuY2VzWzBdIDogaW5zdGFuY2VzO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gYnJvd3NlciBlbnZcbiAgICAgICAgSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLmZsYXRwaWNrciA9IE5vZGVMaXN0LnByb3RvdHlwZS5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih0aGlzLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IoW3RoaXNdLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHZhciBmbGF0cGlja3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcihbc2VsZWN0b3JdLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3Ioc2VsZWN0b3IsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0cztcbiAgICBmbGF0cGlja3IubDEwbnMgPSB7XG4gICAgICAgIGVuOiBfX2Fzc2lnbih7fSwgZW5nbGlzaCksXG4gICAgICAgIFwiZGVmYXVsdFwiOiBfX2Fzc2lnbih7fSwgZW5nbGlzaClcbiAgICB9O1xuICAgIGZsYXRwaWNrci5sb2NhbGl6ZSA9IGZ1bmN0aW9uIChsMTBuKSB7XG4gICAgICAgIGZsYXRwaWNrci5sMTBuc1tcImRlZmF1bHRcIl0gPSBfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmwxMG5zW1wiZGVmYXVsdFwiXSwgbDEwbik7XG4gICAgfTtcbiAgICBmbGF0cGlja3Iuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnID0gX19hc3NpZ24oe30sIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLCBjb25maWcpO1xuICAgIH07XG4gICAgZmxhdHBpY2tyLnBhcnNlRGF0ZSA9IGNyZWF0ZURhdGVQYXJzZXIoe30pO1xuICAgIGZsYXRwaWNrci5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcih7fSk7XG4gICAgZmxhdHBpY2tyLmNvbXBhcmVEYXRlcyA9IGNvbXBhcmVEYXRlcztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGpRdWVyeS5mbi5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih0aGlzLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBEYXRlLnByb3RvdHlwZS5mcF9pbmNyID0gZnVuY3Rpb24gKGRheXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSwgdGhpcy5nZXRNb250aCgpLCB0aGlzLmdldERhdGUoKSArICh0eXBlb2YgZGF5cyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlSW50KGRheXMsIDEwKSA6IGRheXMpKTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHdpbmRvdy5mbGF0cGlja3IgPSBmbGF0cGlja3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYXRwaWNrcjtcblxufSkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmRlID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmcCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmZsYXRwaWNrciAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHdpbmRvdy5mbGF0cGlja3JcbiAgICAgIDoge1xuICAgICAgICAgIGwxMG5zOiB7fVxuICAgICAgfTtcbiAgdmFyIEdlcm1hbiA9IHtcbiAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXCJTb1wiLCBcIk1vXCIsIFwiRGlcIiwgXCJNaVwiLCBcIkRvXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICBcIlNvbm50YWdcIixcbiAgICAgICAgICAgICAgXCJNb250YWdcIixcbiAgICAgICAgICAgICAgXCJEaWVuc3RhZ1wiLFxuICAgICAgICAgICAgICBcIk1pdHR3b2NoXCIsXG4gICAgICAgICAgICAgIFwiRG9ubmVyc3RhZ1wiLFxuICAgICAgICAgICAgICBcIkZyZWl0YWdcIixcbiAgICAgICAgICAgICAgXCJTYW1zdGFnXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIG1vbnRoczoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1xuICAgICAgICAgICAgICBcIkphblwiLFxuICAgICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgICBcIk3DpHJcIixcbiAgICAgICAgICAgICAgXCJBcHJcIixcbiAgICAgICAgICAgICAgXCJNYWlcIixcbiAgICAgICAgICAgICAgXCJKdW5cIixcbiAgICAgICAgICAgICAgXCJKdWxcIixcbiAgICAgICAgICAgICAgXCJBdWdcIixcbiAgICAgICAgICAgICAgXCJTZXBcIixcbiAgICAgICAgICAgICAgXCJPa3RcIixcbiAgICAgICAgICAgICAgXCJOb3ZcIixcbiAgICAgICAgICAgICAgXCJEZXpcIixcbiAgICAgICAgICBdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiSmFudWFyXCIsXG4gICAgICAgICAgICAgIFwiRmVicnVhclwiLFxuICAgICAgICAgICAgICBcIk3DpHJ6XCIsXG4gICAgICAgICAgICAgIFwiQXByaWxcIixcbiAgICAgICAgICAgICAgXCJNYWlcIixcbiAgICAgICAgICAgICAgXCJKdW5pXCIsXG4gICAgICAgICAgICAgIFwiSnVsaVwiLFxuICAgICAgICAgICAgICBcIkF1Z3VzdFwiLFxuICAgICAgICAgICAgICBcIlNlcHRlbWJlclwiLFxuICAgICAgICAgICAgICBcIk9rdG9iZXJcIixcbiAgICAgICAgICAgICAgXCJOb3ZlbWJlclwiLFxuICAgICAgICAgICAgICBcIkRlemVtYmVyXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGZpcnN0RGF5T2ZXZWVrOiAxLFxuICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJLV1wiLFxuICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIGJpcyBcIixcbiAgICAgIHNjcm9sbFRpdGxlOiBcIlp1bSDDhG5kZXJuIHNjcm9sbGVuXCIsXG4gICAgICB0b2dnbGVUaXRsZTogXCJadW0gVW1zY2hhbHRlbiBrbGlja2VuXCJcbiAgfTtcbiAgZnAubDEwbnMuZGUgPSBHZXJtYW47XG4gIHZhciBkZSA9IGZwLmwxMG5zO1xuXG4gIGV4cG9ydHMuR2VybWFuID0gR2VybWFuO1xuICBleHBvcnRzLmRlZmF1bHQgPSBkZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZnIgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZwID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmxhdHBpY2tyICE9PSB1bmRlZmluZWRcbiAgICAgID8gd2luZG93LmZsYXRwaWNrclxuICAgICAgOiB7XG4gICAgICAgICAgbDEwbnM6IHt9XG4gICAgICB9O1xuICB2YXIgRnJlbmNoID0ge1xuICAgICAgZmlyc3REYXlPZldlZWs6IDEsXG4gICAgICB3ZWVrZGF5czoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1wiZGltXCIsIFwibHVuXCIsIFwibWFyXCIsIFwibWVyXCIsIFwiamV1XCIsIFwidmVuXCIsIFwic2FtXCJdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiZGltYW5jaGVcIixcbiAgICAgICAgICAgICAgXCJsdW5kaVwiLFxuICAgICAgICAgICAgICBcIm1hcmRpXCIsXG4gICAgICAgICAgICAgIFwibWVyY3JlZGlcIixcbiAgICAgICAgICAgICAgXCJqZXVkaVwiLFxuICAgICAgICAgICAgICBcInZlbmRyZWRpXCIsXG4gICAgICAgICAgICAgIFwic2FtZWRpXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIG1vbnRoczoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1xuICAgICAgICAgICAgICBcImphbnZcIixcbiAgICAgICAgICAgICAgXCJmw6l2clwiLFxuICAgICAgICAgICAgICBcIm1hcnNcIixcbiAgICAgICAgICAgICAgXCJhdnJcIixcbiAgICAgICAgICAgICAgXCJtYWlcIixcbiAgICAgICAgICAgICAgXCJqdWluXCIsXG4gICAgICAgICAgICAgIFwianVpbFwiLFxuICAgICAgICAgICAgICBcImFvw7t0XCIsXG4gICAgICAgICAgICAgIFwic2VwdFwiLFxuICAgICAgICAgICAgICBcIm9jdFwiLFxuICAgICAgICAgICAgICBcIm5vdlwiLFxuICAgICAgICAgICAgICBcImTDqWNcIixcbiAgICAgICAgICBdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiamFudmllclwiLFxuICAgICAgICAgICAgICBcImbDqXZyaWVyXCIsXG4gICAgICAgICAgICAgIFwibWFyc1wiLFxuICAgICAgICAgICAgICBcImF2cmlsXCIsXG4gICAgICAgICAgICAgIFwibWFpXCIsXG4gICAgICAgICAgICAgIFwianVpblwiLFxuICAgICAgICAgICAgICBcImp1aWxsZXRcIixcbiAgICAgICAgICAgICAgXCJhb8O7dFwiLFxuICAgICAgICAgICAgICBcInNlcHRlbWJyZVwiLFxuICAgICAgICAgICAgICBcIm9jdG9icmVcIixcbiAgICAgICAgICAgICAgXCJub3ZlbWJyZVwiLFxuICAgICAgICAgICAgICBcImTDqWNlbWJyZVwiLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnRoKSB7XG4gICAgICAgICAgaWYgKG50aCA+IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIHJldHVybiBcImVyXCI7XG4gICAgICB9LFxuICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIGF1IFwiLFxuICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJTZW1cIixcbiAgICAgIHNjcm9sbFRpdGxlOiBcIkTDqWZpbGVyIHBvdXIgYXVnbWVudGVyIGxhIHZhbGV1clwiLFxuICAgICAgdG9nZ2xlVGl0bGU6IFwiQ2xpcXVlciBwb3VyIGJhc2N1bGVyXCJcbiAgfTtcbiAgZnAubDEwbnMuZnIgPSBGcmVuY2g7XG4gIHZhciBmciA9IGZwLmwxMG5zO1xuXG4gIGV4cG9ydHMuRnJlbmNoID0gRnJlbmNoO1xuICBleHBvcnRzLmRlZmF1bHQgPSBmcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuaXQgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZwID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmxhdHBpY2tyICE9PSB1bmRlZmluZWRcbiAgICAgID8gd2luZG93LmZsYXRwaWNrclxuICAgICAgOiB7XG4gICAgICAgICAgbDEwbnM6IHt9XG4gICAgICB9O1xuICB2YXIgSXRhbGlhbiA9IHtcbiAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXCJEb21cIiwgXCJMdW5cIiwgXCJNYXJcIiwgXCJNZXJcIiwgXCJHaW9cIiwgXCJWZW5cIiwgXCJTYWJcIl0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJEb21lbmljYVwiLFxuICAgICAgICAgICAgICBcIkx1bmVkw6xcIixcbiAgICAgICAgICAgICAgXCJNYXJ0ZWTDrFwiLFxuICAgICAgICAgICAgICBcIk1lcmNvbGVkw6xcIixcbiAgICAgICAgICAgICAgXCJHaW92ZWTDrFwiLFxuICAgICAgICAgICAgICBcIlZlbmVyZMOsXCIsXG4gICAgICAgICAgICAgIFwiU2FiYXRvXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIG1vbnRoczoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1xuICAgICAgICAgICAgICBcIkdlblwiLFxuICAgICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgICBcIk1hclwiLFxuICAgICAgICAgICAgICBcIkFwclwiLFxuICAgICAgICAgICAgICBcIk1hZ1wiLFxuICAgICAgICAgICAgICBcIkdpdVwiLFxuICAgICAgICAgICAgICBcIkx1Z1wiLFxuICAgICAgICAgICAgICBcIkFnb1wiLFxuICAgICAgICAgICAgICBcIlNldFwiLFxuICAgICAgICAgICAgICBcIk90dFwiLFxuICAgICAgICAgICAgICBcIk5vdlwiLFxuICAgICAgICAgICAgICBcIkRpY1wiLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJHZW5uYWlvXCIsXG4gICAgICAgICAgICAgIFwiRmViYnJhaW9cIixcbiAgICAgICAgICAgICAgXCJNYXJ6b1wiLFxuICAgICAgICAgICAgICBcIkFwcmlsZVwiLFxuICAgICAgICAgICAgICBcIk1hZ2dpb1wiLFxuICAgICAgICAgICAgICBcIkdpdWdub1wiLFxuICAgICAgICAgICAgICBcIkx1Z2xpb1wiLFxuICAgICAgICAgICAgICBcIkFnb3N0b1wiLFxuICAgICAgICAgICAgICBcIlNldHRlbWJyZVwiLFxuICAgICAgICAgICAgICBcIk90dG9icmVcIixcbiAgICAgICAgICAgICAgXCJOb3ZlbWJyZVwiLFxuICAgICAgICAgICAgICBcIkRpY2VtYnJlXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGZpcnN0RGF5T2ZXZWVrOiAxLFxuICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCLCsFwiOyB9LFxuICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIGFsIFwiLFxuICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJTZVwiLFxuICAgICAgc2Nyb2xsVGl0bGU6IFwiU2Nyb2xsYSBwZXIgYXVtZW50YXJlXCIsXG4gICAgICB0b2dnbGVUaXRsZTogXCJDbGljY2EgcGVyIGNhbWJpYXJlXCJcbiAgfTtcbiAgZnAubDEwbnMuaXQgPSBJdGFsaWFuO1xuICB2YXIgaXQgPSBmcC5sMTBucztcblxuICBleHBvcnRzLkl0YWxpYW4gPSBJdGFsaWFuO1xuICBleHBvcnRzLmRlZmF1bHQgPSBpdDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjEyLjlcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuUG9wcGVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBsb25nZXJUaW1lb3V0QnJvd3NlcnMgPSBbJ0VkZ2UnLCAnVHJpZGVudCcsICdGaXJlZm94J107XG52YXIgdGltZW91dER1cmF0aW9uID0gMDtcbmZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgIHRpbWVvdXREdXJhdGlvbiA9IDE7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsKS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudCAmJiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgdmFyIG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddLCAxMCkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10sIDEwKTtcbn1cblxuLyoqXG4gKiBUZWxscyBpZiB5b3UgYXJlIHJ1bm5pbmcgSW50ZXJuZXQgRXhwbG9yZXIgMTBcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFMTBcbiAqL1xudmFyIGlzSUUxMCA9IHVuZGVmaW5lZDtcblxudmFyIGlzSUUxMCQxID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaXNJRTEwID09PSB1bmRlZmluZWQpIHtcbiAgICBpc0lFMTAgPSBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFIDEwJykgIT09IC0xO1xuICB9XG4gIHJldHVybiBpc0lFMTA7XG59O1xuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFMTAkMSgpID8gaHRtbFsnb2Zmc2V0JyArIGF4aXNdICsgY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0gOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoKSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRTEwJDEoKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIGlmIChpc0lFMTAkMSgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9IGVsc2Uge1xuICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGlzSUUxMCA9IGlzSUUxMCQxKCk7XG4gIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgdmFyIGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIHZhciBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCwgMTApO1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wLCAxMCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0LCAxMCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKGlzSUUxMCA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChodG1sKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKTtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQpO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBib3VuZGFyaWVzLmxlZnQgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy50b3AgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy5yaWdodCAtPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBwYWRkaW5nO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB5LFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gIHZhciBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgfTtcblxuICAvLyBkZXBlbmRpbmcgYnkgdGhlIHBvcHBlciBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICB2YXIgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW21haW5TaWRlXSArIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIG9uVXBkYXRlIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICAvLyBmbG9vciBzaWRlcyB0byBhdm9pZCBibHVycnkgdGV4dFxuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICBsZWZ0OiBNYXRoLmZsb29yKHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IE1hdGguZmxvb3IocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiBNYXRoLmZsb29yKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBNYXRoLmZsb29yKHBvcHBlci5yaWdodClcbiAgfTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMkYXJyb3c7XG5cbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICB2YXIgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIHZhciBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVjdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0sIDEwKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddLCAxMCk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLXJpZ2h0YCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0bGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgaGVpZ2h0LlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gTW9yZSBvbiB0aGlzIFtyZWFkaW5nIHRoaXMgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEFuIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIgdGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgaGFzIGFsd2F5cyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLCBjYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNob3RoZXJzXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXhwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gYXNzdXJlIGl0IHRvIHBvaW50IHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcywgeW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVjdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpLlxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLFxuICAgICAqIHRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBrZWVwVG9nZXRoZXIgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM2QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdSBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9ucyB1c2VkIGJ5IFBvcHBlci5qc1xuICogdGhpcyBvYmplY3QgZ2V0IHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXIuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciwgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LCBpdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYXMgM3JkIGFyZ3VtZW50IGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhpcyBvYmplY3QsIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50XG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZFxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLCB0aGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanNcbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhbiB1cGRhdGUsIGl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGVcbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbnJldHVybiBQb3BwZXI7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbiAobSwgZXhwb3J0cykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH07XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkXCIsIF9fc3ByZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG59KTtcclxuIl19
;